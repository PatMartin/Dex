(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.dex = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var css = "/** CSS Dependencies **/\n/*\r\n * Default Layout Theme\r\n *\r\n * Created for jquery.layout\r\n *\r\n * Copyright (c) 2010\r\n *   Fabrizio Balliano (http://www.fabrizioballiano.net)\r\n *   Kevin Dalman (http://allpro.net)\r\n *\r\n * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)\r\n * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.\r\n *\r\n * Last Updated: 2010-02-10\r\n * NOTE: For best code readability, view this with a fixed-space font and tabs equal to 4-chars\r\n */\n/*\r\n *\tDEFAULT FONT\r\n *\tJust to make demo-pages look better - not actually relevant to Layout!\r\n */\nbody {\n  font-family: Geneva, Arial, Helvetica, sans-serif;\n  font-size: 100%;\n  *font-size: 80%;\n}\n/*\r\n *\tPANES & CONTENT-DIVs\r\n */\n.ui-layout-pane {\n  /* all 'panes' */\n  background: #FFF;\n  border: 1px solid #BBB;\n  padding: 10px;\n  overflow: auto;\n  /* DO NOT add scrolling (or padding) to 'panes' that have a content-div,\r\n       otherwise you may get double-scrollbars - on the pane AND on the content-div\r\n       - use ui-layout-wrapper class if pane has a content-div\r\n       - use ui-layout-container if pane has an inner-layout\r\n    */\n}\n/* (scrolling) content-div inside pane allows for fixed header(s) and/or footer(s) */\n.ui-layout-content {\n  padding: 10px;\n  position: relative;\n  /* contain floated or positioned elements */\n  overflow: auto;\n  /* add scrolling to content-div */\n}\n/*\r\n *\tUTILITY CLASSES\r\n *\tMust come AFTER pane-class above so will override\r\n *\tThese classes are NOT auto-generated and are NOT used by Layout\r\n */\n.layout-child-container,\n.layout-content-container {\n  padding: 0;\n  overflow: hidden;\n}\n.layout-child-container {\n  border: 0;\n  /* remove border because inner-layout-panes probably have borders */\n}\n.layout-scroll {\n  overflow: auto;\n}\n.layout-hide {\n  display: none;\n}\n/*\r\n *\tRESIZER-BARS\r\n */\n.ui-layout-resizer {\n  /* all 'resizer-bars' */\n  background: #DDD;\n  border: 1px solid #BBB;\n  border-width: 0;\n}\n.ui-layout-resizer-drag {\n  /* REAL resizer while resize in progress */\n}\n.ui-layout-resizer-hover {\n  /* affects both open and closed states */\n}\n/* NOTE: It looks best when 'hover' and 'dragging' are set to the same color,\r\n    otherwise color shifts while dragging when bar can't keep up with mouse */\n.ui-layout-resizer-open-hover,\n/* hover-color to 'resize' */\r\n.ui-layout-resizer-dragging {\n  /* resizer beging 'dragging' */\n  background: #C4E1A4;\n}\n.ui-layout-resizer-dragging {\n  /* CLONED resizer being dragged */\n  border: 1px solid #BBB;\n}\n.ui-layout-resizer-north-dragging,\n.ui-layout-resizer-south-dragging {\n  border-width: 1px 0;\n}\n.ui-layout-resizer-west-dragging,\n.ui-layout-resizer-east-dragging {\n  border-width: 0 1px;\n}\n/* NOTE: Add a 'dragging-limit' color to provide visual feedback when resizer hits min/max size limits */\n.ui-layout-resizer-dragging-limit {\n  /* CLONED resizer at min or max size-limit */\n  background: #E1A4A4;\n  /* red */\n}\n.ui-layout-resizer-closed-hover {\n  /* hover-color to 'slide open' */\n  background: #EBD5AA;\n}\n.ui-layout-resizer-sliding {\n  /* resizer when pane is 'slid open' */\n  opacity: .10;\n  /* show only a slight shadow */\n  filter: alpha(opacity=10);\n}\n.ui-layout-resizer-sliding-hover {\n  /* sliding resizer - hover */\n  opacity: 1.00;\n  /* on-hover, show the resizer-bar normally */\n  filter: alpha(opacity=100);\n}\n/* sliding resizer - add 'outside-border' to resizer on-hover\r\n * this sample illustrates how to target specific panes and states */\n.ui-layout-resizer-north-sliding-hover {\n  border-bottom-width: 1px;\n}\n.ui-layout-resizer-south-sliding-hover {\n  border-top-width: 1px;\n}\n.ui-layout-resizer-west-sliding-hover {\n  border-right-width: 1px;\n}\n.ui-layout-resizer-east-sliding-hover {\n  border-left-width: 1px;\n}\n/*\r\n *\tTOGGLER-BUTTONS\r\n */\n.ui-layout-toggler {\n  border: 1px solid #BBB;\n  /* match pane-border */\n  background-color: #BBB;\n}\n.ui-layout-resizer-hover .ui-layout-toggler {\n  opacity: .60;\n  filter: alpha(opacity=60);\n}\n.ui-layout-toggler-hover,\n/* need when NOT resizable */\r\n.ui-layout-resizer-hover .ui-layout-toggler-hover {\n  /* need specificity when IS resizable */\n  background-color: #FC6;\n  opacity: 1.00;\n  filter: alpha(opacity=100);\n}\n.ui-layout-toggler-north,\n.ui-layout-toggler-south {\n  border-width: 0 1px;\n  /* left/right borders */\n}\n.ui-layout-toggler-west,\n.ui-layout-toggler-east {\n  border-width: 1px 0;\n  /* top/bottom borders */\n}\n/* hide the toggler-button when the pane is 'slid open' */\n.ui-layout-resizer-sliding  .ui-layout-toggler {\n  display: none;\n}\n/*\r\n *\tstyle the text we put INSIDE the togglers\r\n */\n.ui-layout-toggler .content {\n  color: #666;\n  font-size: 12px;\n  font-weight: bold;\n  width: 100%;\n  padding-bottom: 0.35ex;\n  /* to 'vertically center' text inside text-span */\n}\n/*\r\n *\tPANE-MASKS\r\n *\tthese styles are hard-coded on mask elems, but are also\r\n *\tincluded here as !important to ensure will overrides any generic styles\r\n */\n.ui-layout-mask {\n  border: none !important;\n  padding: 0 !important;\n  margin: 0 !important;\n  overflow: hidden !important;\n  position: absolute !important;\n  opacity: 0 !important;\n  filter: Alpha(Opacity=\"0\") !important;\n}\n.ui-layout-mask-inside-pane {\n  /* masks always inside pane EXCEPT when pane is an iframe */\n  top: 0 !important;\n  left: 0 !important;\n  width: 100% !important;\n  height: 100% !important;\n}\n\n/* standard mask for iframes */\n\n/* extra mask for objects/applets */\n/*\r\n *\tDefault printing styles\r\n */\n@media print {\n  /*\r\n     *\tUnless you want to print the layout as it appears onscreen,\r\n     *\tthese html/body styles are needed to allow the content to 'flow'\r\n     */\n\n  html {\n    height: auto !important;\n    overflow: visible !important;\n  }\n\n  body.ui-layout-container {\n    position: static !important;\n    top: auto !important;\n    bottom: auto !important;\n    left: auto !important;\n    right: auto !important;\n    /* only IE6 has container width & height set by Layout */\n    _width: auto !important;\n    _height: auto !important;\n  }\n\n  .ui-layout-resizer,\n  .ui-layout-toggler {\n    display: none !important;\n  }\n\n  /*\r\n     *\tDefault pane print styles disables positioning, borders and backgrounds.\r\n     *\tYou can modify these styles however it suit your needs.\r\n     */\n\n  .ui-layout-pane {\n    border: none !important;\n    background: transparent !important;\n    position: relative !important;\n    top: auto !important;\n    bottom: auto !important;\n    left: auto !important;\n    right: auto !important;\n    width: auto !important;\n    height: auto !important;\n    overflow: visible !important;\n  }\n}\n.uix-multiselect-original {\n  position: absolute;\n  left: -999999px;\n}\n.uix-multiselect {\n  position: relative;\n  float: left;\n}\n.uix-multiselect {\n  width: 100% !important;\n}\n/** CSS to make the control scalable **/\n.uix-multiselect .multiselect-selected-list {\n  position: absolute;\n  overflow: hidden;\n  width: 50% !important;\n  left: 0% !important;\n}\n.uix-multiselect .multiselect-available-list {\n  position: absolute;\n  overflow: hidden;\n  left: 50% !important;\n  width: 50% !important;\n}\n.uix-multiselect .ui-widget-header {\n  overflow: hidden;\n  white-space: nowrap;\n  padding: 2px 4px;\n}\n.uix-multiselect .ui-widget-header div.header-text {\n  white-space: nowrap;\n  font-size: .9em;\n}\n.uix-multiselect .ui-widget-header .uix-control-right,\n.uix-multiselect .ui-widget-header .uix-control-left {\n  width: 16px;\n  height: 16px;\n}\n.uix-multiselect .ui-widget-header .uix-control-right {\n  float: right;\n}\n.uix-multiselect .ui-widget-header .uix-control-left {\n  float: left;\n}\n.uix-multiselect .ui-widget-header .uix-search {\n  float: right;\n  height: 14px;\n  font-size: 80%;\n}\n.uix-multiselect .uix-list-container {\n  position: relative;\n  overflow: auto;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.uix-multiselect .uix-list-container .ui-priority-secondary {\n  padding-right: 0;\n}\n.uix-multiselect .group-element {\n  position: relative;\n  padding-left: 0;\n  white-space: nowrap;\n  overflow: hidden;\n}\n.uix-multiselect .group-element-collapsable {\n  padding-left: 16px;\n}\n.uix-multiselect .group-element span.collapse-handle {\n  position: absolute;\n  margin-top: -8px;\n  top: 50%;\n  left: 0;\n}\n.uix-multiselect .group-element .label {\n  margin: 0 3px;\n  white-space: nowrap;\n  overflow: hidden;\n}\n.uix-multiselect .group-element .ui-icon {\n  float: left;\n  cursor: pointer;\n}\n.uix-multiselect .option-element,\n.dragged-element {\n  cursor: pointer;\n  padding: 0 2px;\n}\n.uix-multiselect .option-element.ui-state-disabled {\n  font-style: italic;\n}\n.dragged-element,\n.dragged-grouped-element {\n  padding: 1px 3px;\n}\n.dragged-grouped-element {\n  padding-left: 16px;\n}\n.uix-multiselect .grouped-option {\n  position: relative;\n  padding-left: 16px;\n}\n.uix-multiselect .grouped-option .ui-icon {\n  position: absolute;\n  left: 0;\n}\n/*! =======================================================\r\n                      VERSION  9.8.0\r\n========================================================= */\n/*! =========================================================\r\n * bootstrap-slider.js\r\n *\r\n * Maintainers:\r\n *\t\tKyle Kemp\r\n *\t\t\t- Twitter: @seiyria\r\n *\t\t\t- Github:  seiyria\r\n *\t\tRohit Kalkur\r\n *\t\t\t- Twitter: @Rovolutionary\r\n *\t\t\t- Github:  rovolution\r\n *\r\n * =========================================================\r\n  *\r\n * bootstrap-slider is released under the MIT License\r\n * Copyright (c) 2017 Kyle Kemp, Rohit Kalkur, and contributors\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n * ========================================================= */\n.slider {\n  display: inline-block;\n  vertical-align: middle;\n  position: relative;\n}\n.slider.slider-horizontal {\n  width: 210px;\n  height: 20px;\n}\n.slider.slider-horizontal .slider-track {\n  height: 10px;\n  width: 100%;\n  margin-top: -5px;\n  top: 50%;\n  left: 0;\n}\n.slider.slider-horizontal .slider-selection,\n.slider.slider-horizontal .slider-track-low,\n.slider.slider-horizontal .slider-track-high {\n  height: 100%;\n  top: 0;\n  bottom: 0;\n}\n.slider.slider-horizontal .slider-tick,\n.slider.slider-horizontal .slider-handle {\n  margin-left: -10px;\n}\n.slider.slider-horizontal .slider-tick.triangle,\n.slider.slider-horizontal .slider-handle.triangle {\n  position: relative;\n  top: 50%;\n  transform: translateY(-50%);\n  border-width: 0 10px 10px 10px;\n  width: 0;\n  height: 0;\n  border-bottom-color: #0480be;\n  margin-top: 0;\n}\n.slider.slider-horizontal .slider-tick-container {\n  white-space: nowrap;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n}\n.slider.slider-horizontal .slider-tick-label-container {\n  white-space: nowrap;\n  margin-top: 20px;\n}\n.slider.slider-horizontal .slider-tick-label-container .slider-tick-label {\n  padding-top: 4px;\n  display: inline-block;\n  text-align: center;\n}\n.slider.slider-horizontal.slider-rtl .slider-track {\n  left: initial;\n  right: 0;\n}\n.slider.slider-horizontal.slider-rtl .slider-tick,\n.slider.slider-horizontal.slider-rtl .slider-handle {\n  margin-left: initial;\n  margin-right: -10px;\n}\n.slider.slider-horizontal.slider-rtl .slider-tick-container {\n  left: initial;\n  right: 0;\n}\n.slider.slider-vertical {\n  height: 210px;\n  width: 20px;\n}\n.slider.slider-vertical .slider-track {\n  width: 10px;\n  height: 100%;\n  left: 25%;\n  top: 0;\n}\n.slider.slider-vertical .slider-selection {\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 0;\n}\n.slider.slider-vertical .slider-track-low,\n.slider.slider-vertical .slider-track-high {\n  width: 100%;\n  left: 0;\n  right: 0;\n}\n.slider.slider-vertical .slider-tick,\n.slider.slider-vertical .slider-handle {\n  margin-top: -10px;\n}\n.slider.slider-vertical .slider-tick.triangle,\n.slider.slider-vertical .slider-handle.triangle {\n  border-width: 10px 0 10px 10px;\n  width: 1px;\n  height: 1px;\n  border-left-color: #0480be;\n  border-right-color: #0480be;\n  margin-left: 0;\n  margin-right: 0;\n}\n.slider.slider-vertical .slider-tick-label-container {\n  white-space: nowrap;\n}\n.slider.slider-vertical .slider-tick-label-container .slider-tick-label {\n  padding-left: 4px;\n}\n.slider.slider-vertical.slider-rtl .slider-track {\n  left: initial;\n  right: 25%;\n}\n.slider.slider-vertical.slider-rtl .slider-selection {\n  left: initial;\n  right: 0;\n}\n.slider.slider-vertical.slider-rtl .slider-tick.triangle,\n.slider.slider-vertical.slider-rtl .slider-handle.triangle {\n  border-width: 10px 10px 10px 0;\n}\n.slider.slider-vertical.slider-rtl .slider-tick-label-container .slider-tick-label {\n  padding-left: initial;\n  padding-right: 4px;\n}\n.slider.slider-disabled .slider-handle {\n  background-image: -webkit-linear-gradient(top, #dfdfdf 0%, #bebebe 100%);\n  background-image: -o-linear-gradient(top, #dfdfdf 0%, #bebebe 100%);\n  background-image: linear-gradient(to bottom, #dfdfdf 0%, #bebebe 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdfdfdf', endColorstr='#ffbebebe', GradientType=0);\n}\n.slider.slider-disabled .slider-track {\n  background-image: -webkit-linear-gradient(top, #e5e5e5 0%, #e9e9e9 100%);\n  background-image: -o-linear-gradient(top, #e5e5e5 0%, #e9e9e9 100%);\n  background-image: linear-gradient(to bottom, #e5e5e5 0%, #e9e9e9 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe5e5e5', endColorstr='#ffe9e9e9', GradientType=0);\n  cursor: not-allowed;\n}\n.slider input {\n  display: none;\n}\n.slider .tooltip.top {\n  margin-top: -36px;\n}\n.slider .tooltip-inner {\n  white-space: nowrap;\n  max-width: none;\n}\n.slider .hide {\n  display: none;\n}\n.slider-track {\n  position: absolute;\n  cursor: pointer;\n  background-image: -webkit-linear-gradient(top, #f5f5f5 0%, #f9f9f9 100%);\n  background-image: -o-linear-gradient(top, #f5f5f5 0%, #f9f9f9 100%);\n  background-image: linear-gradient(to bottom, #f5f5f5 0%, #f9f9f9 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5', endColorstr='#fff9f9f9', GradientType=0);\n  -webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);\n  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);\n  border-radius: 4px;\n}\n.slider-selection {\n  position: absolute;\n  background-image: -webkit-linear-gradient(top, #f9f9f9 0%, #f5f5f5 100%);\n  background-image: -o-linear-gradient(top, #f9f9f9 0%, #f5f5f5 100%);\n  background-image: linear-gradient(to bottom, #f9f9f9 0%, #f5f5f5 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9', endColorstr='#fff5f5f5', GradientType=0);\n  -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);\n  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border-radius: 4px;\n}\n.slider-selection.tick-slider-selection {\n  background-image: -webkit-linear-gradient(top, #89cdef 0%, #81bfde 100%);\n  background-image: -o-linear-gradient(top, #89cdef 0%, #81bfde 100%);\n  background-image: linear-gradient(to bottom, #89cdef 0%, #81bfde 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef', endColorstr='#ff81bfde', GradientType=0);\n}\n.slider-track-low,\n.slider-track-high {\n  position: absolute;\n  background: transparent;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border-radius: 4px;\n}\n.slider-handle {\n  position: absolute;\n  top: 0;\n  width: 20px;\n  height: 20px;\n  background-color: #337ab7;\n  background-image: -webkit-linear-gradient(top, #149bdf 0%, #0480be 100%);\n  background-image: -o-linear-gradient(top, #149bdf 0%, #0480be 100%);\n  background-image: linear-gradient(to bottom, #149bdf 0%, #0480be 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff149bdf', endColorstr='#ff0480be', GradientType=0);\n  filter: none;\n  -webkit-box-shadow: inset 0 1px 0 rgba(255,255,255,.2), 0 1px 2px rgba(0,0,0,.05);\n  box-shadow: inset 0 1px 0 rgba(255,255,255,.2), 0 1px 2px rgba(0,0,0,.05);\n  border: 0px solid transparent;\n}\n.slider-handle.round {\n  border-radius: 50%;\n}\n.slider-handle.triangle {\n  background: transparent none;\n}\n.slider-handle.custom {\n  background: transparent none;\n}\n.slider-handle.custom::before {\n  line-height: 20px;\n  font-size: 20px;\n  content: '\\2605';\n  color: #726204;\n}\n.slider-tick {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  background-image: -webkit-linear-gradient(top, #f9f9f9 0%, #f5f5f5 100%);\n  background-image: -o-linear-gradient(top, #f9f9f9 0%, #f5f5f5 100%);\n  background-image: linear-gradient(to bottom, #f9f9f9 0%, #f5f5f5 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9', endColorstr='#fff5f5f5', GradientType=0);\n  -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);\n  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  filter: none;\n  opacity: 0.8;\n  border: 0px solid transparent;\n}\n.slider-tick.round {\n  border-radius: 50%;\n}\n.slider-tick.triangle {\n  background: transparent none;\n}\n.slider-tick.custom {\n  background: transparent none;\n}\n.slider-tick.custom::before {\n  line-height: 20px;\n  font-size: 20px;\n  content: '\\2605';\n  color: #726204;\n}\n.slider-tick.in-selection {\n  background-image: -webkit-linear-gradient(top, #89cdef 0%, #81bfde 100%);\n  background-image: -o-linear-gradient(top, #89cdef 0%, #81bfde 100%);\n  background-image: linear-gradient(to bottom, #89cdef 0%, #81bfde 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef', endColorstr='#ff81bfde', GradientType=0);\n  opacity: 1;\n}\n/*\r\n   MODULE: bootstrap-multiselect 0.9.13\r\n   SITE  : https://github.com/davidstutz/bootstrap-multiselect\r\n   SOURCE: https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/css/bootstrap-multiselect.css\r\n*/\n.multiselect-container {\n  position: absolute;\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n}\n.multiselect-container .input-group {\n  margin: 5px;\n}\n.multiselect-container > li {\n  padding: 0;\n}\n.multiselect-container > li > a.multiselect-all label {\n  font-weight: 700;\n}\n.multiselect-container > li.multiselect-group label {\n  margin: 0;\n  padding: 3px 20px 3px 20px;\n  height: 100%;\n  font-weight: 700;\n}\n.multiselect-container > li.multiselect-group-clickable label {\n  cursor: pointer;\n}\n.multiselect-container > li > a {\n  padding: 0;\n}\n.multiselect-container > li > a > label {\n  margin: 0;\n  height: 100%;\n  cursor: pointer;\n  font-weight: 400;\n  padding: 3px 20px 3px 40px;\n}\n.multiselect-container > li > a > label.radio,\n.multiselect-container > li > a > label.checkbox {\n  margin: 0;\n}\n.multiselect-container > li > a > label > input[type=checkbox] {\n  margin-bottom: 5px;\n}\n.btn-group > .btn-group:nth-child(2) > .multiselect.btn {\n  border-top-left-radius: 4px;\n  border-bottom-left-radius: 4px;\n}\n.form-inline .multiselect-container label.checkbox,\n.form-inline .multiselect-container label.radio {\n  padding: 3px 20px 3px 40px;\n}\n.form-inline .multiselect-container li a label.checkbox input[type=checkbox],\n.form-inline .multiselect-container li a label.radio input[type=radio] {\n  margin-left: -20px;\n  margin-right: 0;\n}\n/*! ========================================================================\r\n * Bootstrap Toggle: bootstrap-toggle.css v2.2.0\r\n * http://www.bootstraptoggle.com\r\n * ========================================================================\r\n * Copyright 2014 Min Hur, The New York Times Company\r\n * Licensed under MIT\r\n * ======================================================================== */\n.checkbox label .toggle,\n.checkbox-inline .toggle {\n  margin-left: -20px;\n  margin-right: 5px;\n}\n.toggle {\n  position: relative;\n  overflow: hidden;\n}\n.toggle input[type=\"checkbox\"] {\n  display: none;\n}\n.toggle-group {\n  position: absolute;\n  width: 200%;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  transition: left 0.35s;\n  -webkit-transition: left 0.35s;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n}\n.toggle.off .toggle-group {\n  left: -100%;\n}\n.toggle-on {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 50%;\n  margin: 0;\n  border: 0;\n  border-radius: 0;\n}\n.toggle-off {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 50%;\n  right: 0;\n  margin: 0;\n  border: 0;\n  border-radius: 0;\n}\n.toggle-handle {\n  position: relative;\n  margin: 0 auto;\n  padding-top: 0px;\n  padding-bottom: 0px;\n  height: 100%;\n  width: 0px;\n  border-width: 0 1px;\n}\n.toggle.btn {\n  min-width: 59px;\n  min-height: 34px;\n}\n.toggle-on.btn {\n  padding-right: 24px;\n}\n.toggle-off.btn {\n  padding-left: 24px;\n}\n.toggle.btn-lg {\n  min-width: 79px;\n  min-height: 45px;\n}\n.toggle-on.btn-lg {\n  padding-right: 31px;\n}\n.toggle-off.btn-lg {\n  padding-left: 31px;\n}\n.toggle-handle.btn-lg {\n  width: 40px;\n}\n.toggle.btn-sm {\n  min-width: 50px;\n  min-height: 30px;\n}\n.toggle-on.btn-sm {\n  padding-right: 20px;\n}\n.toggle-off.btn-sm {\n  padding-left: 20px;\n}\n.toggle.btn-xs {\n  min-width: 35px;\n  min-height: 22px;\n}\n.toggle-on.btn-xs {\n  padding-right: 12px;\n}\n.toggle-off.btn-xs {\n  padding-left: 12px;\n}\n/***\r\nSpectrum Colorpicker v1.8.0\r\nhttps://github.com/bgrins/spectrum\r\nAuthor: Brian Grinstead\r\nLicense: MIT\r\n***/\n.sp-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: inline-block;\n  *display: inline;\n  *zoom: 1;\n  /* https://github.com/bgrins/spectrum/issues/40 */\n  z-index: 9999994;\n  overflow: hidden;\n}\n.sp-container.sp-flat {\n  position: relative;\n}\n/* Fix for * { box-sizing: border-box; } */\n.sp-container,\n.sp-container * {\n  -webkit-box-sizing: content-box;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n/* http://ansciath.tumblr.com/post/7347495869/css-aspect-ratio */\n.sp-top {\n  position: relative;\n  width: 100%;\n  display: inline-block;\n}\n.sp-top-inner {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n}\n.sp-color {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 20%;\n}\n.sp-hue {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 84%;\n  height: 100%;\n}\n.sp-clear-enabled .sp-hue {\n  top: 33px;\n  height: 77.5%;\n}\n.sp-fill {\n  padding-top: 80%;\n}\n.sp-sat,\n.sp-val {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n.sp-alpha-enabled .sp-top {\n  margin-bottom: 18px;\n}\n.sp-alpha-enabled .sp-alpha {\n  display: block;\n}\n.sp-alpha-handle {\n  position: absolute;\n  top: -4px;\n  bottom: -4px;\n  width: 6px;\n  left: 50%;\n  cursor: pointer;\n  border: 1px solid black;\n  background: white;\n  opacity: .8;\n}\n.sp-alpha {\n  display: none;\n  position: absolute;\n  bottom: -14px;\n  right: 0;\n  left: 0;\n  height: 8px;\n}\n.sp-alpha-inner {\n  border: solid 1px #333;\n}\n.sp-clear {\n  display: none;\n}\n.sp-clear.sp-clear-display {\n  background-position: center;\n}\n.sp-clear-enabled .sp-clear {\n  display: block;\n  position: absolute;\n  top: 0px;\n  right: 0;\n  bottom: 0;\n  left: 84%;\n  height: 28px;\n}\n/* Don't allow text selection */\n.sp-container,\n.sp-replacer,\n.sp-preview,\n.sp-dragger,\n.sp-slider,\n.sp-alpha,\n.sp-clear,\n.sp-alpha-handle,\n.sp-container.sp-dragging .sp-input,\n.sp-container button {\n  -webkit-user-select: none;\n  -moz-user-select: -moz-none;\n  -o-user-select: none;\n  user-select: none;\n}\n.sp-container.sp-input-disabled .sp-input-container {\n  display: none;\n}\n.sp-container.sp-buttons-disabled .sp-button-container {\n  display: none;\n}\n.sp-container.sp-palette-buttons-disabled .sp-palette-button-container {\n  display: none;\n}\n.sp-palette-only .sp-picker-container {\n  display: none;\n}\n.sp-palette-disabled .sp-palette-container {\n  display: none;\n}\n.sp-initial-disabled .sp-initial {\n  display: none;\n}\n/* Gradients for hue, saturation and value instead of images.  Not pretty... but it works */\n.sp-sat {\n  background-image: -webkit-gradient(linear,  0 0, 100% 0, from(#FFF), to(rgba(204, 154, 129, 0)));\n  background-image: -webkit-linear-gradient(left, #FFF, rgba(204, 154, 129, 0));\n  background-image: -moz-linear-gradient(left, #fff, rgba(204, 154, 129, 0));\n  background-image: -o-linear-gradient(left, #fff, rgba(204, 154, 129, 0));\n  background-image: -ms-linear-gradient(left, #fff, rgba(204, 154, 129, 0));\n  background-image: linear-gradient(to right, #fff, rgba(204, 154, 129, 0));\n  -ms-filter: \"progid:DXImageTransform.Microsoft.gradient(GradientType = 1, startColorstr=#FFFFFFFF, endColorstr=#00CC9A81)\";\n  filter: progid:DXImageTransform.Microsoft.gradient(GradientType = 1, startColorstr='#FFFFFFFF', endColorstr='#00CC9A81');\n}\n.sp-val {\n  background-image: -webkit-gradient(linear, 0 100%, 0 0, from(#000000), to(rgba(204, 154, 129, 0)));\n  background-image: -webkit-linear-gradient(bottom, #000000, rgba(204, 154, 129, 0));\n  background-image: -moz-linear-gradient(bottom, #000, rgba(204, 154, 129, 0));\n  background-image: -o-linear-gradient(bottom, #000, rgba(204, 154, 129, 0));\n  background-image: -ms-linear-gradient(bottom, #000, rgba(204, 154, 129, 0));\n  background-image: linear-gradient(to top, #000, rgba(204, 154, 129, 0));\n  -ms-filter: \"progid:DXImageTransform.Microsoft.gradient(startColorstr=#00CC9A81, endColorstr=#FF000000)\";\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00CC9A81', endColorstr='#FF000000');\n}\n.sp-hue {\n  background: -moz-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\n  background: -ms-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\n  background: -o-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\n  background: -webkit-gradient(linear, left top, left bottom, from(#ff0000), color-stop(0.17, #ffff00), color-stop(0.33, #00ff00), color-stop(0.5, #00ffff), color-stop(0.67, #0000ff), color-stop(0.83, #ff00ff), to(#ff0000));\n  background: -webkit-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\n  background: linear-gradient(to bottom, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\n}\n/* IE filters do not support multiple color stops.\r\n   Generate 6 divs, line them up, and do two color gradients for each.\r\n   Yes, really.\r\n */\n.sp-1 {\n  height: 17%;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0000', endColorstr='#ffff00');\n}\n.sp-2 {\n  height: 16%;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffff00', endColorstr='#00ff00');\n}\n.sp-3 {\n  height: 17%;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00ff00', endColorstr='#00ffff');\n}\n.sp-4 {\n  height: 17%;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00ffff', endColorstr='#0000ff');\n}\n.sp-5 {\n  height: 16%;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#0000ff', endColorstr='#ff00ff');\n}\n.sp-6 {\n  height: 17%;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff00ff', endColorstr='#ff0000');\n}\n.sp-hidden {\n  display: none !important;\n}\n/* Clearfix hack */\n.sp-cf:before,\n.sp-cf:after {\n  content: \"\";\n  display: table;\n}\n.sp-cf:after {\n  clear: both;\n}\n.sp-cf {\n  *zoom: 1;\n}\n/* Mobile devices, make hue slider bigger so it is easier to slide */\n@media (max-device-width: 480px) {\n  .sp-color {\n    right: 40%;\n  }\n\n  .sp-hue {\n    left: 63%;\n  }\n\n  .sp-fill {\n    padding-top: 60%;\n  }\n}\n.sp-dragger {\n  border-radius: 5px;\n  height: 5px;\n  width: 5px;\n  border: 1px solid #fff;\n  background: #000;\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n.sp-slider {\n  position: absolute;\n  top: 0;\n  cursor: pointer;\n  height: 3px;\n  left: -1px;\n  right: -1px;\n  border: 1px solid #000;\n  background: white;\n  opacity: .8;\n}\n/*\r\nTheme authors:\r\nHere are the basic themeable display options (colors, fonts, global widths).\r\nSee http://bgrins.github.io/spectrum/themes/ for instructions.\r\n*/\n.sp-container {\n  border-radius: 0;\n  background-color: #ECECEC;\n  border: solid 1px #f0c49B;\n  padding: 0;\n}\n.sp-container,\n.sp-container button,\n.sp-container input,\n.sp-color,\n.sp-hue,\n.sp-clear {\n  font: normal 12px \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", Geneva, Verdana, sans-serif;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -ms-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.sp-top {\n  margin-bottom: 3px;\n}\n.sp-color,\n.sp-hue,\n.sp-clear {\n  border: solid 1px #666;\n}\n/* Input */\n.sp-input-container {\n  float: right;\n  width: 100px;\n  margin-bottom: 4px;\n}\n.sp-initial-disabled  .sp-input-container {\n  width: 100%;\n}\n.sp-input {\n  font-size: 12px !important;\n  border: 1px inset;\n  padding: 4px 5px;\n  margin: 0;\n  width: 100%;\n  background: transparent;\n  border-radius: 3px;\n  color: #222;\n}\n.sp-input:focus {\n  border: 1px solid orange;\n}\n.sp-input.sp-validation-error {\n  border: 1px solid red;\n  background: #fdd;\n}\n.sp-picker-container,\n.sp-palette-container {\n  float: left;\n  position: relative;\n  padding: 10px;\n  padding-bottom: 300px;\n  margin-bottom: -290px;\n}\n.sp-picker-container {\n  width: 172px;\n  border-left: solid 1px #fff;\n}\n/* Palettes */\n.sp-palette-container {\n  border-right: solid 1px #ccc;\n}\n.sp-palette-only .sp-palette-container {\n  border: 0;\n}\n.sp-palette .sp-thumb-el {\n  display: block;\n  position: relative;\n  float: left;\n  width: 24px;\n  height: 15px;\n  margin: 3px;\n  cursor: pointer;\n  border: solid 2px transparent;\n}\n.sp-palette .sp-thumb-el:hover,\n.sp-palette .sp-thumb-el.sp-thumb-active {\n  border-color: orange;\n}\n.sp-thumb-el {\n  position: relative;\n}\n/* Initial */\n.sp-initial {\n  float: left;\n  border: solid 1px #333;\n}\n.sp-initial span {\n  width: 30px;\n  height: 25px;\n  border: none;\n  display: block;\n  float: left;\n  margin: 0;\n}\n.sp-initial .sp-clear-display {\n  background-position: center;\n}\n/* Buttons */\n.sp-palette-button-container,\n.sp-button-container {\n  float: right;\n}\n/* Replacer (the little preview div that shows up instead of the <input>) */\n.sp-replacer {\n  margin: 0;\n  overflow: hidden;\n  cursor: pointer;\n  padding: 4px;\n  display: inline-block;\n  *zoom: 1;\n  *display: inline;\n  border: solid 1px #91765d;\n  background: #eee;\n  color: #333;\n  vertical-align: middle;\n}\n.sp-replacer:hover,\n.sp-replacer.sp-active {\n  border-color: #F0C49B;\n  color: #111;\n}\n.sp-replacer.sp-disabled {\n  cursor: default;\n  border-color: silver;\n  color: silver;\n}\n.sp-dd {\n  padding: 2px 0;\n  height: 16px;\n  line-height: 16px;\n  float: left;\n  font-size: 10px;\n}\n.sp-preview {\n  position: relative;\n  width: 25px;\n  height: 20px;\n  border: solid 1px #222;\n  margin-right: 5px;\n  float: left;\n  z-index: 0;\n}\n.sp-palette {\n  *width: 220px;\n  max-width: 220px;\n}\n.sp-palette .sp-thumb-el {\n  width: 16px;\n  height: 16px;\n  margin: 2px 1px;\n  border: solid 1px #d0d0d0;\n}\n.sp-container {\n  padding-bottom: 0;\n}\n/* Buttons: http://hellohappy.org/css3-buttons/ */\n.sp-container button {\n  background-color: #eeeeee;\n  background-image: -webkit-linear-gradient(top, #eeeeee, #cccccc);\n  background-image: -moz-linear-gradient(top, #eeeeee, #cccccc);\n  background-image: -ms-linear-gradient(top, #eeeeee, #cccccc);\n  background-image: -o-linear-gradient(top, #eeeeee, #cccccc);\n  background-image: linear-gradient(to bottom, #eeeeee, #cccccc);\n  border: 1px solid #ccc;\n  border-bottom: 1px solid #bbb;\n  border-radius: 3px;\n  color: #333;\n  font-size: 14px;\n  line-height: 1;\n  padding: 5px 4px;\n  text-align: center;\n  text-shadow: 0 1px 0 #eee;\n  vertical-align: middle;\n}\n.sp-container button:hover {\n  background-color: #dddddd;\n  background-image: -webkit-linear-gradient(top, #dddddd, #bbbbbb);\n  background-image: -moz-linear-gradient(top, #dddddd, #bbbbbb);\n  background-image: -ms-linear-gradient(top, #dddddd, #bbbbbb);\n  background-image: -o-linear-gradient(top, #dddddd, #bbbbbb);\n  background-image: linear-gradient(to bottom, #dddddd, #bbbbbb);\n  border: 1px solid #bbb;\n  border-bottom: 1px solid #999;\n  cursor: pointer;\n  text-shadow: 0 1px 0 #ddd;\n}\n.sp-container button:active {\n  border: 1px solid #aaa;\n  border-bottom: 1px solid #888;\n  -webkit-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;\n  -moz-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;\n  -ms-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;\n  -o-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;\n  box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;\n}\n.sp-cancel {\n  font-size: 11px;\n  color: #d93f3f !important;\n  margin: 0;\n  padding: 2px;\n  margin-right: 5px;\n  vertical-align: middle;\n  text-decoration: none;\n}\n.sp-cancel:hover {\n  color: #d93f3f !important;\n  text-decoration: underline;\n}\n.sp-palette span:hover,\n.sp-palette span.sp-thumb-active {\n  border-color: #000;\n}\n.sp-preview,\n.sp-alpha,\n.sp-thumb-el {\n  position: relative;\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);\n}\n.sp-preview-inner,\n.sp-alpha-inner,\n.sp-thumb-inner {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n}\n.sp-palette .sp-thumb-inner {\n  background-position: 50% 50%;\n  background-repeat: no-repeat;\n}\n.sp-palette .sp-thumb-light.sp-thumb-active .sp-thumb-inner {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIVJREFUeNpiYBhsgJFMffxAXABlN5JruT4Q3wfi/0DsT64h8UD8HmpIPCWG/KemIfOJCUB+Aoacx6EGBZyHBqI+WsDCwuQ9mhxeg2A210Ntfo8klk9sOMijaURm7yc1UP2RNCMbKE9ODK1HM6iegYLkfx8pligC9lCD7KmRof0ZhjQACDAAceovrtpVBRkAAAAASUVORK5CYII=);\n}\n.sp-palette .sp-thumb-dark.sp-thumb-active .sp-thumb-inner {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjEwMPRyoQAAAMdJREFUOE+tkgsNwzAMRMugEAahEAahEAZhEAqlEAZhEAohEAYh81X2dIm8fKpEspLGvudPOsUYpxE2BIJCroJmEW9qJ+MKaBFhEMNabSy9oIcIPwrB+afvAUFoK4H0tMaQ3XtlrggDhOVVMuT4E5MMG0FBbCEYzjYT7OxLEvIHQLY2zWwQ3D+9luyOQTfKDiFD3iUIfPk8VqrKjgAiSfGFPecrg6HN6m/iBcwiDAo7WiBeawa+Kwh7tZoSCGLMqwlSAzVDhoK+6vH4G0P5wdkAAAAASUVORK5CYII=);\n}\n.sp-clear-display {\n  background-repeat: no-repeat;\n  background-position: center;\n  background-image: url(data:image/gif;base64,R0lGODlhFAAUAPcAAAAAAJmZmZ2dnZ6enqKioqOjo6SkpKWlpaampqenp6ioqKmpqaqqqqurq/Hx8fLy8vT09PX19ff39/j4+Pn5+fr6+vv7+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAP8ALAAAAAAUABQAAAihAP9FoPCvoMGDBy08+EdhQAIJCCMybCDAAYUEARBAlFiQQoMABQhKUJBxY0SPICEYHBnggEmDKAuoPMjS5cGYMxHW3IiT478JJA8M/CjTZ0GgLRekNGpwAsYABHIypcAgQMsITDtWJYBR6NSqMico9cqR6tKfY7GeBCuVwlipDNmefAtTrkSzB1RaIAoXodsABiZAEFB06gIBWC1mLVgBa0AAOw==);\n}\n/* DataFilterPane */\n.DataFilterPaneClass {\n  display: inline-block;\n  width: 100%;\n  height: 100%;\n  max-width: 100%;\n  max-height: 100%;\n}\n.DataFilterPaneClass h4 {\n  text-align: center;\n  width: 100%;\n  background: #428bca;\n  color: white;\n  padding: 0px;\n  margin-right: 0px;\n  margin-top: 5px;\n  margin-bottom: 5px;\n  margin-left: 0px;\n}\n.DataFilterPaneClass h5 {\n  width: 100%;\n  color: black;\n  padding: 0px;\n  text-align: center;\n  margin-right: 0px;\n  margin-top: 10px;\n  margin-bottom: 0px;\n  margin-left: 0px;\n}\n/* Trigger button */\n.DataFilterPaneClass .btn-group {\n  width: 100%;\n}\n.DataFilterPaneClass #ColumnSelector {\n  height: 160px;\n  margin-bottom: 5px;\n  width: 100%;\n}\n.DataFilterPaneClass .slider {\n  width: 95% !important;\n  margin-left: 5px;\n}\n.DataFilterPaneClass .multiselect {\n  width: 100%;\n  max-width: 100%;\n  max-height: 100%;\n}\n/* ConfigurationPane */\n.ConfigurationPaneClass {\n  display: inline-block;\n  height: 100%;\n  width: 100%;\n  max-height: 100%;\n  max-width: 100%;\n}\n.ConfigurationPaneClass label {\n  font-size: medium;\n}\n.ConfigurationPaneClass .control-string input {\n  width: 100%;\n}\n.ConfigurationPaneClass div,\n.ConfigurationPaneClass h1,\n.ConfigurationPaneClass h2,\n.ConfigurationPaneClass h3,\n.ConfigurationPaneClass h4,\n.ConfigurationPaneClass h5 {\n  padding: 1px !important;\n  margin: 0px !important;\n}\n.ConfigurationPaneClass h1 {\n  font-size: 2.5em !important;\n  font-weight: normal !important;\n  color: white;\n  background-color: #878787;\n  text-align: center;\n}\n.ConfigurationPaneClass h2 {\n  font-size: 2.25em !important;\n  font-weight: normal !important;\n  color: white;\n  background-color: #3288bd;\n  text-align: center;\n}\n.ConfigurationPaneClass h3 {\n  font-size: 2em !important;\n  font-weight: normal !important;\n  color: white;\n  background-color: #1a9850;\n  text-align: center;\n}\n.ConfigurationPaneClass h4 {\n  font-size: 1.5em !important;\n  font-weight: normal !important;\n  color: white;\n  background-color: #d58512;\n  text-align: center;\n}\n.ConfigurationPaneClass h5 {\n  font-size: 1.2em !important;\n  font-weight: normal !important;\n  color: white;\n  background-color: #3e999f;\n  text-align: center;\n}\n.ConfigurationPaneClass h1:hover,\n.ConfigurationPaneClass h2:hover,\n.ConfigurationPaneClass h3:hover,\n.ConfigurationPaneClass h4:hover,\n.ConfigurationPaneClass h5:hover {\n  box-shadow: inset 0 0 100px 100px rgba(255, 255, 255, 0.1);\n  color: yellow;\n}\n.ConfigurationPaneClass .control-boolean label,\n.ConfigurationPaneClass .control-boolean input,\n.ConfigurationPaneClass .control-string label,\n.ConfigurationPaneClass .control-string input {\n  padding: 1px !important;\n  margin: 0px !important;\n}\n.ConfigurationPaneClass .control-float {\n  margin: 10px;\n}\n.ConfigurationPaneClass .slider {\n  margin-left: 5px !important;\n  margin-bottom: 15px !important;\n  margin-top: 0px !important;\n}\n.ConfigurationPaneClass .slider-handle {\n  top: 5px !important;\n}\n/** Treemap **/\n.TreemapClass text {\n  pointer-events: none;\n}\n.TreemapClass .grandparent text {\n  font-weight: bold;\n}\n.TreemapClass rect {\n  fill: none;\n  stroke: #fff;\n}\n.TreemapClass rect.parent,\n.grandparent rect {\n  stroke-width: 2px;\n}\n.TreemapClass .grandparent rect {\n  fill: steelblue;\n}\n.grandparent:hover rect {\n  fill: #ee9700;\n}\n.TreemapClass .children rect.parent,\n.grandparent rect {\n  cursor: pointer;\n}\n.TreemapClass .children rect.parent {\n  fill-opacity: .1;\n}\n.TreemapClass .children:hover rect.child {\n  fill-opacity: .8;\n}\n/** Treemap Bar Chart **/\n.TreemapBarChartClass label {\n  font-family: sans-serif;\n  font-size: 14px;\n  position: absolute;\n  left: 92px;\n  top: 26px;\n}\n.TreemapBarChartClass .axis .domain {\n  display: none;\n}\n.TreemapBarChartClass .axis line {\n  stroke: #ccc;\n}\n.TreemapBarChartClass .axis.x0 text {\n  font-weight: 700;\n}\n.TreemapBarChartClass .hover-active rect {\n  opacity: .75;\n}\n.TreemapBarChartClass .hover-active rect.hover {\n  opacity: 1;\n}\n"; (require("browserify-css").createStyle(css, { "href": "css\\dex.css" }, { "insertAt": "bottom" })); module.exports = css;
},{"browserify-css":11}],2:[function(require,module,exports){
/**
 * Bootstrap Multiselect (https://github.com/davidstutz/bootstrap-multiselect)
 *
 * Apache License, Version 2.0:
 * Copyright (c) 2012 - 2015 David Stutz
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a
 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * BSD 3-Clause License:
 * Copyright (c) 2012 - 2015 David Stutz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    - Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *    - Neither the name of David Stutz nor the names of its contributors may be
 *      used to endorse or promote products derived from this software without
 *      specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
!function ($) {

  if (typeof ko !== 'undefined' && ko.bindingHandlers && !ko.bindingHandlers.multiselect) {
    ko.bindingHandlers.multiselect = {
      after: ['options', 'value', 'selectedOptions', 'enable', 'disable'],

      init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        var $element = $(element);
        var config = ko.toJS(valueAccessor());

        $element.multiselect(config);

        if (allBindings.has('options')) {
          var options = allBindings.get('options');
          if (ko.isObservable(options)) {
            ko.computed({
              read: function() {
                options();
                setTimeout(function() {
                  var ms = $element.data('multiselect');
                  if (ms)
                    ms.updateOriginalOptions();//Not sure how beneficial this is.
                  $element.multiselect('rebuild');
                }, 1);
              },
              disposeWhenNodeIsRemoved: element
            });
          }
        }

        //value and selectedOptions are two-way, so these will be triggered even by our own actions.
        //It needs some way to tell if they are triggered because of us or because of outside change.
        //It doesn't loop but it's a waste of processing.
        if (allBindings.has('value')) {
          var value = allBindings.get('value');
          if (ko.isObservable(value)) {
            ko.computed({
              read: function() {
                value();
                setTimeout(function() {
                  $element.multiselect('refresh');
                }, 1);
              },
              disposeWhenNodeIsRemoved: element
            }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
          }
        }

        //Switched from arrayChange subscription to general subscription using 'refresh'.
        //Not sure performance is any better using 'select' and 'deselect'.
        if (allBindings.has('selectedOptions')) {
          var selectedOptions = allBindings.get('selectedOptions');
          if (ko.isObservable(selectedOptions)) {
            ko.computed({
              read: function() {
                selectedOptions();
                setTimeout(function() {
                  $element.multiselect('refresh');
                }, 1);
              },
              disposeWhenNodeIsRemoved: element
            }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
          }
        }

        var setEnabled = function (enable) {
          setTimeout(function () {
            if (enable)
              $element.multiselect('enable');
            else
              $element.multiselect('disable');
          });
        };

        if (allBindings.has('enable')) {
          var enable = allBindings.get('enable');
          if (ko.isObservable(enable)) {
            ko.computed({
              read: function () {
                setEnabled(enable());
              },
              disposeWhenNodeIsRemoved: element
            }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
          } else {
            setEnabled(enable);
          }
        }

        if (allBindings.has('disable')) {
          var disable = allBindings.get('disable');
          if (ko.isObservable(disable)) {
            ko.computed({
              read: function () {
                setEnabled(!disable());
              },
              disposeWhenNodeIsRemoved: element
            }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
          } else {
            setEnabled(!disable);
          }
        }

        ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
          $element.multiselect('destroy');
        });
      },

      update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        var $element = $(element);
        var config = ko.toJS(valueAccessor());

        $element.multiselect('setOptions', config);
        $element.multiselect('rebuild');
      }
    };
  }

  function forEach(array, callback) {
    for (var index = 0; index < array.length; ++index) {
      callback(array[index], index);
    }
  }

  /**
   * Constructor to create a new multiselect using the given select.
   *
   * @param {jQuery} select
   * @param {Object} options
   * @returns {Multiselect}
   */
  function Multiselect(select, options) {

    this.$select = $(select);

    // Placeholder via data attributes
    if (this.$select.attr("data-placeholder")) {
      options.nonSelectedText = this.$select.data("placeholder");
    }

    this.options = this.mergeOptions($.extend({}, options, this.$select.data()));

    // Initialization.
    // We have to clone to create a new reference.
    this.originalOptions = this.$select.clone()[0].options;
    this.query = '';
    this.searchTimeout = null;
    this.lastToggledInput = null;

    this.options.multiple = this.$select.attr('multiple') === "multiple";
    this.options.onChange = $.proxy(this.options.onChange, this);
    this.options.onDropdownShow = $.proxy(this.options.onDropdownShow, this);
    this.options.onDropdownHide = $.proxy(this.options.onDropdownHide, this);
    this.options.onDropdownShown = $.proxy(this.options.onDropdownShown, this);
    this.options.onDropdownHidden = $.proxy(this.options.onDropdownHidden, this);
    this.options.onInitialized = $.proxy(this.options.onInitialized, this);

    // Build select all if enabled.
    this.buildContainer();
    this.buildButton();
    this.buildDropdown();
    this.buildSelectAll();
    this.buildDropdownOptions();
    this.buildFilter();

    this.updateButtonText();
    this.updateSelectAll(true);

    if (this.options.disableIfEmpty && $('option', this.$select).length <= 0) {
      this.disable();
    }

    this.$select.hide().after(this.$container);
    this.options.onInitialized(this.$select, this.$container);
  }

  Multiselect.prototype = {

    defaults: {
      /**
       * Default text function will either print 'None selected' in case no
       * option is selected or a list of the selected options up to a length
       * of 3 selected options.
       *
       * @param {jQuery} options
       * @param {jQuery} select
       * @returns {String}
       */
      buttonText: function(options, select) {
        if (this.disabledText.length > 0
          && (this.disableIfEmpty || select.prop('disabled'))
          && options.length == 0) {

          return this.disabledText;
        }
        else if (options.length === 0) {
          return this.nonSelectedText;
        }
        else if (this.allSelectedText
          && options.length === $('option', $(select)).length
          && $('option', $(select)).length !== 1
          && this.multiple) {

          if (this.selectAllNumber) {
            return this.allSelectedText + ' (' + options.length + ')';
          }
          else {
            return this.allSelectedText;
          }
        }
        else if (options.length > this.numberDisplayed) {
          return options.length + ' ' + this.nSelectedText;
        }
        else {
          var selected = '';
          var delimiter = this.delimiterText;

          options.each(function() {
            var label = ($(this).attr('label') !== undefined) ? $(this).attr('label') : $(this).text();
            selected += label + delimiter;
          });

          return selected.substr(0, selected.length - 2);
        }
      },
      /**
       * Updates the title of the button similar to the buttonText function.
       *
       * @param {jQuery} options
       * @param {jQuery} select
       * @returns {@exp;selected@call;substr}
       */
      buttonTitle: function(options, select) {
        if (options.length === 0) {
          return this.nonSelectedText;
        }
        else {
          var selected = '';
          var delimiter = this.delimiterText;

          options.each(function () {
            var label = ($(this).attr('label') !== undefined) ? $(this).attr('label') : $(this).text();
            selected += label + delimiter;
          });
          return selected.substr(0, selected.length - 2);
        }
      },
      /**
       * Create a label.
       *
       * @param {jQuery} element
       * @returns {String}
       */
      optionLabel: function(element){
        return $(element).attr('label') || $(element).text();
      },
      /**
       * Create a class.
       *
       * @param {jQuery} element
       * @returns {String}
       */
      optionClass: function(element) {
        return $(element).attr('class') || '';
      },
      /**
       * Triggered on change of the multiselect.
       *
       * Not triggered when selecting/deselecting options manually.
       *
       * @param {jQuery} option
       * @param {Boolean} checked
       */
      onChange : function(option, checked) {

      },
      /**
       * Triggered when the dropdown is shown.
       *
       * @param {jQuery} event
       */
      onDropdownShow: function(event) {

      },
      /**
       * Triggered when the dropdown is hidden.
       *
       * @param {jQuery} event
       */
      onDropdownHide: function(event) {

      },
      /**
       * Triggered after the dropdown is shown.
       *
       * @param {jQuery} event
       */
      onDropdownShown: function(event) {

      },
      /**
       * Triggered after the dropdown is hidden.
       *
       * @param {jQuery} event
       */
      onDropdownHidden: function(event) {

      },
      /**
       * Triggered on select all.
       */
      onSelectAll: function(checked) {

      },
      /**
       * Triggered after initializing.
       *
       * @param {jQuery} $select
       * @param {jQuery} $container
       */
      onInitialized: function($select, $container) {

      },
      enableHTML: false,
      buttonClass: 'btn btn-default',
      inheritClass: false,
      buttonWidth: 'auto',
      buttonContainer: '<div class="btn-group" />',
      dropRight: false,
      dropUp: false,
      selectedClass: 'active',
      // Maximum height of the dropdown menu.
      // If maximum height is exceeded a scrollbar will be displayed.
      maxHeight: false,
      checkboxName: false,
      includeSelectAllOption: false,
      includeSelectAllIfMoreThan: 0,
      selectAllText: ' Select all',
      selectAllValue: 'multiselect-all',
      selectAllName: false,
      selectAllNumber: true,
      selectAllJustVisible: true,
      enableFiltering: false,
      enableCaseInsensitiveFiltering: false,
      enableFullValueFiltering: false,
      enableClickableOptGroups: false,
      enableCollapsibelOptGroups: false,
      filterPlaceholder: 'Search',
      // possible options: 'text', 'value', 'both'
      filterBehavior: 'text',
      includeFilterClearBtn: true,
      preventInputChangeEvent: false,
      nonSelectedText: 'None selected',
      nSelectedText: 'selected',
      allSelectedText: 'All selected',
      numberDisplayed: 3,
      disableIfEmpty: false,
      disabledText: '',
      delimiterText: ', ',
      templates: {
        button: '<button type="button" class="multiselect dropdown-toggle" data-toggle="dropdown"><span class="multiselect-selected-text"></span> <b class="caret"></b></button>',
        ul: '<ul class="multiselect-container dropdown-menu"></ul>',
        filter: '<li class="multiselect-item filter"><div class="input-group"><span class="input-group-addon"><i class="glyphicon glyphicon-search"></i></span><input class="form-control multiselect-search" type="text"></div></li>',
        filterClearBtn: '<span class="input-group-btn"><button class="btn btn-default multiselect-clear-filter" type="button"><i class="glyphicon glyphicon-remove-circle"></i></button></span>',
        li: '<li><a tabindex="0"><label></label></a></li>',
        divider: '<li class="multiselect-item divider"></li>',
        liGroup: '<li class="multiselect-item multiselect-group"><label></label></li>'
      }
    },

    constructor: Multiselect,

    /**
     * Builds the container of the multiselect.
     */
    buildContainer: function() {
      this.$container = $(this.options.buttonContainer);
      this.$container.on('show.bs.dropdown', this.options.onDropdownShow);
      this.$container.on('hide.bs.dropdown', this.options.onDropdownHide);
      this.$container.on('shown.bs.dropdown', this.options.onDropdownShown);
      this.$container.on('hidden.bs.dropdown', this.options.onDropdownHidden);
    },

    /**
     * Builds the button of the multiselect.
     */
    buildButton: function() {
      this.$button = $(this.options.templates.button).addClass(this.options.buttonClass);
      if (this.$select.attr('class') && this.options.inheritClass) {
        this.$button.addClass(this.$select.attr('class'));
      }
      // Adopt active state.
      if (this.$select.prop('disabled')) {
        this.disable();
      }
      else {
        this.enable();
      }

      // Manually add button width if set.
      if (this.options.buttonWidth && this.options.buttonWidth !== 'auto') {
        this.$button.css({
          'width' : this.options.buttonWidth,
          'overflow' : 'hidden',
          'text-overflow' : 'ellipsis'
        });
        this.$container.css({
          'width': this.options.buttonWidth
        });
      }

      // Keep the tab index from the select.
      var tabindex = this.$select.attr('tabindex');
      if (tabindex) {
        this.$button.attr('tabindex', tabindex);
      }

      this.$container.prepend(this.$button);
    },

    /**
     * Builds the ul representing the dropdown menu.
     */
    buildDropdown: function() {

      // Build ul.
      this.$ul = $(this.options.templates.ul);

      if (this.options.dropRight) {
        this.$ul.addClass('pull-right');
      }

      // Set max height of dropdown menu to activate auto scrollbar.
      if (this.options.maxHeight) {
        // TODO: Add a class for this option to move the css declarations.
        this.$ul.css({
          'max-height': this.options.maxHeight + 'px',
          'overflow-y': 'auto',
          'overflow-x': 'hidden'
        });
      }

      if (this.options.dropUp) {

        var height = Math.min(this.options.maxHeight, $('option[data-role!="divider"]', this.$select).length*26 + $('option[data-role="divider"]', this.$select).length*19 + (this.options.includeSelectAllOption ? 26 : 0) + (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering ? 44 : 0));
        var moveCalc = height + 34;

        this.$ul.css({
          'max-height': height + 'px',
          'overflow-y': 'auto',
          'overflow-x': 'hidden',
          'margin-top': "-" + moveCalc + 'px'
        });
      }

      this.$container.append(this.$ul);
    },

    /**
     * Build the dropdown options and binds all nessecary events.
     *
     * Uses createDivider and createOptionValue to create the necessary options.
     */
    buildDropdownOptions: function() {

      this.$select.children().each($.proxy(function(index, element) {

        var $element = $(element);
        // Support optgroups and options without a group simultaneously.
        var tag = $element.prop('tagName')
          .toLowerCase();

        if ($element.prop('value') === this.options.selectAllValue) {
          return;
        }

        if (tag === 'optgroup') {
          this.createOptgroup(element);
        }
        else if (tag === 'option') {

          if ($element.data('role') === 'divider') {
            this.createDivider();
          }
          else {
            this.createOptionValue(element);
          }

        }

        // Other illegal tags will be ignored.
      }, this));

      // Bind the change event on the dropdown elements.
      $('li input', this.$ul).on('change', $.proxy(function(event) {
        var $target = $(event.target);

        var checked = $target.prop('checked') || false;
        var isSelectAllOption = $target.val() === this.options.selectAllValue;

        // Apply or unapply the configured selected class.
        if (this.options.selectedClass) {
          if (checked) {
            $target.closest('li')
              .addClass(this.options.selectedClass);
          }
          else {
            $target.closest('li')
              .removeClass(this.options.selectedClass);
          }
        }

        // Get the corresponding option.
        var value = $target.val();
        var $option = this.getOptionByValue(value);

        var $optionsNotThis = $('option', this.$select).not($option);
        var $checkboxesNotThis = $('input', this.$container).not($target);

        if (isSelectAllOption) {
          if (checked) {
            this.selectAll(this.options.selectAllJustVisible);
          }
          else {
            this.deselectAll(this.options.selectAllJustVisible);
          }
        }
        else {
          if (checked) {
            $option.prop('selected', true);

            if (this.options.multiple) {
              // Simply select additional option.
              $option.prop('selected', true);
            }
            else {
              // Unselect all other options and corresponding checkboxes.
              if (this.options.selectedClass) {
                $($checkboxesNotThis).closest('li').removeClass(this.options.selectedClass);
              }

              $($checkboxesNotThis).prop('checked', false);
              $optionsNotThis.prop('selected', false);

              // It's a single selection, so close.
              this.$button.click();
            }

            if (this.options.selectedClass === "active") {
              $optionsNotThis.closest("a").css("outline", "");
            }
          }
          else {
            // Unselect option.
            $option.prop('selected', false);
          }

          // To prevent select all from firing onChange: #575
          this.options.onChange($option, checked);
        }

        this.$select.change();

        this.updateButtonText();
        this.updateSelectAll();

        if(this.options.preventInputChangeEvent) {
          return false;
        }
      }, this));

      $('li a', this.$ul).on('mousedown', function(e) {
        if (e.shiftKey) {
          // Prevent selecting text by Shift+click
          return false;
        }
      });

      $('li a', this.$ul).on('touchstart click', $.proxy(function(event) {
        event.stopPropagation();

        var $target = $(event.target);

        if (event.shiftKey && this.options.multiple) {
          if($target.is("label")){ // Handles checkbox selection manually (see https://github.com/davidstutz/bootstrap-multiselect/issues/431)
            event.preventDefault();
            $target = $target.find("input");
            $target.prop("checked", !$target.prop("checked"));
          }
          var checked = $target.prop('checked') || false;

          if (this.lastToggledInput !== null && this.lastToggledInput !== $target) { // Make sure we actually have a range
            var from = $target.closest("li").index();
            var to = this.lastToggledInput.closest("li").index();

            if (from > to) { // Swap the indices
              var tmp = to;
              to = from;
              from = tmp;
            }

            // Make sure we grab all elements since slice excludes the last index
            ++to;

            // Change the checkboxes and underlying options
            var range = this.$ul.find("li").slice(from, to).find("input");

            range.prop('checked', checked);

            if (this.options.selectedClass) {
              range.closest('li')
                .toggleClass(this.options.selectedClass, checked);
            }

            for (var i = 0, j = range.length; i < j; i++) {
              var $checkbox = $(range[i]);

              var $option = this.getOptionByValue($checkbox.val());

              $option.prop('selected', checked);
            }
          }

          // Trigger the select "change" event
          $target.trigger("change");
        }

        // Remembers last clicked option
        if($target.is("input") && !$target.closest("li").is(".multiselect-item")){
          this.lastToggledInput = $target;
        }

        $target.blur();
      }, this));

      // Keyboard support.
      this.$container.off('keydown.multiselect').on('keydown.multiselect', $.proxy(function(event) {
        if ($('input[type="text"]', this.$container).is(':focus')) {
          return;
        }

        if (event.keyCode === 9 && this.$container.hasClass('open')) {
          this.$button.click();
        }
        else {
          var $items = $(this.$container).find("li:not(.divider):not(.disabled) a").filter(":visible");

          if (!$items.length) {
            return;
          }

          var index = $items.index($items.filter(':focus'));

          // Navigation up.
          if (event.keyCode === 38 && index > 0) {
            index--;
          }
          // Navigate down.
          else if (event.keyCode === 40 && index < $items.length - 1) {
            index++;
          }
          else if (!~index) {
            index = 0;
          }

          var $current = $items.eq(index);
          $current.focus();

          if (event.keyCode === 32 || event.keyCode === 13) {
            var $checkbox = $current.find('input');

            $checkbox.prop("checked", !$checkbox.prop("checked"));
            $checkbox.change();
          }

          event.stopPropagation();
          event.preventDefault();
        }
      }, this));

      if(this.options.enableClickableOptGroups && this.options.multiple) {
        $('li.multiselect-group', this.$ul).on('click', $.proxy(function(event) {
          event.stopPropagation();
          console.log('test');
          var group = $(event.target).parent();

          // Search all option in optgroup
          var $options = group.nextUntil('li.multiselect-group');
          var $visibleOptions = $options.filter(":visible:not(.disabled)");

          // check or uncheck items
          var allChecked = true;
          var optionInputs = $visibleOptions.find('input');
          var values = [];

          optionInputs.each(function() {
            allChecked = allChecked && $(this).prop('checked');
            values.push($(this).val());
          });

          if (!allChecked) {
            this.select(values, false);
          }
          else {
            this.deselect(values, false);
          }

          this.options.onChange(optionInputs, !allChecked);
        }, this));
      }

      if (this.options.enableCollapsibleOptGroups && this.options.multiple) {
        $("li.multiselect-group input", this.$ul).off();
        $("li.multiselect-group", this.$ul).siblings().not("li.multiselect-group, li.multiselect-all", this.$ul).each( function () {
          $(this).toggleClass('hidden', true);
        });

        $("li.multiselect-group", this.$ul).on("click", $.proxy(function(group) {
          group.stopPropagation();
        }, this));

        $("li.multiselect-group > a > b", this.$ul).on("click", $.proxy(function(t) {
          t.stopPropagation();
          var n = $(t.target).closest('li');
          var r = n.nextUntil("li.multiselect-group");
          var i = true;

          r.each(function() {
            i = i && $(this).hasClass('hidden');
          });

          r.toggleClass('hidden', !i);
        }, this));

        $("li.multiselect-group > a > input", this.$ul).on("change", $.proxy(function(t) {
          t.stopPropagation();
          var n = $(t.target).closest('li');
          var r = n.nextUntil("li.multiselect-group", ':not(.disabled)');
          var s = r.find("input");

          var i = true;
          s.each(function() {
            i = i && $(this).prop("checked");
          });

          s.prop("checked", !i).trigger("change");
        }, this));

        // Set the initial selection state of the groups.
        $('li.multiselect-group', this.$ul).each(function() {
          var r = $(this).nextUntil("li.multiselect-group", ':not(.disabled)');
          var s = r.find("input");

          var i = true;
          s.each(function() {
            i = i && $(this).prop("checked");
          });

          $(this).find('input').prop("checked", i);
        });

        // Update the group checkbox based on new selections among the
        // corresponding children.
        $("li input", this.$ul).on("change", $.proxy(function(t) {
          t.stopPropagation();
          var n = $(t.target).closest('li');
          var r1 = n.prevUntil("li.multiselect-group", ':not(.disabled)');
          var r2 = n.nextUntil("li.multiselect-group", ':not(.disabled)');
          var s1 = r1.find("input");
          var s2 = r2.find("input");

          var i = $(t.target).prop('checked');
          s1.each(function() {
            i = i && $(this).prop("checked");
          });

          s2.each(function() {
            i = i && $(this).prop("checked");
          });

          n.prevAll('.multiselect-group').find('input').prop('checked', i);
        }, this));

        $("li.multiselect-all", this.$ul).css('background', '#f3f3f3').css('border-bottom', '1px solid #eaeaea');
        $("li.multiselect-group > a, li.multiselect-all > a > label.checkbox", this.$ul).css('padding', '3px 20px 3px 35px');
        $("li.multiselect-group > a > input", this.$ul).css('margin', '4px 0px 5px -20px');
      }
    },

    /**
     * Create an option using the given select option.
     *
     * @param {jQuery} element
     */
    createOptionValue: function(element) {
      var $element = $(element);
      if ($element.is(':selected')) {
        $element.prop('selected', true);
      }

      // Support the label attribute on options.
      var label = this.options.optionLabel(element);
      var classes = this.options.optionClass(element);
      var value = $element.val();
      var inputType = this.options.multiple ? "checkbox" : "radio";

      var $li = $(this.options.templates.li);
      var $label = $('label', $li);
      $label.addClass(inputType);
      $li.addClass(classes);

      if (this.options.enableHTML) {
        $label.html(" " + label);
      }
      else {
        $label.text(" " + label);
      }

      var $checkbox = $('<input/>').attr('type', inputType);

      if (this.options.checkboxName) {
        $checkbox.attr('name', this.options.checkboxName);
      }
      $label.prepend($checkbox);

      var selected = $element.prop('selected') || false;
      $checkbox.val(value);

      if (value === this.options.selectAllValue) {
        $li.addClass("multiselect-item multiselect-all");
        $checkbox.parent().parent()
          .addClass('multiselect-all');
      }

      $label.attr('title', $element.attr('title'));

      this.$ul.append($li);

      if ($element.is(':disabled')) {
        $checkbox.attr('disabled', 'disabled')
          .prop('disabled', true)
          .closest('a')
          .attr("tabindex", "-1")
          .closest('li')
          .addClass('disabled');
      }

      $checkbox.prop('checked', selected);

      if (selected && this.options.selectedClass) {
        $checkbox.closest('li')
          .addClass(this.options.selectedClass);
      }
    },

    /**
     * Creates a divider using the given select option.
     *
     * @param {jQuery} element
     */
    createDivider: function(element) {
      var $divider = $(this.options.templates.divider);
      this.$ul.append($divider);
    },

    /**
     * Creates an optgroup.
     *
     * @param {jQuery} group
     */
    createOptgroup: function(group) {
      if (this.options.enableCollapsibleOptGroups && this.options.multiple) {
        var label = $(group).attr("label");
        var value = $(group).attr("value");
        var r = $('<li class="multiselect-item multiselect-group"><a href="javascript:void(0);"><input type="checkbox" value="' + value + '"/><b> ' + label + '<b class="caret"></b></b></a></li>');

        if (this.options.enableClickableOptGroups) {
          r.addClass("multiselect-group-clickable")
        }
        this.$ul.append(r);
        if ($(group).is(":disabled")) {
          r.addClass("disabled")
        }
        $("option", group).each($.proxy(function($, group) {
          this.createOptionValue(group)
        }, this))
      }
      else {
        var groupName = $(group).prop('label');

        // Add a header for the group.
        var $li = $(this.options.templates.liGroup);

        if (this.options.enableHTML) {
          $('label', $li).html(groupName);
        }
        else {
          $('label', $li).text(groupName);
        }

        if (this.options.enableClickableOptGroups) {
          $li.addClass('multiselect-group-clickable');
        }

        this.$ul.append($li);

        if ($(group).is(':disabled')) {
          $li.addClass('disabled');
        }

        // Add the options of the group.
        $('option', group).each($.proxy(function(index, element) {
          this.createOptionValue(element);
        }, this));
      }
    },

    /**
     * Build the select all.
     *
     * Checks if a select all has already been created.
     */
    buildSelectAll: function() {
      if (typeof this.options.selectAllValue === 'number') {
        this.options.selectAllValue = this.options.selectAllValue.toString();
      }

      var alreadyHasSelectAll = this.hasSelectAll();

      if (!alreadyHasSelectAll && this.options.includeSelectAllOption && this.options.multiple
        && $('option', this.$select).length > this.options.includeSelectAllIfMoreThan) {

        // Check whether to add a divider after the select all.
        if (this.options.includeSelectAllDivider) {
          this.$ul.prepend($(this.options.templates.divider));
        }

        var $li = $(this.options.templates.li);
        $('label', $li).addClass("checkbox");

        if (this.options.enableHTML) {
          $('label', $li).html(" " + this.options.selectAllText);
        }
        else {
          $('label', $li).text(" " + this.options.selectAllText);
        }

        if (this.options.selectAllName) {
          $('label', $li).prepend('<input type="checkbox" name="' + this.options.selectAllName + '" />');
        }
        else {
          $('label', $li).prepend('<input type="checkbox" />');
        }

        var $checkbox = $('input', $li);
        $checkbox.val(this.options.selectAllValue);

        $li.addClass("multiselect-item multiselect-all");
        $checkbox.parent().parent()
          .addClass('multiselect-all');

        this.$ul.prepend($li);

        $checkbox.prop('checked', false);
      }
    },

    /**
     * Builds the filter.
     */
    buildFilter: function() {

      // Build filter if filtering OR case insensitive filtering is enabled and the number of options exceeds (or equals) enableFilterLength.
      if (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering) {
        var enableFilterLength = Math.max(this.options.enableFiltering, this.options.enableCaseInsensitiveFiltering);

        if (this.$select.find('option').length >= enableFilterLength) {

          this.$filter = $(this.options.templates.filter);
          $('input', this.$filter).attr('placeholder', this.options.filterPlaceholder);

          // Adds optional filter clear button
          if(this.options.includeFilterClearBtn){
            var clearBtn = $(this.options.templates.filterClearBtn);
            clearBtn.on('click', $.proxy(function(event){
              clearTimeout(this.searchTimeout);
              this.$filter.find('.multiselect-search').val('');
              $('li', this.$ul).show().removeClass("filter-hidden");
              this.updateSelectAll();
            }, this));
            this.$filter.find('.input-group').append(clearBtn);
          }

          this.$ul.prepend(this.$filter);

          this.$filter.val(this.query).on('click', function(event) {
            event.stopPropagation();
          }).on('input keydown', $.proxy(function(event) {
            // Cancel enter key default behaviour
            if (event.which === 13) {
              event.preventDefault();
            }

            // This is useful to catch "keydown" events after the browser has updated the control.
            clearTimeout(this.searchTimeout);

            this.searchTimeout = this.asyncFunction($.proxy(function() {

              if (this.query !== event.target.value) {
                this.query = event.target.value;

                var currentGroup, currentGroupVisible;
                $.each($('li', this.$ul), $.proxy(function(index, element) {
                  var value = $('input', element).length > 0 ? $('input', element).val() : "";
                  var text = $('label', element).text();

                  var filterCandidate = '';
                  if ((this.options.filterBehavior === 'text')) {
                    filterCandidate = text;
                  }
                  else if ((this.options.filterBehavior === 'value')) {
                    filterCandidate = value;
                  }
                  else if (this.options.filterBehavior === 'both') {
                    filterCandidate = text + '\n' + value;
                  }

                  if (value !== this.options.selectAllValue && text) {

                    // By default lets assume that element is not
                    // interesting for this search.
                    var showElement = false;

                    if (this.options.enableCaseInsensitiveFiltering) {
                      filterCandidate = filterCandidate.toLowerCase();
                      this.query = this.query.toLowerCase();
                    }

                    if (this.options.enableFullValueFiltering && this.options.filterBehavior !== 'both') {
                      var valueToMatch = filterCandidate.trim().substring(0, this.query.length);
                      if (this.query.indexOf(valueToMatch) > -1) {
                        showElement = true;
                      }
                    }
                    else if (filterCandidate.indexOf(this.query) > -1) {
                      showElement = true;
                    }

                    // Toggle current element (group or group item) according to showElement boolean.
                    $(element).toggle(showElement).toggleClass('filter-hidden', !showElement);

                    // Differentiate groups and group items.
                    if ($(element).hasClass('multiselect-group')) {
                      // Remember group status.
                      currentGroup = element;
                      currentGroupVisible = showElement;
                    }
                    else {
                      // Show group name when at least one of its items is visible.
                      if (showElement) {
                        $(currentGroup).show().removeClass('filter-hidden');
                      }

                      // Show all group items when group name satisfies filter.
                      if (!showElement && currentGroupVisible) {
                        $(element).show().removeClass('filter-hidden');
                      }
                    }
                  }
                }, this));
              }

              this.updateSelectAll();
            }, this), 300, this);
          }, this));
        }
      }
    },

    /**
     * Unbinds the whole plugin.
     */
    destroy: function() {
      this.$container.remove();
      this.$select.show();
      this.$select.data('multiselect', null);
    },

    /**
     * Refreshs the multiselect based on the selected options of the select.
     */
    refresh: function () {
      var inputs = $.map($('li input', this.$ul), $);

      $('option', this.$select).each($.proxy(function (index, element) {
        var $elem = $(element);
        var value = $elem.val();
        var $input;
        for (var i = inputs.length; 0 < i--; /**/) {
          if (value !== ($input = inputs[i]).val())
            continue; // wrong li

          if ($elem.is(':selected')) {
            $input.prop('checked', true);

            if (this.options.selectedClass) {
              $input.closest('li')
                .addClass(this.options.selectedClass);
            }
          }
          else {
            $input.prop('checked', false);

            if (this.options.selectedClass) {
              $input.closest('li')
                .removeClass(this.options.selectedClass);
            }
          }

          if ($elem.is(":disabled")) {
            $input.attr('disabled', 'disabled')
              .prop('disabled', true)
              .closest('li')
              .addClass('disabled');
          }
          else {
            $input.prop('disabled', false)
              .closest('li')
              .removeClass('disabled');
          }
          break; // assumes unique values
        }
      }, this));

      this.updateButtonText();
      this.updateSelectAll();
    },

    /**
     * Select all options of the given values.
     *
     * If triggerOnChange is set to true, the on change event is triggered if
     * and only if one value is passed.
     *
     * @param {Array} selectValues
     * @param {Boolean} triggerOnChange
     */
    select: function(selectValues, triggerOnChange) {
      if(!$.isArray(selectValues)) {
        selectValues = [selectValues];
      }

      for (var i = 0; i < selectValues.length; i++) {
        var value = selectValues[i];

        if (value === null || value === undefined) {
          continue;
        }

        var $option = this.getOptionByValue(value);
        var $checkbox = this.getInputByValue(value);

        if($option === undefined || $checkbox === undefined) {
          continue;
        }

        if (!this.options.multiple) {
          this.deselectAll(false);
        }

        if (this.options.selectedClass) {
          $checkbox.closest('li')
            .addClass(this.options.selectedClass);
        }

        $checkbox.prop('checked', true);
        $option.prop('selected', true);

        if (triggerOnChange) {
          this.options.onChange($option, true);
        }
      }

      this.updateButtonText();
      this.updateSelectAll();
    },

    /**
     * Clears all selected items.
     */
    clearSelection: function () {
      this.deselectAll(false);
      this.updateButtonText();
      this.updateSelectAll();
    },

    /**
     * Deselects all options of the given values.
     *
     * If triggerOnChange is set to true, the on change event is triggered, if
     * and only if one value is passed.
     *
     * @param {Array} deselectValues
     * @param {Boolean} triggerOnChange
     */
    deselect: function(deselectValues, triggerOnChange) {
      if(!$.isArray(deselectValues)) {
        deselectValues = [deselectValues];
      }

      for (var i = 0; i < deselectValues.length; i++) {
        var value = deselectValues[i];

        if (value === null || value === undefined) {
          continue;
        }

        var $option = this.getOptionByValue(value);
        var $checkbox = this.getInputByValue(value);

        if($option === undefined || $checkbox === undefined) {
          continue;
        }

        if (this.options.selectedClass) {
          $checkbox.closest('li')
            .removeClass(this.options.selectedClass);
        }

        $checkbox.prop('checked', false);
        $option.prop('selected', false);

        if (triggerOnChange) {
          this.options.onChange($option, false);
        }
      }

      this.updateButtonText();
      this.updateSelectAll();
    },

    /**
     * Selects all enabled & visible options.
     *
     * If justVisible is true or not specified, only visible options are selected.
     *
     * @param {Boolean} justVisible
     * @param {Boolean} triggerOnSelectAll
     */
    selectAll: function (justVisible, triggerOnSelectAll) {
      justVisible = (this.options.enableCollapsibleOptGroups && this.options.multiple) ? false : justVisible;

      var justVisible = typeof justVisible === 'undefined' ? true : justVisible;
      var allCheckboxes = $("li input[type='checkbox']:enabled", this.$ul);
      var visibleCheckboxes = allCheckboxes.filter(":visible");
      var allCheckboxesCount = allCheckboxes.length;
      var visibleCheckboxesCount = visibleCheckboxes.length;

      if(justVisible) {
        visibleCheckboxes.prop('checked', true);
        $("li:not(.divider):not(.disabled)", this.$ul).filter(":visible").addClass(this.options.selectedClass);
      }
      else {
        allCheckboxes.prop('checked', true);
        $("li:not(.divider):not(.disabled)", this.$ul).addClass(this.options.selectedClass);
      }

      if (allCheckboxesCount === visibleCheckboxesCount || justVisible === false) {
        $("option:not([data-role='divider']):enabled", this.$select).prop('selected', true);
      }
      else {
        var values = visibleCheckboxes.map(function() {
          return $(this).val();
        }).get();

        $("option:enabled", this.$select).filter(function(index) {
          return $.inArray($(this).val(), values) !== -1;
        }).prop('selected', true);
      }

      if (triggerOnSelectAll) {
        this.options.onSelectAll();
      }
    },

    /**
     * Deselects all options.
     *
     * If justVisible is true or not specified, only visible options are deselected.
     *
     * @param {Boolean} justVisible
     */
    deselectAll: function (justVisible) {
      justVisible = (this.options.enableCollapsibleOptGroups && this.options.multiple) ? false : justVisible;
      justVisible = typeof justVisible === 'undefined' ? true : justVisible;

      if(justVisible) {
        var visibleCheckboxes = $("li input[type='checkbox']:not(:disabled)", this.$ul).filter(":visible");
        visibleCheckboxes.prop('checked', false);

        var values = visibleCheckboxes.map(function() {
          return $(this).val();
        }).get();

        $("option:enabled", this.$select).filter(function(index) {
          return $.inArray($(this).val(), values) !== -1;
        }).prop('selected', false);

        if (this.options.selectedClass) {
          $("li:not(.divider):not(.disabled)", this.$ul).filter(":visible").removeClass(this.options.selectedClass);
        }
      }
      else {
        $("li input[type='checkbox']:enabled", this.$ul).prop('checked', false);
        $("option:enabled", this.$select).prop('selected', false);

        if (this.options.selectedClass) {
          $("li:not(.divider):not(.disabled)", this.$ul).removeClass(this.options.selectedClass);
        }
      }
    },

    /**
     * Rebuild the plugin.
     *
     * Rebuilds the dropdown, the filter and the select all option.
     */
    rebuild: function() {
      this.$ul.html('');

      // Important to distinguish between radios and checkboxes.
      this.options.multiple = this.$select.attr('multiple') === "multiple";

      this.buildSelectAll();
      this.buildDropdownOptions();
      this.buildFilter();

      this.updateButtonText();
      this.updateSelectAll(true);

      if (this.options.disableIfEmpty && $('option', this.$select).length <= 0) {
        this.disable();
      }
      else {
        this.enable();
      }

      if (this.options.dropRight) {
        this.$ul.addClass('pull-right');
      }
    },

    /**
     * The provided data will be used to build the dropdown.
     */
    dataprovider: function(dataprovider) {

      var groupCounter = 0;
      var $select = this.$select.empty();

      $.each(dataprovider, function (index, option) {
        var $tag;

        if ($.isArray(option.children)) { // create optiongroup tag
          groupCounter++;

          $tag = $('<optgroup/>').attr({
            label: option.label || 'Group ' + groupCounter,
            disabled: !!option.disabled
          });

          forEach(option.children, function(subOption) { // add children option tags
            $tag.append($('<option/>').attr({
              value: subOption.value,
              label: subOption.label || subOption.value,
              title: subOption.title,
              selected: !!subOption.selected,
              disabled: !!subOption.disabled
            }));
          });
        }
        else {
          $tag = $('<option/>').attr({
            value: option.value,
            label: option.label || option.value,
            title: option.title,
            class: option.class,
            selected: !!option.selected,
            disabled: !!option.disabled
          });
          $tag.text(option.label || option.value);
        }

        $select.append($tag);
      });

      this.rebuild();
    },

    /**
     * Enable the multiselect.
     */
    enable: function() {
      this.$select.prop('disabled', false);
      this.$button.prop('disabled', false)
        .removeClass('disabled');
    },

    /**
     * Disable the multiselect.
     */
    disable: function() {
      this.$select.prop('disabled', true);
      this.$button.prop('disabled', true)
        .addClass('disabled');
    },

    /**
     * Set the options.
     *
     * @param {Array} options
     */
    setOptions: function(options) {
      this.options = this.mergeOptions(options);
    },

    /**
     * Merges the given options with the default options.
     *
     * @param {Array} options
     * @returns {Array}
     */
    mergeOptions: function(options) {
      return $.extend(true, {}, this.defaults, this.options, options);
    },

    /**
     * Checks whether a select all checkbox is present.
     *
     * @returns {Boolean}
     */
    hasSelectAll: function() {
      return $('li.multiselect-all', this.$ul).length > 0;
    },

    /**
     * Updates the select all checkbox based on the currently displayed and selected checkboxes.
     */
    updateSelectAll: function(notTriggerOnSelectAll) {
      if (this.hasSelectAll()) {
        var allBoxes = $("li:not(.multiselect-item):not(.filter-hidden) input:enabled", this.$ul);
        var allBoxesLength = allBoxes.length;
        var checkedBoxesLength = allBoxes.filter(":checked").length;
        var selectAllLi  = $("li.multiselect-all", this.$ul);
        var selectAllInput = selectAllLi.find("input");

        if (checkedBoxesLength > 0 && checkedBoxesLength === allBoxesLength) {
          selectAllInput.prop("checked", true);
          selectAllLi.addClass(this.options.selectedClass);
          this.options.onSelectAll(true);
        }
        else {
          selectAllInput.prop("checked", false);
          selectAllLi.removeClass(this.options.selectedClass);
          if (checkedBoxesLength === 0) {
            if (!notTriggerOnSelectAll) {
              this.options.onSelectAll(false);
            }
          }
        }
      }
    },

    /**
     * Update the button text and its title based on the currently selected options.
     */
    updateButtonText: function() {
      var options = this.getSelected();

      // First update the displayed button text.
      if (this.options.enableHTML) {
        $('.multiselect .multiselect-selected-text', this.$container).html(this.options.buttonText(options, this.$select));
      }
      else {
        $('.multiselect .multiselect-selected-text', this.$container).text(this.options.buttonText(options, this.$select));
      }

      // Now update the title attribute of the button.
      $('.multiselect', this.$container).attr('title', this.options.buttonTitle(options, this.$select));
    },

    /**
     * Get all selected options.
     *
     * @returns {jQUery}
     */
    getSelected: function() {
      return $('option', this.$select).filter(":selected");
    },

    /**
     * Gets a select option by its value.
     *
     * @param {String} value
     * @returns {jQuery}
     */
    getOptionByValue: function (value) {

      var options = $('option', this.$select);
      var valueToCompare = value.toString();

      for (var i = 0; i < options.length; i = i + 1) {
        var option = options[i];
        if (option.value === valueToCompare) {
          return $(option);
        }
      }
    },

    /**
     * Get the input (radio/checkbox) by its value.
     *
     * @param {String} value
     * @returns {jQuery}
     */
    getInputByValue: function (value) {

      var checkboxes = $('li input', this.$ul);
      var valueToCompare = value.toString();

      for (var i = 0; i < checkboxes.length; i = i + 1) {
        var checkbox = checkboxes[i];
        if (checkbox.value === valueToCompare) {
          return $(checkbox);
        }
      }
    },

    /**
     * Used for knockout integration.
     */
    updateOriginalOptions: function() {
      this.originalOptions = this.$select.clone()[0].options;
    },

    asyncFunction: function(callback, timeout, self) {
      var args = Array.prototype.slice.call(arguments, 3);
      return setTimeout(function() {
        callback.apply(self || window, args);
      }, timeout);
    },

    setAllSelectedText: function(allSelectedText) {
      this.options.allSelectedText = allSelectedText;
      this.updateButtonText();
    }
  };

  $.fn.multiselect = function(option, parameter, extraOptions) {
    return this.each(function() {
      var data = $(this).data('multiselect');
      var options = typeof option === 'object' && option;

      // Initialize the multiselect.
      if (!data) {
        data = new Multiselect(this, options);
        $(this).data('multiselect', data);
      }

      // Call multiselect method.
      if (typeof option === 'string') {
        data[option](parameter, extraOptions);

        if (option === 'destroy') {
          $(this).data('multiselect', false);
        }
      }
    });
  };

  $.fn.multiselect.Constructor = Multiselect;

  $(function() {
    $("select[data-role=multiselect]").multiselect();
  });

}(window.jQuery);
},{}],3:[function(require,module,exports){
/*! =======================================================
 VERSION  9.8.0
 ========================================================= */


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! =========================================================
 * bootstrap-slider.js
 *
 * Maintainers:
 *		Kyle Kemp
 *			- Twitter: @seiyria
 *			- Github:  seiyria
 *		Rohit Kalkur
 *			- Twitter: @Rovolutionary
 *			- Github:  rovolution
 *
 * =========================================================
 *
 * bootstrap-slider is released under the MIT License
 * Copyright (c) 2017 Kyle Kemp, Rohit Kalkur, and contributors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * ========================================================= */

/**
 * Bridget makes jQuery widgets
 * v1.0.1
 * MIT license
 */
var windowIsDefined = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object";

(function (factory) {
  if (typeof define === "function" && define.amd) {
    define(["jquery"], factory);
  } else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module.exports) {
    var jQuery;
    try {
      jQuery = require("jquery");
    } catch (err) {
      jQuery = null;
    }
    module.exports = factory(jQuery);
  } else if (window) {
    window.Slider = factory(window.jQuery);
  }
})(function ($) {
  // Constants
  var NAMESPACE_MAIN = 'slider';
  var NAMESPACE_ALTERNATE = 'bootstrapSlider';

  // Polyfill console methods
  if (windowIsDefined && !window.console) {
    window.console = {};
  }
  if (windowIsDefined && !window.console.log) {
    window.console.log = function () {};
  }
  if (windowIsDefined && !window.console.warn) {
    window.console.warn = function () {};
  }

  // Reference to Slider constructor
  var Slider;

  (function ($) {



    // -------------------------- utils -------------------------- //

    var slice = Array.prototype.slice;

    function noop() {}

    // -------------------------- definition -------------------------- //

    function defineBridget($) {

      // bail if no jQuery
      if (!$) {
        return;
      }

      // -------------------------- addOptionMethod -------------------------- //

      /**
       * adds option method -> $().plugin('option', {...})
       * @param {Function} PluginClass - constructor class
       */
      function addOptionMethod(PluginClass) {
        // don't overwrite original option method
        if (PluginClass.prototype.option) {
          return;
        }

        // option setter
        PluginClass.prototype.option = function (opts) {
          // bail out if not an object
          if (!$.isPlainObject(opts)) {
            return;
          }
          this.options = $.extend(true, this.options, opts);
        };
      }

      // -------------------------- plugin bridge -------------------------- //

      // helper function for logging errors
      // $.error breaks jQuery chaining
      var logError = typeof console === 'undefined' ? noop : function (message) {
        console.error(message);
      };

      /**
       * jQuery plugin bridge, access methods like $elem.plugin('method')
       * @param {String} namespace - plugin name
       * @param {Function} PluginClass - constructor class
       */
      function bridge(namespace, PluginClass) {
        // add to jQuery fn namespace
        $.fn[namespace] = function (options) {
          if (typeof options === 'string') {
            // call plugin method when first argument is a string
            // get arguments for method
            var args = slice.call(arguments, 1);

            for (var i = 0, len = this.length; i < len; i++) {
              var elem = this[i];
              var instance = $.data(elem, namespace);
              if (!instance) {
                logError("cannot call methods on " + namespace + " prior to initialization; " + "attempted to call '" + options + "'");
                continue;
              }
              if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
                logError("no such method '" + options + "' for " + namespace + " instance");
                continue;
              }

              // trigger method with arguments
              var returnValue = instance[options].apply(instance, args);

              // break look and return first value if provided
              if (returnValue !== undefined && returnValue !== instance) {
                return returnValue;
              }
            }
            // return this if no return value
            return this;
          } else {
            var objects = this.map(function () {
              var instance = $.data(this, namespace);
              if (instance) {
                // apply options & init
                instance.option(options);
                instance._init();
              } else {
                // initialize new instance
                instance = new PluginClass(this, options);
                $.data(this, namespace, instance);
              }
              return $(this);
            });

            if (!objects || objects.length > 1) {
              return objects;
            } else {
              return objects[0];
            }
          }
        };
      }

      // -------------------------- bridget -------------------------- //

      /**
       * converts a Prototypical class into a proper jQuery plugin
       *   the class must have a ._init method
       * @param {String} namespace - plugin name, used in $().pluginName
       * @param {Function} PluginClass - constructor class
       */
      $.bridget = function (namespace, PluginClass) {
        addOptionMethod(PluginClass);
        bridge(namespace, PluginClass);
      };

      return $.bridget;
    }

    // get jquery from browser global
    defineBridget($);
  })($);

  /*************************************************
   BOOTSTRAP-SLIDER SOURCE CODE
   **************************************************/

  (function ($) {

    var ErrorMsgs = {
      formatInvalidInputErrorMsg: function formatInvalidInputErrorMsg(input) {
        return "Invalid input value '" + input + "' passed in";
      },
      callingContextNotSliderInstance: "Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"
    };

    var SliderScale = {
      linear: {
        toValue: function toValue(percentage) {
          var rawValue = percentage / 100 * (this.options.max - this.options.min);
          var shouldAdjustWithBase = true;
          if (this.options.ticks_positions.length > 0) {
            var minv,
              maxv,
              minp,
              maxp = 0;
            for (var i = 1; i < this.options.ticks_positions.length; i++) {
              if (percentage <= this.options.ticks_positions[i]) {
                minv = this.options.ticks[i - 1];
                minp = this.options.ticks_positions[i - 1];
                maxv = this.options.ticks[i];
                maxp = this.options.ticks_positions[i];

                break;
              }
            }
            var partialPercentage = (percentage - minp) / (maxp - minp);
            rawValue = minv + partialPercentage * (maxv - minv);
            shouldAdjustWithBase = false;
          }

          var adjustment = shouldAdjustWithBase ? this.options.min : 0;
          var value = adjustment + Math.round(rawValue / this.options.step) * this.options.step;
          if (value < this.options.min) {
            return this.options.min;
          } else if (value > this.options.max) {
            return this.options.max;
          } else {
            return value;
          }
        },
        toPercentage: function toPercentage(value) {
          if (this.options.max === this.options.min) {
            return 0;
          }

          if (this.options.ticks_positions.length > 0) {
            var minv,
              maxv,
              minp,
              maxp = 0;
            for (var i = 0; i < this.options.ticks.length; i++) {
              if (value <= this.options.ticks[i]) {
                minv = i > 0 ? this.options.ticks[i - 1] : 0;
                minp = i > 0 ? this.options.ticks_positions[i - 1] : 0;
                maxv = this.options.ticks[i];
                maxp = this.options.ticks_positions[i];

                break;
              }
            }
            if (i > 0) {
              var partialPercentage = (value - minv) / (maxv - minv);
              return minp + partialPercentage * (maxp - minp);
            }
          }

          return 100 * (value - this.options.min) / (this.options.max - this.options.min);
        }
      },

      logarithmic: {
        /* Based on http://stackoverflow.com/questions/846221/logarithmic-slider */
        toValue: function toValue(percentage) {
          var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
          var max = Math.log(this.options.max);
          var value = Math.exp(min + (max - min) * percentage / 100);
          value = this.options.min + Math.round((value - this.options.min) / this.options.step) * this.options.step;
          /* Rounding to the nearest step could exceed the min or
           * max, so clip to those values. */
          if (value < this.options.min) {
            return this.options.min;
          } else if (value > this.options.max) {
            return this.options.max;
          } else {
            return value;
          }
        },
        toPercentage: function toPercentage(value) {
          if (this.options.max === this.options.min) {
            return 0;
          } else {
            var max = Math.log(this.options.max);
            var min = this.options.min === 0 ? 0 : Math.log(this.options.min);
            var v = value === 0 ? 0 : Math.log(value);
            return 100 * (v - min) / (max - min);
          }
        }
      }
    };

    /*************************************************
     CONSTRUCTOR
     **************************************************/
    Slider = function Slider(element, options) {
      createNewSlider.call(this, element, options);
      return this;
    };

    function createNewSlider(element, options) {

      /*
       The internal state object is used to store data about the current 'state' of slider.
       This includes values such as the `value`, `enabled`, etc...
       */
      this._state = {
        value: null,
        enabled: null,
        offset: null,
        size: null,
        percentage: null,
        inDrag: false,
        over: false
      };

      // The objects used to store the reference to the tick methods if ticks_tooltip is on
      this.ticksCallbackMap = {};
      this.handleCallbackMap = {};

      if (typeof element === "string") {
        this.element = document.querySelector(element);
      } else if (element instanceof HTMLElement) {
        this.element = element;
      }

      /*************************************************
       Process Options
       **************************************************/
      options = options ? options : {};
      var optionTypes = Object.keys(this.defaultOptions);

      for (var i = 0; i < optionTypes.length; i++) {
        var optName = optionTypes[i];

        // First check if an option was passed in via the constructor
        var val = options[optName];
        // If no data attrib, then check data atrributes
        val = typeof val !== 'undefined' ? val : getDataAttrib(this.element, optName);
        // Finally, if nothing was specified, use the defaults
        val = val !== null ? val : this.defaultOptions[optName];

        // Set all options on the instance of the Slider
        if (!this.options) {
          this.options = {};
        }
        this.options[optName] = val;
      }

      // Check options.rtl
      if (this.options.rtl === 'auto') {
        this.options.rtl = window.getComputedStyle(this.element).direction === 'rtl';
      }

      /*
       Validate `tooltip_position` against 'orientation`
       - if `tooltip_position` is incompatible with orientation, swith it to a default compatible with specified `orientation`
       -- default for "vertical" -> "right", "left" if rtl
       -- default for "horizontal" -> "top"
       */
      if (this.options.orientation === "vertical" && (this.options.tooltip_position === "top" || this.options.tooltip_position === "bottom")) {
        if (this.options.rtl) {
          this.options.tooltip_position = "left";
        } else {
          this.options.tooltip_position = "right";
        }
      } else if (this.options.orientation === "horizontal" && (this.options.tooltip_position === "left" || this.options.tooltip_position === "right")) {

        this.options.tooltip_position = "top";
      }

      function getDataAttrib(element, optName) {
        var dataName = "data-slider-" + optName.replace(/_/g, '-');
        var dataValString = element.getAttribute(dataName);

        try {
          return JSON.parse(dataValString);
        } catch (err) {
          return dataValString;
        }
      }

      /*************************************************
       Create Markup
       **************************************************/

      var origWidth = this.element.style.width;
      var updateSlider = false;
      var parent = this.element.parentNode;
      var sliderTrackSelection;
      var sliderTrackLow, sliderTrackHigh;
      var sliderMinHandle;
      var sliderMaxHandle;

      if (this.sliderElem) {
        updateSlider = true;
      } else {
        /* Create elements needed for slider */
        this.sliderElem = document.createElement("div");
        this.sliderElem.className = "slider";

        /* Create slider track elements */
        var sliderTrack = document.createElement("div");
        sliderTrack.className = "slider-track";

        sliderTrackLow = document.createElement("div");
        sliderTrackLow.className = "slider-track-low";

        sliderTrackSelection = document.createElement("div");
        sliderTrackSelection.className = "slider-selection";

        sliderTrackHigh = document.createElement("div");
        sliderTrackHigh.className = "slider-track-high";

        sliderMinHandle = document.createElement("div");
        sliderMinHandle.className = "slider-handle min-slider-handle";
        sliderMinHandle.setAttribute('role', 'slider');
        sliderMinHandle.setAttribute('aria-valuemin', this.options.min);
        sliderMinHandle.setAttribute('aria-valuemax', this.options.max);

        sliderMaxHandle = document.createElement("div");
        sliderMaxHandle.className = "slider-handle max-slider-handle";
        sliderMaxHandle.setAttribute('role', 'slider');
        sliderMaxHandle.setAttribute('aria-valuemin', this.options.min);
        sliderMaxHandle.setAttribute('aria-valuemax', this.options.max);

        sliderTrack.appendChild(sliderTrackLow);
        sliderTrack.appendChild(sliderTrackSelection);
        sliderTrack.appendChild(sliderTrackHigh);

        /* Create highlight range elements */
        this.rangeHighlightElements = [];
        var rangeHighlightsOpts = this.options.rangeHighlights;
        if (Array.isArray(rangeHighlightsOpts) && rangeHighlightsOpts.length > 0) {
          for (var j = 0; j < rangeHighlightsOpts.length; j++) {
            var rangeHighlightElement = document.createElement("div");
            var customClassString = rangeHighlightsOpts[j].class || "";
            rangeHighlightElement.className = "slider-rangeHighlight slider-selection " + customClassString;
            this.rangeHighlightElements.push(rangeHighlightElement);
            sliderTrack.appendChild(rangeHighlightElement);
          }
        }

        /* Add aria-labelledby to handle's */
        var isLabelledbyArray = Array.isArray(this.options.labelledby);
        if (isLabelledbyArray && this.options.labelledby[0]) {
          sliderMinHandle.setAttribute('aria-labelledby', this.options.labelledby[0]);
        }
        if (isLabelledbyArray && this.options.labelledby[1]) {
          sliderMaxHandle.setAttribute('aria-labelledby', this.options.labelledby[1]);
        }
        if (!isLabelledbyArray && this.options.labelledby) {
          sliderMinHandle.setAttribute('aria-labelledby', this.options.labelledby);
          sliderMaxHandle.setAttribute('aria-labelledby', this.options.labelledby);
        }

        /* Create ticks */
        this.ticks = [];
        if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
          this.ticksContainer = document.createElement('div');
          this.ticksContainer.className = 'slider-tick-container';

          for (i = 0; i < this.options.ticks.length; i++) {
            var tick = document.createElement('div');
            tick.className = 'slider-tick';
            if (this.options.ticks_tooltip) {
              var tickListenerReference = this._addTickListener();
              var enterCallback = tickListenerReference.addMouseEnter(this, tick, i);
              var leaveCallback = tickListenerReference.addMouseLeave(this, tick);

              this.ticksCallbackMap[i] = {
                mouseEnter: enterCallback,
                mouseLeave: leaveCallback
              };
            }
            this.ticks.push(tick);
            this.ticksContainer.appendChild(tick);
          }

          sliderTrackSelection.className += " tick-slider-selection";
        }

        this.tickLabels = [];
        if (Array.isArray(this.options.ticks_labels) && this.options.ticks_labels.length > 0) {
          this.tickLabelContainer = document.createElement('div');
          this.tickLabelContainer.className = 'slider-tick-label-container';

          for (i = 0; i < this.options.ticks_labels.length; i++) {
            var label = document.createElement('div');
            var noTickPositionsSpecified = this.options.ticks_positions.length === 0;
            var tickLabelsIndex = this.options.reversed && noTickPositionsSpecified ? this.options.ticks_labels.length - (i + 1) : i;
            label.className = 'slider-tick-label';
            label.innerHTML = this.options.ticks_labels[tickLabelsIndex];

            this.tickLabels.push(label);
            this.tickLabelContainer.appendChild(label);
          }
        }

        var createAndAppendTooltipSubElements = function createAndAppendTooltipSubElements(tooltipElem) {
          var arrow = document.createElement("div");
          arrow.className = "tooltip-arrow";

          var inner = document.createElement("div");
          inner.className = "tooltip-inner";

          tooltipElem.appendChild(arrow);
          tooltipElem.appendChild(inner);
        };

        /* Create tooltip elements */
        var sliderTooltip = document.createElement("div");
        sliderTooltip.className = "tooltip tooltip-main";
        sliderTooltip.setAttribute('role', 'presentation');
        createAndAppendTooltipSubElements(sliderTooltip);

        var sliderTooltipMin = document.createElement("div");
        sliderTooltipMin.className = "tooltip tooltip-min";
        sliderTooltipMin.setAttribute('role', 'presentation');
        createAndAppendTooltipSubElements(sliderTooltipMin);

        var sliderTooltipMax = document.createElement("div");
        sliderTooltipMax.className = "tooltip tooltip-max";
        sliderTooltipMax.setAttribute('role', 'presentation');
        createAndAppendTooltipSubElements(sliderTooltipMax);

        /* Append components to sliderElem */
        this.sliderElem.appendChild(sliderTrack);
        this.sliderElem.appendChild(sliderTooltip);
        this.sliderElem.appendChild(sliderTooltipMin);
        this.sliderElem.appendChild(sliderTooltipMax);

        if (this.tickLabelContainer) {
          this.sliderElem.appendChild(this.tickLabelContainer);
        }
        if (this.ticksContainer) {
          this.sliderElem.appendChild(this.ticksContainer);
        }

        this.sliderElem.appendChild(sliderMinHandle);
        this.sliderElem.appendChild(sliderMaxHandle);

        /* Append slider element to parent container, right before the original <input> element */
        parent.insertBefore(this.sliderElem, this.element);

        /* Hide original <input> element */
        this.element.style.display = "none";
      }
      /* If JQuery exists, cache JQ references */
      if ($) {
        this.$element = $(this.element);
        this.$sliderElem = $(this.sliderElem);
      }

      /*************************************************
       Setup
       **************************************************/
      this.eventToCallbackMap = {};
      this.sliderElem.id = this.options.id;

      this.touchCapable = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch;

      this.touchX = 0;
      this.touchY = 0;

      this.tooltip = this.sliderElem.querySelector('.tooltip-main');
      this.tooltipInner = this.tooltip.querySelector('.tooltip-inner');

      this.tooltip_min = this.sliderElem.querySelector('.tooltip-min');
      this.tooltipInner_min = this.tooltip_min.querySelector('.tooltip-inner');

      this.tooltip_max = this.sliderElem.querySelector('.tooltip-max');
      this.tooltipInner_max = this.tooltip_max.querySelector('.tooltip-inner');

      if (SliderScale[this.options.scale]) {
        this.options.scale = SliderScale[this.options.scale];
      }

      if (updateSlider === true) {
        // Reset classes
        this._removeClass(this.sliderElem, 'slider-horizontal');
        this._removeClass(this.sliderElem, 'slider-vertical');
        this._removeClass(this.sliderElem, 'slider-rtl');
        this._removeClass(this.tooltip, 'hide');
        this._removeClass(this.tooltip_min, 'hide');
        this._removeClass(this.tooltip_max, 'hide');

        // Undo existing inline styles for track
        ["left", "right", "top", "width", "height"].forEach(function (prop) {
          this._removeProperty(this.trackLow, prop);
          this._removeProperty(this.trackSelection, prop);
          this._removeProperty(this.trackHigh, prop);
        }, this);

        // Undo inline styles on handles
        [this.handle1, this.handle2].forEach(function (handle) {
          this._removeProperty(handle, 'left');
          this._removeProperty(handle, 'right');
          this._removeProperty(handle, 'top');
        }, this);

        // Undo inline styles and classes on tooltips
        [this.tooltip, this.tooltip_min, this.tooltip_max].forEach(function (tooltip) {
          this._removeProperty(tooltip, 'left');
          this._removeProperty(tooltip, 'right');
          this._removeProperty(tooltip, 'top');
          this._removeProperty(tooltip, 'margin-left');
          this._removeProperty(tooltip, 'margin-right');
          this._removeProperty(tooltip, 'margin-top');

          this._removeClass(tooltip, 'right');
          this._removeClass(tooltip, 'left');
          this._removeClass(tooltip, 'top');
        }, this);
      }

      if (this.options.orientation === 'vertical') {
        this._addClass(this.sliderElem, 'slider-vertical');
        this.stylePos = 'top';
        this.mousePos = 'pageY';
        this.sizePos = 'offsetHeight';
      } else {
        this._addClass(this.sliderElem, 'slider-horizontal');
        this.sliderElem.style.width = origWidth;
        this.options.orientation = 'horizontal';
        if (this.options.rtl) {
          this.stylePos = 'right';
        } else {
          this.stylePos = 'left';
        }
        this.mousePos = 'pageX';
        this.sizePos = 'offsetWidth';
      }
      // specific rtl class
      if (this.options.rtl) {
        this._addClass(this.sliderElem, 'slider-rtl');
      }
      this._setTooltipPosition();
      /* In case ticks are specified, overwrite the min and max bounds */
      if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {
        this.options.max = Math.max.apply(Math, this.options.ticks);
        this.options.min = Math.min.apply(Math, this.options.ticks);
      }

      if (Array.isArray(this.options.value)) {
        this.options.range = true;
        this._state.value = this.options.value;
      } else if (this.options.range) {
        // User wants a range, but value is not an array
        this._state.value = [this.options.value, this.options.max];
      } else {
        this._state.value = this.options.value;
      }

      this.trackLow = sliderTrackLow || this.trackLow;
      this.trackSelection = sliderTrackSelection || this.trackSelection;
      this.trackHigh = sliderTrackHigh || this.trackHigh;

      if (this.options.selection === 'none') {
        this._addClass(this.trackLow, 'hide');
        this._addClass(this.trackSelection, 'hide');
        this._addClass(this.trackHigh, 'hide');
      } else if (this.options.selection === 'after' || this.options.selection === 'before') {
        this._removeClass(this.trackLow, 'hide');
        this._removeClass(this.trackSelection, 'hide');
        this._removeClass(this.trackHigh, 'hide');
      }

      this.handle1 = sliderMinHandle || this.handle1;
      this.handle2 = sliderMaxHandle || this.handle2;

      if (updateSlider === true) {
        // Reset classes
        this._removeClass(this.handle1, 'round triangle');
        this._removeClass(this.handle2, 'round triangle hide');

        for (i = 0; i < this.ticks.length; i++) {
          this._removeClass(this.ticks[i], 'round triangle hide');
        }
      }

      var availableHandleModifiers = ['round', 'triangle', 'custom'];
      var isValidHandleType = availableHandleModifiers.indexOf(this.options.handle) !== -1;
      if (isValidHandleType) {
        this._addClass(this.handle1, this.options.handle);
        this._addClass(this.handle2, this.options.handle);

        for (i = 0; i < this.ticks.length; i++) {
          this._addClass(this.ticks[i], this.options.handle);
        }
      }

      this._state.offset = this._offset(this.sliderElem);
      this._state.size = this.sliderElem[this.sizePos];
      this.setValue(this._state.value);

      /******************************************
       Bind Event Listeners
       ******************************************/

      // Bind keyboard handlers
      this.handle1Keydown = this._keydown.bind(this, 0);
      this.handle1.addEventListener("keydown", this.handle1Keydown, false);

      this.handle2Keydown = this._keydown.bind(this, 1);
      this.handle2.addEventListener("keydown", this.handle2Keydown, false);

      this.mousedown = this._mousedown.bind(this);
      this.touchstart = this._touchstart.bind(this);
      this.touchmove = this._touchmove.bind(this);

      if (this.touchCapable) {
        // Test for passive event support
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, 'passive', {
            get: function get() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e) {}
        // Use our detect's results. passive applied if supported, capture will be false either way.
        var eventOptions = supportsPassive ? { passive: true } : false;
        // Bind touch handlers
        this.sliderElem.addEventListener("touchstart", this.touchstart, eventOptions);
        this.sliderElem.addEventListener("touchmove", this.touchmove, eventOptions);
      }
      this.sliderElem.addEventListener("mousedown", this.mousedown, false);

      // Bind window handlers
      this.resize = this._resize.bind(this);
      window.addEventListener("resize", this.resize, false);

      // Bind tooltip-related handlers
      if (this.options.tooltip === 'hide') {
        this._addClass(this.tooltip, 'hide');
        this._addClass(this.tooltip_min, 'hide');
        this._addClass(this.tooltip_max, 'hide');
      } else if (this.options.tooltip === 'always') {
        this._showTooltip();
        this._alwaysShowTooltip = true;
      } else {
        this.showTooltip = this._showTooltip.bind(this);
        this.hideTooltip = this._hideTooltip.bind(this);

        if (this.options.ticks_tooltip) {
          var callbackHandle = this._addTickListener();
          //create handle1 listeners and store references in map
          var mouseEnter = callbackHandle.addMouseEnter(this, this.handle1);
          var mouseLeave = callbackHandle.addMouseLeave(this, this.handle1);
          this.handleCallbackMap.handle1 = {
            mouseEnter: mouseEnter,
            mouseLeave: mouseLeave
          };
          //create handle2 listeners and store references in map
          mouseEnter = callbackHandle.addMouseEnter(this, this.handle2);
          mouseLeave = callbackHandle.addMouseLeave(this, this.handle2);
          this.handleCallbackMap.handle2 = {
            mouseEnter: mouseEnter,
            mouseLeave: mouseLeave
          };
        } else {
          this.sliderElem.addEventListener("mouseenter", this.showTooltip, false);
          this.sliderElem.addEventListener("mouseleave", this.hideTooltip, false);
        }

        this.handle1.addEventListener("focus", this.showTooltip, false);
        this.handle1.addEventListener("blur", this.hideTooltip, false);

        this.handle2.addEventListener("focus", this.showTooltip, false);
        this.handle2.addEventListener("blur", this.hideTooltip, false);
      }

      if (this.options.enabled) {
        this.enable();
      } else {
        this.disable();
      }
    }

    /*************************************************
     INSTANCE PROPERTIES/METHODS
     - Any methods bound to the prototype are considered
     part of the plugin's `public` interface
     **************************************************/
    Slider.prototype = {
      _init: function _init() {}, // NOTE: Must exist to support bridget

      constructor: Slider,

      defaultOptions: {
        id: "",
        min: 0,
        max: 10,
        step: 1,
        precision: 0,
        orientation: 'horizontal',
        value: 5,
        range: false,
        selection: 'before',
        tooltip: 'show',
        tooltip_split: false,
        handle: 'round',
        reversed: false,
        rtl: 'auto',
        enabled: true,
        formatter: function formatter(val) {
          if (Array.isArray(val)) {
            return val[0] + " : " + val[1];
          } else {
            return val;
          }
        },
        natural_arrow_keys: false,
        ticks: [],
        ticks_positions: [],
        ticks_labels: [],
        ticks_snap_bounds: 0,
        ticks_tooltip: false,
        scale: 'linear',
        focus: false,
        tooltip_position: null,
        labelledby: null,
        rangeHighlights: []
      },

      getElement: function getElement() {
        return this.sliderElem;
      },

      getValue: function getValue() {
        if (this.options.range) {
          return this._state.value;
        } else {
          return this._state.value[0];
        }
      },

      setValue: function setValue(val, triggerSlideEvent, triggerChangeEvent) {
        if (!val) {
          val = 0;
        }
        var oldValue = this.getValue();
        this._state.value = this._validateInputValue(val);
        var applyPrecision = this._applyPrecision.bind(this);

        if (this.options.range) {
          this._state.value[0] = applyPrecision(this._state.value[0]);
          this._state.value[1] = applyPrecision(this._state.value[1]);

          this._state.value[0] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[0]));
          this._state.value[1] = Math.max(this.options.min, Math.min(this.options.max, this._state.value[1]));
        } else {
          this._state.value = applyPrecision(this._state.value);
          this._state.value = [Math.max(this.options.min, Math.min(this.options.max, this._state.value))];
          this._addClass(this.handle2, 'hide');
          if (this.options.selection === 'after') {
            this._state.value[1] = this.options.max;
          } else {
            this._state.value[1] = this.options.min;
          }
        }

        if (this.options.max > this.options.min) {
          this._state.percentage = [this._toPercentage(this._state.value[0]), this._toPercentage(this._state.value[1]), this.options.step * 100 / (this.options.max - this.options.min)];
        } else {
          this._state.percentage = [0, 0, 100];
        }

        this._layout();
        var newValue = this.options.range ? this._state.value : this._state.value[0];

        this._setDataVal(newValue);
        if (triggerSlideEvent === true) {
          this._trigger('slide', newValue);
        }
        if (oldValue !== newValue && triggerChangeEvent === true) {
          this._trigger('change', {
            oldValue: oldValue,
            newValue: newValue
          });
        }

        return this;
      },

      destroy: function destroy() {
        // Remove event handlers on slider elements
        this._removeSliderEventHandlers();

        // Remove the slider from the DOM
        this.sliderElem.parentNode.removeChild(this.sliderElem);
        /* Show original <input> element */
        this.element.style.display = "";

        // Clear out custom event bindings
        this._cleanUpEventCallbacksMap();

        // Remove data values
        this.element.removeAttribute("data");

        // Remove JQuery handlers/data
        if ($) {
          this._unbindJQueryEventHandlers();
          this.$element.removeData('slider');
        }
      },

      disable: function disable() {
        this._state.enabled = false;
        this.handle1.removeAttribute("tabindex");
        this.handle2.removeAttribute("tabindex");
        this._addClass(this.sliderElem, 'slider-disabled');
        this._trigger('slideDisabled');

        return this;
      },

      enable: function enable() {
        this._state.enabled = true;
        this.handle1.setAttribute("tabindex", 0);
        this.handle2.setAttribute("tabindex", 0);
        this._removeClass(this.sliderElem, 'slider-disabled');
        this._trigger('slideEnabled');

        return this;
      },

      toggle: function toggle() {
        if (this._state.enabled) {
          this.disable();
        } else {
          this.enable();
        }
        return this;
      },

      isEnabled: function isEnabled() {
        return this._state.enabled;
      },

      on: function on(evt, callback) {
        this._bindNonQueryEventHandler(evt, callback);
        return this;
      },

      off: function off(evt, callback) {
        if ($) {
          this.$element.off(evt, callback);
          this.$sliderElem.off(evt, callback);
        } else {
          this._unbindNonQueryEventHandler(evt, callback);
        }
      },

      getAttribute: function getAttribute(attribute) {
        if (attribute) {
          return this.options[attribute];
        } else {
          return this.options;
        }
      },

      setAttribute: function setAttribute(attribute, value) {
        this.options[attribute] = value;
        return this;
      },

      refresh: function refresh() {
        this._removeSliderEventHandlers();
        createNewSlider.call(this, this.element, this.options);
        if ($) {
          // Bind new instance of slider to the element
          $.data(this.element, 'slider', this);
        }
        return this;
      },

      relayout: function relayout() {
        this._resize();
        this._layout();
        return this;
      },

      /******************************+
       HELPERS
       - Any method that is not part of the public interface.
       - Place it underneath this comment block and write its signature like so:
       _fnName : function() {...}
       ********************************/
      _removeSliderEventHandlers: function _removeSliderEventHandlers() {
        // Remove keydown event listeners
        this.handle1.removeEventListener("keydown", this.handle1Keydown, false);
        this.handle2.removeEventListener("keydown", this.handle2Keydown, false);

        //remove the listeners from the ticks and handles if they had their own listeners
        if (this.options.ticks_tooltip) {
          var ticks = this.ticksContainer.getElementsByClassName('slider-tick');
          for (var i = 0; i < ticks.length; i++) {
            ticks[i].removeEventListener('mouseenter', this.ticksCallbackMap[i].mouseEnter, false);
            ticks[i].removeEventListener('mouseleave', this.ticksCallbackMap[i].mouseLeave, false);
          }
          this.handle1.removeEventListener('mouseenter', this.handleCallbackMap.handle1.mouseEnter, false);
          this.handle2.removeEventListener('mouseenter', this.handleCallbackMap.handle2.mouseEnter, false);
          this.handle1.removeEventListener('mouseleave', this.handleCallbackMap.handle1.mouseLeave, false);
          this.handle2.removeEventListener('mouseleave', this.handleCallbackMap.handle2.mouseLeave, false);
        }

        this.handleCallbackMap = null;
        this.ticksCallbackMap = null;

        if (this.showTooltip) {
          this.handle1.removeEventListener("focus", this.showTooltip, false);
          this.handle2.removeEventListener("focus", this.showTooltip, false);
        }
        if (this.hideTooltip) {
          this.handle1.removeEventListener("blur", this.hideTooltip, false);
          this.handle2.removeEventListener("blur", this.hideTooltip, false);
        }

        // Remove event listeners from sliderElem
        if (this.showTooltip) {
          this.sliderElem.removeEventListener("mouseenter", this.showTooltip, false);
        }
        if (this.hideTooltip) {
          this.sliderElem.removeEventListener("mouseleave", this.hideTooltip, false);
        }
        this.sliderElem.removeEventListener("touchstart", this.touchstart, false);
        this.sliderElem.removeEventListener("touchmove", this.touchmove, false);
        this.sliderElem.removeEventListener("mousedown", this.mousedown, false);

        // Remove window event listener
        window.removeEventListener("resize", this.resize, false);
      },
      _bindNonQueryEventHandler: function _bindNonQueryEventHandler(evt, callback) {
        if (this.eventToCallbackMap[evt] === undefined) {
          this.eventToCallbackMap[evt] = [];
        }
        this.eventToCallbackMap[evt].push(callback);
      },
      _unbindNonQueryEventHandler: function _unbindNonQueryEventHandler(evt, callback) {
        var callbacks = this.eventToCallbackMap[evt];
        if (callbacks !== undefined) {
          for (var i = 0; i < callbacks.length; i++) {
            if (callbacks[i] === callback) {
              callbacks.splice(i, 1);
              break;
            }
          }
        }
      },
      _cleanUpEventCallbacksMap: function _cleanUpEventCallbacksMap() {
        var eventNames = Object.keys(this.eventToCallbackMap);
        for (var i = 0; i < eventNames.length; i++) {
          var eventName = eventNames[i];
          delete this.eventToCallbackMap[eventName];
        }
      },
      _showTooltip: function _showTooltip() {
        if (this.options.tooltip_split === false) {
          this._addClass(this.tooltip, 'in');
          this.tooltip_min.style.display = 'none';
          this.tooltip_max.style.display = 'none';
        } else {
          this._addClass(this.tooltip_min, 'in');
          this._addClass(this.tooltip_max, 'in');
          this.tooltip.style.display = 'none';
        }
        this._state.over = true;
      },
      _hideTooltip: function _hideTooltip() {
        if (this._state.inDrag === false && this.alwaysShowTooltip !== true) {
          this._removeClass(this.tooltip, 'in');
          this._removeClass(this.tooltip_min, 'in');
          this._removeClass(this.tooltip_max, 'in');
        }
        this._state.over = false;
      },
      _setToolTipOnMouseOver: function _setToolTipOnMouseOver(tempState) {
        var formattedTooltipVal = this.options.formatter(!tempState ? this._state.value[0] : tempState.value[0]);
        var positionPercentages = !tempState ? getPositionPercentages(this._state, this.options.reversed) : getPositionPercentages(tempState, this.options.reversed);
        this._setText(this.tooltipInner, formattedTooltipVal);

        this.tooltip.style[this.stylePos] = positionPercentages[0] + "%";
        if (this.options.orientation === 'vertical') {
          this._css(this.tooltip, "margin-" + this.stylePos, -this.tooltip.offsetHeight / 2 + "px");
        } else {
          this._css(this.tooltip, "margin-" + this.stylePos, -this.tooltip.offsetWidth / 2 + "px");
        }

        function getPositionPercentages(state, reversed) {
          if (reversed) {
            return [100 - state.percentage[0], this.options.range ? 100 - state.percentage[1] : state.percentage[1]];
          }
          return [state.percentage[0], state.percentage[1]];
        }
      },
      _addTickListener: function _addTickListener() {
        return {
          addMouseEnter: function addMouseEnter(reference, tick, index) {
            var enter = function enter() {
              var tempState = reference._state;
              var idString = index >= 0 ? index : this.attributes['aria-valuenow'].value;
              var hoverIndex = parseInt(idString, 10);
              tempState.value[0] = hoverIndex;
              tempState.percentage[0] = reference.options.ticks_positions[hoverIndex];
              reference._setToolTipOnMouseOver(tempState);
              reference._showTooltip();
            };
            tick.addEventListener("mouseenter", enter, false);
            return enter;
          },
          addMouseLeave: function addMouseLeave(reference, tick) {
            var leave = function leave() {
              reference._hideTooltip();
            };
            tick.addEventListener("mouseleave", leave, false);
            return leave;
          }
        };
      },
      _layout: function _layout() {
        var positionPercentages;

        if (this.options.reversed) {
          positionPercentages = [100 - this._state.percentage[0], this.options.range ? 100 - this._state.percentage[1] : this._state.percentage[1]];
        } else {
          positionPercentages = [this._state.percentage[0], this._state.percentage[1]];
        }

        this.handle1.style[this.stylePos] = positionPercentages[0] + "%";
        this.handle1.setAttribute('aria-valuenow', this._state.value[0]);
        if (isNaN(this.options.formatter(this._state.value[0]))) {
          this.handle1.setAttribute('aria-valuetext', this.options.formatter(this._state.value[0]));
        }

        this.handle2.style[this.stylePos] = positionPercentages[1] + "%";
        this.handle2.setAttribute('aria-valuenow', this._state.value[1]);
        if (isNaN(this.options.formatter(this._state.value[1]))) {
          this.handle2.setAttribute('aria-valuetext', this.options.formatter(this._state.value[1]));
        }

        /* Position highlight range elements */
        if (this.rangeHighlightElements.length > 0 && Array.isArray(this.options.rangeHighlights) && this.options.rangeHighlights.length > 0) {
          for (var _i = 0; _i < this.options.rangeHighlights.length; _i++) {
            var startPercent = this._toPercentage(this.options.rangeHighlights[_i].start);
            var endPercent = this._toPercentage(this.options.rangeHighlights[_i].end);

            if (this.options.reversed) {
              var sp = 100 - endPercent;
              endPercent = 100 - startPercent;
              startPercent = sp;
            }

            var currentRange = this._createHighlightRange(startPercent, endPercent);

            if (currentRange) {
              if (this.options.orientation === 'vertical') {
                this.rangeHighlightElements[_i].style.top = currentRange.start + "%";
                this.rangeHighlightElements[_i].style.height = currentRange.size + "%";
              } else {
                if (this.options.rtl) {
                  this.rangeHighlightElements[_i].style.right = currentRange.start + "%";
                } else {
                  this.rangeHighlightElements[_i].style.left = currentRange.start + "%";
                }
                this.rangeHighlightElements[_i].style.width = currentRange.size + "%";
              }
            } else {
              this.rangeHighlightElements[_i].style.display = "none";
            }
          }
        }

        /* Position ticks and labels */
        if (Array.isArray(this.options.ticks) && this.options.ticks.length > 0) {

          var styleSize = this.options.orientation === 'vertical' ? 'height' : 'width';
          var styleMargin;
          if (this.options.orientation === 'vertical') {
            styleMargin = 'marginTop';
          } else {
            if (this.options.rtl) {
              styleMargin = 'marginRight';
            } else {
              styleMargin = 'marginLeft';
            }
          }
          var labelSize = this._state.size / (this.options.ticks.length - 1);

          if (this.tickLabelContainer) {
            var extraMargin = 0;
            if (this.options.ticks_positions.length === 0) {
              if (this.options.orientation !== 'vertical') {
                this.tickLabelContainer.style[styleMargin] = -labelSize / 2 + "px";
              }

              extraMargin = this.tickLabelContainer.offsetHeight;
            } else {
              /* Chidren are position absolute, calculate height by finding the max offsetHeight of a child */
              for (i = 0; i < this.tickLabelContainer.childNodes.length; i++) {
                if (this.tickLabelContainer.childNodes[i].offsetHeight > extraMargin) {
                  extraMargin = this.tickLabelContainer.childNodes[i].offsetHeight;
                }
              }
            }
            if (this.options.orientation === 'horizontal') {
              this.sliderElem.style.marginBottom = extraMargin + "px";
            }
          }
          for (var i = 0; i < this.options.ticks.length; i++) {

            var percentage = this.options.ticks_positions[i] || this._toPercentage(this.options.ticks[i]);

            if (this.options.reversed) {
              percentage = 100 - percentage;
            }

            this.ticks[i].style[this.stylePos] = percentage + "%";

            /* Set class labels to denote whether ticks are in the selection */
            this._removeClass(this.ticks[i], 'in-selection');
            if (!this.options.range) {
              if (this.options.selection === 'after' && percentage >= positionPercentages[0]) {
                this._addClass(this.ticks[i], 'in-selection');
              } else if (this.options.selection === 'before' && percentage <= positionPercentages[0]) {
                this._addClass(this.ticks[i], 'in-selection');
              }
            } else if (percentage >= positionPercentages[0] && percentage <= positionPercentages[1]) {
              this._addClass(this.ticks[i], 'in-selection');
            }

            if (this.tickLabels[i]) {
              this.tickLabels[i].style[styleSize] = labelSize + "px";

              if (this.options.orientation !== 'vertical' && this.options.ticks_positions[i] !== undefined) {
                this.tickLabels[i].style.position = 'absolute';
                this.tickLabels[i].style[this.stylePos] = percentage + "%";
                this.tickLabels[i].style[styleMargin] = -labelSize / 2 + 'px';
              } else if (this.options.orientation === 'vertical') {
                if (this.options.rtl) {
                  this.tickLabels[i].style['marginRight'] = this.sliderElem.offsetWidth + "px";
                } else {
                  this.tickLabels[i].style['marginLeft'] = this.sliderElem.offsetWidth + "px";
                }
                this.tickLabelContainer.style[styleMargin] = this.sliderElem.offsetWidth / 2 * -1 + 'px';
              }
            }
          }
        }

        var formattedTooltipVal;

        if (this.options.range) {
          formattedTooltipVal = this.options.formatter(this._state.value);
          this._setText(this.tooltipInner, formattedTooltipVal);
          this.tooltip.style[this.stylePos] = (positionPercentages[1] + positionPercentages[0]) / 2 + "%";

          if (this.options.orientation === 'vertical') {
            this._css(this.tooltip, "margin-" + this.stylePos, -this.tooltip.offsetHeight / 2 + "px");
          } else {
            this._css(this.tooltip, "margin-" + this.stylePos, -this.tooltip.offsetWidth / 2 + "px");
          }

          var innerTooltipMinText = this.options.formatter(this._state.value[0]);
          this._setText(this.tooltipInner_min, innerTooltipMinText);

          var innerTooltipMaxText = this.options.formatter(this._state.value[1]);
          this._setText(this.tooltipInner_max, innerTooltipMaxText);

          this.tooltip_min.style[this.stylePos] = positionPercentages[0] + "%";

          if (this.options.orientation === 'vertical') {
            this._css(this.tooltip_min, "margin-" + this.stylePos, -this.tooltip_min.offsetHeight / 2 + "px");
          } else {
            this._css(this.tooltip_min, "margin-" + this.stylePos, -this.tooltip_min.offsetWidth / 2 + "px");
          }

          this.tooltip_max.style[this.stylePos] = positionPercentages[1] + "%";

          if (this.options.orientation === 'vertical') {
            this._css(this.tooltip_max, "margin-" + this.stylePos, -this.tooltip_max.offsetHeight / 2 + "px");
          } else {
            this._css(this.tooltip_max, "margin-" + this.stylePos, -this.tooltip_max.offsetWidth / 2 + "px");
          }
        } else {
          formattedTooltipVal = this.options.formatter(this._state.value[0]);
          this._setText(this.tooltipInner, formattedTooltipVal);

          this.tooltip.style[this.stylePos] = positionPercentages[0] + "%";
          if (this.options.orientation === 'vertical') {
            this._css(this.tooltip, "margin-" + this.stylePos, -this.tooltip.offsetHeight / 2 + "px");
          } else {
            this._css(this.tooltip, "margin-" + this.stylePos, -this.tooltip.offsetWidth / 2 + "px");
          }
        }

        if (this.options.orientation === 'vertical') {
          this.trackLow.style.top = '0';
          this.trackLow.style.height = Math.min(positionPercentages[0], positionPercentages[1]) + '%';

          this.trackSelection.style.top = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
          this.trackSelection.style.height = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

          this.trackHigh.style.bottom = '0';
          this.trackHigh.style.height = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';
        } else {
          if (this.stylePos === 'right') {
            this.trackLow.style.right = '0';
          } else {
            this.trackLow.style.left = '0';
          }
          this.trackLow.style.width = Math.min(positionPercentages[0], positionPercentages[1]) + '%';

          if (this.stylePos === 'right') {
            this.trackSelection.style.right = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
          } else {
            this.trackSelection.style.left = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
          }
          this.trackSelection.style.width = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

          if (this.stylePos === 'right') {
            this.trackHigh.style.left = '0';
          } else {
            this.trackHigh.style.right = '0';
          }
          this.trackHigh.style.width = 100 - Math.min(positionPercentages[0], positionPercentages[1]) - Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

          var offset_min = this.tooltip_min.getBoundingClientRect();
          var offset_max = this.tooltip_max.getBoundingClientRect();

          if (this.options.tooltip_position === 'bottom') {
            if (offset_min.right > offset_max.left) {
              this._removeClass(this.tooltip_max, 'bottom');
              this._addClass(this.tooltip_max, 'top');
              this.tooltip_max.style.top = '';
              this.tooltip_max.style.bottom = 22 + 'px';
            } else {
              this._removeClass(this.tooltip_max, 'top');
              this._addClass(this.tooltip_max, 'bottom');
              this.tooltip_max.style.top = this.tooltip_min.style.top;
              this.tooltip_max.style.bottom = '';
            }
          } else {
            if (offset_min.right > offset_max.left) {
              this._removeClass(this.tooltip_max, 'top');
              this._addClass(this.tooltip_max, 'bottom');
              this.tooltip_max.style.top = 18 + 'px';
            } else {
              this._removeClass(this.tooltip_max, 'bottom');
              this._addClass(this.tooltip_max, 'top');
              this.tooltip_max.style.top = this.tooltip_min.style.top;
            }
          }
        }
      },
      _createHighlightRange: function _createHighlightRange(start, end) {
        if (this._isHighlightRange(start, end)) {
          if (start > end) {
            return { 'start': end, 'size': start - end };
          }
          return { 'start': start, 'size': end - start };
        }
        return null;
      },
      _isHighlightRange: function _isHighlightRange(start, end) {
        if (0 <= start && start <= 100 && 0 <= end && end <= 100) {
          return true;
        } else {
          return false;
        }
      },
      _resize: function _resize(ev) {
        /*jshint unused:false*/
        this._state.offset = this._offset(this.sliderElem);
        this._state.size = this.sliderElem[this.sizePos];
        this._layout();
      },
      _removeProperty: function _removeProperty(element, prop) {
        if (element.style.removeProperty) {
          element.style.removeProperty(prop);
        } else {
          element.style.removeAttribute(prop);
        }
      },
      _mousedown: function _mousedown(ev) {
        if (!this._state.enabled) {
          return false;
        }

        this._state.offset = this._offset(this.sliderElem);
        this._state.size = this.sliderElem[this.sizePos];

        var percentage = this._getPercentage(ev);

        if (this.options.range) {
          var diff1 = Math.abs(this._state.percentage[0] - percentage);
          var diff2 = Math.abs(this._state.percentage[1] - percentage);
          this._state.dragged = diff1 < diff2 ? 0 : 1;
          this._adjustPercentageForRangeSliders(percentage);
        } else {
          this._state.dragged = 0;
        }

        this._state.percentage[this._state.dragged] = percentage;
        this._layout();

        if (this.touchCapable) {
          document.removeEventListener("touchmove", this.mousemove, false);
          document.removeEventListener("touchend", this.mouseup, false);
        }

        if (this.mousemove) {
          document.removeEventListener("mousemove", this.mousemove, false);
        }
        if (this.mouseup) {
          document.removeEventListener("mouseup", this.mouseup, false);
        }

        this.mousemove = this._mousemove.bind(this);
        this.mouseup = this._mouseup.bind(this);

        if (this.touchCapable) {
          // Touch: Bind touch events:
          document.addEventListener("touchmove", this.mousemove, false);
          document.addEventListener("touchend", this.mouseup, false);
        }
        // Bind mouse events:
        document.addEventListener("mousemove", this.mousemove, false);
        document.addEventListener("mouseup", this.mouseup, false);

        this._state.inDrag = true;
        var newValue = this._calculateValue();

        this._trigger('slideStart', newValue);

        this._setDataVal(newValue);
        this.setValue(newValue, false, true);

        ev.returnValue = false;

        if (this.options.focus) {
          this._triggerFocusOnHandle(this._state.dragged);
        }

        return true;
      },
      _touchstart: function _touchstart(ev) {
        if (ev.changedTouches === undefined) {
          this._mousedown(ev);
          return;
        }

        var touch = ev.changedTouches[0];
        this.touchX = touch.pageX;
        this.touchY = touch.pageY;
      },
      _triggerFocusOnHandle: function _triggerFocusOnHandle(handleIdx) {
        if (handleIdx === 0) {
          this.handle1.focus();
        }
        if (handleIdx === 1) {
          this.handle2.focus();
        }
      },
      _keydown: function _keydown(handleIdx, ev) {
        if (!this._state.enabled) {
          return false;
        }

        var dir;
        switch (ev.keyCode) {
          case 37: // left
          case 40:
            // down
            dir = -1;
            break;
          case 39: // right
          case 38:
            // up
            dir = 1;
            break;
        }
        if (!dir) {
          return;
        }

        // use natural arrow keys instead of from min to max
        if (this.options.natural_arrow_keys) {
          var ifVerticalAndNotReversed = this.options.orientation === 'vertical' && !this.options.reversed;
          var ifHorizontalAndReversed = this.options.orientation === 'horizontal' && this.options.reversed; // @todo control with rtl

          if (ifVerticalAndNotReversed || ifHorizontalAndReversed) {
            dir = -dir;
          }
        }

        var val = this._state.value[handleIdx] + dir * this.options.step;
        var percentage = val / this.options.max * 100;
        this._state.keyCtrl = handleIdx;
        if (this.options.range) {
          this._adjustPercentageForRangeSliders(percentage);
          var val1 = !this._state.keyCtrl ? val : this._state.value[0];
          var val2 = this._state.keyCtrl ? val : this._state.value[1];
          val = [val1, val2];
        }

        this._trigger('slideStart', val);
        this._setDataVal(val);
        this.setValue(val, true, true);

        this._setDataVal(val);
        this._trigger('slideStop', val);
        this._layout();

        this._pauseEvent(ev);
        delete this._state.keyCtrl;

        return false;
      },
      _pauseEvent: function _pauseEvent(ev) {
        if (ev.stopPropagation) {
          ev.stopPropagation();
        }
        if (ev.preventDefault) {
          ev.preventDefault();
        }
        ev.cancelBubble = true;
        ev.returnValue = false;
      },
      _mousemove: function _mousemove(ev) {
        if (!this._state.enabled) {
          return false;
        }

        var percentage = this._getPercentage(ev);
        this._adjustPercentageForRangeSliders(percentage);
        this._state.percentage[this._state.dragged] = percentage;
        this._layout();

        var val = this._calculateValue(true);
        this.setValue(val, true, true);

        return false;
      },
      _touchmove: function _touchmove(ev) {
        if (ev.changedTouches === undefined) {
          return;
        }

        var touch = ev.changedTouches[0];

        var xDiff = touch.pageX - this.touchX;
        var yDiff = touch.pageY - this.touchY;

        if (!this._state.inDrag) {
          // Vertical Slider
          if (this.options.orientation === 'vertical' && xDiff <= 5 && xDiff >= -5 && (yDiff >= 15 || yDiff <= -15)) {
            this._mousedown(ev);
          }
          // Horizontal slider.
          else if (yDiff <= 5 && yDiff >= -5 && (xDiff >= 15 || xDiff <= -15)) {
            this._mousedown(ev);
          }
        }
      },
      _adjustPercentageForRangeSliders: function _adjustPercentageForRangeSliders(percentage) {
        if (this.options.range) {
          var precision = this._getNumDigitsAfterDecimalPlace(percentage);
          precision = precision ? precision - 1 : 0;
          var percentageWithAdjustedPrecision = this._applyToFixedAndParseFloat(percentage, precision);
          if (this._state.dragged === 0 && this._applyToFixedAndParseFloat(this._state.percentage[1], precision) < percentageWithAdjustedPrecision) {
            this._state.percentage[0] = this._state.percentage[1];
            this._state.dragged = 1;
          } else if (this._state.dragged === 1 && this._applyToFixedAndParseFloat(this._state.percentage[0], precision) > percentageWithAdjustedPrecision) {
            this._state.percentage[1] = this._state.percentage[0];
            this._state.dragged = 0;
          } else if (this._state.keyCtrl === 0 && this._state.value[1] / this.options.max * 100 < percentage) {
            this._state.percentage[0] = this._state.percentage[1];
            this._state.keyCtrl = 1;
            this.handle2.focus();
          } else if (this._state.keyCtrl === 1 && this._state.value[0] / this.options.max * 100 > percentage) {
            this._state.percentage[1] = this._state.percentage[0];
            this._state.keyCtrl = 0;
            this.handle1.focus();
          }
        }
      },
      _mouseup: function _mouseup() {
        if (!this._state.enabled) {
          return false;
        }
        if (this.touchCapable) {
          // Touch: Unbind touch event handlers:
          document.removeEventListener("touchmove", this.mousemove, false);
          document.removeEventListener("touchend", this.mouseup, false);
        }
        // Unbind mouse event handlers:
        document.removeEventListener("mousemove", this.mousemove, false);
        document.removeEventListener("mouseup", this.mouseup, false);

        this._state.inDrag = false;
        if (this._state.over === false) {
          this._hideTooltip();
        }
        var val = this._calculateValue(true);

        this._layout();
        this._setDataVal(val);
        this._trigger('slideStop', val);

        return false;
      },
      _calculateValue: function _calculateValue(snapToClosestTick) {
        var val;
        if (this.options.range) {
          val = [this.options.min, this.options.max];
          if (this._state.percentage[0] !== 0) {
            val[0] = this._toValue(this._state.percentage[0]);
            val[0] = this._applyPrecision(val[0]);
          }
          if (this._state.percentage[1] !== 100) {
            val[1] = this._toValue(this._state.percentage[1]);
            val[1] = this._applyPrecision(val[1]);
          }
        } else {
          val = this._toValue(this._state.percentage[0]);
          val = parseFloat(val);
          val = this._applyPrecision(val);
        }

        if (snapToClosestTick) {
          var min = [val, Infinity];
          for (var i = 0; i < this.options.ticks.length; i++) {
            var diff = Math.abs(this.options.ticks[i] - val);
            if (diff <= min[1]) {
              min = [this.options.ticks[i], diff];
            }
          }
          if (min[1] <= this.options.ticks_snap_bounds) {
            return min[0];
          }
        }

        return val;
      },
      _applyPrecision: function _applyPrecision(val) {
        var precision = this.options.precision || this._getNumDigitsAfterDecimalPlace(this.options.step);
        return this._applyToFixedAndParseFloat(val, precision);
      },
      _getNumDigitsAfterDecimalPlace: function _getNumDigitsAfterDecimalPlace(num) {
        var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
        if (!match) {
          return 0;
        }
        return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
      },
      _applyToFixedAndParseFloat: function _applyToFixedAndParseFloat(num, toFixedInput) {
        var truncatedNum = num.toFixed(toFixedInput);
        return parseFloat(truncatedNum);
      },
      /*
       Credits to Mike Samuel for the following method!
       Source: http://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number
       */
      _getPercentage: function _getPercentage(ev) {
        if (this.touchCapable && (ev.type === 'touchstart' || ev.type === 'touchmove')) {
          ev = ev.touches[0];
        }

        var eventPosition = ev[this.mousePos];
        var sliderOffset = this._state.offset[this.stylePos];
        var distanceToSlide = eventPosition - sliderOffset;
        if (this.stylePos === 'right') {
          distanceToSlide = -distanceToSlide;
        }
        // Calculate what percent of the length the slider handle has slid
        var percentage = distanceToSlide / this._state.size * 100;
        percentage = Math.round(percentage / this._state.percentage[2]) * this._state.percentage[2];
        if (this.options.reversed) {
          percentage = 100 - percentage;
        }

        // Make sure the percent is within the bounds of the slider.
        // 0% corresponds to the 'min' value of the slide
        // 100% corresponds to the 'max' value of the slide
        return Math.max(0, Math.min(100, percentage));
      },
      _validateInputValue: function _validateInputValue(val) {
        if (!isNaN(+val)) {
          return +val;
        } else if (Array.isArray(val)) {
          this._validateArray(val);
          return val;
        } else {
          throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(val));
        }
      },
      _validateArray: function _validateArray(val) {
        for (var i = 0; i < val.length; i++) {
          var input = val[i];
          if (typeof input !== 'number') {
            throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(input));
          }
        }
      },
      _setDataVal: function _setDataVal(val) {
        this.element.setAttribute('data-value', val);
        this.element.setAttribute('value', val);
        this.element.value = val;
      },
      _trigger: function _trigger(evt, val) {
        val = val || val === 0 ? val : undefined;

        var callbackFnArray = this.eventToCallbackMap[evt];
        if (callbackFnArray && callbackFnArray.length) {
          for (var i = 0; i < callbackFnArray.length; i++) {
            var callbackFn = callbackFnArray[i];
            callbackFn(val);
          }
        }

        /* If JQuery exists, trigger JQuery events */
        if ($) {
          this._triggerJQueryEvent(evt, val);
        }
      },
      _triggerJQueryEvent: function _triggerJQueryEvent(evt, val) {
        var eventData = {
          type: evt,
          value: val
        };
        this.$element.trigger(eventData);
        this.$sliderElem.trigger(eventData);
      },
      _unbindJQueryEventHandlers: function _unbindJQueryEventHandlers() {
        this.$element.off();
        this.$sliderElem.off();
      },
      _setText: function _setText(element, text) {
        if (typeof element.textContent !== "undefined") {
          element.textContent = text;
        } else if (typeof element.innerText !== "undefined") {
          element.innerText = text;
        }
      },
      _removeClass: function _removeClass(element, classString) {
        var classes = classString.split(" ");
        var newClasses = element.className;

        for (var i = 0; i < classes.length; i++) {
          var classTag = classes[i];
          var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
          newClasses = newClasses.replace(regex, " ");
        }

        element.className = newClasses.trim();
      },
      _addClass: function _addClass(element, classString) {
        var classes = classString.split(" ");
        var newClasses = element.className;

        for (var i = 0; i < classes.length; i++) {
          var classTag = classes[i];
          var regex = new RegExp("(?:\\s|^)" + classTag + "(?:\\s|$)");
          var ifClassExists = regex.test(newClasses);

          if (!ifClassExists) {
            newClasses += " " + classTag;
          }
        }

        element.className = newClasses.trim();
      },
      _offsetLeft: function _offsetLeft(obj) {
        return obj.getBoundingClientRect().left;
      },
      _offsetRight: function _offsetRight(obj) {
        return obj.getBoundingClientRect().right;
      },
      _offsetTop: function _offsetTop(obj) {
        var offsetTop = obj.offsetTop;
        while ((obj = obj.offsetParent) && !isNaN(obj.offsetTop)) {
          offsetTop += obj.offsetTop;
          if (obj.tagName !== 'BODY') {
            offsetTop -= obj.scrollTop;
          }
        }
        return offsetTop;
      },
      _offset: function _offset(obj) {
        return {
          left: this._offsetLeft(obj),
          right: this._offsetRight(obj),
          top: this._offsetTop(obj)
        };
      },
      _css: function _css(elementRef, styleName, value) {
        if ($) {
          $.style(elementRef, styleName, value);
        } else {
          var style = styleName.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function (all, letter) {
            return letter.toUpperCase();
          });
          elementRef.style[style] = value;
        }
      },
      _toValue: function _toValue(percentage) {
        return this.options.scale.toValue.apply(this, [percentage]);
      },
      _toPercentage: function _toPercentage(value) {
        return this.options.scale.toPercentage.apply(this, [value]);
      },
      _setTooltipPosition: function _setTooltipPosition() {
        var tooltips = [this.tooltip, this.tooltip_min, this.tooltip_max];
        if (this.options.orientation === 'vertical') {
          var tooltipPos;
          if (this.options.tooltip_position) {
            tooltipPos = this.options.tooltip_position;
          } else {
            if (this.options.rtl) {
              tooltipPos = 'left';
            } else {
              tooltipPos = 'right';
            }
          }
          var oppositeSide = tooltipPos === 'left' ? 'right' : 'left';
          tooltips.forEach(function (tooltip) {
            this._addClass(tooltip, tooltipPos);
            tooltip.style[oppositeSide] = '100%';
          }.bind(this));
        } else if (this.options.tooltip_position === 'bottom') {
          tooltips.forEach(function (tooltip) {
            this._addClass(tooltip, 'bottom');
            tooltip.style.top = 22 + 'px';
          }.bind(this));
        } else {
          tooltips.forEach(function (tooltip) {
            this._addClass(tooltip, 'top');
            tooltip.style.top = -this.tooltip.outerHeight - 14 + 'px';
          }.bind(this));
        }
      }
    };

    /*********************************
     Attach to global namespace
     *********************************/
    if ($ && $.fn) {
      var autoRegisterNamespace = void 0;

      if (!$.fn.slider) {
        $.bridget(NAMESPACE_MAIN, Slider);
        autoRegisterNamespace = NAMESPACE_MAIN;
      } else {
        if (windowIsDefined) {
          window.console.warn("bootstrap-slider.js - WARNING: $.fn.slider namespace is already bound. Use the $.fn.bootstrapSlider namespace instead.");
        }
        autoRegisterNamespace = NAMESPACE_ALTERNATE;
      }
      $.bridget(NAMESPACE_ALTERNATE, Slider);

      // Auto-Register data-provide="slider" Elements
      $(function () {
        $("input[data-provide=slider]")[autoRegisterNamespace]();
      });
    }
  })($);

  return Slider;
});
},{"jquery":12}],4:[function(require,module,exports){
/*! ========================================================================
 * Bootstrap Toggle: bootstrap-toggle.js v2.2.0
 * http://www.bootstraptoggle.com
 * ========================================================================
 * Copyright 2014 Min Hur, The New York Times Company
 * Licensed under MIT
 * ======================================================================== */


+function ($) {


  // TOGGLE PUBLIC CLASS DEFINITION
  // ==============================

  var Toggle = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, this.defaults(), options)
    this.render()
  }

  Toggle.VERSION  = '2.2.0'

  Toggle.DEFAULTS = {
    on: 'On',
    off: 'Off',
    onstyle: 'primary',
    offstyle: 'default',
    size: 'normal',
    style: '',
    width: null,
    height: null
  }

  Toggle.prototype.defaults = function() {
    return {
      on: this.$element.attr('data-on') || Toggle.DEFAULTS.on,
      off: this.$element.attr('data-off') || Toggle.DEFAULTS.off,
      onstyle: this.$element.attr('data-onstyle') || Toggle.DEFAULTS.onstyle,
      offstyle: this.$element.attr('data-offstyle') || Toggle.DEFAULTS.offstyle,
      size: this.$element.attr('data-size') || Toggle.DEFAULTS.size,
      style: this.$element.attr('data-style') || Toggle.DEFAULTS.style,
      width: this.$element.attr('data-width') || Toggle.DEFAULTS.width,
      height: this.$element.attr('data-height') || Toggle.DEFAULTS.height
    }
  }

  Toggle.prototype.render = function () {
    this._onstyle = 'btn-' + this.options.onstyle
    this._offstyle = 'btn-' + this.options.offstyle
    var size = this.options.size === 'large' ? 'btn-lg'
      : this.options.size === 'small' ? 'btn-sm'
        : this.options.size === 'mini' ? 'btn-xs'
          : ''
    var $toggleOn = $('<label class="btn">').html(this.options.on)
      .addClass(this._onstyle + ' ' + size)
    var $toggleOff = $('<label class="btn">').html(this.options.off)
      .addClass(this._offstyle + ' ' + size + ' active')
    var $toggleHandle = $('<span class="toggle-handle btn btn-default">')
      .addClass(size)
    var $toggleGroup = $('<div class="toggle-group">')
      .append($toggleOn, $toggleOff, $toggleHandle)
    var $toggle = $('<div class="toggle btn" data-toggle="toggle">')
      .addClass( this.$element.prop('checked') ? this._onstyle : this._offstyle+' off' )
      .addClass(size).addClass(this.options.style)

    this.$element.wrap($toggle)
    $.extend(this, {
      $toggle: this.$element.parent(),
      $toggleOn: $toggleOn,
      $toggleOff: $toggleOff,
      $toggleGroup: $toggleGroup
    })
    this.$toggle.append($toggleGroup)

    var width = this.options.width || Math.max($toggleOn.outerWidth(), $toggleOff.outerWidth())+($toggleHandle.outerWidth()/2)
    var height = this.options.height || Math.max($toggleOn.outerHeight(), $toggleOff.outerHeight())
    $toggleOn.addClass('toggle-on')
    $toggleOff.addClass('toggle-off')
    this.$toggle.css({ width: width, height: height })
    if (this.options.height) {
      $toggleOn.css('line-height', $toggleOn.height() + 'px')
      $toggleOff.css('line-height', $toggleOff.height() + 'px')
    }
    this.update(true)
    this.trigger(true)
  }

  Toggle.prototype.toggle = function () {
    if (this.$element.prop('checked')) this.off()
    else this.on()
  }

  Toggle.prototype.on = function (silent) {
    if (this.$element.prop('disabled')) return false
    this.$toggle.removeClass(this._offstyle + ' off').addClass(this._onstyle)
    this.$element.prop('checked', true)
    if (!silent) this.trigger()
  }

  Toggle.prototype.off = function (silent) {
    if (this.$element.prop('disabled')) return false
    this.$toggle.removeClass(this._onstyle).addClass(this._offstyle + ' off')
    this.$element.prop('checked', false)
    if (!silent) this.trigger()
  }

  Toggle.prototype.enable = function () {
    this.$toggle.removeAttr('disabled')
    this.$element.prop('disabled', false)
  }

  Toggle.prototype.disable = function () {
    this.$toggle.attr('disabled', 'disabled')
    this.$element.prop('disabled', true)
  }

  Toggle.prototype.update = function (silent) {
    if (this.$element.prop('disabled')) this.disable()
    else this.enable()
    if (this.$element.prop('checked')) this.on(silent)
    else this.off(silent)
  }

  Toggle.prototype.trigger = function (silent) {
    this.$element.off('change.bs.toggle')
    if (!silent) this.$element.change()
    this.$element.on('change.bs.toggle', $.proxy(function() {
      this.update()
    }, this))
  }

  Toggle.prototype.destroy = function() {
    this.$element.off('change.bs.toggle')
    this.$toggleGroup.remove()
    this.$element.removeData('bs.toggle')
    this.$element.unwrap()
  }

  // TOGGLE PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.toggle')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.toggle', (data = new Toggle(this, options)))
      if (typeof option == 'string' && data[option]) data[option]()
    })
  }

  var old = $.fn.bootstrapToggle

  $.fn.bootstrapToggle             = Plugin
  $.fn.bootstrapToggle.Constructor = Toggle

  // TOGGLE NO CONFLICT
  // ==================

  $.fn.toggle.noConflict = function () {
    $.fn.bootstrapToggle = old
    return this
  }

  // TOGGLE DATA-API
  // ===============

  $(function() {
    $('input[type=checkbox][data-toggle^=toggle]').bootstrapToggle()
  })

  $(document).on('click.bs.toggle', 'div[data-toggle^=toggle]', function(e) {
    var $checkbox = $(this).find('input[type=checkbox]')
    $checkbox.bootstrapToggle('toggle')
    e.preventDefault()
  })

}(jQuery);
},{}],5:[function(require,module,exports){
!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return t>n?-1:n>t?1:n>=t?0:NaN}function r(n){return null===n?NaN:+n}function i(n){return!isNaN(n)}function u(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function l(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function c(){this._=Object.create(null)}function f(n){return(n+="")===bo||n[0]===_o?_o+n:n}function s(n){return(n+="")[0]===_o?n.slice(1):n}function h(n){return f(n)in this._}function p(n){return(n=f(n))in this._&&delete this._[n]}function g(){var n=[];for(var t in this._)n.push(s(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function y(){this._=Object.create(null)}function m(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=wo.length;r>e;++e){var i=wo[e]+t;if(i in n)return i}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,i=-1,u=r.length;++i<u;)(t=r[i].on)&&t.apply(this,arguments);return n}var e=[],r=new c;return t.on=function(t,i){var u,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,u=e.indexOf(o)).concat(e.slice(u+1)),r.remove(t)),i&&e.push(r.set(t,{on:i})),n)},t}function S(){ao.event.preventDefault()}function k(){for(var n,t=ao.event;n=t.sourceEvent;)t=n;return t}function N(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(i){try{var u=i.sourceEvent=ao.event;i.target=n,ao.event=i,t[i.type].apply(e,r)}finally{ao.event=u}}},t}function E(n){return ko(n,Co),n}function A(n){return"function"==typeof n?n:function(){return No(n,this)}}function C(n){return"function"==typeof n?n:function(){return Eo(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function i(){this.setAttribute(n,t)}function u(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ao.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?u:i}function L(n){return n.trim().replace(/\s+/g," ")}function q(n){return new RegExp("(?:^|\\s+)"+ao.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<i;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<i;)n[e](this,r)}n=T(n).map(D);var i=n.length;return"function"==typeof t?r:e}function D(n){var t=q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",L(i+" "+n))):e.setAttribute("class",L(i.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function i(){this.style.setProperty(n,t,e)}function u(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?u:i}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function i(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?i:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e===zo&&t.documentElement.namespaceURI===zo?t.createElement(n):t.createElementNS(e,n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ao.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return Ao(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;r>e;e++)for(var i,u=n[e],o=0,a=u.length;a>o;o++)(i=u[o])&&t(i,o,e);return n}function Z(n){return ko(n,qo),n}function V(n){var t,e;return function(r,i,u){var o,a=n[u].update,l=a.length;for(u!=e&&(e=u,t=0),i>=t&&(t=i+1);!(o=a[t])&&++t<l;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function i(){var i=l(t,co(arguments));r.call(this),this.addEventListener(n,this[o]=i,i.$=e),i._=t}function u(){var t,e=new RegExp("^__on([^.]+)"+ao.requote(n)+"$");for(var r in this)if(t=r.match(e)){var i=this[r];this.removeEventListener(t[1],i,i.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),l=$;a>0&&(n=n.slice(0,a));var c=To.get(n);return c&&(n=c,l=B),a?t?i:r:t?b:u}function $(n,t){return function(e){var r=ao.event;ao.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ao.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Do,i="click"+r,u=ao.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ro&&(Ro="onselectstart"in e?!1:x(e.style,"userSelect")),Ro){var o=n(e).style,a=o[Ro];o[Ro]="none"}return function(n){if(u.on(r,null),Ro&&(o[Ro]=a),n){var t=function(){u.on(i,null)};u.on(i,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var i=r.createSVGPoint();if(0>Po){var u=t(n);if(u.scrollX||u.scrollY){r=ao.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Po=!(o.f||o.e),r.remove()}}return Po?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),i=i.matrixTransform(n.getScreenCTM().inverse()),[i.x,i.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ao.event.changedTouches[0].identifier}function K(n){return n>0?1:0>n?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nn(n){return n>1?0:-1>n?Fo:Math.acos(n)}function tn(n){return n>1?Io:-1>n?-Io:Math.asin(n)}function en(n){return((n=Math.exp(n))-1/n)/2}function rn(n){return((n=Math.exp(n))+1/n)/2}function un(n){return((n=Math.exp(2*n))-1)/(n+1)}function on(n){return(n=Math.sin(n/2))*n}function an(){}function ln(n,t,e){return this instanceof ln?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ln?new ln(n.h,n.s,n.l):_n(""+n,wn,ln):new ln(n,t,e)}function cn(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?u+(o-u)*n/60:180>n?o:240>n?u+(o-u)*(240-n)/60:u}function i(n){return Math.round(255*r(n))}var u,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,u=2*e-o,new mn(i(n+120),i(n),i(n-120))}function fn(n,t,e){return this instanceof fn?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof fn?new fn(n.h,n.c,n.l):n instanceof hn?gn(n.l,n.a,n.b):gn((n=Sn((n=ao.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new fn(n,t,e)}function sn(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new hn(e,Math.cos(n*=Yo)*t,Math.sin(n)*t)}function hn(n,t,e){return this instanceof hn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof hn?new hn(n.l,n.a,n.b):n instanceof fn?sn(n.h,n.c,n.l):Sn((n=mn(n)).r,n.g,n.b):new hn(n,t,e)}function pn(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return i=vn(i)*na,r=vn(r)*ta,u=vn(u)*ea,new mn(yn(3.2404542*i-1.5371385*r-.4985314*u),yn(-.969266*i+1.8760108*r+.041556*u),yn(.0556434*i-.2040259*r+1.0572252*u))}function gn(n,t,e){return n>0?new fn(Math.atan2(e,t)*Zo,Math.sqrt(t*t+e*e),n):new fn(NaN,NaN,n)}function vn(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function dn(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function yn(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mn(n,t,e){return this instanceof mn?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mn?new mn(n.r,n.g,n.b):_n(""+n,mn,cn):new mn(n,t,e)}function Mn(n){return new mn(n>>16,n>>8&255,255&n)}function xn(n){return Mn(n)+""}function bn(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function _n(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Nn(i[0]),Nn(i[1]),Nn(i[2]))}return(u=ua.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o=o>>4|o,a=240&u,a=a>>4|a,l=15&u,l=l<<4|l):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function wn(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=.5>l?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&1>l?0:r),new ln(r,i,l)}function Sn(n,t,e){n=kn(n),t=kn(t),e=kn(e);var r=dn((.4124564*n+.3575761*t+.1804375*e)/na),i=dn((.2126729*n+.7151522*t+.072175*e)/ta),u=dn((.0193339*n+.119192*t+.9503041*e)/ea);return hn(116*i-16,500*(r-i),200*(i-u))}function kn(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Nn(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function En(n){return"function"==typeof n?n:function(){return n}}function An(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Cn(t,e,n,r)}}function Cn(n,t,e,r){function i(){var n,t=l.status;if(!t&&Ln(l)||t>=200&&300>t||304===t){try{n=e.call(u,l)}catch(r){return void o.error.call(u,r)}o.load.call(u,n)}else o.error.call(u,l)}var u={},o=ao.dispatch("beforesend","progress","load","error"),a={},l=new XMLHttpRequest,c=null;return!this.XDomainRequest||"withCredentials"in l||!/^(http(s)?:)?\/\//.test(n)||(l=new XDomainRequest),"onload"in l?l.onload=l.onerror=i:l.onreadystatechange=function(){l.readyState>3&&i()},l.onprogress=function(n){var t=ao.event;ao.event=n;try{o.progress.call(u,l)}finally{ao.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.responseType=function(n){return arguments.length?(c=n,u):c},u.response=function(n){return e=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(co(arguments)))}}),u.send=function(e,r,i){if(2===arguments.length&&"function"==typeof r&&(i=r,r=null),l.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),l.setRequestHeader)for(var f in a)l.setRequestHeader(f,a[f]);return null!=t&&l.overrideMimeType&&l.overrideMimeType(t),null!=c&&(l.responseType=c),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),o.beforesend.call(u,l),l.send(null==r?null:r),u},u.abort=function(){return l.abort(),u},ao.rebind(u,o,"on"),null==r?u:u.get(zn(r))}function zn(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Ln(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qn(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var i=e+t,u={c:n,t:i,n:null};return aa?aa.n=u:oa=u,aa=u,la||(ca=clearTimeout(ca),la=1,fa(Tn)),u}function Tn(){var n=Rn(),t=Dn()-n;t>24?(isFinite(t)&&(clearTimeout(ca),ca=setTimeout(Tn,t)),la=0):(la=1,fa(Tn))}function Rn(){for(var n=Date.now(),t=oa;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Dn(){for(var n,t=oa,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:oa=t.n;return aa=n,e}function Pn(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Un(n,t){var e=Math.pow(10,3*xo(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function jn(n){var t=n.decimal,e=n.thousands,r=n.grouping,i=n.currency,u=r&&e?function(n,t){for(var i=n.length,u=[],o=0,a=r[0],l=0;i>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(i-=a,i+a)),!((l+=a+1)>t));)a=r[o=(o+1)%r.length];return u.reverse().join(e)}:m;return function(n){var e=ha.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",l=e[4]||"",c=e[5],f=+e[6],s=e[7],h=e[8],p=e[9],g=1,v="",d="",y=!1,m=!0;switch(h&&(h=+h.substring(1)),(c||"0"===r&&"="===o)&&(c=r="0",o="="),p){case"n":s=!0,p="g";break;case"%":g=100,d="%",p="f";break;case"p":g=100,d="%",p="r";break;case"b":case"o":case"x":case"X":"#"===l&&(v="0"+p.toLowerCase());case"c":m=!1;case"d":y=!0,h=0;break;case"s":g=-1,p="r"}"$"===l&&(v=i[0],d=i[1]),"r"!=p||h||(p="g"),null!=h&&("g"==p?h=Math.max(1,Math.min(21,h)):"e"!=p&&"f"!=p||(h=Math.max(0,Math.min(20,h)))),p=pa.get(p)||Fn;var M=c&&s;return function(n){var e=d;if(y&&n%1)return"";var i=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>g){var l=ao.formatPrefix(n,h);n=l.scale(n),e=l.symbol+d}else n*=g;n=p(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=m?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!c&&s&&(x=u(x,1/0));var S=v.length+x.length+b.length+(M?0:i.length),k=f>S?new Array(S=f-S+1).join(r):"";return M&&(x=u(k+x,k.length?f-b.length:1/0)),i+=v,n=x+b,("<"===o?i+n+k:">"===o?k+i+n:"^"===o?k.substring(0,S>>=1)+i+n+k.substring(S):i+(M?n:k+n))+e}}}function Fn(n){return n+""}function Hn(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function On(n,t,e){function r(t){var e=n(t),r=u(e,1);return r-t>t-e?e:r}function i(e){return t(e=n(new va(e-1)),1),e}function u(n,e){return t(n=new va(+n),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;r>o;)e(o)%u||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{va=Hn;var r=new Hn;return r._=n,o(r,t,e)}finally{va=Date}}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var l=n.utc=In(n);return l.floor=l,l.round=In(r),l.ceil=In(i),l.offset=In(u),l.range=a,n}function In(n){return function(t,e){try{va=Hn;var r=new Hn;return r._=t,n(r,e)._}finally{va=Date}}}function Yn(n){function t(n){function t(t){for(var e,i,u,o=[],a=-1,l=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=ya[e=n.charAt(++a)])&&(e=n.charAt(++a)),(u=A[e])&&(e=u(t,null==i?"e"===e?" ":"0":i)),o.push(e),l=a+1);return o.push(n.slice(l,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=e(r,n,t,0);if(i!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var u=null!=r.Z&&va!==Hn,o=new(u?Hn:va);return"j"in r?o.setFullYear(r.y,0,r.j):"W"in r||"U"in r?("w"in r||(r.w="W"in r?1:0),o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),u?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;l>a;){if(r>=c)return-1;if(i=t.charCodeAt(a++),37===i){if(o=t.charAt(a++),u=C[o in ya?t.charAt(a++):o],!u||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){N.lastIndex=0;var r=N.exec(t.slice(e));return r?(n.m=E.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,A.c.toString(),t,r)}function l(n,t,r){return e(n,A.x.toString(),t,r)}function c(n,t,r){return e(n,A.X.toString(),t,r)}function f(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var s=n.dateTime,h=n.date,p=n.time,g=n.periods,v=n.days,d=n.shortDays,y=n.months,m=n.shortMonths;t.utc=function(n){function e(n){try{va=Hn;var t=new va;return t._=n,r(t)}finally{va=Date}}var r=t(n);return e.parse=function(n){try{va=Hn;var t=r.parse(n);return t&&t._}finally{va=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ct;var M=ao.map(),x=Vn(v),b=Xn(v),_=Vn(d),w=Xn(d),S=Vn(y),k=Xn(y),N=Vn(m),E=Xn(m);g.forEach(function(n,t){M.set(n.toLowerCase(),t)});var A={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return m[n.getMonth()]},B:function(n){return y[n.getMonth()]},c:t(s),d:function(n,t){return Zn(n.getDate(),t,2)},e:function(n,t){return Zn(n.getDate(),t,2)},H:function(n,t){return Zn(n.getHours(),t,2)},I:function(n,t){return Zn(n.getHours()%12||12,t,2)},j:function(n,t){return Zn(1+ga.dayOfYear(n),t,3)},L:function(n,t){return Zn(n.getMilliseconds(),t,3)},m:function(n,t){return Zn(n.getMonth()+1,t,2)},M:function(n,t){return Zn(n.getMinutes(),t,2)},p:function(n){return g[+(n.getHours()>=12)]},S:function(n,t){return Zn(n.getSeconds(),t,2)},U:function(n,t){return Zn(ga.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Zn(ga.mondayOfYear(n),t,2)},x:t(h),X:t(p),y:function(n,t){return Zn(n.getFullYear()%100,t,2)},Y:function(n,t){return Zn(n.getFullYear()%1e4,t,4)},Z:at,"%":function(){return"%"}},C={a:r,A:i,b:u,B:o,c:a,d:tt,e:tt,H:rt,I:rt,j:et,L:ot,m:nt,M:it,p:f,S:ut,U:Bn,w:$n,W:Wn,x:l,X:c,y:Gn,Y:Jn,Z:Kn,"%":lt};return t}function Zn(n,t,e){var r=0>n?"-":"",i=(r?-n:n)+"",u=i.length;return r+(e>u?new Array(e-u+1).join(t)+i:i)}function Vn(n){return new RegExp("^(?:"+n.map(ao.requote).join("|")+")","i")}function Xn(n){for(var t=new c,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function $n(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Bn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function Wn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Jn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Gn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.y=Qn(+r[0]),e+r[0].length):-1}function Kn(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Qn(n){return n+(n>68?1900:2e3)}function nt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function tt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function et(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function rt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function it(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ut(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ot(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function at(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=xo(t)/60|0,i=xo(t)%60;return e+Zn(r,"0",2)+Zn(i,"0",2)}function lt(n,t,e){Ma.lastIndex=0;var r=Ma.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ct(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ft(){}function st(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function ht(n,t){n&&wa.hasOwnProperty(n.type)&&wa[n.type](n,t)}function pt(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function gt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)pt(n[e],t,1);t.polygonEnd()}function vt(){function n(n,t){n*=Yo,t=t*Yo/2+Fo/4;var e=n-r,o=e>=0?1:-1,a=o*e,l=Math.cos(t),c=Math.sin(t),f=u*c,s=i*l+f*Math.cos(a),h=f*o*Math.sin(a);ka.add(Math.atan2(h,s)),r=n,i=l,u=c}var t,e,r,i,u;Na.point=function(o,a){Na.point=n,r=(t=o)*Yo,i=Math.cos(a=(e=a)*Yo/2+Fo/4),u=Math.sin(a)},Na.lineEnd=function(){n(t,e)}}function dt(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function yt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function mt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Mt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function xt(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function bt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function _t(n){return[Math.atan2(n[1],n[0]),tn(n[2])]}function wt(n,t){return xo(n[0]-t[0])<Uo&&xo(n[1]-t[1])<Uo}function St(n,t){n*=Yo;var e=Math.cos(t*=Yo);kt(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function kt(n,t,e){++Ea,Ca+=(n-Ca)/Ea,za+=(t-za)/Ea,La+=(e-La)/Ea}function Nt(){function n(n,i){n*=Yo;var u=Math.cos(i*=Yo),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=e*l-r*a)*c+(c=r*o-t*l)*c+(c=t*a-e*o)*c),t*o+e*a+r*l);Aa+=c,qa+=c*(t+(t=o)),Ta+=c*(e+(e=a)),Ra+=c*(r+(r=l)),kt(t,e,r)}var t,e,r;ja.point=function(i,u){i*=Yo;var o=Math.cos(u*=Yo);t=o*Math.cos(i),e=o*Math.sin(i),r=Math.sin(u),ja.point=n,kt(t,e,r)}}function Et(){ja.point=St}function At(){function n(n,t){n*=Yo;var e=Math.cos(t*=Yo),o=e*Math.cos(n),a=e*Math.sin(n),l=Math.sin(t),c=i*l-u*a,f=u*o-r*l,s=r*a-i*o,h=Math.sqrt(c*c+f*f+s*s),p=r*o+i*a+u*l,g=h&&-nn(p)/h,v=Math.atan2(h,p);Da+=g*c,Pa+=g*f,Ua+=g*s,Aa+=v,qa+=v*(r+(r=o)),Ta+=v*(i+(i=a)),Ra+=v*(u+(u=l)),kt(r,i,u)}var t,e,r,i,u;ja.point=function(o,a){t=o,e=a,ja.point=n,o*=Yo;var l=Math.cos(a*=Yo);r=l*Math.cos(o),i=l*Math.sin(o),u=Math.sin(a),kt(r,i,u)},ja.lineEnd=function(){n(t,e),ja.lineEnd=Et,ja.point=St}}function Ct(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function zt(){return!0}function Lt(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(wt(e,r)){i.lineStart();for(var a=0;t>a;++a)i.point((e=n[a])[0],e[1]);return void i.lineEnd()}var l=new Tt(e,n,null,!0),c=new Tt(e,null,l,!1);l.o=c,u.push(l),o.push(c),l=new Tt(r,n,null,!1),c=new Tt(r,null,l,!0),l.o=c,u.push(l),o.push(c)}}),o.sort(t),qt(u),qt(o),u.length){for(var a=0,l=e,c=o.length;c>a;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(var a=0,c=f.length;c>a;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g){f=p.p.z;for(var a=f.length-1;a>=0;--a)i.point((s=f[a])[0],s[1])}else r(p.x,p.p.x,-1,i);p=p.p}p=p.o,f=p.z,g=!g}while(!p.v);i.lineEnd()}}}function qt(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function Tt(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Rt(n,t,e,r){return function(i,u){function o(t,e){var r=i(t,e);n(t=r[0],e=r[1])&&u.point(t,e)}function a(n,t){var e=i(n,t);d.point(e[0],e[1])}function l(){m.point=a,d.lineStart()}function c(){m.point=o,d.lineEnd()}function f(n,t){v.push([n,t]);var e=i(n,t);x.point(e[0],e[1])}function s(){x.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),g.push(v),v=null,r)if(1&t){n=e[0];var i,r=n.length-1,o=-1;if(r>0){for(b||(u.polygonStart(),b=!0),u.lineStart();++o<r;)u.point((i=n[o])[0],i[1]);u.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),p.push(e.filter(Dt))}var p,g,v,d=t(u),y=i.invert(r[0],r[1]),m={point:o,lineStart:l,lineEnd:c,polygonStart:function(){m.point=f,m.lineStart=s,m.lineEnd=h,p=[],g=[]},polygonEnd:function(){m.point=o,m.lineStart=l,m.lineEnd=c,p=ao.merge(p);var n=Ot(y,g);p.length?(b||(u.polygonStart(),b=!0),Lt(p,Ut,n,e,u)):n&&(b||(u.polygonStart(),b=!0),u.lineStart(),e(null,null,1,u),u.lineEnd()),b&&(u.polygonEnd(),b=!1),p=g=null},sphere:function(){u.polygonStart(),u.lineStart(),e(null,null,1,u),u.lineEnd(),u.polygonEnd()}},M=Pt(),x=t(M),b=!1;return m}}function Dt(n){return n.length>1}function Pt(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ut(n,t){return((n=n.x)[0]<0?n[1]-Io-Uo:Io-n[1])-((t=t.x)[0]<0?t[1]-Io-Uo:Io-t[1])}function jt(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?Fo:-Fo,l=xo(u-e);xo(l-Fo)<Uo?(n.point(e,r=(r+o)/2>0?Io:-Io),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=Fo&&(xo(e-i)<Uo&&(e-=i*Uo),xo(u-a)<Uo&&(u-=a*Uo),r=Ft(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}}function Ft(n,t,e,r){var i,u,o=Math.sin(n-e);return xo(o)>Uo?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}function Ht(n,t,e,r){var i;if(null==n)i=e*Io,r.point(-Fo,i),r.point(0,i),r.point(Fo,i),r.point(Fo,0),r.point(Fo,-i),r.point(0,-i),r.point(-Fo,-i),r.point(-Fo,0),r.point(-Fo,i);else if(xo(n[0]-t[0])>Uo){var u=n[0]<t[0]?Fo:-Fo;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])}function Ot(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;ka.reset();for(var a=0,l=t.length;l>a;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+Fo/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0),n=c[d];var y=n[0],m=n[1]/2+Fo/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>Fo,k=g*M;if(ka.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Ho:b,S^h>=e^y>=e){var N=mt(dt(s),dt(n));bt(N);var E=mt(i,N);bt(E);var A=(S^b>=0?-1:1)*tn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(-Uo>u||Uo>u&&-Uo>ka)^1&o}function It(n){function t(n,t){return Math.cos(n)*Math.cos(t)>u}function e(n){var e,u,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=t(s,h),d=o?v?0:i(s,h):v?i(s+(0>s?Fo:-Fo),h):0;if(!e&&(c=l=v)&&n.lineStart(),v!==l&&(p=r(e,g),(wt(e,p)||wt(g,p))&&(g[0]+=Uo,g[1]+=Uo,v=t(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=r(g,e),n.point(p[0],p[1])):(p=r(e,g),n.point(p[0],p[1]),n.lineEnd()),e=p;else if(a&&e&&o^v){var y;d&u||!(y=r(g,e,!0))||(f=0,o?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||e&&wt(e,g)||n.point(g[0],g[1]),e=g,l=v,u=d},lineEnd:function(){l&&n.lineEnd(),e=null},clean:function(){return f|(c&&l)<<1}}}function r(n,t,e){var r=dt(n),i=dt(t),o=[1,0,0],a=mt(r,i),l=yt(a,a),c=a[0],f=l-c*c;if(!f)return!e&&n;var s=u*l/f,h=-u*c/f,p=mt(o,a),g=xt(o,s),v=xt(a,h);Mt(g,v);var d=p,y=yt(g,d),m=yt(d,d),M=y*y-m*(yt(g,g)-1);if(!(0>M)){var x=Math.sqrt(M),b=xt(d,(-y-x)/m);if(Mt(b,g),b=_t(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],N=t[1];w>S&&(_=w,w=S,S=_);var E=S-w,A=xo(E-Fo)<Uo,C=A||Uo>E;if(!A&&k>N&&(_=k,k=N,N=_),C?A?k+N>0^b[1]<(xo(b[0]-w)<Uo?k:N):k<=b[1]&&b[1]<=N:E>Fo^(w<=b[0]&&b[0]<=S)){var z=xt(d,(-y+x)/m);return Mt(z,g),[b,_t(z)]}}}function i(t,e){var r=o?n:Fo-n,i=0;return-r>t?i|=1:t>r&&(i|=2),-r>e?i|=4:e>r&&(i|=8),i}var u=Math.cos(n),o=u>0,a=xo(u)>Uo,l=ve(n,6*Yo);return Rt(t,e,l,o?[0,-n]:[-Fo,n-Fo])}function Yt(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=a.x,s=a.y,h=0,p=1,g=f-l,v=s-c;if(u=n-l,g||!(u>0)){if(u/=g,0>g){if(h>u)return;p>u&&(p=u)}else if(g>0){if(u>p)return;u>h&&(h=u)}if(u=e-l,g||!(0>u)){if(u/=g,0>g){if(u>p)return;u>h&&(h=u)}else if(g>0){if(h>u)return;p>u&&(p=u)}if(u=t-c,v||!(u>0)){if(u/=v,0>v){if(h>u)return;p>u&&(p=u)}else if(v>0){if(u>p)return;u>h&&(h=u)}if(u=r-c,v||!(0>u)){if(u/=v,0>v){if(u>p)return;u>h&&(h=u)}else if(v>0){if(h>u)return;p>u&&(p=u)}return h>0&&(i.a={x:l+h*g,y:c+h*v}),1>p&&(i.b={x:l+p*g,y:c+p*v}),i}}}}}}function Zt(n,t,e,r){function i(r,i){return xo(r[0]-n)<Uo?i>0?0:3:xo(r[0]-e)<Uo?i>0?2:1:xo(r[1]-t)<Uo?i>0?1:0:i>0?3:2}function u(n,t){return o(n.x,t.x)}function o(n,t){var e=i(n,1),r=i(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function l(n){for(var t=0,e=d.length,r=n[1],i=0;e>i;++i)for(var u,o=1,a=d[i],l=a.length,c=a[0];l>o;++o)u=a[o],c[1]<=r?u[1]>r&&Q(c,u,n)>0&&++t:u[1]<=r&&Q(c,u,n)<0&&--t,c=u;return 0!==t}function c(u,a,l,c){var f=0,s=0;if(null==u||(f=i(u,l))!==(s=i(a,l))||o(u,a)<0^l>0){do c.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+l+4)%4)!==s)}else c.point(a[0],a[1])}function f(i,u){return i>=n&&e>=i&&u>=t&&r>=u}function s(n,t){f(n,t)&&a.point(n,t)}function h(){C.point=g,d&&d.push(y=[]),S=!0,w=!1,b=_=NaN}function p(){v&&(g(m,M),x&&w&&E.rejoin(),v.push(E.buffer())),C.point=s,w&&a.lineEnd()}function g(n,t){n=Math.max(-Ha,Math.min(Ha,n)),t=Math.max(-Ha,Math.min(Ha,t));var e=f(n,t);if(d&&y.push([n,t]),S)m=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};A(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,y,m,M,x,b,_,w,S,k,N=a,E=Pt(),A=Yt(n,t,e,r),C={point:s,lineStart:h,lineEnd:p,polygonStart:function(){a=E,v=[],d=[],k=!0},polygonEnd:function(){a=N,v=ao.merge(v);var t=l([n,r]),e=k&&t,i=v.length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),c(null,null,1,a),a.lineEnd()),i&&Lt(v,u,t,c,a),a.polygonEnd()),v=d=y=null}};return C}}function Vt(n){var t=0,e=Fo/3,r=ae(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*Fo/180,e=n[1]*Fo/180):[t/Fo*180,e/Fo*180]},i}function Xt(n,t){function e(n,t){var e=Math.sqrt(u-2*i*Math.sin(t))/i;return[e*Math.sin(n*=i),o-e*Math.cos(n)]}var r=Math.sin(n),i=(r+Math.sin(t))/2,u=1+r*(2*i-r),o=Math.sqrt(u)/i;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/i,tn((u-(n*n+e*e)*i*i)/(2*i))]},e}function $t(){function n(n,t){Ia+=i*n-r*t,r=n,i=t}var t,e,r,i;$a.point=function(u,o){$a.point=n,t=r=u,e=i=o},$a.lineEnd=function(){n(t,e)}}function Bt(n,t){Ya>n&&(Ya=n),n>Va&&(Va=n),Za>t&&(Za=t),t>Xa&&(Xa=t)}function Wt(){function n(n,t){o.push("M",n,",",t,u)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function i(){o.push("Z")}var u=Jt(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return u=Jt(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Jt(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Gt(n,t){Ca+=n,za+=t,++La}function Kt(){function n(n,r){var i=n-t,u=r-e,o=Math.sqrt(i*i+u*u);qa+=o*(t+n)/2,Ta+=o*(e+r)/2,Ra+=o,Gt(t=n,e=r)}var t,e;Wa.point=function(r,i){Wa.point=n,Gt(t=r,e=i)}}function Qt(){Wa.point=Gt}function ne(){function n(n,t){var e=n-r,u=t-i,o=Math.sqrt(e*e+u*u);qa+=o*(r+n)/2,Ta+=o*(i+t)/2,Ra+=o,o=i*n-r*t,Da+=o*(r+n),Pa+=o*(i+t),Ua+=3*o,Gt(r=n,i=t)}var t,e,r,i;Wa.point=function(u,o){Wa.point=n,Gt(t=r=u,e=i=o)},Wa.lineEnd=function(){n(t,e)}}function te(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Ho)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function i(){a.point=t}function u(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:i,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=i,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function ee(n){function t(n){return(a?r:e)(n)}function e(t){return ue(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=NaN,S.point=u,t.lineStart()}function u(e,r){var u=dt([e,r]),o=n(e,r);i(M,x,m,b,_,w,M=o[0],x=o[1],m=e,b=u[0],_=u[1],w=u[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function l(){
  r(),S.point=c,S.lineEnd=f}function c(n,t){u(s=n,h=t),p=M,g=x,v=b,d=_,y=w,S.point=u}function f(){i(M,x,m,b,_,w,p,g,s,v,d,y,a,t),S.lineEnd=o,o()}var s,h,p,g,v,d,y,m,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=l},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function i(t,e,r,a,l,c,f,s,h,p,g,v,d,y){var m=f-t,M=s-e,x=m*m+M*M;if(x>4*u&&d--){var b=a+p,_=l+g,w=c+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),N=xo(xo(w)-1)<Uo||xo(r-h)<Uo?(r+h)/2:Math.atan2(_,b),E=n(N,k),A=E[0],C=E[1],z=A-t,L=C-e,q=M*z-m*L;(q*q/x>u||xo((m*z+M*L)/x-.5)>.3||o>a*p+l*g+c*v)&&(i(t,e,r,a,l,c,A,C,N,b/=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v,d,y))}}var u=.5,o=Math.cos(30*Yo),a=16;return t.precision=function(n){return arguments.length?(a=(u=n*n)>0&&16,t):Math.sqrt(u)},t}function re(n){var t=ee(function(t,e){return n([t*Zo,e*Zo])});return function(n){return le(t(n))}}function ie(n){this.stream=n}function ue(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function oe(n){return ae(function(){return n})()}function ae(n){function t(n){return n=a(n[0]*Yo,n[1]*Yo),[n[0]*h+l,c-n[1]*h]}function e(n){return n=a.invert((n[0]-l)/h,(c-n[1])/h),n&&[n[0]*Zo,n[1]*Zo]}function r(){a=Ct(o=se(y,M,x),u);var n=u(v,d);return l=p-n[0]*h,c=g+n[1]*h,i()}function i(){return f&&(f.valid=!1,f=null),t}var u,o,a,l,c,f,s=ee(function(n,t){return n=u(n,t),[n[0]*h+l,c-n[1]*h]}),h=150,p=480,g=250,v=0,d=0,y=0,M=0,x=0,b=Fa,_=m,w=null,S=null;return t.stream=function(n){return f&&(f.valid=!1),f=le(b(o,s(_(n)))),f.valid=!0,f},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Fa):It((w=+n)*Yo),i()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Zt(n[0][0],n[0][1],n[1][0],n[1][1]):m,i()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(p=+n[0],g=+n[1],r()):[p,g]},t.center=function(n){return arguments.length?(v=n[0]%360*Yo,d=n[1]%360*Yo,r()):[v*Zo,d*Zo]},t.rotate=function(n){return arguments.length?(y=n[0]%360*Yo,M=n[1]%360*Yo,x=n.length>2?n[2]%360*Yo:0,r()):[y*Zo,M*Zo,x*Zo]},ao.rebind(t,s,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function le(n){return ue(n,function(t,e){n.point(t*Yo,e*Yo)})}function ce(n,t){return[n,t]}function fe(n,t){return[n>Fo?n-Ho:-Fo>n?n+Ho:n,t]}function se(n,t,e){return n?t||e?Ct(pe(n),ge(t,e)):pe(n):t||e?ge(t,e):fe}function he(n){return function(t,e){return t+=n,[t>Fo?t-Ho:-Fo>t?t+Ho:t,e]}}function pe(n){var t=he(n);return t.invert=he(-n),t}function ge(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*r+a*i;return[Math.atan2(l*u-f*o,a*r-c*i),tn(f*u+l*o)]}var r=Math.cos(n),i=Math.sin(n),u=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*u-l*o;return[Math.atan2(l*u+c*o,a*r+f*i),tn(f*r-a*i)]},e}function ve(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=de(e,i),u=de(e,u),(o>0?u>i:i>u)&&(i+=o*Ho)):(i=n+o*Ho,u=n-.5*l);for(var c,f=i;o>0?f>u:u>f;f-=l)a.point((c=_t([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function de(n,t){var e=dt(t);e[0]-=n,bt(e);var r=nn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Uo)%(2*Math.PI)}function ye(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function me(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function Me(n){return n.source}function xe(n){return n.target}function be(n,t,e,r){var i=Math.cos(t),u=Math.sin(t),o=Math.cos(r),a=Math.sin(r),l=i*Math.cos(n),c=i*Math.sin(n),f=o*Math.cos(e),s=o*Math.sin(e),h=2*Math.asin(Math.sqrt(on(r-t)+i*o*on(e-n))),p=1/Math.sin(h),g=h?function(n){var t=Math.sin(n*=h)*p,e=Math.sin(h-n)*p,r=e*l+t*f,i=e*c+t*s,o=e*u+t*a;return[Math.atan2(i,r)*Zo,Math.atan2(o,Math.sqrt(r*r+i*i))*Zo]}:function(){return[n*Zo,t*Zo]};return g.distance=h,g}function _e(){function n(n,i){var u=Math.sin(i*=Yo),o=Math.cos(i),a=xo((n*=Yo)-t),l=Math.cos(a);Ja+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*u-e*o*l)*a),e*u+r*o*l),t=n,e=u,r=o}var t,e,r;Ga.point=function(i,u){t=i*Yo,e=Math.sin(u*=Yo),r=Math.cos(u),Ga.point=n},Ga.lineEnd=function(){Ga.point=Ga.lineEnd=b}}function we(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}function Se(n,t){function e(n,t){o>0?-Io+Uo>t&&(t=-Io+Uo):t>Io-Uo&&(t=Io-Uo);var e=o/Math.pow(i(t),u);return[e*Math.sin(u*n),o-e*Math.cos(u*n)]}var r=Math.cos(n),i=function(n){return Math.tan(Fo/4+n/2)},u=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(i(t)/i(n)),o=r*Math.pow(i(n),u)/u;return u?(e.invert=function(n,t){var e=o-t,r=K(u)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/u,2*Math.atan(Math.pow(o/r,1/u))-Io]},e):Ne}function ke(n,t){function e(n,t){var e=u-t;return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}var r=Math.cos(n),i=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),u=r/i+n;return xo(i)<Uo?ce:(e.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/i,u-K(i)*Math.sqrt(n*n+e*e)]},e)}function Ne(n,t){return[n,Math.log(Math.tan(Fo/4+t/2))]}function Ee(n){var t,e=oe(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=Fo*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Ae(n,t){return[Math.log(Math.tan(Fo/4+t/2)),-n]}function Ce(n){return n[0]}function ze(n){return n[1]}function Le(n){for(var t=n.length,e=[0,1],r=2,i=2;t>i;i++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function qe(n,t){return n[0]-t[0]||n[1]-t[1]}function Te(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Re(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function De(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Pe(){rr(this),this.edge=this.site=this.circle=null}function Ue(n){var t=cl.pop()||new Pe;return t.site=n,t}function je(n){Be(n),ol.remove(n),cl.push(n),rr(n)}function Fe(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];je(n);for(var l=u;l.circle&&xo(e-l.circle.x)<Uo&&xo(r-l.circle.cy)<Uo;)u=l.P,a.unshift(l),je(l),l=u;a.unshift(l),Be(l);for(var c=o;c.circle&&xo(e-c.circle.x)<Uo&&xo(r-c.circle.cy)<Uo;)o=c.N,a.push(c),je(c),c=o;a.push(c),Be(c);var f,s=a.length;for(f=1;s>f;++f)c=a[f],l=a[f-1],nr(c.edge,l.site,c.site,i);l=a[0],c=a[s-1],c.edge=Ke(l.site,c.site,null,i),$e(l),$e(c)}function He(n){for(var t,e,r,i,u=n.x,o=n.y,a=ol._;a;)if(r=Oe(a,o)-u,r>Uo)a=a.L;else{if(i=u-Ie(a,o),!(i>Uo)){r>-Uo?(t=a.P,e=a):i>-Uo?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=Ue(n);if(ol.insert(t,l),t||e){if(t===e)return Be(t),e=Ue(t.site),ol.insert(l,e),l.edge=e.edge=Ke(t.site,l.site),$e(t),void $e(e);if(!e)return void(l.edge=Ke(t.site,l.site));Be(t),Be(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};nr(e.edge,c,g,x),l.edge=Ke(c,n,null,x),e.edge=Ke(n,g,null,x),$e(t),$e(e)}}function Oe(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-(1/0);e=o.site;var a=e.x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function Ie(n,t){var e=n.N;if(e)return Oe(e,t);var r=n.site;return r.y===t?r.x:1/0}function Ye(n){this.site=n,this.edges=[]}function Ze(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ul,d=v.length;d--;)if(u=v[d],u&&u.prepare())for(a=u.edges,l=a.length,o=0;l>o;)f=a[o].end(),r=f.x,i=f.y,c=a[++o%l].start(),t=c.x,e=c.y,(xo(r-t)>Uo||xo(i-e)>Uo)&&(a.splice(o,0,new tr(Qe(u.site,f,xo(r-s)<Uo&&g-i>Uo?{x:s,y:xo(t-s)<Uo?e:g}:xo(i-g)<Uo&&h-r>Uo?{x:xo(e-g)<Uo?t:h,y:g}:xo(r-h)<Uo&&i-p>Uo?{x:h,y:xo(t-h)<Uo?e:p}:xo(i-p)<Uo&&r-s>Uo?{x:xo(e-p)<Uo?t:s,y:p}:null),u.site,null)),++l)}function Ve(n,t){return t.angle-n.angle}function Xe(){rr(this),this.x=this.y=this.arc=this.site=this.cy=null}function $e(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=u.y-a,h=2*(l*s-c*f);if(!(h>=-jo)){var p=l*l+c*c,g=f*f+s*s,v=(s*p-c*g)/h,d=(l*g-f*p)/h,s=d+a,y=fl.pop()||new Xe;y.arc=n,y.site=i,y.x=v+o,y.y=s+Math.sqrt(v*v+d*d),y.cy=s,n.circle=y;for(var m=null,M=ll._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}ll.insert(m,y),m||(al=y)}}}}function Be(n){var t=n.circle;t&&(t.P||(al=t.N),ll.remove(t),fl.push(t),rr(t),n.circle=null)}function We(n){for(var t,e=il,r=Yt(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)t=e[i],(!Je(t,n)||!r(t)||xo(t.a.x-t.b.x)<Uo&&xo(t.a.y-t.b.y)<Uo)&&(t.a=t.b=null,e.splice(i,1))}function Je(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(o>d||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(r=(h-g)/(v-p),i=y-r*d,-1>r||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(v>p){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Ge(n,t){this.l=n,this.r=t,this.a=this.b=null}function Ke(n,t,e,r){var i=new Ge(n,t);return il.push(i),e&&nr(i,n,t,e),r&&nr(i,t,n,r),ul[n.i].edges.push(new tr(i,n,t)),ul[t.i].edges.push(new tr(i,t,n)),i}function Qe(n,t,e){var r=new Ge(n,null);return r.a=t,r.b=e,il.push(r),r}function nr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function tr(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function er(){this._=null}function rr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function ir(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ur(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function or(n){for(;n.L;)n=n.L;return n}function ar(n,t){var e,r,i,u=n.sort(lr).pop();for(il=[],ul=new Array(n.length),ol=new er,ll=new er;;)if(i=al,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ul[u.i]=new Ye(u),He(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;Fe(i.arc)}t&&(We(t),Ze(t));var o={cells:ul,edges:il};return ol=ll=il=ul=null,o}function lr(n,t){return t.y-n.y||t.x-n.x}function cr(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function fr(n){return n.x}function sr(n){return n.y}function hr(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function pr(n,t,e,r,i,u){if(!n(t,e,r,i,u)){var o=.5*(e+i),a=.5*(r+u),l=t.nodes;l[0]&&pr(n,l[0],e,r,o,a),l[1]&&pr(n,l[1],o,r,i,a),l[2]&&pr(n,l[2],e,a,o,u),l[3]&&pr(n,l[3],o,a,i,u)}}function gr(n,t,e,r,i,u,o){var a,l=1/0;return function c(n,f,s,h,p){if(!(f>u||s>o||r>h||i>p)){if(g=n.point){var g,v=t-n.x,d=e-n.y,y=v*v+d*d;if(l>y){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=n.nodes,x=.5*(f+h),b=.5*(s+p),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:c(n,f,s,x,b);break;case 1:c(n,x,s,h,b);break;case 2:c(n,f,b,x,p);break;case 3:c(n,x,b,h,p)}}}(n,r,i,u,o),a}function vr(n,t){n=ao.rgb(n),t=ao.rgb(t);var e=n.r,r=n.g,i=n.b,u=t.r-e,o=t.g-r,a=t.b-i;return function(n){return"#"+bn(Math.round(e+u*n))+bn(Math.round(r+o*n))+bn(Math.round(i+a*n))}}function dr(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Mr(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function yr(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function mr(n,t){var e,r,i,u=hl.lastIndex=pl.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=hl.exec(n))&&(r=pl.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:yr(e,r)})),u=pl.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;t>r;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}function Mr(n,t){for(var e,r=ao.interpolators.length;--r>=0&&!(e=ao.interpolators[r](n,t)););return e}function xr(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(Mr(n[e],t[e]));for(;u>e;++e)i[e]=n[e];for(;o>e;++e)i[e]=t[e];return function(n){for(e=0;a>e;++e)i[e]=r[e](n);return i}}function br(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function _r(n){return function(t){return 1-n(1-t)}}function wr(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function Sr(n){return n*n}function kr(n){return n*n*n}function Nr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function Ar(n){return 1-Math.cos(n*Io)}function Cr(n){return Math.pow(2,10*(n-1))}function zr(n){return 1-Math.sqrt(1-n*n)}function Lr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Ho*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Ho/t)}}function qr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Tr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Rr(n,t){n=ao.hcl(n),t=ao.hcl(t);var e=n.h,r=n.c,i=n.l,u=t.h-e,o=t.c-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return sn(e+u*n,r+o*n,i+a*n)+""}}function Dr(n,t){n=ao.hsl(n),t=ao.hsl(t);var e=n.h,r=n.s,i=n.l,u=t.h-e,o=t.s-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return cn(e+u*n,r+o*n,i+a*n)+""}}function Pr(n,t){n=ao.lab(n),t=ao.lab(t);var e=n.l,r=n.a,i=n.b,u=t.l-e,o=t.a-r,a=t.b-i;return function(n){return pn(e+u*n,r+o*n,i+a*n)+""}}function Ur(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function jr(n){var t=[n.a,n.b],e=[n.c,n.d],r=Hr(t),i=Fr(t,e),u=Hr(Or(e,t,-i))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,i*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Zo,this.translate=[n.e,n.f],this.scale=[r,u],this.skew=u?Math.atan2(i,u)*Zo:0}function Fr(n,t){return n[0]*t[0]+n[1]*t[1]}function Hr(n){var t=Math.sqrt(Fr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Or(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ir(n){return n.length?n.pop()+",":""}function Yr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}function Zr(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(Ir(e)+"rotate(",null,")")-2,x:yr(n,t)})):t&&e.push(Ir(e)+"rotate("+t+")")}function Vr(n,t,e,r){n!==t?r.push({i:e.push(Ir(e)+"skewX(",null,")")-2,x:yr(n,t)}):t&&e.push(Ir(e)+"skewX("+t+")")}function Xr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(Ir(e)+"scale(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(Ir(e)+"scale("+t+")")}function $r(n,t){var e=[],r=[];return n=ao.transform(n),t=ao.transform(t),Yr(n.translate,t.translate,e,r),Zr(n.rotate,t.rotate,e,r),Vr(n.skew,t.skew,e,r),Xr(n.scale,t.scale,e,r),n=t=null,function(n){for(var t,i=-1,u=r.length;++i<u;)e[(t=r[i]).i]=t.x(n);return e.join("")}}function Br(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Wr(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Jr(n){for(var t=n.source,e=n.target,r=Kr(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function Gr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Kr(n,t){if(n===t)return n;for(var e=Gr(n),r=Gr(t),i=e.pop(),u=r.pop(),o=null;i===u;)o=i,i=e.pop(),u=r.pop();return o}function Qr(n){n.fixed|=2}function ni(n){n.fixed&=-7}function ti(n){n.fixed|=4,n.px=n.x,n.py=n.y}function ei(n){n.fixed&=-5}function ri(n,t,e){var r=0,i=0;if(n.charge=0,!n.leaf)for(var u,o=n.nodes,a=o.length,l=-1;++l<a;)u=o[l],null!=u&&(ri(u,t,e),n.charge+=u.charge,r+=u.charge*u.cx,i+=u.charge*u.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var c=t*e[n.point.index];n.charge+=n.pointCharge=c,r+=c*n.point.x,i+=c*n.point.y}n.cx=r/n.charge,n.cy=i/n.charge}function ii(n,t){return ao.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=fi,n}function ui(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function oi(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ai(n){return n.children}function li(n){return n.value}function ci(n,t){return t.value-n.value}function fi(n){return ao.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function si(n){return n.x}function hi(n){return n.y}function pi(n,t,e){n.y0=t,n.y=e}function gi(n){return ao.range(n.length)}function vi(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function di(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;u>e;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function yi(n){return n.reduce(mi,0)}function mi(n,t){return n+t[1]}function Mi(n,t){return xi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function xi(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function bi(n){return[ao.min(n),ao.max(n)]}function _i(n,t){return n.value-t.value}function wi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Si(n,t){n._pack_next=t,t._pack_prev=n}function ki(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function Ni(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),p=Math.max(n.y+n.r,p)}if((e=n.children)&&(c=e.length)){var e,r,i,u,o,a,l,c,f=1/0,s=-(1/0),h=1/0,p=-(1/0);if(e.forEach(Ei),r=e[0],r.x=-r.r,r.y=0,t(r),c>1&&(i=e[1],i.x=i.r,i.y=0,t(i),c>2))for(u=e[2],zi(r,i,u),t(u),wi(r,u),r._pack_prev=u,wi(u,i),i=r._pack_next,o=3;c>o;o++){zi(r,i,u=e[o]);var g=0,v=1,d=1;for(a=i._pack_next;a!==i;a=a._pack_next,v++)if(ki(a,u)){g=1;break}if(1==g)for(l=r._pack_prev;l!==a._pack_prev&&!ki(l,u);l=l._pack_prev,d++);g?(d>v||v==d&&i.r<r.r?Si(r,i=a):Si(r=l,i),o--):(wi(r,u),i=u,t(u))}var y=(f+s)/2,m=(h+p)/2,M=0;for(o=0;c>o;o++)u=e[o],u.x-=y,u.y-=m,M=Math.max(M,u.r+Math.sqrt(u.x*u.x+u.y*u.y));n.r=M,e.forEach(Ai)}}function Ei(n){n._pack_next=n._pack_prev=n}function Ai(n){delete n._pack_next,delete n._pack_prev}function Ci(n,t,e,r){var i=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,i)for(var u=-1,o=i.length;++u<o;)Ci(i[u],t,e,r)}function zi(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u;o*=o,r*=r;var l=.5+(r-o)/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Li(n,t){return n.parent==t.parent?1:2}function qi(n){var t=n.children;return t.length?t[0]:n.t}function Ti(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ri(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Di(n){for(var t,e=0,r=0,i=n.children,u=i.length;--u>=0;)t=i[u],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Pi(n,t,e){return n.a.parent===t.parent?n.a:e}function Ui(n){return 1+ao.max(n,function(n){return n.y})}function ji(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Fi(n){var t=n.children;return t&&t.length?Fi(t[0]):n}function Hi(n){var t,e=n.children;return e&&(t=e.length)?Hi(e[t-1]):n}function Oi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Ii(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return 0>i&&(e+=i/2,i=0),0>u&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function Yi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Zi(n){return n.rangeExtent?n.rangeExtent():Yi(n.range())}function Vi(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function Xi(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return u>o&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function $i(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:Sl}function Bi(n,t,e,r){var i=[],u=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)i.push(e(n[o-1],n[o])),u.push(r(t[o-1],t[o]));return function(t){var e=ao.bisect(n,t,1,a)-1;return u[e](i[e](t))}}function Wi(n,t,e,r){function i(){var i=Math.min(n.length,t.length)>2?Bi:Vi,l=r?Wr:Br;return o=i(n,t,l,e),a=i(t,n,l,Mr),u}function u(n){return o(n)}var o,a;return u.invert=function(n){return a(n)},u.domain=function(t){return arguments.length?(n=t.map(Number),i()):n},u.range=function(n){return arguments.length?(t=n,i()):t},u.rangeRound=function(n){return u.range(n).interpolate(Ur)},u.clamp=function(n){return arguments.length?(r=n,i()):r},u.interpolate=function(n){return arguments.length?(e=n,i()):e},u.ticks=function(t){return Qi(n,t)},u.tickFormat=function(t,e){return nu(n,t,e)},u.nice=function(t){return Gi(n,t),i()},u.copy=function(){return Wi(n,t,e,r)},i()}function Ji(n,t){return ao.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Gi(n,t){return Xi(n,$i(Ki(n,t)[2])),Xi(n,$i(Ki(n,t)[2])),n}function Ki(n,t){null==t&&(t=10);var e=Yi(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return.15>=u?i*=10:.35>=u?i*=5:.75>=u&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function Qi(n,t){return ao.range.apply(ao,Ki(n,t))}function nu(n,t,e){var r=Ki(n,t);if(e){var i=ha.exec(e);if(i.shift(),"s"===i[8]){var u=ao.formatPrefix(Math.max(xo(r[0]),xo(r[1])));return i[7]||(i[7]="."+tu(u.scale(r[2]))),i[8]="f",e=ao.format(i.join("")),function(n){return e(u.scale(n))+u.symbol}}i[7]||(i[7]="."+eu(i[8],r)),e=i.join("")}else e=",."+tu(r[2])+"f";return ao.format(e)}function tu(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function eu(n,t){var e=tu(t[2]);return n in kl?Math.abs(e-tu(Math.max(xo(t[0]),xo(t[1]))))+ +("e"!==n):e-2*("%"===n)}function ru(n,t,e,r){function i(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function u(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(i(t))}return o.invert=function(t){return u(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(i)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(i)),o):t},o.nice=function(){var t=Xi(r.map(i),e?Math:El);return n.domain(t),r=t.map(u),o},o.ticks=function(){var n=Yi(r),o=[],a=n[0],l=n[1],c=Math.floor(i(a)),f=Math.ceil(i(l)),s=t%1?2:t;if(isFinite(f-c)){if(e){for(;f>c;c++)for(var h=1;s>h;h++)o.push(u(c)*h);o.push(u(c))}else for(o.push(u(c));c++<f;)for(var h=s-1;h>0;h--)o.push(u(c)*h);for(c=0;o[c]<a;c++);for(f=o.length;o[f-1]>l;f--);o=o.slice(c,f)}return o},o.tickFormat=function(n,e){if(!arguments.length)return Nl;arguments.length<2?e=Nl:"function"!=typeof e&&(e=ao.format(e));var r=Math.max(1,t*n/o.ticks().length);return function(n){var o=n/u(Math.round(i(n)));return t-.5>o*t&&(o*=t),r>=o?e(n):""}},o.copy=function(){return ru(n.copy(),t,e,r)},Ji(o,n)}function iu(n,t,e){function r(t){return n(i(t))}var i=uu(t),u=uu(1/t);return r.invert=function(t){return u(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(i)),r):e},r.ticks=function(n){return Qi(e,n)},r.tickFormat=function(n,t){return nu(e,n,t)},r.nice=function(n){return r.domain(Gi(e,n))},r.exponent=function(o){return arguments.length?(i=uu(t=o),u=uu(1/t),n.domain(e.map(i)),r):t},r.copy=function(){return iu(n.copy(),t,e)},Ji(r,n)}function uu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function ou(n,t){function e(e){return u[((i.get(e)||("range"===t.t?i.set(e,n.push(e)):NaN))-1)%u.length]}function r(t,e){return ao.range(n.length).map(function(n){return t+e*n})}var i,u,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new c;for(var u,o=-1,a=r.length;++o<a;)i.has(u=r[o])||i.set(u,n.push(u));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(u=n,o=0,t={t:"range",a:arguments},e):u},e.rangePoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=(l+c)/2,0):(c-l)/(n.length-1+a);return u=r(l+f*a/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=c=Math.round((l+c)/2),0):(c-l)/(n.length-1+a)|0;return u=r(l+Math.round(f*a/2+(c-l-(n.length-1+a)*f)/2),f),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=(s-f)/(n.length-a+2*l);return u=r(f+h*l,h),c&&u.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=Math.floor((s-f)/(n.length-a+2*l));return u=r(f+Math.round((s-f-(n.length-a)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Yi(t.a[0])},e.copy=function(){return ou(n,t)},e.domain(n)}function au(n,t){function u(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ao.quantile(n,e/r);return o}function o(n){return isNaN(n=+n)?void 0:t[ao.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(i).sort(e),u()):n},o.range=function(n){return arguments.length?(t=n,u()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),0>e?[NaN,NaN]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return au(n,t)},u()}function lu(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(u*(t-n))))]}function i(){return u=e.length/(t-n),o=e.length-1,r}var u,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],i()):[n,t]},r.range=function(n){return arguments.length?(e=n,i()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?NaN:t/u+n,[t,t+1/u]},r.copy=function(){return lu(n,t,e)},i()}function cu(n,t){function e(e){return e>=e?t[ao.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return cu(n,t)},e}function fu(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Qi(n,t)},t.tickFormat=function(t,e){return nu(n,t,e)},t.copy=function(){return fu(n)},t}function su(){return 0}function hu(n){return n.innerRadius}function pu(n){return n.outerRadius}function gu(n){return n.startAngle}function vu(n){return n.endAngle}function du(n){return n&&n.padAngle}function yu(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function mu(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(0>y?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Mu(n){function t(t){function o(){c.push("M",u(n(f),a))}for(var l,c=[],f=[],s=-1,h=t.length,p=En(e),g=En(r);++s<h;)i.call(this,l=t[s],s)?f.push([+p.call(this,l,s),+g.call(this,l,s)]):f.length&&(o(),f=[]);return f.length&&o(),c.length?c.join(""):null}var e=Ce,r=ze,i=zt,u=xu,o=u.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(i=n,t):i},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?u=n:(u=Tl.get(n)||xu).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function xu(n){return n.length>1?n.join("L"):n+"Z"}function bu(n){return n.join("L")+"Z"}function _u(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&i.push("H",r[0]),i.join("")}function wu(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Su(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function ku(n,t){return n.length<4?xu(n):n[1]+Au(n.slice(1,-1),Cu(n,t))}function Nu(n,t){return n.length<3?bu(n):n[0]+Au((n.push(n[0]),n),Cu([n[n.length-2]].concat(n,[n[1]]),t))}function Eu(n,t){return n.length<3?xu(n):n[0]+Au(n,Cu(n,t))}function Au(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return xu(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Cu(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function zu(n){if(n.length<3)return xu(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Ru(Pl,o),",",Ru(Pl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Du(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Lu(n){if(n.length<4)return xu(n);for(var t,e=[],r=-1,i=n.length,u=[0],o=[0];++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);for(e.push(Ru(Pl,u)+","+Ru(Pl,o)),--r;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Du(e,u,o);return e.join("")}function qu(n){for(var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);for(t=[Ru(Pl,o),",",Ru(Pl,a)],--r;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Du(t,o,a);return t.join("")}function Tu(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return zu(n)}function Ru(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Du(n,t,e){n.push("C",Ru(Rl,t),",",Ru(Rl,e),",",Ru(Dl,t),",",Ru(Dl,e),",",Ru(Pl,t),",",Ru(Pl,e))}function Pu(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Uu(n){for(var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Pu(i,u);++t<e;)r[t]=(o+(o=Pu(i=u,u=n[t+1])))/2;return r[t]=o,r}function ju(n){for(var t,e,r,i,u=[],o=Uu(n),a=-1,l=n.length-1;++a<l;)t=Pu(n[a],n[a+1]),xo(t)<Uo?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,i=e*e+r*r,i>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));for(a=-1;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}function Fu(n){return n.length<3?xu(n):n[0]+Au(n,ju(n))}function Hu(n){for(var t,e,r,i=-1,u=n.length;++i<u;)t=n[i],e=t[0],r=t[1]-Io,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Ou(n){function t(t){function l(){v.push("M",a(n(y),s),f,c(n(d.reverse()),s),"Z")}for(var h,p,g,v=[],d=[],y=[],m=-1,M=t.length,x=En(e),b=En(i),_=e===r?function(){
    return p}:En(r),w=i===u?function(){return g}:En(u);++m<M;)o.call(this,h=t[m],m)?(d.push([p=+x.call(this,h,m),g=+b.call(this,h,m)]),y.push([+_.call(this,h,m),+w.call(this,h,m)])):d.length&&(l(),d=[],y=[]);return d.length&&l(),v.length?v.join(""):null}var e=Ce,r=Ce,i=0,u=ze,o=zt,a=xu,l=a.key,c=a,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(i=u=n,t):u},t.y0=function(n){return arguments.length?(i=n,t):i},t.y1=function(n){return arguments.length?(u=n,t):u},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(l="function"==typeof n?a=n:(a=Tl.get(n)||xu).key,c=a.reverse||a,f=a.closed?"M":"L",t):l},t.tension=function(n){return arguments.length?(s=n,t):s},t}function Iu(n){return n.radius}function Yu(n){return[n.x,n.y]}function Zu(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Io;return[e*Math.cos(r),e*Math.sin(r)]}}function Vu(){return 64}function Xu(){return"circle"}function $u(n){var t=Math.sqrt(n/Fo);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Bu(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function Wu(n,t,e){return ko(n,Yl),n.namespace=t,n.id=e,n}function Ju(n,t,e,r){var i=n.id,u=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function Gu(n){return null==n&&(n=""),function(){this.textContent=n}}function Ku(n){return null==n?"__transition__":"__transition_"+n+"__"}function Qu(n,t,e,r,i){function u(n){var t=v.delay;return f.t=t+l,n>=t?o(n-t):void(f.c=o)}function o(e){var i=g.active,u=g[i];u&&(u.timer.c=null,u.timer.t=NaN,--g.count,delete g[i],u.event&&u.event.interrupt.call(n,n.__data__,u.index));for(var o in g)if(r>+o){var c=g[o];c.timer.c=null,c.timer.t=NaN,--g.count,delete g[o]}f.c=a,qn(function(){return f.c&&a(e||1)&&(f.c=null,f.t=NaN),1},0,l),g.active=r,v.event&&v.event.start.call(n,n.__data__,t),p=[],v.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&p.push(r)}),h=v.ease,s=v.duration}function a(i){for(var u=i/s,o=h(u),a=p.length;a>0;)p[--a].call(n,o);return u>=1?(v.event&&v.event.end.call(n,n.__data__,t),--g.count?delete g[r]:delete n[e],1):void 0}var l,f,s,h,p,g=n[e]||(n[e]={active:0,count:0}),v=g[r];v||(l=i.time,f=qn(u,0,l),v=g[r]={tween:new c,time:l,timer:f,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++g.count)}function no(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function to(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function eo(n){return n.toISOString()}function ro(n,t,e){function r(t){return n(t)}function i(n,e){var r=n[1]-n[0],i=r/e,u=ao.bisect(Kl,i);return u==Kl.length?[t.year,Ki(n.map(function(n){return n/31536e6}),e)[2]]:u?t[i/Kl[u-1]<Kl[u]/i?u-1:u]:[tc,Ki(n,e)[2]]}return r.invert=function(t){return io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,io(+e+1),t).length}var u=r.domain(),o=Yi(u),a=null==n?i(o,10):"number"==typeof n&&i(o,n);return a&&(n=a[0],t=a[1]),r.domain(Xi(u,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Yi(r.domain()),u=null==n?i(e,10):"number"==typeof n?i(e,n):!n.range&&[{range:n},t];return u&&(n=u[0],t=u[1]),n.range(e[0],io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return ro(n.copy(),t,e)},Ji(r,n)}function io(n){return new Date(n)}function uo(n){return JSON.parse(n.responseText)}function oo(n){var t=fo.createRange();return t.selectNode(fo.body),t.createContextualFragment(n.responseText)}var ao={version:"3.5.17"},lo=[].slice,co=function(n){return lo.call(n)},fo=this.document;if(fo)try{co(fo.documentElement.childNodes)[0].nodeType}catch(so){co=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),fo)try{fo.createElement("DIV").style.setProperty("opacity",0,"")}catch(ho){var po=this.Element.prototype,go=po.setAttribute,vo=po.setAttributeNS,yo=this.CSSStyleDeclaration.prototype,mo=yo.setProperty;po.setAttribute=function(n,t){go.call(this,n,t+"")},po.setAttributeNS=function(n,t,e){vo.call(this,n,t,e+"")},yo.setProperty=function(n,t,e){mo.call(this,n,t+"",e)}}ao.ascending=e,ao.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:NaN},ao.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},ao.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},ao.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),r>i&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),r>i&&(i=r))}return[e,i]},ao.sum=function(n,t){var e,r=0,u=n.length,o=-1;if(1===arguments.length)for(;++o<u;)i(e=+n[o])&&(r+=e);else for(;++o<u;)i(e=+t.call(n,n[o],o))&&(r+=e);return r},ao.mean=function(n,t){var e,u=0,o=n.length,a=-1,l=o;if(1===arguments.length)for(;++a<o;)i(e=r(n[a]))?u+=e:--l;else for(;++a<o;)i(e=r(t.call(n,n[a],a)))?u+=e:--l;return l?u/l:void 0},ao.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},ao.median=function(n,t){var u,o=[],a=n.length,l=-1;if(1===arguments.length)for(;++l<a;)i(u=r(n[l]))&&o.push(u);else for(;++l<a;)i(u=r(t.call(n,n[l],l)))&&o.push(u);return o.length?ao.quantile(o.sort(e),.5):void 0},ao.variance=function(n,t){var e,u,o=n.length,a=0,l=0,c=-1,f=0;if(1===arguments.length)for(;++c<o;)i(e=r(n[c]))&&(u=e-a,a+=u/++f,l+=u*(e-a));else for(;++c<o;)i(e=r(t.call(n,n[c],c)))&&(u=e-a,a+=u/++f,l+=u*(e-a));return f>1?l/(f-1):void 0},ao.deviation=function(){var n=ao.variance.apply(this,arguments);return n?Math.sqrt(n):n};var Mo=u(e);ao.bisectLeft=Mo.left,ao.bisect=ao.bisectRight=Mo.right,ao.bisector=function(n){return u(1===n.length?function(t,r){return e(n(t),r)}:n)},ao.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,2>u&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},ao.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ao.pairs=function(n){for(var t,e=0,r=n.length-1,i=n[0],u=new Array(0>r?0:r);r>e;)u[e]=[t=i,i=n[++e]];return u},ao.transpose=function(n){if(!(i=n.length))return[];for(var t=-1,e=ao.min(n,o),r=new Array(e);++t<e;)for(var i,u=-1,a=r[t]=new Array(i);++u<i;)a[u]=n[u][t];return r},ao.zip=function(){return ao.transpose(arguments)},ao.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ao.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ao.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ao.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(r=n[i],t=r.length;--t>=0;)e[--o]=r[t];return e};var xo=Math.abs;ao.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,i=[],u=a(xo(e)),o=-1;if(n*=u,t*=u,e*=u,0>e)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},ao.map=function(n,t){var e=new c;if(n instanceof c)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var bo="__proto__",_o="\x00";l(c,{has:h,get:function(n){return this._[f(n)]},set:function(n,t){return this._[f(n)]=t},remove:p,keys:g,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:s(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t),this._[t])}}),ao.nest=function(){function n(t,o,a){if(a>=u.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,p=-1,g=o.length,v=u[a++],d=new c;++p<g;)(h=d.get(l=v(f=o[p])))?h.push(f):d.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,a))}):(f={},s=function(e,r){f[e]=n(t,r,a)}),d.forEach(s),f}function t(n,e){if(e>=u.length)return n;var r=[],i=o[e++];return n.forEach(function(n,i){r.push({key:n,values:t(i,e)})}),i?r.sort(function(n,t){return i(n.key,t.key)}):r}var e,r,i={},u=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(ao.map,e,0),0)},i.key=function(n){return u.push(n),i},i.sortKeys=function(n){return o[u.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},ao.set=function(n){var t=new y;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},l(y,{has:h,add:function(n){return this._[f(n+="")]=!0,n},remove:p,values:g,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t))}}),ao.behavior={},ao.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=M(n,t,t[e]);return n};var wo=["webkit","ms","moz","Moz","o","O"];ao.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ao.event=null,ao.requote=function(n){return n.replace(So,"\\$&")};var So=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ko={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},No=function(n,t){return t.querySelector(n)},Eo=function(n,t){return t.querySelectorAll(n)},Ao=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(Ao=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(No=function(n,t){return Sizzle(n,t)[0]||null},Eo=Sizzle,Ao=Sizzle.matchesSelector),ao.selection=function(){return ao.select(fo.documentElement)};var Co=ao.selection.prototype=[];Co.select=function(n){var t,e,r,i,u=[];n=A(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return E(u)},Co.selectAll=function(n){var t,e,r=[];n=C(n);for(var i=-1,u=this.length;++i<u;)for(var o=this[i],a=-1,l=o.length;++a<l;)(e=o[a])&&(r.push(t=co(n.call(e,e.__data__,a,i))),t.parentNode=e);return E(r)};var zo="http://www.w3.org/1999/xhtml",Lo={svg:"http://www.w3.org/2000/svg",xhtml:zo,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ao.ns={prefix:Lo,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),Lo.hasOwnProperty(e)?{space:Lo[e],local:n}:n}},Co.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ao.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},Co.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!q(n[i]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},Co.style=function(n,e,r){var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(2>i){var u=this.node();return t(u).getComputedStyle(u,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},Co.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},Co.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Co.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Co.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},Co.insert=function(n,t){return n=j(n),t=A(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},Co.remove=function(){return this.each(F)},Co.data=function(n,t){function e(n,e){var r,i,u,o=n.length,s=e.length,h=Math.min(o,s),p=new Array(s),g=new Array(s),v=new Array(o);if(t){var d,y=new c,m=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(y.has(d=t.call(i,i.__data__,r))?v[r]=i:y.set(d,i),m[r]=d);for(r=-1;++r<s;)(i=y.get(d=t.call(e,u=e[r],r)))?i!==!0&&(p[r]=i,i.__data__=u):g[r]=H(u),y.set(d,!0);for(r=-1;++r<o;)r in m&&y.get(m[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],u=e[r],i?(i.__data__=u,p[r]=i):g[r]=H(u);for(;s>r;++r)g[r]=H(e[r]);for(;o>r;++r)v[r]=n[r]}g.update=p,g.parentNode=p.parentNode=v.parentNode=n.parentNode,a.push(g),l.push(p),f.push(v)}var r,i,u=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++u<o;)(i=r[u])&&(n[u]=i.__data__);return n}var a=Z([]),l=E([]),f=E([]);if("function"==typeof n)for(;++u<o;)e(r=this[u],n.call(r,r.parentNode.__data__,u));else for(;++u<o;)e(r=this[u],n);return l.enter=function(){return a},l.exit=function(){return f},l},Co.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Co.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return E(i)},Co.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},Co.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Co.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Co.call=function(n){var t=co(arguments);return n.apply(t[0]=this,t),this},Co.empty=function(){return!this.node()},Co.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,i=e.length;i>r;r++){var u=e[r];if(u)return u}return null},Co.size=function(){var n=0;return Y(this,function(){++n}),n};var qo=[];ao.selection.enter=Z,ao.selection.enter.prototype=qo,qo.append=Co.append,qo.empty=Co.empty,qo.node=Co.node,qo.call=Co.call,qo.size=Co.size,qo.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return E(o)},qo.insert=function(n,t){return arguments.length<2&&(t=V(this)),Co.insert.call(this,n,t)},ao.select=function(t){var e;return"string"==typeof t?(e=[No(t,fo)],e.parentNode=fo.documentElement):(e=[t],e.parentNode=n(t)),E([e])},ao.selectAll=function(n){var t;return"string"==typeof n?(t=co(Eo(n,fo)),t.parentNode=fo.documentElement):(t=co(n),t.parentNode=null),E([t])},Co.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var To=ao.map({mouseenter:"mouseover",mouseleave:"mouseout"});fo&&To.forEach(function(n){"on"+n in fo&&To.remove(n)});var Ro,Do=0;ao.mouse=function(n){return J(n,k())};var Po=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ao.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,i=0,u=t.length;u>i;++i)if((r=t[i]).identifier===e)return J(n,r)},ao.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",o)}function e(n,t,e,u,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],g|=n|e,M=r,p({type:"drag",x:r[0]+c[0],y:r[1]+c[1],dx:n,dy:e}))}function l(){t(h,v)&&(y.on(u+d,null).on(o+d,null),m(g),p({type:"dragend"}))}var c,f=this,s=ao.event.target.correspondingElement||ao.event.target,h=f.parentNode,p=r.of(f,arguments),g=0,v=n(),d=".drag"+(null==v?"":"-"+v),y=ao.select(e(s)).on(u+d,a).on(o+d,l),m=W(s),M=t(h,v);i?(c=i.apply(f,arguments),c=[c.x-M[0],c.y-M[1]]):c=[0,0],p({type:"dragstart"})}}var r=N(n,"drag","dragstart","dragend"),i=null,u=e(b,ao.mouse,t,"mousemove","mouseup"),o=e(G,ao.touch,m,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},ao.rebind(n,r,"on")},ao.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?co(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Uo=1e-6,jo=Uo*Uo,Fo=Math.PI,Ho=2*Fo,Oo=Ho-Uo,Io=Fo/2,Yo=Fo/180,Zo=180/Fo,Vo=Math.SQRT2,Xo=2,$o=4;ao.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(jo>h)r=Math.log(c/o)/Vo,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Vo*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+$o*h)/(2*o*Xo*p),v=(c*c-o*o-$o*h)/(2*c*Xo*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Vo,e=function(n){var t=n*r,e=rn(d),a=o/(Xo*p)*(e*un(Vo*t+d)-en(d));return[i+a*f,u+a*s,o*e/rn(Vo*t+d)]}}return e.duration=1e3*r,e},ao.behavior.zoom=function(){function n(n){n.on(L,s).on(Wo+".zoom",p).on("dblclick.zoom",g).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function i(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},i(Math.pow(2,o)),u(d=e,r),t=ao.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function l(n){z++||n({type:"zoomstart"})}function c(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function f(n){--z||(n({type:"zoomend"}),d=null)}function s(){function n(){a=1,u(ao.mouse(i),h),c(o)}function r(){s.on(q,null).on(T,null),p(a),f(o)}var i=this,o=D.of(i,arguments),a=0,s=ao.select(t(i)).on(q,n).on(T,r),h=e(ao.mouse(i)),p=W(i);Il.call(i),l(o)}function h(){function n(){var n=ao.touches(g);return p=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ao.event.target;ao.select(t).on(x,r).on(b,a),_.push(t);for(var e=ao.event.changedTouches,i=0,u=e.length;u>i;++i)d[e[i].identifier]=null;var l=n(),c=Date.now();if(1===l.length){if(500>c-M){var f=l[0];o(g,f,d[f.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=c}else if(l.length>1){var f=l[0],s=l[1],h=f[0]-s[0],p=f[1]-s[1];y=h*h+p*p}}function r(){var n,t,e,r,o=ao.touches(g);Il.call(g);for(var a=0,l=o.length;l>a;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var f=(f=e[0]-n[0])*f+(f=e[1]-n[1])*f,s=y&&Math.sqrt(f/y);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],i(s*p)}M=null,u(n,t),c(v)}function a(){if(ao.event.touches.length){for(var t=ao.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var i in d)return void n()}ao.selectAll(_).on(m,null),w.on(L,s).on(R,h),N(),f(v)}var p,g=this,v=D.of(g,arguments),d={},y=0,m=".zoom-"+ao.event.changedTouches[0].identifier,x="touchmove"+m,b="touchend"+m,_=[],w=ao.select(g),N=W(g);t(),l(v),w.on(L,null).on(R,t)}function p(){var n=D.of(this,arguments);m?clearTimeout(m):(Il.call(this),v=e(d=y||ao.mouse(this)),l(n)),m=setTimeout(function(){m=null,f(n)},50),S(),i(Math.pow(2,.002*Bo())*k.k),u(d,v),c(n)}function g(){var n=ao.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ao.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,y,m,M,x,b,_,w,k={x:0,y:0,k:1},E=[960,500],A=Jo,C=250,z=0,L="mousedown.zoom",q="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=N(n,"zoomstart","zoom","zoomend");return Wo||(Wo="onwheel"in fo?(Bo=function(){return-ao.event.deltaY*(ao.event.deltaMode?120:1)},"wheel"):"onmousewheel"in fo?(Bo=function(){return ao.event.wheelDelta},"mousewheel"):(Bo=function(){return-ao.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Hl?ao.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},l(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],i=d?d[0]:e/2,u=d?d[1]:r/2,o=ao.interpolateZoom([(i-k.x)/k.k,(u-k.y)/k.k,e/k.k],[(i-t.x)/t.k,(u-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:i-r[0]*a,y:u-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){f(n)}).each("end.zoom",function(){f(n)}):(this.__chart__=k,l(n),c(n),f(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:null},i(+t),a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Jo:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(y=t&&[+t[0],+t[1]],n):y},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ao.rebind(n,D,"on")};var Bo,Wo,Jo=[0,1/0];ao.color=an,an.prototype.toString=function(){return this.rgb()+""},ao.hsl=ln;var Go=ln.prototype=new an;Go.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,this.l/n)},Go.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,n*this.l)},Go.rgb=function(){return cn(this.h,this.s,this.l)},ao.hcl=fn;var Ko=fn.prototype=new an;Ko.brighter=function(n){return new fn(this.h,this.c,Math.min(100,this.l+Qo*(arguments.length?n:1)))},Ko.darker=function(n){return new fn(this.h,this.c,Math.max(0,this.l-Qo*(arguments.length?n:1)))},Ko.rgb=function(){return sn(this.h,this.c,this.l).rgb()},ao.lab=hn;var Qo=18,na=.95047,ta=1,ea=1.08883,ra=hn.prototype=new an;ra.brighter=function(n){return new hn(Math.min(100,this.l+Qo*(arguments.length?n:1)),this.a,this.b)},ra.darker=function(n){return new hn(Math.max(0,this.l-Qo*(arguments.length?n:1)),this.a,this.b)},ra.rgb=function(){return pn(this.l,this.a,this.b)},ao.rgb=mn;var ia=mn.prototype=new an;ia.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&i>t&&(t=i),e&&i>e&&(e=i),r&&i>r&&(r=i),new mn(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mn(i,i,i)},ia.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mn(n*this.r,n*this.g,n*this.b)},ia.hsl=function(){return wn(this.r,this.g,this.b)},ia.toString=function(){return"#"+bn(this.r)+bn(this.g)+bn(this.b)};var ua=ao.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});ua.forEach(function(n,t){ua.set(n,Mn(t))}),ao.functor=En,ao.xhr=An(m),ao.dsv=function(n,t){function e(n,e,u){arguments.length<3&&(u=e,e=null);var o=Cn(n,t,null==e?r:i(e),u);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:i(n)):e},o}function r(n){return e.parse(n.responseText)}function i(n){return function(t){return e.parse(t.responseText,n)}}function u(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(i(n),e)}:i})},e.parseRows=function(n,t){function e(){if(f>=c)return o;if(i)return i=!1,u;var t=f;if(34===n.charCodeAt(t)){for(var e=t;e++<c;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(i=!0,10===n.charCodeAt(e+2)&&++f):10===r&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),a=1;if(10===r)i=!0;else if(13===r)i=!0,10===n.charCodeAt(f)&&(++f,++a);else if(r!==l)continue;return n.slice(t,f-a)}return n.slice(t)}for(var r,i,u={},o={},a=[],c=n.length,f=0,s=0;(r=e())!==o;){for(var h=[];r!==u&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,s++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new y,i=[];return t.forEach(function(n){for(var t in n)r.has(t)||i.push(r.add(t))}),[i.map(o).join(n)].concat(t.map(function(t){return i.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(u).join("\n")},e},ao.csv=ao.dsv(",","text/csv"),ao.tsv=ao.dsv("	","text/tab-separated-values");var oa,aa,la,ca,fa=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ao.timer=function(){qn.apply(this,arguments)},ao.timer.flush=function(){Rn(),Dn()},ao.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var sa=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Un);ao.formatPrefix=function(n,t){var e=0;return(n=+n)&&(0>n&&(n*=-1),t&&(n=ao.round(n,Pn(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),sa[8+e/3]};var ha=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,pa=ao.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ao.round(n,Pn(n,t))).toFixed(Math.max(0,Math.min(20,Pn(n*(1+1e-15),t))))}}),ga=ao.time={},va=Date;Hn.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){da.setUTCDate.apply(this._,arguments)},setDay:function(){da.setUTCDay.apply(this._,arguments)},setFullYear:function(){da.setUTCFullYear.apply(this._,arguments)},setHours:function(){da.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){da.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){da.setUTCMinutes.apply(this._,arguments)},setMonth:function(){da.setUTCMonth.apply(this._,arguments)},setSeconds:function(){da.setUTCSeconds.apply(this._,arguments)},setTime:function(){da.setTime.apply(this._,arguments)}};var da=Date.prototype;ga.year=On(function(n){return n=ga.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ga.years=ga.year.range,ga.years.utc=ga.year.utc.range,ga.day=On(function(n){var t=new va(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ga.days=ga.day.range,ga.days.utc=ga.day.utc.range,ga.dayOfYear=function(n){var t=ga.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ga[n]=On(function(n){return(n=ga.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ga[n+"s"]=e.range,ga[n+"s"].utc=e.utc.range,ga[n+"OfYear"]=function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)}}),ga.week=ga.sunday,ga.weeks=ga.sunday.range,ga.weeks.utc=ga.sunday.utc.range,ga.weekOfYear=ga.sundayOfYear;var ya={"-":"",_:" ",0:"0"},ma=/^\s*\d+/,Ma=/^%/;ao.locale=function(n){return{numberFormat:jn(n),timeFormat:Yn(n)}};var xa=ao.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
  shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ao.format=xa.numberFormat,ao.geo={},ft.prototype={s:0,t:0,add:function(n){st(n,this.t,ba),st(ba.s,this.s,this),this.s?this.t+=ba.t:this.s=ba.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ba=new ft;ao.geo.stream=function(n,t){n&&_a.hasOwnProperty(n.type)?_a[n.type](n,t):ht(n,t)};var _a={Feature:function(n,t){ht(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)ht(e[r].geometry,t)}},wa={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){pt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)pt(e[r],t,0)},Polygon:function(n,t){gt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)gt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)ht(e[r],t)}};ao.geo.area=function(n){return Sa=0,ao.geo.stream(n,Na),Sa};var Sa,ka=new ft,Na={sphere:function(){Sa+=4*Fo},point:b,lineStart:b,lineEnd:b,polygonStart:function(){ka.reset(),Na.lineStart=vt},polygonEnd:function(){var n=2*ka;Sa+=0>n?4*Fo+n:n,Na.lineStart=Na.lineEnd=Na.point=b}};ao.geo.bounds=function(){function n(n,t){M.push(x=[f=n,h=n]),s>t&&(s=t),t>p&&(p=t)}function t(t,e){var r=dt([t*Yo,e*Yo]);if(y){var i=mt(y,r),u=[i[1],-i[0],0],o=mt(u,i);bt(o),o=_t(o);var l=t-g,c=l>0?1:-1,v=o[0]*Zo*c,d=xo(l)>180;if(d^(v>c*g&&c*t>v)){var m=o[1]*Zo;m>p&&(p=m)}else if(v=(v+360)%360-180,d^(v>c*g&&c*t>v)){var m=-o[1]*Zo;s>m&&(s=m)}else s>e&&(s=e),e>p&&(p=e);d?g>t?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t):h>=f?(f>t&&(f=t),t>h&&(h=t)):t>g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t)}else n(t,e);y=r,g=t}function e(){b.point=t}function r(){x[0]=f,x[1]=h,b.point=n,y=null}function i(n,e){if(y){var r=n-g;m+=xo(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Na.point(n,e),t(n,e)}function u(){Na.lineStart()}function o(){i(v,d),Na.lineEnd(),xo(m)>Uo&&(f=-(h=180)),x[0]=f,x[1]=h,y=null}function a(n,t){return(t-=n)<0?t+360:t}function l(n,t){return n[0]-t[0]}function c(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var f,s,h,p,g,v,d,y,m,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=i,b.lineStart=u,b.lineEnd=o,m=0,Na.polygonStart()},polygonEnd:function(){Na.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>ka?(f=-(h=180),s=-(p=90)):m>Uo?p=90:-Uo>m&&(s=-90),x[0]=f,x[1]=h}};return function(n){p=h=-(f=s=1/0),M=[],ao.geo.stream(n,b);var t=M.length;if(t){M.sort(l);for(var e,r=1,i=M[0],u=[i];t>r;++r)e=M[r],c(e[0],i)||c(e[1],i)?(a(i[0],e[1])>a(i[0],i[1])&&(i[1]=e[1]),a(e[0],i[1])>a(i[0],i[1])&&(i[0]=e[0])):u.push(i=e);for(var o,e,g=-(1/0),t=u.length-1,r=0,i=u[t];t>=r;i=e,++r)e=u[r],(o=a(i[1],e[0]))>g&&(g=o,f=e[0],h=i[1])}return M=x=null,f===1/0||s===1/0?[[NaN,NaN],[NaN,NaN]]:[[f,s],[h,p]]}}(),ao.geo.centroid=function(n){Ea=Aa=Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,ja);var t=Da,e=Pa,r=Ua,i=t*t+e*e+r*r;return jo>i&&(t=qa,e=Ta,r=Ra,Uo>Aa&&(t=Ca,e=za,r=La),i=t*t+e*e+r*r,jo>i)?[NaN,NaN]:[Math.atan2(e,t)*Zo,tn(r/Math.sqrt(i))*Zo]};var Ea,Aa,Ca,za,La,qa,Ta,Ra,Da,Pa,Ua,ja={sphere:b,point:St,lineStart:Nt,lineEnd:Et,polygonStart:function(){ja.lineStart=At},polygonEnd:function(){ja.lineStart=Nt}},Fa=Rt(zt,jt,Ht,[-Fo,-Fo/2]),Ha=1e9;ao.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),i=u(n),i.valid=!0,i},extent:function(a){return arguments.length?(u=Zt(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ao.geo.conicEqualArea=function(){return Vt(Xt)}).raw=Xt,ao.geo.albers=function(){return ao.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ao.geo.albersUsa=function(){function n(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}var t,e,r,i,u=ao.geo.albers(),o=ao.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ao.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&.234>i&&r>=-.425&&-.214>r?o:i>=.166&&.234>i&&r>=-.214&&-.115>r?a:u).invert(n)},n.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(u.precision(t),o.precision(t),a.precision(t),n):u.precision()},n.scale=function(t){return arguments.length?(u.scale(t),o.scale(.35*t),a.scale(t),n.translate(u.translate())):u.scale()},n.translate=function(t){if(!arguments.length)return u.translate();var c=u.scale(),f=+t[0],s=+t[1];return e=u.translate(t).clipExtent([[f-.455*c,s-.238*c],[f+.455*c,s+.238*c]]).stream(l).point,r=o.translate([f-.307*c,s+.201*c]).clipExtent([[f-.425*c+Uo,s+.12*c+Uo],[f-.214*c-Uo,s+.234*c-Uo]]).stream(l).point,i=a.translate([f-.205*c,s+.212*c]).clipExtent([[f-.214*c+Uo,s+.166*c+Uo],[f-.115*c-Uo,s+.234*c-Uo]]).stream(l).point,n},n.scale(1070)};var Oa,Ia,Ya,Za,Va,Xa,$a={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Ia=0,$a.lineStart=$t},polygonEnd:function(){$a.lineStart=$a.lineEnd=$a.point=b,Oa+=xo(Ia/2)}},Ba={point:Bt,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Wa={point:Gt,lineStart:Kt,lineEnd:Qt,polygonStart:function(){Wa.lineStart=ne},polygonEnd:function(){Wa.point=Gt,Wa.lineStart=Kt,Wa.lineEnd=Qt}};ao.geo.path=function(){function n(n){return n&&("function"==typeof a&&u.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=i(u)),ao.geo.stream(n,o)),u.result()}function t(){return o=null,n}var e,r,i,u,o,a=4.5;return n.area=function(n){return Oa=0,ao.geo.stream(n,i($a)),Oa},n.centroid=function(n){return Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,i(Wa)),Ua?[Da/Ua,Pa/Ua]:Ra?[qa/Ra,Ta/Ra]:La?[Ca/La,za/La]:[NaN,NaN]},n.bounds=function(n){return Va=Xa=-(Ya=Za=1/0),ao.geo.stream(n,i(Ba)),[[Ya,Za],[Va,Xa]]},n.projection=function(n){return arguments.length?(i=(e=n)?n.stream||re(n):m,t()):e},n.context=function(n){return arguments.length?(u=null==(r=n)?new Wt:new te(n),"function"!=typeof a&&u.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(u.pointRadius(+t),+t),n):a},n.projection(ao.geo.albersUsa()).context(null)},ao.geo.transform=function(n){return{stream:function(t){var e=new ie(t);for(var r in n)e[r]=n[r];return e}}},ie.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ao.geo.projection=oe,ao.geo.projectionMutator=ae,(ao.geo.equirectangular=function(){return oe(ce)}).raw=ce.invert=ce,ao.geo.rotation=function(n){function t(t){return t=n(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t}return n=se(n[0]%360*Yo,n[1]*Yo,n.length>2?n[2]*Yo:0),t.invert=function(t){return t=n.invert(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t},t},fe.invert=ce,ao.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=se(-n[0]*Yo,-n[1]*Yo,0).invert,i=[];return e(null,null,1,{point:function(n,e){i.push(n=t(n,e)),n[0]*=Zo,n[1]*=Zo}}),{type:"Polygon",coordinates:[i]}}var t,e,r=[0,0],i=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ve((t=+r)*Yo,i*Yo),n):t},n.precision=function(r){return arguments.length?(e=ve(t*Yo,(i=+r)*Yo),n):i},n.angle(90)},ao.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Yo,i=n[1]*Yo,u=t[1]*Yo,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},ao.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ao.range(Math.ceil(u/d)*d,i,d).map(h).concat(ao.range(Math.ceil(c/y)*y,l,y).map(p)).concat(ao.range(Math.ceil(r/g)*g,e,g).filter(function(n){return xo(n%d)>Uo}).map(f)).concat(ao.range(Math.ceil(a/v)*v,o,v).filter(function(n){return xo(n%y)>Uo}).map(s))}var e,r,i,u,o,a,l,c,f,s,h,p,g=10,v=g,d=90,y=360,m=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(u).concat(p(l).slice(1),h(i).reverse().slice(1),p(c).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(u=+t[0][0],i=+t[1][0],c=+t[0][1],l=+t[1][1],u>i&&(t=u,u=i,i=t),c>l&&(t=c,c=l,l=t),n.precision(m)):[[u,c],[i,l]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(m)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],y=+t[1],n):[d,y]},n.minorStep=function(t){return arguments.length?(g=+t[0],v=+t[1],n):[g,v]},n.precision=function(t){return arguments.length?(m=+t,f=ye(a,o,90),s=me(r,e,m),h=ye(c,l,90),p=me(u,i,m),n):m},n.majorExtent([[-180,-90+Uo],[180,90-Uo]]).minorExtent([[-180,-80-Uo],[180,80+Uo]])},ao.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}var t,e,r=Me,i=xe;return n.distance=function(){return ao.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(i=t,e="function"==typeof t?null:t,n):i},n.precision=function(){return arguments.length?n:0},n},ao.geo.interpolate=function(n,t){return be(n[0]*Yo,n[1]*Yo,t[0]*Yo,t[1]*Yo)},ao.geo.length=function(n){return Ja=0,ao.geo.stream(n,Ga),Ja};var Ja,Ga={sphere:b,point:b,lineStart:_e,lineEnd:b,polygonStart:b,polygonEnd:b},Ka=we(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ao.geo.azimuthalEqualArea=function(){return oe(Ka)}).raw=Ka;var Qa=we(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},m);(ao.geo.azimuthalEquidistant=function(){return oe(Qa)}).raw=Qa,(ao.geo.conicConformal=function(){return Vt(Se)}).raw=Se,(ao.geo.conicEquidistant=function(){return Vt(ke)}).raw=ke;var nl=we(function(n){return 1/n},Math.atan);(ao.geo.gnomonic=function(){return oe(nl)}).raw=nl,Ne.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Io]},(ao.geo.mercator=function(){return Ee(Ne)}).raw=Ne;var tl=we(function(){return 1},Math.asin);(ao.geo.orthographic=function(){return oe(tl)}).raw=tl;var el=we(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ao.geo.stereographic=function(){return oe(el)}).raw=el,Ae.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Io]},(ao.geo.transverseMercator=function(){var n=Ee(Ae),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Ae,ao.geom={},ao.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,i=En(e),u=En(r),o=n.length,a=[],l=[];for(t=0;o>t;t++)a.push([+i.call(this,n[t],t),+u.call(this,n[t],t),t]);for(a.sort(qe),t=0;o>t;t++)l.push([a[t][0],-a[t][1]]);var c=Le(a),f=Le(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(t=c.length-1;t>=0;--t)p.push(n[a[c[t]][2]]);for(t=+s;t<f.length-h;++t)p.push(n[a[f[t]][2]]);return p}var e=Ce,r=ze;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ao.geom.polygon=function(n){return ko(n,rl),n};var rl=ao.geom.polygon.prototype=[];rl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},rl.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},rl.clip=function(n){for(var t,e,r,i,u,o,a=De(n),l=-1,c=this.length-De(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Te(o,f,i)?(Te(u,f,i)||n.push(Re(u,o,f,i)),n.push(o)):Te(u,f,i)&&n.push(Re(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var il,ul,ol,al,ll,cl=[],fl=[];Ye.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ve),t.length},tr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=or(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(ir(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ur(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(ur(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ir(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?or(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===i.L){if(t=i.R,t.C&&(t.C=!1,i.C=!0,ir(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ur(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,ir(this,i),n=this._;break}}else if(t=i.L,t.C&&(t.C=!1,i.C=!0,ur(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,ir(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,ur(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},ao.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],i=a[0][1],u=a[1][0],o=a[1][1];return ar(e(n),a).cells.forEach(function(e,a){var l=e.edges,c=e.site,f=t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=r&&c.x<=u&&c.y>=i&&c.y<=o?[[r,o],[u,o],[u,i],[r,i]]:[];f.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(u(n,t)/Uo)*Uo,y:Math.round(o(n,t)/Uo)*Uo,i:t}})}var r=Ce,i=ze,u=r,o=i,a=sl;return n?t(n):(t.links=function(n){return ar(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return ar(e(n)).cells.forEach(function(e,r){for(var i,u,o=e.site,a=e.edges.sort(Ve),l=-1,c=a.length,f=a[c-1].edge,s=f.l===o?f.r:f.l;++l<c;)i=f,u=s,f=a[l].edge,s=f.l===o?f.r:f.l,r<u.i&&r<s.i&&cr(o,u,s)<0&&t.push([n[r],n[u.i],n[s.i]])}),t},t.x=function(n){return arguments.length?(u=En(r=n),t):r},t.y=function(n){return arguments.length?(o=En(i=n),t):i},t.clipExtent=function(n){return arguments.length?(a=null==n?sl:n,t):a===sl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===sl?null:a&&a[1]},t)};var sl=[[-1e6,-1e6],[1e6,1e6]];ao.geom.delaunay=function(n){return ao.geom.voronoi().triangles(n)},ao.geom.quadtree=function(n,t,e,r,i){function u(n){function u(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,f=n.y;if(null!=l)if(xo(l-e)+xo(f-r)<.01)c(n,t,e,r,i,u,o,a);else{var s=n.point;n.x=n.y=n.point=null,c(n,s,l,f,i,u,o,a),c(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else c(n,t,e,r,i,u,o,a)}function c(n,t,e,r,i,o,a,l){var c=.5*(i+a),f=.5*(o+l),s=e>=c,h=r>=f,p=h<<1|s;n.leaf=!1,n=n.nodes[p]||(n.nodes[p]=hr()),s?i=c:a=c,h?o=f:l=f,u(n,t,e,r,i,o,a,l)}var f,s,h,p,g,v,d,y,m,M=En(a),x=En(l);if(null!=t)v=t,d=e,y=r,m=i;else if(y=m=-(v=d=1/0),s=[],h=[],g=n.length,o)for(p=0;g>p;++p)f=n[p],f.x<v&&(v=f.x),f.y<d&&(d=f.y),f.x>y&&(y=f.x),f.y>m&&(m=f.y),s.push(f.x),h.push(f.y);else for(p=0;g>p;++p){var b=+M(f=n[p],p),_=+x(f,p);v>b&&(v=b),d>_&&(d=_),b>y&&(y=b),_>m&&(m=_),s.push(b),h.push(_)}var w=y-v,S=m-d;w>S?m=d+w:y=v+S;var k=hr();if(k.add=function(n){u(k,n,+M(n,++p),+x(n,p),v,d,y,m)},k.visit=function(n){pr(n,k,v,d,y,m)},k.find=function(n){return gr(k,n[0],n[1],v,d,y,m)},p=-1,null==t){for(;++p<g;)u(k,n[p],s[p],h[p],v,d,y,m);--p}else n.forEach(k.add);return s=h=n=f=null,k}var o,a=Ce,l=ze;return(o=arguments.length)?(a=fr,l=sr,3===o&&(i=e,r=t,e=t=0),u(n)):(u.x=function(n){return arguments.length?(a=n,u):a},u.y=function(n){return arguments.length?(l=n,u):l},u.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),u):null==t?null:[[t,e],[r,i]]},u.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),u):null==t?null:[r-t,i-e]},u)},ao.interpolateRgb=vr,ao.interpolateObject=dr,ao.interpolateNumber=yr,ao.interpolateString=mr;var hl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,pl=new RegExp(hl.source,"g");ao.interpolate=Mr,ao.interpolators=[function(n,t){var e=typeof t;return("string"===e?ua.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?vr:mr:t instanceof an?vr:Array.isArray(t)?xr:"object"===e&&isNaN(t)?dr:yr)(n,t)}],ao.interpolateArray=xr;var gl=function(){return m},vl=ao.map({linear:gl,poly:Er,quad:function(){return Sr},cubic:function(){return kr},sin:function(){return Ar},exp:function(){return Cr},circle:function(){return zr},elastic:Lr,back:qr,bounce:function(){return Tr}}),dl=ao.map({"in":m,out:_r,"in-out":wr,"out-in":function(n){return wr(_r(n))}});ao.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=vl.get(e)||gl,r=dl.get(r)||m,br(r(e.apply(null,lo.call(arguments,1))))},ao.interpolateHcl=Rr,ao.interpolateHsl=Dr,ao.interpolateLab=Pr,ao.interpolateRound=Ur,ao.transform=function(n){var t=fo.createElementNS(ao.ns.prefix.svg,"g");return(ao.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new jr(e?e.matrix:yl)})(n)},jr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var yl={a:1,b:0,c:0,d:1,e:0,f:0};ao.interpolateTransform=$r,ao.layout={},ao.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Jr(n[e]));return t}},ao.layout.chord=function(){function n(){var n,c,s,h,p,g={},v=[],d=ao.range(u),y=[];for(e=[],r=[],n=0,h=-1;++h<u;){for(c=0,p=-1;++p<u;)c+=i[h][p];v.push(c),y.push(ao.range(u)),n+=c}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&y.forEach(function(n,t){n.sort(function(n,e){return a(i[t][n],i[t][e])})}),n=(Ho-f*u)/n,c=0,h=-1;++h<u;){for(s=c,p=-1;++p<u;){var m=d[h],M=y[m][p],x=i[m][M],b=c,_=c+=x*n;g[m+"-"+M]={index:m,subindex:M,startAngle:b,endAngle:_,value:x}}r[m]={index:m,startAngle:s,endAngle:c,value:v[m]},c+=f}for(h=-1;++h<u;)for(p=h-1;++p<u;){var w=g[h+"-"+p],S=g[p+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}l&&t()}function t(){e.sort(function(n,t){return l((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,i,u,o,a,l,c={},f=0;return c.matrix=function(n){return arguments.length?(u=(i=n)&&i.length,e=r=null,c):i},c.padding=function(n){return arguments.length?(f=n,e=r=null,c):f},c.sortGroups=function(n){return arguments.length?(o=n,e=r=null,c):o},c.sortSubgroups=function(n){return arguments.length?(a=n,e=null,c):a},c.sortChords=function(n){return arguments.length?(l=n,e&&t(),c):l},c.chords=function(){return e||n(),e},c.groups=function(){return r||n(),r},c},ao.layout.force=function(){function n(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(l>a*a/y){if(v>l){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&v>l){var c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function t(n){n.px=ao.event.x,n.py=ao.event.y,l.resume()}var e,r,i,u,o,a,l={},c=ao.dispatch("start","tick","end"),f=[1,1],s=.9,h=ml,p=Ml,g=-30,v=xl,d=.1,y=.64,M=[],x=[];return l.tick=function(){if((i*=.99)<.005)return e=null,c.end({type:"end",alpha:i=0}),!0;var t,r,l,h,p,v,y,m,b,_=M.length,w=x.length;for(r=0;w>r;++r)l=x[r],h=l.source,p=l.target,m=p.x-h.x,b=p.y-h.y,(v=m*m+b*b)&&(v=i*o[r]*((v=Math.sqrt(v))-u[r])/v,m*=v,b*=v,p.x-=m*(y=h.weight+p.weight?h.weight/(h.weight+p.weight):.5),p.y-=b*y,h.x+=m*(y=1-y),h.y+=b*y);if((y=i*d)&&(m=f[0]/2,b=f[1]/2,r=-1,y))for(;++r<_;)l=M[r],l.x+=(m-l.x)*y,l.y+=(b-l.y)*y;if(g)for(ri(t=ao.geom.quadtree(M),i,a),r=-1;++r<_;)(l=M[r]).fixed||t.visit(n(l));for(r=-1;++r<_;)l=M[r],l.fixed?(l.x=l.px,l.y=l.py):(l.x-=(l.px-(l.px=l.x))*s,l.y-=(l.py-(l.py=l.y))*s);c.tick({type:"tick",alpha:i})},l.nodes=function(n){return arguments.length?(M=n,l):M},l.links=function(n){return arguments.length?(x=n,l):x},l.size=function(n){return arguments.length?(f=n,l):f},l.linkDistance=function(n){return arguments.length?(h="function"==typeof n?n:+n,l):h},l.distance=l.linkDistance,l.linkStrength=function(n){return arguments.length?(p="function"==typeof n?n:+n,l):p},l.friction=function(n){return arguments.length?(s=+n,l):s},l.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,l):g},l.chargeDistance=function(n){return arguments.length?(v=n*n,l):Math.sqrt(v)},l.gravity=function(n){return arguments.length?(d=+n,l):d},l.theta=function(n){return arguments.length?(y=n*n,l):Math.sqrt(y)},l.alpha=function(n){return arguments.length?(n=+n,i?n>0?i=n:(e.c=null,e.t=NaN,e=null,c.end({type:"end",alpha:i=0})):n>0&&(c.start({type:"start",alpha:i=n}),e=qn(l.tick)),l):i},l.start=function(){function n(n,r){if(!e){for(e=new Array(i),l=0;i>l;++l)e[l]=[];for(l=0;c>l;++l){var u=x[l];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var o,a=e[t],l=-1,f=a.length;++l<f;)if(!isNaN(o=a[l][n]))return o;return Math.random()*r}var t,e,r,i=M.length,c=x.length,s=f[0],v=f[1];for(t=0;i>t;++t)(r=M[t]).index=t,r.weight=0;for(t=0;c>t;++t)r=x[t],"number"==typeof r.source&&(r.source=M[r.source]),"number"==typeof r.target&&(r.target=M[r.target]),++r.source.weight,++r.target.weight;for(t=0;i>t;++t)r=M[t],isNaN(r.x)&&(r.x=n("x",s)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof h)for(t=0;c>t;++t)u[t]=+h.call(this,x[t],t);else for(t=0;c>t;++t)u[t]=h;if(o=[],"function"==typeof p)for(t=0;c>t;++t)o[t]=+p.call(this,x[t],t);else for(t=0;c>t;++t)o[t]=p;if(a=[],"function"==typeof g)for(t=0;i>t;++t)a[t]=+g.call(this,M[t],t);else for(t=0;i>t;++t)a[t]=g;return l.resume()},l.resume=function(){return l.alpha(.1)},l.stop=function(){return l.alpha(0)},l.drag=function(){return r||(r=ao.behavior.drag().origin(m).on("dragstart.force",Qr).on("drag.force",t).on("dragend.force",ni)),arguments.length?void this.on("mouseover.force",ti).on("mouseout.force",ei).call(r):r},ao.rebind(l,c,"on")};var ml=20,Ml=1,xl=1/0;ao.layout.hierarchy=function(){function n(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=e.call(n,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;r&&(u.value=0),u.children=c}else r&&(u.value=+r.call(n,u,u.depth)||0),delete u.children;return oi(i,function(n){var e,i;t&&(e=n.children)&&e.sort(t),r&&(i=n.parent)&&(i.value+=n.value)}),a}var t=ci,e=ai,r=li;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(ui(t,function(n){n.children&&(n.value=0)}),oi(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ao.layout.partition=function(){function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}function t(n){var e=n.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,t(e[u]));return 1+r}function e(e,u){var o=r.call(this,e,u);return n(o[0],0,i[0],i[1]/t(o[0])),o}var r=ao.layout.hierarchy(),i=[1,1];return e.size=function(n){return arguments.length?(i=n,e):i},ii(e,r)},ao.layout.pie=function(){function n(o){var a,l=o.length,c=o.map(function(e,r){return+t.call(n,e,r)}),f=+("function"==typeof r?r.apply(this,arguments):r),s=("function"==typeof i?i.apply(this,arguments):i)-f,h=Math.min(Math.abs(s)/l,+("function"==typeof u?u.apply(this,arguments):u)),p=h*(0>s?-1:1),g=ao.sum(c),v=g?(s-l*p)/g:0,d=ao.range(l),y=[];return null!=e&&d.sort(e===bl?function(n,t){return c[t]-c[n]}:function(n,t){return e(o[n],o[t])}),d.forEach(function(n){y[n]={data:o[n],value:a=c[n],startAngle:f,endAngle:f+=a*v+p,padAngle:h}}),y}var t=Number,e=bl,r=0,i=Ho,u=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(i=t,n):i},n.padAngle=function(t){return arguments.length?(u=t,n):u},n};var bl={};ao.layout.stack=function(){function n(a,l){if(!(h=a.length))return a;var c=a.map(function(e,r){return t.call(n,e,r)}),f=c.map(function(t){return t.map(function(t,e){return[u.call(n,t,e),o.call(n,t,e)]})}),s=e.call(n,f,l);c=ao.permute(c,s),f=ao.permute(f,s);var h,p,g,v,d=r.call(n,f,l),y=c[0].length;for(g=0;y>g;++g)for(i.call(n,c[0][g],v=d[g],f[0][g][1]),p=1;h>p;++p)i.call(n,c[p][g],v+=f[p-1][g][1],f[p][g][1]);return a}var t=m,e=gi,r=vi,i=pi,u=si,o=hi;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:_l.get(t)||gi,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:wl.get(t)||vi,n):r},n.x=function(t){return arguments.length?(u=t,n):u},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(i=t,n):i},n};var _l=ao.map({"inside-out":function(n){var t,e,r=n.length,i=n.map(di),u=n.map(yi),o=ao.range(r).sort(function(n,t){return i[n]-i[t]}),a=0,l=0,c=[],f=[];for(t=0;r>t;++t)e=o[t],l>a?(a+=u[e],c.push(e)):(l+=u[e],f.push(e));return f.reverse().concat(c)},reverse:function(n){return ao.range(n.length).reverse()},"default":gi}),wl=ao.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;u>e;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;h>e;++e){for(t=0,i=0;f>t;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];f>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,c>l&&(c=l)}for(e=0;h>e;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];if(r)for(t=0;i>t;t++)n[t][e][1]/=r;else for(t=0;i>t;t++)n[t][e][1]=o}for(e=0;u>e;++e)a[e]=0;return a},zero:vi});ao.layout.histogram=function(){function n(n,u){for(var o,a,l=[],c=n.map(e,this),f=r.call(this,c,u),s=i.call(this,f,c,u),u=-1,h=c.length,p=s.length-1,g=t?1:1/h;++u<p;)o=l[u]=[],o.dx=s[u+1]-(o.x=s[u]),o.y=0;if(p>0)for(u=-1;++u<h;)a=c[u],a>=f[0]&&a<=f[1]&&(o=l[ao.bisect(s,a,1,p)-1],o.y+=g,o.push(n[u]));return l}var t=!0,e=Number,r=bi,i=Mi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=En(t),n):r},n.bins=function(t){return arguments.length?(i="number"==typeof t?function(n){return xi(n,t)}:En(t),n):i},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ao.layout.pack=function(){function n(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,oi(a,function(n){n.r=+f(n.value)}),oi(a,Ni),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;oi(a,function(n){n.r+=s}),oi(a,Ni),oi(a,function(n){n.r-=s})}return Ci(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}var t,e=ao.layout.hierarchy().sort(_i),r=0,i=[1,1];return n.size=function(t){return arguments.length?(i=t,n):i},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},ii(n,e)},ao.layout.tree=function(){function n(n,i){var f=o.call(this,n,i),s=f[0],h=t(s);if(oi(h,e),h.parent.m=-h.z,ui(h,r),c)ui(s,u);else{var p=s,g=s,v=s;ui(s,function(n){n.x<p.x&&(p=n),n.x>g.x&&(g=n),n.depth>v.depth&&(v=n)});var d=a(p,g)/2-p.x,y=l[0]/(g.x+a(g,p)/2+d),m=l[1]/(v.depth||1);ui(s,function(n){n.x=(n.x+d)*y,n.y=n.depth*m})}return f}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;a>o;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Di(n);var u=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-u):n.z=u}else r&&(n.z=r.z+a(n._,r._));n.parent.A=i(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function i(n,t,e){if(t){for(var r,i=n,u=n,o=t,l=i.parent.children[0],c=i.m,f=u.m,s=o.m,h=l.m;o=Ti(o),i=qi(i),o&&i;)l=qi(l),u=Ti(u),u.a=n,r=o.z+s-i.z-c+a(o._,i._),r>0&&(Ri(Pi(o,n,e),n,r),c+=r,f+=r),s+=o.m,c+=i.m,h+=l.m,f+=u.m;o&&!Ti(u)&&(u.t=o,u.m+=s-f),i&&!qi(l)&&(l.t=i,l.m+=c-h,e=n)}return e}function u(n){n.x*=l[0],n.y=n.depth*l[1]}var o=ao.layout.hierarchy().sort(null).value(null),a=Li,l=[1,1],c=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(c=null==(l=t)?u:null,n):c?null:l},n.nodeSize=function(t){return arguments.length?(c=null==(l=t)?null:u,n):c?l:null},ii(n,o)},ao.layout.cluster=function(){function n(n,u){var o,a=t.call(this,n,u),l=a[0],c=0;oi(l,function(n){var t=n.children;t&&t.length?(n.x=ji(t),n.y=Ui(t)):(n.x=o?c+=e(n,o):0,n.y=0,o=n)});var f=Fi(l),s=Hi(l),h=f.x-e(f,s)/2,p=s.x+e(s,f)/2;return oi(l,i?function(n){n.x=(n.x-l.x)*r[0],n.y=(l.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(p-h)*r[0],n.y=(1-(l.y?n.y/l.y:1))*r[1]}),a}var t=ao.layout.hierarchy().sort(null).value(null),e=Li,r=[1,1],i=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(i=null==(r=t),n):i?null:r},n.nodeSize=function(t){return arguments.length?(i=null!=(r=t),n):i?r:null},ii(n,t)},ao.layout.treemap=function(){function n(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var u=e.children;if(u&&u.length){var o,a,l,c=s(e),f=[],h=u.slice(),g=1/0,v="slice"===p?c.dx:"dice"===p?c.dy:"slice-dice"===p?1&e.depth?c.dy:c.dx:Math.min(c.dx,c.dy);for(n(h,c.dx*c.dy/e.value),f.area=0;(l=h.length)>0;)f.push(o=h[l-1]),f.area+=o.area,"squarify"!==p||(a=r(f,v))<=g?(h.pop(),g=a):(f.area-=f.pop().area,i(f,v,c,!1),v=Math.min(c.dx,c.dy),f.length=f.area=0,g=1/0);f.length&&(i(f,v,c,!0),f.length=f.area=0),u.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var u,o=s(t),a=r.slice(),l=[];for(n(a,o.dx*o.dy/t.value),l.area=0;u=a.pop();)l.push(u),l.area+=u.area,null!=u.z&&(i(l,u.z?o.dx:o.dy,o,!a.length),l.length=l.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(u>e&&(u=e),e>i&&(i=e));return r*=r,t*=t,r?Math.max(t*i*g/r,r/(t*u*g)):1/0}function i(n,t,e,r){var i,u=-1,o=n.length,a=e.x,c=e.y,f=t?l(n.area/t):0;
  if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++u<o;)i=n[u],i.x=a,i.y=c,i.dy=f,a+=i.dx=Math.min(e.x+e.dx-a,f?l(i.area/f):0);i.z=!0,i.dx+=e.x+e.dx-a,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++u<o;)i=n[u],i.x=a,i.y=c,i.dx=f,c+=i.dy=Math.min(e.y+e.dy-c,f?l(i.area/f):0);i.z=!1,i.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function u(r){var i=o||a(r),u=i[0];return u.x=u.y=0,u.value?(u.dx=c[0],u.dy=c[1]):u.dx=u.dy=0,o&&a.revalue(u),n([u],u.dx*u.dy/u.value),(o?e:t)(u),h&&(o=i),i}var o,a=ao.layout.hierarchy(),l=Math.round,c=[1,1],f=null,s=Oi,h=!1,p="squarify",g=.5*(1+Math.sqrt(5));return u.size=function(n){return arguments.length?(c=n,u):c},u.padding=function(n){function t(t){var e=n.call(u,t,t.depth);return null==e?Oi(t):Ii(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Ii(t,n)}if(!arguments.length)return f;var r;return s=null==(f=n)?Oi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,u},u.round=function(n){return arguments.length?(l=n?Math.round:Number,u):l!=Number},u.sticky=function(n){return arguments.length?(h=n,o=null,u):h},u.ratio=function(n){return arguments.length?(g=n,u):g},u.mode=function(n){return arguments.length?(p=n+"",u):p},ii(u,a)},ao.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,i;do e=2*Math.random()-1,r=2*Math.random()-1,i=e*e+r*r;while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var n=ao.random.normal.apply(ao,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ao.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ao.scale={};var Sl={floor:m,ceil:m};ao.scale.linear=function(){return Wi([0,1],[0,1],Mr,!1)};var kl={s:1,g:1,p:1,r:1,e:1};ao.scale.log=function(){return ru(ao.scale.linear().domain([0,1]),10,!0,[1,10])};var Nl=ao.format(".0e"),El={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ao.scale.pow=function(){return iu(ao.scale.linear(),1,[0,1])},ao.scale.sqrt=function(){return ao.scale.pow().exponent(.5)},ao.scale.ordinal=function(){return ou([],{t:"range",a:[[]]})},ao.scale.category10=function(){return ao.scale.ordinal().range(Al)},ao.scale.category20=function(){return ao.scale.ordinal().range(Cl)},ao.scale.category20b=function(){return ao.scale.ordinal().range(zl)},ao.scale.category20c=function(){return ao.scale.ordinal().range(Ll)};var Al=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(xn),Cl=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(xn),zl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(xn),Ll=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(xn);ao.scale.quantile=function(){return au([],[])},ao.scale.quantize=function(){return lu(0,1,[0,1])},ao.scale.threshold=function(){return cu([.5],[0,1])},ao.scale.identity=function(){return fu([0,1])},ao.svg={},ao.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),c=Math.max(0,+r.apply(this,arguments)),f=o.apply(this,arguments)-Io,s=a.apply(this,arguments)-Io,h=Math.abs(s-f),p=f>s?0:1;if(n>c&&(g=c,c=n,n=g),h>=Oo)return t(c,p)+(n?t(n,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+l.apply(this,arguments)||0)/2)&&(d=u===ql?Math.sqrt(n*n+c*c):+u.apply(this,arguments),p||(E*=-1),c&&(E=tn(d/c*Math.sin(y))),n&&(N=tn(d/n*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=Fo?0:1;if(E&&yu(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(n){_=n*Math.cos(s-N),w=n*Math.sin(s-N),S=n*Math.cos(f+N),k=n*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=Fo?0:1;if(N&&yu(_,w,S,k)===1-p^L){var q=(f+s)/2;_=n*Math.cos(q),w=n*Math.sin(q),S=k=null}}else _=w=0;if(h>Uo&&(g=Math.min(Math.abs(c-n)/2,+i.apply(this,arguments)))>.001){v=c>n^p?0:1;var T=g,R=g;if(Fo>h){var D=null==S?[_,w]:null==x?[m,M]:Re([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(n-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=mu(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=mu([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^yu(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=mu([m,M],[S,k],n,-R,p),V=mu([_,w],null==x?[m,M]:[x,b],n,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",n,",",n," 0 ",p^yu(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",n,",",n," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=hu,r=pu,i=su,u=ql,o=gu,a=vu,l=du;return n.innerRadius=function(t){return arguments.length?(e=En(t),n):e},n.outerRadius=function(t){return arguments.length?(r=En(t),n):r},n.cornerRadius=function(t){return arguments.length?(i=En(t),n):i},n.padRadius=function(t){return arguments.length?(u=t==ql?ql:En(t),n):u},n.startAngle=function(t){return arguments.length?(o=En(t),n):o},n.endAngle=function(t){return arguments.length?(a=En(t),n):a},n.padAngle=function(t){return arguments.length?(l=En(t),n):l},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Io;return[Math.cos(t)*n,Math.sin(t)*n]},n};var ql="auto";ao.svg.line=function(){return Mu(m)};var Tl=ao.map({linear:xu,"linear-closed":bu,step:_u,"step-before":wu,"step-after":Su,basis:zu,"basis-open":Lu,"basis-closed":qu,bundle:Tu,cardinal:Eu,"cardinal-open":ku,"cardinal-closed":Nu,monotone:Fu});Tl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Rl=[0,2/3,1/3,0],Dl=[0,1/3,2/3,0],Pl=[0,1/6,2/3,1/6];ao.svg.line.radial=function(){var n=Mu(Hu);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},wu.reverse=Su,Su.reverse=wu,ao.svg.area=function(){return Ou(m)},ao.svg.area.radial=function(){var n=Ou(Hu);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ao.svg.chord=function(){function n(n,a){var l=t(this,u,n,a),c=t(this,o,n,a);return"M"+l.p0+r(l.r,l.p1,l.a1-l.a0)+(e(l,c)?i(l.r,l.p1,l.r,l.p0):i(l.r,l.p1,c.r,c.p0)+r(c.r,c.p1,c.a1-c.a0)+i(c.r,c.p1,l.r,l.p0))+"Z"}function t(n,t,e,r){var i=t.call(n,e,r),u=a.call(n,i,r),o=l.call(n,i,r)-Io,f=c.call(n,i,r)-Io;return{r:u,a0:o,a1:f,p0:[u*Math.cos(o),u*Math.sin(o)],p1:[u*Math.cos(f),u*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Fo)+",1 "+t}function i(n,t,e,r){return"Q 0,0 "+r}var u=Me,o=xe,a=Iu,l=gu,c=vu;return n.radius=function(t){return arguments.length?(a=En(t),n):a},n.source=function(t){return arguments.length?(u=En(t),n):u},n.target=function(t){return arguments.length?(o=En(t),n):o},n.startAngle=function(t){return arguments.length?(l=En(t),n):l},n.endAngle=function(t){return arguments.length?(c=En(t),n):c},n},ao.svg.diagonal=function(){function n(n,i){var u=t.call(this,n,i),o=e.call(this,n,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return l=l.map(r),"M"+l[0]+"C"+l[1]+" "+l[2]+" "+l[3]}var t=Me,e=xe,r=Yu;return n.source=function(e){return arguments.length?(t=En(e),n):t},n.target=function(t){return arguments.length?(e=En(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ao.svg.diagonal.radial=function(){var n=ao.svg.diagonal(),t=Yu,e=n.projection;return n.projection=function(n){return arguments.length?e(Zu(t=n)):t},n},ao.svg.symbol=function(){function n(n,r){return(Ul.get(t.call(this,n,r))||$u)(e.call(this,n,r))}var t=Xu,e=Vu;return n.type=function(e){return arguments.length?(t=En(e),n):t},n.size=function(t){return arguments.length?(e=En(t),n):e},n};var Ul=ao.map({circle:$u,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Fl)),e=t*Fl;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ao.svg.symbolTypes=Ul.keys();var jl=Math.sqrt(3),Fl=Math.tan(30*Yo);Co.transition=function(n){for(var t,e,r=Hl||++Zl,i=Ku(n),u=[],o=Ol||{time:Date.now(),ease:Nr,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&Qu(e,f,i,r,o),t.push(e)}return Wu(u,i,r)},Co.interrupt=function(n){return this.each(null==n?Il:Bu(Ku(n)))};var Hl,Ol,Il=Bu(Ku()),Yl=[],Zl=0;Yl.call=Co.call,Yl.empty=Co.empty,Yl.node=Co.node,Yl.size=Co.size,ao.transition=function(n,t){return n&&n.transition?Hl?n.transition(t):n:ao.selection().transition(n)},ao.transition.prototype=Yl,Yl.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=A(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),Qu(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return Wu(o,u,i)},Yl.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=C(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&Qu(i,g,a,o,u),t.push(i)}return Wu(l,a,o)},Yl.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]);for(var e=this[u],a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return Wu(i,this.namespace,this.id)},Yl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},Yl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function i(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function u(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?$r:Mr,a=ao.ns.qualify(n);return Ju(this,"attr."+n,t,a.local?u:i)},Yl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(i));return r&&function(n){this.setAttribute(i,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(i.space,i.local));return r&&function(n){this.setAttributeNS(i.space,i.local,r(n))}}var i=ao.ns.qualify(n);return this.tween("attr."+n,i.local?r:e)},Yl.style=function(n,e,r){function i(){this.style.removeProperty(n)}function u(e){return null==e?i:(e+="",function(){var i,u=t(this).getComputedStyle(this,null).getPropertyValue(n);return u!==e&&(i=Mr(u,e),function(t){this.style.setProperty(n,i(t),r)})})}var o=arguments.length;if(3>o){if("string"!=typeof n){2>o&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Ju(this,"style."+n,e,u)},Yl.styleTween=function(n,e,r){function i(i,u){var o=e.call(this,i,u,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,i)},Yl.text=function(n){return Ju(this,"text",n,Gu)},Yl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Yl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ao.ease.apply(ao,arguments)),Y(this,function(r){r[e][t].ease=n}))},Yl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},Yl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Yl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var i=Ol,u=Hl;try{Hl=e,Y(this,function(t,i,u){Ol=t[r][e],n.call(t,t.__data__,i,u)})}finally{Ol=i,Hl=u}}else Y(this,function(i){var u=i[r][e];(u.event||(u.event=ao.dispatch("start","end","interrupt"))).on(n,t)});return this},Yl.transition=function(){for(var n,t,e,r,i=this.id,u=++Zl,o=this.namespace,a=[],l=0,c=this.length;c>l;l++){a.push(n=[]);for(var t=this[l],f=0,s=t.length;s>f;f++)(e=t[f])&&(r=e[o][i],Qu(e,f,o,u,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Wu(a,o,u)},ao.svg.axis=function(){function n(n){n.each(function(){var n,c=ao.select(this),f=this.__chart__||e,s=this.__chart__=e.copy(),h=null==l?s.ticks?s.ticks.apply(s,a):s.domain():l,p=null==t?s.tickFormat?s.tickFormat.apply(s,a):m:t,g=c.selectAll(".tick").data(h,s),v=g.enter().insert("g",".domain").attr("class","tick").style("opacity",Uo),d=ao.transition(g.exit()).style("opacity",Uo).remove(),y=ao.transition(g.order()).style("opacity",1),M=Math.max(i,0)+o,x=Zi(s),b=c.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ao.transition(b));v.append("line"),v.append("text");var w,S,k,N,E=v.select("line"),A=y.select("line"),C=g.select("text").text(p),z=v.select("text"),L=y.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=no,w="x",k="y",S="x2",N="y2",C.attr("dy",0>q?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+q*u+"V0H"+x[1]+"V"+q*u)):(n=to,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",0>q?"end":"start"),_.attr("d","M"+q*u+","+x[0]+"H0V"+x[1]+"H"+q*u)),E.attr(N,q*i),z.attr(k,q*M),A.attr(S,0).attr(N,q*i),L.attr(w,0).attr(k,q*M),s.rangeBand){var T=s,R=T.rangeBand()/2;f=s=function(n){return T(n)+R}}else f.rangeBand?f=s:d.call(n,s,f);v.call(n,f,s),y.call(n,s,s)})}var t,e=ao.scale.linear(),r=Vl,i=6,u=6,o=3,a=[10],l=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Xl?t+"":Vl,n):r},n.ticks=function(){return arguments.length?(a=co(arguments),n):a},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(i=+t,u=+arguments[e-1],n):i},n.innerTickSize=function(t){return arguments.length?(i=+t,n):i},n.outerTickSize=function(t){return arguments.length?(u=+t,n):u},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Vl="bottom",Xl={top:1,right:1,bottom:1,left:1};ao.svg.brush=function(){function n(t){t.each(function(){var t=ao.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,m);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return $l[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,s=ao.transition(t),h=ao.transition(o);c&&(l=Zi(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),r(s)),f&&(l=Zi(f),h.attr("y",l[0]).attr("height",l[1]-l[0]),i(s)),e(s)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function i(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function u(){function u(){32==ao.event.keyCode&&(C||(M=null,L[0]-=s[1],L[1]-=h[1],C=2),S())}function v(){32==ao.event.keyCode&&2==C&&(L[0]+=s[1],L[1]+=h[1],C=0,S())}function d(){var n=ao.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ao.event.altKey?(M||(M=[(s[0]+s[1])/2,(h[0]+h[1])/2]),L[0]=s[+(n[0]<M[0])],L[1]=h[+(n[1]<M[1])]):M=null),E&&y(n,c,0)&&(r(k),t=!0),A&&y(n,f,1)&&(i(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function y(n,t,e){var r,i,u=Zi(t),l=u[0],c=u[1],f=L[e],v=e?h:s,d=v[1]-v[0];return C&&(l-=f,c-=d+f),r=(e?g:p)?Math.max(l,Math.min(c,n[e])):n[e],C?i=(r+=f)+d:(M&&(f=Math.max(l,Math.min(c,2*M[e]-r))),r>f?(i=r,r=f):i=f),v[0]!=r||v[1]!=i?(e?a=null:o=null,v[0]=r,v[1]=i,!0):void 0}function m(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ao.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ao.select(ao.event.target),w=l.of(b,arguments),k=ao.select(b),N=_.datum(),E=!/^(n|s)$/.test(N)&&c,A=!/^(e|w)$/.test(N)&&f,C=_.classed("extent"),z=W(b),L=ao.mouse(b),q=ao.select(t(b)).on("keydown.brush",u).on("keyup.brush",v);if(ao.event.changedTouches?q.on("touchmove.brush",d).on("touchend.brush",m):q.on("mousemove.brush",d).on("mouseup.brush",m),k.interrupt().selectAll("*").interrupt(),C)L[0]=s[0]-L[0],L[1]=h[0]-L[1];else if(N){var T=+/w$/.test(N),R=+/^n/.test(N);x=[s[1-T]-L[0],h[1-R]-L[1]],L[0]=s[T],L[1]=h[R]}else ao.event.altKey&&(M=L.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ao.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,l=N(n,"brushstart","brush","brushend"),c=null,f=null,s=[0,0],h=[0,0],p=!0,g=!0,v=Bl[0];return n.event=function(n){n.each(function(){var n=l.of(this,arguments),t={x:s,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Hl?ao.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,s=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=xr(s,t.x),r=xr(h,t.y);return o=a=null,function(i){s=t.x=e(i),h=t.y=r(i),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,v=Bl[!c<<1|!f],n):c},n.y=function(t){return arguments.length?(f=t,v=Bl[!c<<1|!f],n):f},n.clamp=function(t){return arguments.length?(c&&f?(p=!!t[0],g=!!t[1]):c?p=!!t:f&&(g=!!t),n):c&&f?[p,g]:c?p:f?g:null},n.extent=function(t){var e,r,i,u,l;return arguments.length?(c&&(e=t[0],r=t[1],f&&(e=e[0],r=r[0]),o=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(l=e,e=r,r=l),e==s[0]&&r==s[1]||(s=[e,r])),f&&(i=t[0],u=t[1],c&&(i=i[1],u=u[1]),a=[i,u],f.invert&&(i=f(i),u=f(u)),i>u&&(l=i,i=u,u=l),i==h[0]&&u==h[1]||(h=[i,u])),n):(c&&(o?(e=o[0],r=o[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(l=e,e=r,r=l))),f&&(a?(i=a[0],u=a[1]):(i=h[0],u=h[1],f.invert&&(i=f.invert(i),u=f.invert(u)),i>u&&(l=i,i=u,u=l))),c&&f?[[e,i],[r,u]]:c?[e,r]:f&&[i,u])},n.clear=function(){return n.empty()||(s=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!f&&h[0]==h[1]},ao.rebind(n,l,"on")};var $l={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Bl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Wl=ga.format=xa.timeFormat,Jl=Wl.utc,Gl=Jl("%Y-%m-%dT%H:%M:%S.%LZ");Wl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?eo:Gl,eo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},eo.toString=Gl.toString,ga.second=On(function(n){return new va(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ga.seconds=ga.second.range,ga.seconds.utc=ga.second.utc.range,ga.minute=On(function(n){return new va(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ga.minutes=ga.minute.range,ga.minutes.utc=ga.minute.utc.range,ga.hour=On(function(n){var t=n.getTimezoneOffset()/60;return new va(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ga.hours=ga.hour.range,ga.hours.utc=ga.hour.utc.range,ga.month=On(function(n){return n=ga.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ga.months=ga.month.range,ga.months.utc=ga.month.utc.range;var Kl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Ql=[[ga.second,1],[ga.second,5],[ga.second,15],[ga.second,30],[ga.minute,1],[ga.minute,5],[ga.minute,15],[ga.minute,30],[ga.hour,1],[ga.hour,3],[ga.hour,6],[ga.hour,12],[ga.day,1],[ga.day,2],[ga.week,1],[ga.month,1],[ga.month,3],[ga.year,1]],nc=Wl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",zt]]),tc={range:function(n,t,e){return ao.range(Math.ceil(n/e)*e,+t,e).map(io)},floor:m,ceil:m};Ql.year=ga.year,ga.scale=function(){return ro(ao.scale.linear(),Ql,nc)};var ec=Ql.map(function(n){return[n[0].utc,n[1]]}),rc=Jl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",zt]]);ec.year=ga.year.utc,ga.scale.utc=function(){return ro(ao.scale.linear(),ec,rc)},ao.text=An(function(n){return n.responseText}),ao.json=function(n,t){return Cn(n,"application/json",uo,t)},ao.html=function(n,t){return Cn(n,"text/html",oo,t)},ao.xml=An(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=ao,define(ao)):"object"==typeof module&&module.exports?module.exports=ao:this.d3=ao}();
},{}],6:[function(require,module,exports){
// https://d3js.org Version 4.4.0. Copyright 2016 Mike Bostock.
(function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.d3=t.d3||{})})(this,function(t){function n(t){return function(n,e){return Ms(t(n),e)}}function e(t,n,e){var r=Math.abs(n-t)/Math.max(0,e),i=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),o=r/i;return o>=Fs?i*=10:o>=Is?i*=5:o>=Ys&&(i*=2),n<t?-i:i}function r(t){return t.length}function i(){}function o(t,n){var e=new i;if(t instanceof i)t.each(function(t,n){e.set(n,t)});else if(Array.isArray(t)){var r,o=-1,u=t.length;if(null==n)for(;++o<u;)e.set(o,t[o]);else for(;++o<u;)e.set(n(r=t[o],o,t),r)}else if(t)for(var a in t)e.set(a,t[a]);return e}function u(){return{}}function a(t,n,e){t[n]=e}function c(){return o()}function s(t,n,e){t.set(n,e)}function f(){}function l(t,n){var e=new f;if(t instanceof f)t.each(function(t){e.add(t)});else if(t){var r=-1,i=t.length;if(null==n)for(;++r<i;)e.add(t[r]);else for(;++r<i;)e.add(n(t[r],r,t))}return e}function h(t){return+t}function p(t){return t*t}function d(t){return t*(2-t)}function v(t){return((t*=2)<=1?t*t:--t*(2-t)+1)/2}function _(t){return t*t*t}function y(t){return--t*t*t+1}function g(t){return((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2}function m(t){return 1-Math.cos(t*Tf)}function x(t){return Math.sin(t*Tf)}function b(t){return(1-Math.cos(Mf*t))/2}function w(t){return Math.pow(2,10*t-10)}function M(t){return 1-Math.pow(2,-10*t)}function T(t){return((t*=2)<=1?Math.pow(2,10*t-10):2-Math.pow(2,10-10*t))/2}function N(t){return 1-Math.sqrt(1-t*t)}function k(t){return Math.sqrt(1- --t*t)}function S(t){return((t*=2)<=1?1-Math.sqrt(1-t*t):Math.sqrt(1-(t-=2)*t)+1)/2}function E(t){return 1-A(1-t)}function A(t){return(t=+t)<Nf?qf*t*t:t<Sf?qf*(t-=kf)*t+Ef:t<Cf?qf*(t-=Af)*t+zf:qf*(t-=Pf)*t+Rf}function C(t){return((t*=2)<=1?1-A(1-t):A(t-1)+1)/2}function z(t,n){return t[0]-n[0]||t[1]-n[1]}function P(t){for(var n=t.length,e=[0,1],r=2,i=2;i<n;++i){for(;r>1&&Wf(t[e[r-2]],t[e[r-1]],t[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function R(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function q(){return new R}function L(t,n,e,r){if(isNaN(n)||isNaN(e))return t;var i,o,u,a,c,s,f,l,h,p=t._root,d={data:r},v=t._x0,_=t._y0,y=t._x1,g=t._y1;if(!p)return t._root=d,t;for(;p.length;)if((s=n>=(o=(v+y)/2))?v=o:y=o,(f=e>=(u=(_+g)/2))?_=u:g=u,i=p,!(p=p[l=f<<1|s]))return i[l]=d,t;if(a=+t._x.call(null,p.data),c=+t._y.call(null,p.data),n===a&&e===c)return d.next=p,i?i[l]=d:t._root=d,t;do i=i?i[l]=new Array(4):t._root=new Array(4),(s=n>=(o=(v+y)/2))?v=o:y=o,(f=e>=(u=(_+g)/2))?_=u:g=u;while((l=f<<1|s)===(h=(c>=u)<<1|a>=o));return i[h]=p,i[l]=d,t}function U(t){var n,e,r,i,o=t.length,u=new Array(o),a=new Array(o),c=1/0,s=1/0,f=-(1/0),l=-(1/0);for(e=0;e<o;++e)isNaN(r=+this._x.call(null,n=t[e]))||isNaN(i=+this._y.call(null,n))||(u[e]=r,a[e]=i,r<c&&(c=r),r>f&&(f=r),i<s&&(s=i),i>l&&(l=i));for(f<c&&(c=this._x0,f=this._x1),l<s&&(s=this._y0,l=this._y1),this.cover(c,s).cover(f,l),e=0;e<o;++e)L(this,u[e],a[e],t[e]);return this}function D(t){for(var n=0,e=t.length;n<e;++n)this.remove(t[n]);return this}function O(t){return t[0]}function F(t){return t[1]}function I(t,n,e){var r=new Y(null==n?O:n,null==e?F:e,NaN,NaN,NaN,NaN);return null==t?r:r.addAll(t)}function Y(t,n,e,r,i,o){this._x=t,this._y=n,this._x0=e,this._y0=r,this._x1=i,this._y1=o,this._root=void 0}function B(t){for(var n={data:t.data},e=n;t=t.next;)e=e.next={data:t.data};return n}function j(t){if(!(t>=1))throw new Error;this._size=t,this._call=this._error=null,this._tasks=[],this._data=[],this._waiting=this._active=this._ended=this._start=0}function H(t){if(!t._start)try{X(t)}catch(n){if(t._tasks[t._ended+t._active-1])W(t,n);else if(!t._data)throw n}}function X(t){for(;t._start=t._waiting&&t._active<t._size;){var n=t._ended+t._active,e=t._tasks[n],r=e.length-1,i=e[r];e[r]=V(t,n),--t._waiting,++t._active,e=i.apply(null,e),t._tasks[n]&&(t._tasks[n]=e||_l)}}function V(t,n){return function(e,r){t._tasks[n]&&(--t._active,++t._ended,t._tasks[n]=null,null==t._error&&(null!=e?W(t,e):(t._data[n]=r,t._waiting?H(t):$(t))))}}function W(t,n){var e,r=t._tasks.length;for(t._error=n,t._data=void 0,t._waiting=NaN;--r>=0;)if((e=t._tasks[r])&&(t._tasks[r]=null,e.abort))try{e.abort()}catch(t){}t._active=NaN,$(t)}function $(t){if(!t._active&&t._call){var n=t._data;t._data=void 0,t._call(t._error,n)}}function Z(t){return new j(arguments.length?+t:1/0)}function G(t){return t.innerRadius}function J(t){return t.outerRadius}function Q(t){return t.startAngle}function K(t){return t.endAngle}function tt(t){return t&&t.padAngle}function nt(t){return t>=1?xl:t<=-1?-xl:Math.asin(t)}function et(t,n,e,r,i,o,u,a){var c=e-t,s=r-n,f=u-i,l=a-o,h=(f*(n-o)-l*(t-i))/(l*c-f*s);return[t+h*c,n+h*s]}function rt(t,n,e,r,i,o,u){var a=t-e,c=n-r,s=(u?o:-o)/Math.sqrt(a*a+c*c),f=s*c,l=-s*a,h=t+f,p=n+l,d=e+f,v=r+l,_=(h+d)/2,y=(p+v)/2,g=d-h,m=v-p,x=g*g+m*m,b=i-o,w=h*v-d*p,M=(m<0?-1:1)*Math.sqrt(Math.max(0,b*b*x-w*w)),T=(w*m-g*M)/x,N=(-w*g-m*M)/x,k=(w*m+g*M)/x,S=(-w*g+m*M)/x,E=T-_,A=N-y,C=k-_,z=S-y;return E*E+A*A>C*C+z*z&&(T=k,N=S),{cx:T,cy:N,x01:-f,y01:-l,x11:T*(i/b-1),y11:N*(i/b-1)}}function it(t){this._context=t}function ot(t){return t[0]}function ut(t){return t[1]}function at(t){this._curve=t}function ct(t){function n(n){return new at(t(n))}return n._curve=t,n}function st(t){var n=t.curve;return t.angle=t.x,delete t.x,t.radius=t.y,delete t.y,t.curve=function(t){return arguments.length?n(ct(t)):n()._curve},t}function ft(t,n,e){t._context.bezierCurveTo((2*t._x0+t._x1)/3,(2*t._y0+t._y1)/3,(t._x0+2*t._x1)/3,(t._y0+2*t._y1)/3,(t._x0+4*t._x1+n)/6,(t._y0+4*t._y1+e)/6)}function lt(t){this._context=t}function ht(t){this._context=t}function pt(t){this._context=t}function dt(t,n){this._basis=new lt(t),this._beta=n}function vt(t,n,e){t._context.bezierCurveTo(t._x1+t._k*(t._x2-t._x0),t._y1+t._k*(t._y2-t._y0),t._x2+t._k*(t._x1-n),t._y2+t._k*(t._y1-e),t._x2,t._y2)}function _t(t,n){this._context=t,this._k=(1-n)/6}function yt(t,n){this._context=t,this._k=(1-n)/6}function gt(t,n){this._context=t,this._k=(1-n)/6}function mt(t,n,e){var r=t._x1,i=t._y1,o=t._x2,u=t._y2;if(t._l01_a>gl){var a=2*t._l01_2a+3*t._l01_a*t._l12_a+t._l12_2a,c=3*t._l01_a*(t._l01_a+t._l12_a);r=(r*a-t._x0*t._l12_2a+t._x2*t._l01_2a)/c,i=(i*a-t._y0*t._l12_2a+t._y2*t._l01_2a)/c}if(t._l23_a>gl){var s=2*t._l23_2a+3*t._l23_a*t._l12_a+t._l12_2a,f=3*t._l23_a*(t._l23_a+t._l12_a);o=(o*s+t._x1*t._l23_2a-n*t._l12_2a)/f,u=(u*s+t._y1*t._l23_2a-e*t._l12_2a)/f}t._context.bezierCurveTo(r,i,o,u,t._x2,t._y2)}function xt(t,n){this._context=t,this._alpha=n}function bt(t,n){this._context=t,this._alpha=n}function wt(t,n){this._context=t,this._alpha=n}function Mt(t){this._context=t}function Tt(t){return t<0?-1:1}function Nt(t,n,e){var r=t._x1-t._x0,i=n-t._x1,o=(t._y1-t._y0)/(r||i<0&&-0),u=(e-t._y1)/(i||r<0&&-0),a=(o*i+u*r)/(r+i);return(Tt(o)+Tt(u))*Math.min(Math.abs(o),Math.abs(u),.5*Math.abs(a))||0}function kt(t,n){var e=t._x1-t._x0;return e?(3*(t._y1-t._y0)/e-n)/2:n}function St(t,n,e){var r=t._x0,i=t._y0,o=t._x1,u=t._y1,a=(o-r)/3;t._context.bezierCurveTo(r+a,i+a*n,o-a,u-a*e,o,u)}function Et(t){this._context=t}function At(t){this._context=new Ct(t)}function Ct(t){this._context=t}function zt(t){return new Et(t)}function Pt(t){return new At(t)}function Rt(t){this._context=t}function qt(t){var n,e,r=t.length-1,i=new Array(r),o=new Array(r),u=new Array(r);for(i[0]=0,o[0]=2,u[0]=t[0]+2*t[1],n=1;n<r-1;++n)i[n]=1,o[n]=4,u[n]=4*t[n]+2*t[n+1];for(i[r-1]=2,o[r-1]=7,u[r-1]=8*t[r-1]+t[r],n=1;n<r;++n)e=i[n]/o[n-1],o[n]-=e,u[n]-=e*u[n-1];for(i[r-1]=u[r-1]/o[r-1],n=r-2;n>=0;--n)i[n]=(u[n]-i[n+1])/o[n];for(o[r-1]=(t[r]+i[r-1])/2,n=0;n<r-1;++n)o[n]=2*t[n+1]-i[n+1];return[i,o]}function Lt(t,n){this._context=t,this._t=n}function Ut(t){return new Lt(t,0)}function Dt(t){return new Lt(t,1)}function Ot(t,n){return t[n]}function Ft(t){for(var n,e=0,r=-1,i=t.length;++r<i;)(n=+t[r][1])&&(e+=n);return e}function It(t,n){var e=Object.create(t.prototype);for(var r in n)e[r]=n[r];return e}function Yt(){}function Bt(t){var n;return t=(t+"").trim().toLowerCase(),(n=Ah.exec(t))?(n=parseInt(n[1],16),new Wt(n>>8&15|n>>4&240,n>>4&15|240&n,(15&n)<<4|15&n,1)):(n=Ch.exec(t))?jt(parseInt(n[1],16)):(n=zh.exec(t))?new Wt(n[1],n[2],n[3],1):(n=Ph.exec(t))?new Wt(255*n[1]/100,255*n[2]/100,255*n[3]/100,1):(n=Rh.exec(t))?Ht(n[1],n[2],n[3],n[4]):(n=qh.exec(t))?Ht(255*n[1]/100,255*n[2]/100,255*n[3]/100,n[4]):(n=Lh.exec(t))?$t(n[1],n[2]/100,n[3]/100,1):(n=Uh.exec(t))?$t(n[1],n[2]/100,n[3]/100,n[4]):Dh.hasOwnProperty(t)?jt(Dh[t]):"transparent"===t?new Wt(NaN,NaN,NaN,0):null}function jt(t){return new Wt(t>>16&255,t>>8&255,255&t,1)}function Ht(t,n,e,r){return r<=0&&(t=n=e=NaN),new Wt(t,n,e,r)}function Xt(t){return t instanceof Yt||(t=Bt(t)),t?(t=t.rgb(),new Wt(t.r,t.g,t.b,t.opacity)):new Wt}function Vt(t,n,e,r){return 1===arguments.length?Xt(t):new Wt(t,n,e,null==r?1:r)}function Wt(t,n,e,r){this.r=+t,this.g=+n,this.b=+e,this.opacity=+r}function $t(t,n,e,r){return r<=0?t=n=e=NaN:e<=0||e>=1?t=n=NaN:n<=0&&(t=NaN),new Jt(t,n,e,r)}function Zt(t){if(t instanceof Jt)return new Jt(t.h,t.s,t.l,t.opacity);if(t instanceof Yt||(t=Bt(t)),!t)return new Jt;if(t instanceof Jt)return t;t=t.rgb();var n=t.r/255,e=t.g/255,r=t.b/255,i=Math.min(n,e,r),o=Math.max(n,e,r),u=NaN,a=o-i,c=(o+i)/2;return a?(u=n===o?(e-r)/a+6*(e<r):e===o?(r-n)/a+2:(n-e)/a+4,a/=c<.5?o+i:2-o-i,u*=60):a=c>0&&c<1?0:u,new Jt(u,a,c,t.opacity)}function Gt(t,n,e,r){return 1===arguments.length?Zt(t):new Jt(t,n,e,null==r?1:r)}function Jt(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function Qt(t,n,e){return 255*(t<60?n+(e-n)*t/60:t<180?e:t<240?n+(e-n)*(240-t)/60:n)}function Kt(t){if(t instanceof nn)return new nn(t.l,t.a,t.b,t.opacity);if(t instanceof sn){var n=t.h*Oh;return new nn(t.l,Math.cos(n)*t.c,Math.sin(n)*t.c,t.opacity)}t instanceof Wt||(t=Xt(t));var e=un(t.r),r=un(t.g),i=un(t.b),o=en((.4124564*e+.3575761*r+.1804375*i)/Yh),u=en((.2126729*e+.7151522*r+.072175*i)/Bh),a=en((.0193339*e+.119192*r+.9503041*i)/jh);return new nn(116*u-16,500*(o-u),200*(u-a),t.opacity)}function tn(t,n,e,r){return 1===arguments.length?Kt(t):new nn(t,n,e,null==r?1:r)}function nn(t,n,e,r){this.l=+t,this.a=+n,this.b=+e,this.opacity=+r}function en(t){return t>Wh?Math.pow(t,1/3):t/Vh+Hh}function rn(t){return t>Xh?t*t*t:Vh*(t-Hh)}function on(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function un(t){return(t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function an(t){if(t instanceof sn)return new sn(t.h,t.c,t.l,t.opacity);t instanceof nn||(t=Kt(t));var n=Math.atan2(t.b,t.a)*Fh;return new sn(n<0?n+360:n,Math.sqrt(t.a*t.a+t.b*t.b),t.l,t.opacity)}function cn(t,n,e,r){return 1===arguments.length?an(t):new sn(t,n,e,null==r?1:r)}function sn(t,n,e,r){this.h=+t,this.c=+n,this.l=+e,this.opacity=+r}function fn(t){if(t instanceof hn)return new hn(t.h,t.s,t.l,t.opacity);t instanceof Wt||(t=Xt(t));var n=t.r/255,e=t.g/255,r=t.b/255,i=(np*r+Kh*n-tp*e)/(np+Kh-tp),o=r-i,u=(Qh*(e-i)-Gh*o)/Jh,a=Math.sqrt(u*u+o*o)/(Qh*i*(1-i)),c=a?Math.atan2(u,o)*Fh-120:NaN;return new hn(c<0?c+360:c,a,i,t.opacity)}function ln(t,n,e,r){return 1===arguments.length?fn(t):new hn(t,n,e,null==r?1:r)}function hn(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function pn(t,n,e,r,i){var o=t*t,u=o*t;return((1-3*t+3*o-u)*n+(4-6*o+3*u)*e+(1+3*t+3*o-3*u)*r+u*i)/6}function dn(t,n){return function(e){return t+e*n}}function vn(t,n,e){return t=Math.pow(t,e),n=Math.pow(n,e)-t,e=1/e,function(r){return Math.pow(t+r*n,e)}}function _n(t,n){var e=n-t;return e?dn(t,e>180||e<-180?e-360*Math.round(e/360):e):cp(isNaN(t)?n:t)}function yn(t){return 1===(t=+t)?gn:function(n,e){return e-n?vn(n,e,t):cp(isNaN(n)?e:n)}}function gn(t,n){var e=n-t;return e?dn(t,e):cp(isNaN(t)?n:t)}function mn(t){return function(n){var e,r,i=n.length,o=new Array(i),u=new Array(i),a=new Array(i);for(e=0;e<i;++e)r=Vt(n[e]),o[e]=r.r||0,u[e]=r.g||0,a[e]=r.b||0;return o=t(o),u=t(u),a=t(a),r.opacity=1,function(t){return r.r=o(t),r.g=u(t),r.b=a(t),r+""}}}function xn(t){return function(){return t}}function bn(t){return function(n){return t(n)+""}}function wn(t){return"none"===t?wp:(ep||(ep=document.createElement("DIV"),rp=document.documentElement,ip=document.defaultView),ep.style.transform=t,t=ip.getComputedStyle(rp.appendChild(ep),null).getPropertyValue("transform"),rp.removeChild(ep),t=t.slice(7,-1).split(","),Mp(+t[0],+t[1],+t[2],+t[3],+t[4],+t[5]))}function Mn(t){return null==t?wp:(op||(op=document.createElementNS("http://www.w3.org/2000/svg","g")),op.setAttribute("transform",t),(t=op.transform.baseVal.consolidate())?(t=t.matrix,Mp(t.a,t.b,t.c,t.d,t.e,t.f)):wp)}function Tn(t,n,e,r){function i(t){return t.length?t.pop()+" ":""}function o(t,r,i,o,u,a){if(t!==i||r!==o){var c=u.push("translate(",null,n,null,e);a.push({i:c-4,x:dp(t,i)},{i:c-2,x:dp(r,o)})}else(i||o)&&u.push("translate("+i+n+o+e)}function u(t,n,e,o){t!==n?(t-n>180?n+=360:n-t>180&&(t+=360),o.push({i:e.push(i(e)+"rotate(",null,r)-2,x:dp(t,n)})):n&&e.push(i(e)+"rotate("+n+r)}function a(t,n,e,o){t!==n?o.push({i:e.push(i(e)+"skewX(",null,r)-2,x:dp(t,n)}):n&&e.push(i(e)+"skewX("+n+r)}function c(t,n,e,r,o,u){if(t!==e||n!==r){var a=o.push(i(o)+"scale(",null,",",null,")");u.push({i:a-4,x:dp(t,e)},{i:a-2,x:dp(n,r)})}else 1===e&&1===r||o.push(i(o)+"scale("+e+","+r+")")}return function(n,e){var r=[],i=[];return n=t(n),e=t(e),o(n.translateX,n.translateY,e.translateX,e.translateY,r,i),u(n.rotate,e.rotate,r,i),a(n.skewX,e.skewX,r,i),c(n.scaleX,n.scaleY,e.scaleX,e.scaleY,r,i),n=e=null,function(t){for(var n,e=-1,o=i.length;++e<o;)r[(n=i[e]).i]=n.x(t);return r.join("")}}}function Nn(t){return((t=Math.exp(t))+1/t)/2}function kn(t){return((t=Math.exp(t))-1/t)/2}function Sn(t){return((t=Math.exp(2*t))-1)/(t+1)}function En(t){return function(n,e){var r=t((n=Gt(n)).h,(e=Gt(e)).h),i=gn(n.s,e.s),o=gn(n.l,e.l),u=gn(n.opacity,e.opacity);return function(t){return n.h=r(t),n.s=i(t),n.l=o(t),n.opacity=u(t),n+""}}}function An(t,n){var e=gn((t=tn(t)).l,(n=tn(n)).l),r=gn(t.a,n.a),i=gn(t.b,n.b),o=gn(t.opacity,n.opacity);return function(n){return t.l=e(n),t.a=r(n),t.b=i(n),t.opacity=o(n),t+""}}function Cn(t){return function(n,e){var r=t((n=cn(n)).h,(e=cn(e)).h),i=gn(n.c,e.c),o=gn(n.l,e.l),u=gn(n.opacity,e.opacity);return function(t){return n.h=r(t),n.c=i(t),n.l=o(t),n.opacity=u(t),n+""}}}function zn(t){return function n(e){function r(n,r){var i=t((n=ln(n)).h,(r=ln(r)).h),o=gn(n.s,r.s),u=gn(n.l,r.l),a=gn(n.opacity,r.opacity);return function(t){return n.h=i(t),n.s=o(t),n.l=u(Math.pow(t,e)),n.opacity=a(t),n+""}}return e=+e,r.gamma=n,r}(1)}function Pn(){for(var t,n=0,e=arguments.length,r={};n<e;++n){if(!(t=arguments[n]+"")||t in r)throw new Error("illegal type: "+t);r[t]=[]}return new Rn(r)}function Rn(t){this._=t}function qn(t,n){return t.trim().split(/^|\s+/).map(function(t){var e="",r=t.indexOf(".");if(r>=0&&(e=t.slice(r+1),t=t.slice(0,r)),t&&!n.hasOwnProperty(t))throw new Error("unknown type: "+t);return{type:t,name:e}})}function Ln(t,n){for(var e,r=0,i=t.length;r<i;++r)if((e=t[r]).name===n)return e.value}function Un(t,n,e){for(var r=0,i=t.length;r<i;++r)if(t[r].name===n){t[r]=Op,t=t.slice(0,r).concat(t.slice(r+1));break}return null!=e&&t.push({name:n,value:e}),t}function Dn(t){return new Function("d","return {"+t.map(function(t,n){return JSON.stringify(t)+": d["+n+"]"}).join(",")+"}")}function On(t,n){var e=Dn(t);return function(r,i){return n(e(r),i,t)}}function Fn(t){var n=Object.create(null),e=[];return t.forEach(function(t){for(var r in t)r in n||e.push(n[r]=r)}),e}function In(t){return function(n,e){t(null==n?e:null)}}function Yn(t){var n=t.responseType;return n&&"text"!==n?t.response:t.responseText}function Bn(t,n){return function(e){return t(e.responseText,n)}}function jn(){return hd||(vd(Hn),hd=dd.now()+pd)}function Hn(){hd=0}function Xn(){this._call=this._time=this._next=null}function Vn(t,n,e){var r=new Xn;return r.restart(t,n,e),r}function Wn(){jn(),++ad;for(var t,n=Fp;n;)(t=hd-n._time)>=0&&n._call.call(null,t),n=n._next;--ad}function $n(){hd=(ld=dd.now())+pd,ad=cd=0;try{Wn()}finally{ad=0,Gn(),hd=0}}function Zn(){var t=dd.now(),n=t-ld;n>fd&&(pd-=n,ld=t)}function Gn(){for(var t,n,e=Fp,r=1/0;e;)e._call?(r>e._time&&(r=e._time),t=e,e=e._next):(n=e._next,e._next=null,e=t?t._next=n:Fp=n);Ip=t,Jn(r)}function Jn(t){if(!ad){cd&&(cd=clearTimeout(cd));var n=t-hd;n>24?(t<1/0&&(cd=setTimeout($n,n)),sd&&(sd=clearInterval(sd))):(sd||(sd=setInterval(Zn,fd)),ad=1,vd($n))}}function Qn(t,n,e,r){function i(n){return t(n=new Date(+n)),n}return i.floor=i,i.ceil=function(e){return t(e=new Date(e-1)),n(e,1),t(e),e},i.round=function(t){var n=i(t),e=i.ceil(t);return t-n<e-t?n:e},i.offset=function(t,e){return n(t=new Date(+t),null==e?1:Math.floor(e)),t},i.range=function(e,r,o){var u=[];if(e=i.ceil(e),o=null==o?1:Math.floor(o),!(e<r&&o>0))return u;do u.push(new Date(+e));while(n(e,o),t(e),e<r);return u},i.filter=function(e){return Qn(function(n){if(n>=n)for(;t(n),!e(n);)n.setTime(n-1)},function(t,r){if(t>=t)for(;--r>=0;)for(;n(t,1),!e(t););})},e&&(i.count=function(n,r){return gd.setTime(+n),md.setTime(+r),t(gd),t(md),Math.floor(e(gd,md))},i.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?i.filter(r?function(n){return r(n)%t===0}:function(n){return i.count(0,n)%t===0}):i:null}),i}function Kn(t){return Qn(function(n){n.setDate(n.getDate()-(n.getDay()+7-t)%7),n.setHours(0,0,0,0)},function(t,n){t.setDate(t.getDate()+7*n)},function(t,n){return(n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*Md)/kd})}function te(t){return Qn(function(n){n.setUTCDate(n.getUTCDate()-(n.getUTCDay()+7-t)%7),n.setUTCHours(0,0,0,0)},function(t,n){t.setUTCDate(t.getUTCDate()+7*n)},function(t,n){return(n-t)/kd})}function ne(t){if(!(n=zv.exec(t)))throw new Error("invalid format: "+t);var n,e=n[1]||" ",r=n[2]||">",i=n[3]||"-",o=n[4]||"",u=!!n[5],a=n[6]&&+n[6],c=!!n[7],s=n[8]&&+n[8].slice(1),f=n[9]||"";"n"===f?(c=!0,f="g"):Cv[f]||(f=""),(u||"0"===e&&"="===r)&&(u=!0,e="0",r="="),this.fill=e,this.align=r,this.sign=i,this.symbol=o,this.zero=u,this.width=a,this.comma=c,this.precision=s,this.type=f}function ee(t){return t}function re(n){return Rv=Lv(n),t.format=Rv.format,t.formatPrefix=Rv.formatPrefix,Rv}function ie(t){if(0<=t.y&&t.y<100){var n=new Date(-1,t.m,t.d,t.H,t.M,t.S,t.L);return n.setFullYear(t.y),n}return new Date(t.y,t.m,t.d,t.H,t.M,t.S,t.L)}function oe(t){if(0<=t.y&&t.y<100){var n=new Date(Date.UTC(-1,t.m,t.d,t.H,t.M,t.S,t.L));return n.setUTCFullYear(t.y),n}return new Date(Date.UTC(t.y,t.m,t.d,t.H,t.M,t.S,t.L))}function ue(t){return{y:t,m:0,d:1,H:0,M:0,S:0,L:0}}function ae(t){function n(t,n){return function(e){var r,i,o,u=[],a=-1,c=0,s=t.length;for(e instanceof Date||(e=new Date(+e));++a<s;)37===t.charCodeAt(a)&&(u.push(t.slice(c,a)),null!=(i=Iv[r=t.charAt(++a)])?r=t.charAt(++a):i="e"===r?" ":"0",(o=n[r])&&(r=o(e,i)),u.push(r),c=a+1);return u.push(t.slice(c,a)),u.join("")}}function e(t,n){return function(e){var i=ue(1900),o=r(i,t,e+="",0);if(o!=e.length)return null;if("p"in i&&(i.H=i.H%12+12*i.p),"W"in i||"U"in i){"w"in i||(i.w="W"in i?1:0);var u="Z"in i?oe(ue(i.y)).getUTCDay():n(ue(i.y)).getDay();i.m=0,i.d="W"in i?(i.w+6)%7+7*i.W-(u+5)%7:i.w+7*i.U-(u+6)%7}return"Z"in i?(i.H+=i.Z/100|0,i.M+=i.Z%100,oe(i)):n(i)}}function r(t,n,e,r){for(var i,o,u=0,a=n.length,c=e.length;u<a;){if(r>=c)return-1;if(i=n.charCodeAt(u++),37===i){if(i=n.charAt(u++),o=B[i in Iv?n.charAt(u++):i],!o||(r=o(t,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function i(t,n,e){var r=C.exec(n.slice(e));return r?(t.p=z[r[0].toLowerCase()],e+r[0].length):-1}function o(t,n,e){var r=q.exec(n.slice(e));return r?(t.w=L[r[0].toLowerCase()],e+r[0].length):-1}function u(t,n,e){var r=P.exec(n.slice(e));return r?(t.w=R[r[0].toLowerCase()],e+r[0].length):-1}function a(t,n,e){var r=O.exec(n.slice(e));return r?(t.m=F[r[0].toLowerCase()],e+r[0].length):-1}function c(t,n,e){var r=U.exec(n.slice(e));return r?(t.m=D[r[0].toLowerCase()],e+r[0].length):-1}function s(t,n,e){return r(t,w,n,e)}function f(t,n,e){return r(t,M,n,e)}function l(t,n,e){return r(t,T,n,e)}function h(t){return S[t.getDay()]}function p(t){return k[t.getDay()]}function d(t){return A[t.getMonth()]}function v(t){return E[t.getMonth()]}function _(t){return N[+(t.getHours()>=12)]}function y(t){return S[t.getUTCDay()]}function g(t){return k[t.getUTCDay()]}function m(t){return A[t.getUTCMonth()]}function x(t){return E[t.getUTCMonth()]}function b(t){return N[+(t.getUTCHours()>=12)]}var w=t.dateTime,M=t.date,T=t.time,N=t.periods,k=t.days,S=t.shortDays,E=t.months,A=t.shortMonths,C=fe(N),z=le(N),P=fe(k),R=le(k),q=fe(S),L=le(S),U=fe(E),D=le(E),O=fe(A),F=le(A),I={a:h,A:p,b:d,B:v,c:null,d:ke,e:ke,H:Se,I:Ee,j:Ae,L:Ce,m:ze,M:Pe,p:_,S:Re,U:qe,w:Le,W:Ue,x:null,X:null,y:De,Y:Oe,Z:Fe,"%":tr},Y={a:y,A:g,b:m,B:x,c:null,d:Ie,e:Ie,H:Ye,I:Be,j:je,L:He,m:Xe,M:Ve,p:b,S:We,U:$e,w:Ze,W:Ge,x:null,X:null,y:Je,Y:Qe,Z:Ke,"%":tr},B={a:o,A:u,b:a,B:c,c:s,d:me,e:me,H:be,I:be,j:xe,L:Te,m:ge,M:we,p:i,S:Me,U:pe,w:he,W:de,x:f,X:l,y:_e,Y:ve,Z:ye,"%":Ne};return I.x=n(M,I),I.X=n(T,I),I.c=n(w,I),Y.x=n(M,Y),Y.X=n(T,Y),Y.c=n(w,Y),{format:function(t){var e=n(t+="",I);return e.toString=function(){return t},e},parse:function(t){var n=e(t+="",ie);return n.toString=function(){return t},n},utcFormat:function(t){var e=n(t+="",Y);return e.toString=function(){return t},e},utcParse:function(t){var n=e(t,oe);return n.toString=function(){return t},n}}}function ce(t,n,e){var r=t<0?"-":"",i=(r?-t:t)+"",o=i.length;return r+(o<e?new Array(e-o+1).join(n)+i:i)}function se(t){return t.replace(jv,"\\$&")}function fe(t){return new RegExp("^(?:"+t.map(se).join("|")+")","i")}function le(t){for(var n={},e=-1,r=t.length;++e<r;)n[t[e].toLowerCase()]=e;return n}function he(t,n,e){var r=Yv.exec(n.slice(e,e+1));return r?(t.w=+r[0],e+r[0].length):-1}function pe(t,n,e){var r=Yv.exec(n.slice(e));return r?(t.U=+r[0],e+r[0].length):-1}function de(t,n,e){var r=Yv.exec(n.slice(e));return r?(t.W=+r[0],e+r[0].length):-1}function ve(t,n,e){var r=Yv.exec(n.slice(e,e+4));return r?(t.y=+r[0],e+r[0].length):-1}function _e(t,n,e){var r=Yv.exec(n.slice(e,e+2));return r?(t.y=+r[0]+(+r[0]>68?1900:2e3),e+r[0].length):-1}function ye(t,n,e){var r=/^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(n.slice(e,e+6));return r?(t.Z=r[1]?0:-(r[2]+(r[3]||"00")),e+r[0].length):-1}function ge(t,n,e){var r=Yv.exec(n.slice(e,e+2));return r?(t.m=r[0]-1,e+r[0].length):-1}function me(t,n,e){var r=Yv.exec(n.slice(e,e+2));return r?(t.d=+r[0],e+r[0].length):-1}function xe(t,n,e){var r=Yv.exec(n.slice(e,e+3));return r?(t.m=0,t.d=+r[0],e+r[0].length):-1}function be(t,n,e){var r=Yv.exec(n.slice(e,e+2));return r?(t.H=+r[0],e+r[0].length):-1}function we(t,n,e){var r=Yv.exec(n.slice(e,e+2));return r?(t.M=+r[0],e+r[0].length):-1}function Me(t,n,e){var r=Yv.exec(n.slice(e,e+2));return r?(t.S=+r[0],e+r[0].length):-1}function Te(t,n,e){var r=Yv.exec(n.slice(e,e+3));return r?(t.L=+r[0],e+r[0].length):-1}function Ne(t,n,e){var r=Bv.exec(n.slice(e,e+1));return r?e+r[0].length:-1}function ke(t,n){return ce(t.getDate(),n,2)}function Se(t,n){return ce(t.getHours(),n,2)}function Ee(t,n){return ce(t.getHours()%12||12,n,2)}function Ae(t,n){return ce(1+Rd.count(Jd(t),t),n,3)}function Ce(t,n){return ce(t.getMilliseconds(),n,3)}function ze(t,n){return ce(t.getMonth()+1,n,2)}function Pe(t,n){return ce(t.getMinutes(),n,2)}function Re(t,n){return ce(t.getSeconds(),n,2)}function qe(t,n){return ce(Ld.count(Jd(t),t),n,2)}function Le(t){return t.getDay()}function Ue(t,n){return ce(Ud.count(Jd(t),t),n,2)}function De(t,n){return ce(t.getFullYear()%100,n,2)}function Oe(t,n){return ce(t.getFullYear()%1e4,n,4)}function Fe(t){var n=t.getTimezoneOffset();return(n>0?"-":(n*=-1,"+"))+ce(n/60|0,"0",2)+ce(n%60,"0",2)}function Ie(t,n){return ce(t.getUTCDate(),n,2)}function Ye(t,n){return ce(t.getUTCHours(),n,2)}function Be(t,n){return ce(t.getUTCHours()%12||12,n,2)}function je(t,n){return ce(1+rv.count(bv(t),t),n,3)}function He(t,n){return ce(t.getUTCMilliseconds(),n,3)}function Xe(t,n){return ce(t.getUTCMonth()+1,n,2)}function Ve(t,n){return ce(t.getUTCMinutes(),n,2)}function We(t,n){return ce(t.getUTCSeconds(),n,2)}function $e(t,n){return ce(ov.count(bv(t),t),n,2)}function Ze(t){return t.getUTCDay()}function Ge(t,n){return ce(uv.count(bv(t),t),n,2)}function Je(t,n){return ce(t.getUTCFullYear()%100,n,2)}function Qe(t,n){return ce(t.getUTCFullYear()%1e4,n,4)}function Ke(){return"+0000"}function tr(){return"%"}function nr(n){return Uv=ae(n),t.timeFormat=Uv.format,t.timeParse=Uv.parse,t.utcFormat=Uv.utcFormat,t.utcParse=Uv.utcParse,Uv}function er(t){return t.toISOString()}function rr(t){var n=new Date(t);return isNaN(n)?null:n}function ir(t){function n(n){var o=n+"",u=e.get(o);if(!u){if(i!==Gv)return i;e.set(o,u=r.push(n))}return t[(u-1)%t.length]}var e=o(),r=[],i=Gv;return t=null==t?[]:Zv.call(t),n.domain=function(t){if(!arguments.length)return r.slice();r=[],e=o();for(var i,u,a=-1,c=t.length;++a<c;)e.has(u=(i=t[a])+"")||e.set(u,r.push(i));return n},n.range=function(e){return arguments.length?(t=Zv.call(e),n):t.slice()},n.unknown=function(t){return arguments.length?(i=t,n):i},n.copy=function(){return ir().domain(r).range(t).unknown(i)},n}function or(){function t(){var t=i().length,r=u[1]<u[0],l=u[r-0],h=u[1-r];n=(h-l)/Math.max(1,t-c+2*s),a&&(n=Math.floor(n)),l+=(h-l-n*(t-c))*f,e=n*(1-c),a&&(l=Math.round(l),e=Math.round(e));var p=Os(t).map(function(t){return l+n*t});return o(r?p.reverse():p)}var n,e,r=ir().unknown(void 0),i=r.domain,o=r.range,u=[0,1],a=!1,c=0,s=0,f=.5;return delete r.unknown,r.domain=function(n){return arguments.length?(i(n),t()):i()},r.range=function(n){return arguments.length?(u=[+n[0],+n[1]],t()):u.slice()},r.rangeRound=function(n){return u=[+n[0],+n[1]],a=!0,t()},r.bandwidth=function(){return e},r.step=function(){return n},r.round=function(n){return arguments.length?(a=!!n,t()):a},r.padding=function(n){return arguments.length?(c=s=Math.max(0,Math.min(1,n)),t()):c},r.paddingInner=function(n){return arguments.length?(c=Math.max(0,Math.min(1,n)),t()):c},r.paddingOuter=function(n){return arguments.length?(s=Math.max(0,Math.min(1,n)),t()):s},r.align=function(n){return arguments.length?(f=Math.max(0,Math.min(1,n)),t()):f},r.copy=function(){return or().domain(i()).range(u).round(a).paddingInner(c).paddingOuter(s).align(f)},t()}function ur(t){var n=t.copy;return t.padding=t.paddingOuter,delete t.paddingInner,delete t.paddingOuter,t.copy=function(){return ur(n())},t}function ar(){return ur(or().paddingInner(1))}function cr(t,n){return(n-=t=+t)?function(e){return(e-t)/n}:Jv(n)}function sr(t){return function(n,e){var r=t(n=+n,e=+e);return function(t){return t<=n?0:t>=e?1:r(t)}}}function fr(t){return function(n,e){var r=t(n=+n,e=+e);return function(t){return t<=0?n:t>=1?e:r(t)}}}function lr(t,n,e,r){var i=t[0],o=t[1],u=n[0],a=n[1];return o<i?(i=e(o,i),u=r(a,u)):(i=e(i,o),u=r(u,a)),function(t){return u(i(t))}}function hr(t,n,e,r){var i=Math.min(t.length,n.length)-1,o=new Array(i),u=new Array(i),a=-1;for(t[i]<t[0]&&(t=t.slice().reverse(),n=n.slice().reverse());++a<i;)o[a]=e(t[a],t[a+1]),u[a]=r(n[a],n[a+1]);return function(n){var e=ks(t,n,1,i)-1;return u[e](o[e](n))}}function pr(t,n){return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp())}function dr(t,n){function e(){return i=Math.min(a.length,c.length)>2?hr:lr,o=u=null,r}function r(n){return(o||(o=i(a,c,f?sr(t):t,s)))(+n)}var i,o,u,a=Kv,c=Kv,s=mp,f=!1;return r.invert=function(t){return(u||(u=i(c,a,cr,f?fr(n):n)))(+t)},r.domain=function(t){return arguments.length?(a=$v.call(t,Qv),e()):a.slice()},r.range=function(t){return arguments.length?(c=Zv.call(t),e()):c.slice()},r.rangeRound=function(t){return c=Zv.call(t),s=xp,e()},r.clamp=function(t){return arguments.length?(f=!!t,e()):f},r.interpolate=function(t){return arguments.length?(s=t,e()):s},e()}function vr(t){var n=t.domain;return t.ticks=function(t){var e=n();return Bs(e[0],e[e.length-1],null==t?10:t)},t.tickFormat=function(t,e){return t_(n(),t,e)},t.nice=function(r){var i=n(),o=i.length-1,u=null==r?10:r,a=i[0],c=i[o],s=e(a,c,u);return s&&(s=e(Math.floor(a/s)*s,Math.ceil(c/s)*s,u),i[0]=Math.floor(a/s)*s,i[o]=Math.ceil(c/s)*s,n(i)),t},t}function _r(){var t=dr(cr,dp);return t.copy=function(){return pr(t,_r())},vr(t)}function yr(){function t(t){return+t}var n=[0,1];return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=$v.call(e,Qv),t):n.slice()},t.copy=function(){return yr().domain(n)},vr(t)}function gr(t,n){return(n=Math.log(n/t))?function(e){return Math.log(e/t)/n}:Jv(n)}function mr(t,n){return t<0?function(e){return-Math.pow(-n,e)*Math.pow(-t,1-e)}:function(e){return Math.pow(n,e)*Math.pow(t,1-e)}}function xr(t){return isFinite(t)?+("1e"+t):t<0?0:t}function br(t){return 10===t?xr:t===Math.E?Math.exp:function(n){return Math.pow(t,n)}}function wr(t){return t===Math.E?Math.log:10===t&&Math.log10||2===t&&Math.log2||(t=Math.log(t),function(n){return Math.log(n)/t})}function Mr(t){return function(n){return-t(-n)}}function Tr(){function n(){return o=wr(i),u=br(i),r()[0]<0&&(o=Mr(o),u=Mr(u)),e}var e=dr(gr,mr).domain([1,10]),r=e.domain,i=10,o=wr(10),u=br(10);return e.base=function(t){return arguments.length?(i=+t,n()):i},e.domain=function(t){return arguments.length?(r(t),n()):r()},e.ticks=function(t){var n,e=r(),a=e[0],c=e[e.length-1];(n=c<a)&&(h=a,a=c,c=h);var s,f,l,h=o(a),p=o(c),d=null==t?10:+t,v=[];if(!(i%1)&&p-h<d){if(h=Math.round(h)-1,p=Math.round(p)+1,a>0){for(;h<p;++h)for(f=1,s=u(h);f<i;++f)if(l=s*f,!(l<a)){if(l>c)break;v.push(l)}}else for(;h<p;++h)for(f=i-1,s=u(h);f>=1;--f)if(l=s*f,!(l<a)){if(l>c)break;v.push(l)}}else v=Bs(h,p,Math.min(p-h,d)).map(u);return n?v.reverse():v},e.tickFormat=function(n,r){if(null==r&&(r=10===i?".0e":","),"function"!=typeof r&&(r=t.format(r)),n===1/0)return r;null==n&&(n=10);var a=Math.max(1,i*n/e.ticks().length);return function(t){var n=t/u(Math.round(o(t)));return n*i<i-.5&&(n*=i),n<=a?r(t):""}},e.nice=function(){return r(n_(r(),{floor:function(t){return u(Math.floor(o(t)))},ceil:function(t){return u(Math.ceil(o(t)))}}))},e.copy=function(){return pr(e,Tr().base(i))},e}function Nr(t,n){return t<0?-Math.pow(-t,n):Math.pow(t,n)}function kr(){function t(t,n){return(n=Nr(n,e)-(t=Nr(t,e)))?function(r){return(Nr(r,e)-t)/n}:Jv(n)}function n(t,n){return n=Nr(n,e)-(t=Nr(t,e)),function(r){return Nr(t+n*r,1/e)}}var e=1,r=dr(t,n),i=r.domain;return r.exponent=function(t){return arguments.length?(e=+t,i(i())):e},r.copy=function(){return pr(r,kr().exponent(e))},vr(r)}function Sr(){return kr().exponent(.5)}function Er(){function t(){var t=0,o=Math.max(1,r.length);for(i=new Array(o-1);++t<o;)i[t-1]=Xs(e,t/o);return n}function n(t){if(!isNaN(t=+t))return r[ks(i,t)]}var e=[],r=[],i=[];return n.invertExtent=function(t){var n=r.indexOf(t);return n<0?[NaN,NaN]:[n>0?i[n-1]:e[0],n<i.length?i[n]:e[e.length-1]]},n.domain=function(n){if(!arguments.length)return e.slice();e=[];for(var r,i=0,o=n.length;i<o;++i)r=n[i],null==r||isNaN(r=+r)||e.push(r);return e.sort(Ms),t()},n.range=function(n){return arguments.length?(r=Zv.call(n),t()):r.slice()},n.quantiles=function(){return i.slice()},n.copy=function(){return Er().domain(e).range(r)},n}function Ar(){function t(t){if(t<=t)return u[ks(o,t,0,i)]}function n(){var n=-1;for(o=new Array(i);++n<i;)o[n]=((n+1)*r-(n-i)*e)/(i+1);return t}var e=0,r=1,i=1,o=[.5],u=[0,1];return t.domain=function(t){return arguments.length?(e=+t[0],r=+t[1],n()):[e,r]},t.range=function(t){return arguments.length?(i=(u=Zv.call(t)).length-1,n()):u.slice()},t.invertExtent=function(t){var n=u.indexOf(t);return n<0?[NaN,NaN]:n<1?[e,o[0]]:n>=i?[o[i-1],r]:[o[n-1],o[n]]},t.copy=function(){return Ar().domain([e,r]).range(u)},vr(t)}function Cr(){function t(t){if(t<=t)return e[ks(n,t,0,r)]}var n=[.5],e=[0,1],r=1;return t.domain=function(i){return arguments.length?(n=Zv.call(i),r=Math.min(n.length,e.length-1),t):n.slice()},t.range=function(i){return arguments.length?(e=Zv.call(i),r=Math.min(n.length,e.length-1),t):e.slice()},t.invertExtent=function(t){var r=e.indexOf(t);return[n[r-1],n[r]]},t.copy=function(){return Cr().domain(n).range(e)},t}function zr(t){return new Date(t);
}function Pr(t){return t instanceof Date?+t:+new Date(+t)}function Rr(t,n,r,i,o,u,a,c,s){function f(e){return(a(e)<e?v:u(e)<e?_:o(e)<e?y:i(e)<e?g:n(e)<e?r(e)<e?m:x:t(e)<e?b:w)(e)}function l(n,r,i,o){if(null==n&&(n=10),"number"==typeof n){var u=Math.abs(i-r)/n,a=Ts(function(t){return t[2]}).right(M,u);a===M.length?(o=e(r/c_,i/c_,n),n=t):a?(a=M[u/M[a-1][2]<M[a][2]/u?a-1:a],o=a[1],n=a[0]):(o=e(r,i,n),n=c)}return null==o?n:n.every(o)}var h=dr(cr,dp),p=h.invert,d=h.domain,v=s(".%L"),_=s(":%S"),y=s("%I:%M"),g=s("%I %p"),m=s("%a %d"),x=s("%b %d"),b=s("%B"),w=s("%Y"),M=[[a,1,e_],[a,5,5*e_],[a,15,15*e_],[a,30,30*e_],[u,1,r_],[u,5,5*r_],[u,15,15*r_],[u,30,30*r_],[o,1,i_],[o,3,3*i_],[o,6,6*i_],[o,12,12*i_],[i,1,o_],[i,2,2*o_],[r,1,u_],[n,1,a_],[n,3,3*a_],[t,1,c_]];return h.invert=function(t){return new Date(p(t))},h.domain=function(t){return arguments.length?d($v.call(t,Pr)):d().map(zr)},h.ticks=function(t,n){var e,r=d(),i=r[0],o=r[r.length-1],u=o<i;return u&&(e=i,i=o,o=e),e=l(t,i,o,n),e=e?e.range(i,o+1):[],u?e.reverse():e},h.tickFormat=function(t,n){return null==n?f:s(n)},h.nice=function(t,n){var e=d();return(t=l(t,e[0],e[e.length-1],n))?d(n_(e,t)):h},h.copy=function(){return pr(h,Rr(t,n,r,i,o,u,a,c,s))},h}function qr(t){var n=t.length;return function(e){return t[Math.max(0,Math.min(n-1,Math.floor(e*n)))]}}function Lr(t){function n(n){var o=(n-e)/(r-e);return t(i?Math.max(0,Math.min(1,o)):o)}var e=0,r=1,i=!1;return n.domain=function(t){return arguments.length?(e=+t[0],r=+t[1],n):[e,r]},n.clamp=function(t){return arguments.length?(i=!!t,n):i},n.interpolator=function(e){return arguments.length?(t=e,n):t},n.copy=function(){return Lr(t).domain([e,r]).clamp(i)},vr(n)}function Ur(t){return function(){var n=this.ownerDocument,e=this.namespaceURI;return e===N_&&n.documentElement.namespaceURI===N_?n.createElement(t):n.createElementNS(e,t)}}function Dr(t){return function(){return this.ownerDocument.createElementNS(t.space,t.local)}}function Or(){return new Fr}function Fr(){this._="@"+(++A_).toString(36)}function Ir(t,n,e){return t=Yr(t,n,e),function(n){var e=n.relatedTarget;e&&(e===this||8&e.compareDocumentPosition(this))||t.call(this,n)}}function Yr(n,e,r){return function(i){var o=t.event;t.event=i;try{n.call(this,this.__data__,e,r)}finally{t.event=o}}}function Br(t){return t.trim().split(/^|\s+/).map(function(t){var n="",e=t.indexOf(".");return e>=0&&(n=t.slice(e+1),t=t.slice(0,e)),{type:t,name:n}})}function jr(t){return function(){var n=this.__on;if(n){for(var e,r=0,i=-1,o=n.length;r<o;++r)e=n[r],t.type&&e.type!==t.type||e.name!==t.name?n[++i]=e:this.removeEventListener(e.type,e.listener,e.capture);++i?n.length=i:delete this.__on}}}function Hr(t,n,e){var r=q_.hasOwnProperty(t.type)?Ir:Yr;return function(i,o,u){var a,c=this.__on,s=r(n,o,u);if(c)for(var f=0,l=c.length;f<l;++f)if((a=c[f]).type===t.type&&a.name===t.name)return this.removeEventListener(a.type,a.listener,a.capture),this.addEventListener(a.type,a.listener=s,a.capture=e),void(a.value=n);this.addEventListener(t.type,s,e),a={type:t.type,name:t.name,value:n,listener:s,capture:e},c?c.push(a):this.__on=[a]}}function Xr(n,e,r,i){var o=t.event;n.sourceEvent=t.event,t.event=n;try{return e.apply(r,i)}finally{t.event=o}}function Vr(){}function Wr(){return[]}function $r(t,n){this.ownerDocument=t.ownerDocument,this.namespaceURI=t.namespaceURI,this._next=null,this._parent=t,this.__data__=n}function Zr(t,n,e,r,i,o){for(var u,a=0,c=n.length,s=o.length;a<s;++a)(u=n[a])?(u.__data__=o[a],r[a]=u):e[a]=new $r(t,o[a]);for(;a<c;++a)(u=n[a])&&(i[a]=u)}function Gr(t,n,e,r,i,o,u){var a,c,s,f={},l=n.length,h=o.length,p=new Array(l);for(a=0;a<l;++a)(c=n[a])&&(p[a]=s=$_+u.call(c,c.__data__,a,n),s in f?i[a]=c:f[s]=c);for(a=0;a<h;++a)s=$_+u.call(t,o[a],a,o),(c=f[s])?(r[a]=c,c.__data__=o[a],f[s]=null):e[a]=new $r(t,o[a]);for(a=0;a<l;++a)(c=n[a])&&f[p[a]]===c&&(i[a]=c)}function Jr(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function Qr(t){return function(){this.removeAttribute(t)}}function Kr(t){return function(){this.removeAttributeNS(t.space,t.local)}}function ti(t,n){return function(){this.setAttribute(t,n)}}function ni(t,n){return function(){this.setAttributeNS(t.space,t.local,n)}}function ei(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttribute(t):this.setAttribute(t,e)}}function ri(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,e)}}function ii(t){return function(){this.style.removeProperty(t)}}function oi(t,n,e){return function(){this.style.setProperty(t,n,e)}}function ui(t,n,e){return function(){var r=n.apply(this,arguments);null==r?this.style.removeProperty(t):this.style.setProperty(t,r,e)}}function ai(t){return function(){delete this[t]}}function ci(t,n){return function(){this[t]=n}}function si(t,n){return function(){var e=n.apply(this,arguments);null==e?delete this[t]:this[t]=e}}function fi(t){return t.trim().split(/^|\s+/)}function li(t){return t.classList||new hi(t)}function hi(t){this._node=t,this._names=fi(t.getAttribute("class")||"")}function pi(t,n){for(var e=li(t),r=-1,i=n.length;++r<i;)e.add(n[r])}function di(t,n){for(var e=li(t),r=-1,i=n.length;++r<i;)e.remove(n[r])}function vi(t){return function(){pi(this,t)}}function _i(t){return function(){di(this,t)}}function yi(t,n){return function(){(n.apply(this,arguments)?pi:di)(this,t)}}function gi(){this.textContent=""}function mi(t){return function(){this.textContent=t}}function xi(t){return function(){var n=t.apply(this,arguments);this.textContent=null==n?"":n}}function bi(){this.innerHTML=""}function wi(t){return function(){this.innerHTML=t}}function Mi(t){return function(){var n=t.apply(this,arguments);this.innerHTML=null==n?"":n}}function Ti(){this.nextSibling&&this.parentNode.appendChild(this)}function Ni(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function ki(){return null}function Si(){var t=this.parentNode;t&&t.removeChild(this)}function Ei(t,n,e){var r=ay(t),i=r.CustomEvent;i?i=new i(n,e):(i=r.document.createEvent("Event"),e?(i.initEvent(n,e.bubbles,e.cancelable),i.detail=e.detail):i.initEvent(n,!1,!1)),t.dispatchEvent(i)}function Ai(t,n){return function(){return Ei(this,t,n)}}function Ci(t,n){return function(){return Ei(this,t,n.apply(this,arguments))}}function zi(t,n){this._groups=t,this._parents=n}function Pi(){return new zi([[document.documentElement]],xy)}function Ri(t,n){var e=t.__transition;if(!e||!(e=e[n])||e.state>Sy)throw new Error("too late");return e}function qi(t,n){var e=t.__transition;if(!e||!(e=e[n])||e.state>Ay)throw new Error("too late");return e}function Li(t,n){var e=t.__transition;if(!e||!(e=e[n]))throw new Error("too late");return e}function Ui(t,n,e){function r(t){e.state=Ey,e.timer.restart(i,e.delay,e.time),e.delay<=t&&i(t-e.delay)}function i(r){var s,f,l,h;if(e.state!==Ey)return u();for(s in c)if(h=c[s],h.name===e.name){if(h.state===Cy)return _d(i);h.state===zy?(h.state=Ry,h.timer.stop(),h.on.call("interrupt",t,t.__data__,h.index,h.group),delete c[s]):+s<n&&(h.state=Ry,h.timer.stop(),delete c[s])}if(_d(function(){e.state===Cy&&(e.state=zy,e.timer.restart(o,e.delay,e.time),o(r))}),e.state=Ay,e.on.call("start",t,t.__data__,e.index,e.group),e.state===Ay){for(e.state=Cy,a=new Array(l=e.tween.length),s=0,f=-1;s<l;++s)(h=e.tween[s].value.call(t,t.__data__,e.index,e.group))&&(a[++f]=h);a.length=f+1}}function o(n){for(var r=n<e.duration?e.ease.call(null,n/e.duration):(e.timer.restart(u),e.state=Py,1),i=-1,o=a.length;++i<o;)a[i].call(null,r);e.state===Py&&(e.on.call("end",t,t.__data__,e.index,e.group),u())}function u(){e.state=Ry,e.timer.stop(),delete c[n];for(var r in c)return;delete t.__transition}var a,c=t.__transition;c[n]=e,e.timer=Vn(r,0,e.time)}function Di(t,n){var e,r;return function(){var i=qi(this,t),o=i.tween;if(o!==e){r=e=o;for(var u=0,a=r.length;u<a;++u)if(r[u].name===n){r=r.slice(),r.splice(u,1);break}}i.tween=r}}function Oi(t,n,e){var r,i;if("function"!=typeof e)throw new Error;return function(){var o=qi(this,t),u=o.tween;if(u!==r){i=(r=u).slice();for(var a={name:n,value:e},c=0,s=i.length;c<s;++c)if(i[c].name===n){i[c]=a;break}c===s&&i.push(a)}o.tween=i}}function Fi(t,n,e){var r=t._id;return t.each(function(){var t=qi(this,r);(t.value||(t.value={}))[n]=e.apply(this,arguments)}),function(t){return Li(t,r).value[n]}}function Ii(t){return function(){this.removeAttribute(t)}}function Yi(t){return function(){this.removeAttributeNS(t.space,t.local)}}function Bi(t,n,e){var r,i;return function(){var o=this.getAttribute(t);return o===e?null:o===r?i:i=n(r=o,e)}}function ji(t,n,e){var r,i;return function(){var o=this.getAttributeNS(t.space,t.local);return o===e?null:o===r?i:i=n(r=o,e)}}function Hi(t,n,e){var r,i,o;return function(){var u,a=e(this);return null==a?void this.removeAttribute(t):(u=this.getAttribute(t),u===a?null:u===r&&a===i?o:o=n(r=u,i=a))}}function Xi(t,n,e){var r,i,o;return function(){var u,a=e(this);return null==a?void this.removeAttributeNS(t.space,t.local):(u=this.getAttributeNS(t.space,t.local),u===a?null:u===r&&a===i?o:o=n(r=u,i=a))}}function Vi(t,n){function e(){var e=this,r=n.apply(e,arguments);return r&&function(n){e.setAttributeNS(t.space,t.local,r(n))}}return e._value=n,e}function Wi(t,n){function e(){var e=this,r=n.apply(e,arguments);return r&&function(n){e.setAttribute(t,r(n))}}return e._value=n,e}function $i(t,n){return function(){Ri(this,t).delay=+n.apply(this,arguments)}}function Zi(t,n){return n=+n,function(){Ri(this,t).delay=n}}function Gi(t,n){return function(){qi(this,t).duration=+n.apply(this,arguments)}}function Ji(t,n){return n=+n,function(){qi(this,t).duration=n}}function Qi(t,n){if("function"!=typeof n)throw new Error;return function(){qi(this,t).ease=n}}function Ki(t){return(t+"").trim().split(/^|\s+/).every(function(t){var n=t.indexOf(".");return n>=0&&(t=t.slice(0,n)),!t||"start"===t})}function to(t,n,e){var r,i,o=Ki(n)?Ri:qi;return function(){var u=o(this,t),a=u.on;a!==r&&(i=(r=a).copy()).on(n,e),u.on=i}}function no(t){return function(){var n=this.parentNode;for(var e in this.__transition)if(+e!==t)return;n&&n.removeChild(this)}}function eo(t,n){var e,r,i;return function(){var o=ay(this).getComputedStyle(this,null),u=o.getPropertyValue(t),a=(this.style.removeProperty(t),o.getPropertyValue(t));return u===a?null:u===e&&a===r?i:i=n(e=u,r=a)}}function ro(t){return function(){this.style.removeProperty(t)}}function io(t,n,e){var r,i;return function(){var o=ay(this).getComputedStyle(this,null).getPropertyValue(t);return o===e?null:o===r?i:i=n(r=o,e)}}function oo(t,n,e){var r,i,o;return function(){var u=ay(this).getComputedStyle(this,null),a=u.getPropertyValue(t),c=e(this);return null==c&&(this.style.removeProperty(t),c=u.getPropertyValue(t)),a===c?null:a===r&&c===i?o:o=n(r=a,i=c)}}function uo(t,n,e){function r(){var r=this,i=n.apply(r,arguments);return i&&function(n){r.style.setProperty(t,i(n),e)}}return r._value=n,r}function ao(t){return function(){this.textContent=t}}function co(t){return function(){var n=t(this);this.textContent=null==n?"":n}}function so(t,n,e,r){this._groups=t,this._parents=n,this._name=e,this._id=r}function fo(t){return Pi().transition(t)}function lo(){return++eg}function ho(t,n){for(var e;!(e=t.__transition)||!(e=e[n]);)if(!(t=t.parentNode))return ig.time=jn(),ig;return e}function po(t,n,e){var r=t(e);return"translate("+(isFinite(r)?r:n(e))+",0)"}function vo(t,n,e){var r=t(e);return"translate(0,"+(isFinite(r)?r:n(e))+")"}function _o(t){var n=t.bandwidth()/2;return t.round()&&(n=Math.round(n)),function(e){return t(e)+n}}function yo(){return!this.__axis}function go(t,n){function e(e){var s,f=null==i?n.ticks?n.ticks.apply(n,r):n.domain():i,l=null==o?n.tickFormat?n.tickFormat.apply(n,r):sg:o,h=Math.max(u,0)+c,p=t===fg||t===hg?po:vo,d=n.range(),v=d[0]+.5,_=d[d.length-1]+.5,y=(n.bandwidth?_o:sg)(n.copy()),g=e.selection?e.selection():e,m=g.selectAll(".domain").data([null]),x=g.selectAll(".tick").data(f,n).order(),b=x.exit(),w=x.enter().append("g").attr("class","tick"),M=x.select("line"),T=x.select("text"),N=t===fg||t===pg?-1:1,k=t===pg||t===lg?(s="x","y"):(s="y","x");m=m.merge(m.enter().insert("path",".tick").attr("class","domain").attr("stroke","#000")),x=x.merge(w),M=M.merge(w.append("line").attr("stroke","#000").attr(s+"2",N*u).attr(k+"1",.5).attr(k+"2",.5)),T=T.merge(w.append("text").attr("fill","#000").attr(s,N*h).attr(k,.5).attr("dy",t===fg?"0em":t===hg?"0.71em":"0.32em")),e!==g&&(m=m.transition(e),x=x.transition(e),M=M.transition(e),T=T.transition(e),b=b.transition(e).attr("opacity",dg).attr("transform",function(t){return p(y,this.parentNode.__axis||y,t)}),w.attr("opacity",dg).attr("transform",function(t){return p(this.parentNode.__axis||y,y,t)})),b.remove(),m.attr("d",t===pg||t==lg?"M"+N*a+","+v+"H0.5V"+_+"H"+N*a:"M"+v+","+N*a+"V0.5H"+_+"V"+N*a),x.attr("opacity",1).attr("transform",function(t){return p(y,y,t)}),M.attr(s+"2",N*u),T.attr(s,N*h).text(l),g.filter(yo).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",t===lg?"start":t===pg?"end":"middle"),g.each(function(){this.__axis=y})}var r=[],i=null,o=null,u=6,a=6,c=3;return e.scale=function(t){return arguments.length?(n=t,e):n},e.ticks=function(){return r=cg.call(arguments),e},e.tickArguments=function(t){return arguments.length?(r=null==t?[]:cg.call(t),e):r.slice()},e.tickValues=function(t){return arguments.length?(i=null==t?null:cg.call(t),e):i&&i.slice()},e.tickFormat=function(t){return arguments.length?(o=t,e):o},e.tickSize=function(t){return arguments.length?(u=a=+t,e):u},e.tickSizeInner=function(t){return arguments.length?(u=+t,e):u},e.tickSizeOuter=function(t){return arguments.length?(a=+t,e):a},e.tickPadding=function(t){return arguments.length?(c=+t,e):c},e}function mo(t){return go(fg,t)}function xo(t){return go(lg,t)}function bo(t){return go(hg,t)}function wo(t){return go(pg,t)}function Mo(t,n){return t.parent===n.parent?1:2}function To(t){return t.reduce(No,0)/t.length}function No(t,n){return t+n.x}function ko(t){return 1+t.reduce(So,0)}function So(t,n){return Math.max(t,n.y)}function Eo(t){for(var n;n=t.children;)t=n[0];return t}function Ao(t){for(var n;n=t.children;)t=n[n.length-1];return t}function Co(t,n){if(t===n)return t;var e=t.ancestors(),r=n.ancestors(),i=null;for(t=e.pop(),n=r.pop();t===n;)i=t,t=e.pop(),n=r.pop();return i}function zo(t,n){var e,r,i,o,u,a=new Uo(t),c=+t.value&&(a.value=t.value),s=[a];for(null==n&&(n=Ro);e=s.pop();)if(c&&(e.value=+e.data.value),(i=n(e.data))&&(u=i.length))for(e.children=new Array(u),o=u-1;o>=0;--o)s.push(r=e.children[o]=new Uo(i[o])),r.parent=e,r.depth=e.depth+1;return a.eachBefore(Lo)}function Po(){return zo(this).eachBefore(qo)}function Ro(t){return t.children}function qo(t){t.data=t.data.data}function Lo(t){var n=0;do t.height=n;while((t=t.parent)&&t.height<++n)}function Uo(t){this.data=t,this.depth=this.height=0,this.parent=null}function Do(t){this._=t,this.next=null}function Oo(t,n){var e=n.x-t.x,r=n.y-t.y,i=t.r-n.r;return i*i+1e-6>e*e+r*r}function Fo(t,n){var e,r,i,o=null,u=t.head;switch(n.length){case 1:e=Io(n[0]);break;case 2:e=Yo(n[0],n[1]);break;case 3:e=Bo(n[0],n[1],n[2])}for(;u;)i=u._,r=u.next,e&&Oo(e,i)?o=u:(o?(t.tail=o,o.next=null):t.head=t.tail=null,n.push(i),e=Fo(t,n),n.pop(),t.head?(u.next=t.head,t.head=u):(u.next=null,t.head=t.tail=u),o=t.tail,o.next=r),u=r;return t.tail=o,e}function Io(t){return{x:t.x,y:t.y,r:t.r}}function Yo(t,n){var e=t.x,r=t.y,i=t.r,o=n.x,u=n.y,a=n.r,c=o-e,s=u-r,f=a-i,l=Math.sqrt(c*c+s*s);return{x:(e+o+c/l*f)/2,y:(r+u+s/l*f)/2,r:(l+i+a)/2}}function Bo(t,n,e){var r=t.x,i=t.y,o=t.r,u=n.x,a=n.y,c=n.r,s=e.x,f=e.y,l=e.r,h=2*(r-u),p=2*(i-a),d=2*(c-o),v=r*r+i*i-o*o-u*u-a*a+c*c,_=2*(r-s),y=2*(i-f),g=2*(l-o),m=r*r+i*i-o*o-s*s-f*f+l*l,x=_*p-h*y,b=(p*m-y*v)/x-r,w=(y*d-p*g)/x,M=(_*v-h*m)/x-i,T=(h*g-_*d)/x,N=w*w+T*T-1,k=2*(b*w+M*T+o),S=b*b+M*M-o*o,E=(-k-Math.sqrt(k*k-4*N*S))/(2*N);return{x:b+w*E+r,y:M+T*E+i,r:E}}function jo(t,n,e){var r=t.x,i=t.y,o=n.r+e.r,u=t.r+e.r,a=n.x-r,c=n.y-i,s=a*a+c*c;if(s){var f=.5+((u*=u)-(o*=o))/(2*s),l=Math.sqrt(Math.max(0,2*o*(u+s)-(u-=s)*u-o*o))/(2*s);e.x=r+f*a+l*c,e.y=i+f*c-l*a}else e.x=r+u,e.y=i}function Ho(t,n){var e=n.x-t.x,r=n.y-t.y,i=t.r+n.r;return i*i>e*e+r*r}function Xo(t,n,e){var r=t.x-n,i=t.y-e;return r*r+i*i}function Vo(t){this._=t,this.next=null,this.previous=null}function Wo(t){if(!(i=t.length))return 0;var n,e,r,i;if(n=t[0],n.x=0,n.y=0,!(i>1))return n.r;if(e=t[1],n.x=-e.r,e.x=n.r,e.y=0,!(i>2))return n.r+e.r;jo(e,n,r=t[2]);var o,u,a,c,s,f,l,h=n.r*n.r,p=e.r*e.r,d=r.r*r.r,v=h+p+d,_=h*n.x+p*e.x+d*r.x,y=h*n.y+p*e.y+d*r.y;n=new Vo(n),e=new Vo(e),r=new Vo(r),n.next=r.previous=e,e.next=n.previous=r,r.next=e.previous=n;t:for(a=3;a<i;++a){if(jo(n._,e._,r=t[a]),r=new Vo(r),(s=n.previous)===(c=e.next)){if(Ho(c._,r._)){n=e,e=c,--a;continue t}}else{f=c._.r,l=s._.r;do if(f<=l){if(Ho(c._,r._)){e=c,n.next=e,e.previous=n,--a;continue t}c=c.next,f+=c._.r}else{if(Ho(s._,r._)){n=s,n.next=e,e.previous=n,--a;continue t}s=s.previous,l+=s._.r}while(c!==s.next)}for(r.previous=n,r.next=e,n.next=e.previous=e=r,v+=d=r._.r*r._.r,_+=d*r._.x,y+=d*r._.y,h=Xo(n._,o=_/v,u=y/v);(r=r.next)!==e;)(d=Xo(r._,o,u))<h&&(n=r,h=d);e=n.next}for(n=[e._],r=e;(r=r.next)!==e;)n.push(r._);for(r=Sg(n),a=0;a<i;++a)n=t[a],n.x-=r.x,n.y-=r.y;return r.r}function $o(t){return null==t?null:Zo(t)}function Zo(t){if("function"!=typeof t)throw new Error;return t}function Go(){return 0}function Jo(t){return Math.sqrt(t.value)}function Qo(t){return function(n){n.children||(n.r=Math.max(0,+t(n)||0))}}function Ko(t,n){return function(e){if(r=e.children){var r,i,o,u=r.length,a=t(e)*n||0;if(a)for(i=0;i<u;++i)r[i].r+=a;if(o=Wo(r),a)for(i=0;i<u;++i)r[i].r-=a;e.r=o+a}}}function tu(t){return function(n){var e=n.parent;n.r*=t,e&&(n.x=e.x+t*n.x,n.y=e.y+t*n.y)}}function nu(t){return t.id}function eu(t){return t.parentId}function ru(t,n){return t.parent===n.parent?1:2}function iu(t){var n=t.children;return n?n[0]:t.t}function ou(t){var n=t.children;return n?n[n.length-1]:t.t}function uu(t,n,e){var r=e/(n.i-t.i);n.c-=r,n.s+=e,t.c+=r,n.z+=e,n.m+=e}function au(t){for(var n,e=0,r=0,i=t.children,o=i.length;--o>=0;)n=i[o],n.z+=e,n.m+=e,e+=n.s+(r+=n.c)}function cu(t,n,e){return t.a.parent===n.parent?t.a:e}function su(t,n){this._=t,this.parent=null,this.children=null,this.A=null,this.a=this,this.z=0,this.m=0,this.c=0,this.s=0,this.t=null,this.i=n}function fu(t){for(var n,e,r,i,o,u=new su(t,0),a=[u];n=a.pop();)if(r=n._.children)for(n.children=new Array(o=r.length),i=o-1;i>=0;--i)a.push(e=n.children[i]=new su(r[i],i)),e.parent=n;return(u.parent=new su(null,0)).children=[u],u}function lu(t,n,e,r,i,o){for(var u,a,c,s,f,l,h,p,d,v,_,y=[],g=n.children,m=0,x=0,b=g.length,w=n.value;m<b;){c=i-e,s=o-r;do f=g[x++].value;while(!f&&x<b);for(l=h=f,v=Math.max(s/c,c/s)/(w*t),_=f*f*v,d=Math.max(h/_,_/l);x<b;++x){if(f+=a=g[x].value,a<l&&(l=a),a>h&&(h=a),_=f*f*v,p=Math.max(h/_,_/l),p>d){f-=a;break}d=p}y.push(u={value:f,dice:c<s,children:g.slice(m,x)}),u.dice?Pg(u,e,r,i,w?r+=s*f/w:o):Fg(u,e,r,w?e+=c*f/w:i,o),w-=f,m=x}return y}function hu(t){return t.x+t.vx}function pu(t){return t.y+t.vy}function du(t){return t.index}function vu(t,n){var e=t.get(n);if(!e)throw new Error("missing: "+n);return e}function _u(t){return t.x}function yu(t){return t.y}function gu(){t.event.stopImmediatePropagation()}function mu(t,n){var e=t.document.documentElement,r=by(t).on("dragstart.drag",null);n&&(r.on("click.drag",rm,!0),setTimeout(function(){r.on("click.drag",null)},0)),"onselectstart"in e?r.on("selectstart.drag",null):(e.style.MozUserSelect=e.__noselect,delete e.__noselect)}function xu(t,n,e,r,i,o,u,a,c,s){this.target=t,this.type=n,this.subject=e,this.identifier=r,this.active=i,this.x=o,this.y=u,this.dx=a,this.dy=c,this._=s}function bu(){return!t.event.button}function wu(){return this.parentNode}function Mu(n){return null==n?{x:t.event.x,y:t.event.y}:n}function Tu(t){return t[0]}function Nu(t){return t[1]}function ku(){this._=null}function Su(t){t.U=t.C=t.L=t.R=t.P=t.N=null}function Eu(t,n){var e=n,r=n.R,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function Au(t,n){var e=n,r=n.L,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function Cu(t){for(;t.L;)t=t.L;return t}function zu(t,n,e,r){var i=[null,null],o=hm.push(i)-1;return i.left=t,i.right=n,e&&Ru(i,t,n,e),r&&Ru(i,n,t,r),fm[t.index].halfedges.push(o),fm[n.index].halfedges.push(o),i}function Pu(t,n,e){var r=[n,e];return r.left=t,r}function Ru(t,n,e,r){t[0]||t[1]?t.left===e?t[1]=r:t[0]=r:(t[0]=r,t.left=n,t.right=e)}function qu(t,n,e,r,i){var o,u=t[0],a=t[1],c=u[0],s=u[1],f=a[0],l=a[1],h=0,p=1,d=f-c,v=l-s;if(o=n-c,d||!(o>0)){if(o/=d,d<0){if(o<h)return;o<p&&(p=o)}else if(d>0){if(o>p)return;o>h&&(h=o)}if(o=r-c,d||!(o<0)){if(o/=d,d<0){if(o>p)return;o>h&&(h=o)}else if(d>0){if(o<h)return;o<p&&(p=o)}if(o=e-s,v||!(o>0)){if(o/=v,v<0){if(o<h)return;o<p&&(p=o)}else if(v>0){if(o>p)return;o>h&&(h=o)}if(o=i-s,v||!(o<0)){if(o/=v,v<0){if(o>p)return;o>h&&(h=o)}else if(v>0){if(o<h)return;o<p&&(p=o)}return!(h>0||p<1)||(h>0&&(t[0]=[c+h*d,s+h*v]),p<1&&(t[1]=[c+p*d,s+p*v]),!0)}}}}}function Lu(t,n,e,r,i){var o=t[1];if(o)return!0;var u,a,c=t[0],s=t.left,f=t.right,l=s[0],h=s[1],p=f[0],d=f[1],v=(l+p)/2,_=(h+d)/2;if(d===h){if(v<n||v>=r)return;if(l>p){if(c){if(c[1]>=i)return}else c=[v,e];o=[v,i]}else{if(c){if(c[1]<e)return}else c=[v,i];o=[v,e]}}else if(u=(l-p)/(d-h),a=_-u*v,u<-1||u>1)if(l>p){if(c){if(c[1]>=i)return}else c=[(e-a)/u,e];o=[(i-a)/u,i]}else{if(c){if(c[1]<e)return}else c=[(i-a)/u,i];o=[(e-a)/u,e]}else if(h<d){if(c){if(c[0]>=r)return}else c=[n,u*n+a];o=[r,u*r+a]}else{if(c){if(c[0]<n)return}else c=[r,u*r+a];o=[n,u*n+a]}return t[0]=c,t[1]=o,!0}function Uu(t,n,e,r){for(var i,o=hm.length;o--;)Lu(i=hm[o],t,n,e,r)&&qu(i,t,n,e,r)&&(Math.abs(i[0][0]-i[1][0])>vm||Math.abs(i[0][1]-i[1][1])>vm)||delete hm[o]}function Du(t){return fm[t.index]={site:t,halfedges:[]}}function Ou(t,n){var e=t.site,r=n.left,i=n.right;return e===i&&(i=r,r=e),i?Math.atan2(i[1]-r[1],i[0]-r[0]):(e===r?(r=n[1],i=n[0]):(r=n[0],i=n[1]),Math.atan2(r[0]-i[0],i[1]-r[1]))}function Fu(t,n){return n[+(n.left!==t.site)]}function Iu(t,n){return n[+(n.left===t.site)]}function Yu(){for(var t,n,e,r,i=0,o=fm.length;i<o;++i)if((t=fm[i])&&(r=(n=t.halfedges).length)){var u=new Array(r),a=new Array(r);for(e=0;e<r;++e)u[e]=e,a[e]=Ou(t,hm[n[e]]);for(u.sort(function(t,n){return a[n]-a[t]}),e=0;e<r;++e)a[e]=n[u[e]];for(e=0;e<r;++e)n[e]=a[e]}}function Bu(t,n,e,r){var i,o,u,a,c,s,f,l,h,p,d,v,_=fm.length,y=!0;for(i=0;i<_;++i)if(o=fm[i]){for(u=o.site,c=o.halfedges,a=c.length;a--;)hm[c[a]]||c.splice(a,1);for(a=0,s=c.length;a<s;)p=Iu(o,hm[c[a]]),d=p[0],v=p[1],f=Fu(o,hm[c[++a%s]]),l=f[0],h=f[1],(Math.abs(d-l)>vm||Math.abs(v-h)>vm)&&(c.splice(a,0,hm.push(Pu(u,p,Math.abs(d-t)<vm&&r-v>vm?[t,Math.abs(l-t)<vm?h:r]:Math.abs(v-r)<vm&&e-d>vm?[Math.abs(h-r)<vm?l:e,r]:Math.abs(d-e)<vm&&v-n>vm?[e,Math.abs(l-e)<vm?h:n]:Math.abs(v-n)<vm&&d-t>vm?[Math.abs(h-n)<vm?l:t,n]:null))-1),++s);s&&(y=!1)}if(y){var g,m,x,b=1/0;for(i=0,y=null;i<_;++i)(o=fm[i])&&(u=o.site,g=u[0]-t,m=u[1]-n,x=g*g+m*m,x<b&&(b=x,y=o));if(y){var w=[t,n],M=[t,r],T=[e,r],N=[e,n];y.halfedges.push(hm.push(Pu(u=y.site,w,M))-1,hm.push(Pu(u,M,T))-1,hm.push(Pu(u,T,N))-1,hm.push(Pu(u,N,w))-1)}}for(i=0;i<_;++i)(o=fm[i])&&(o.halfedges.length||delete fm[i])}function ju(){Su(this),this.x=this.y=this.arc=this.site=this.cy=null}function Hu(t){var n=t.P,e=t.N;if(n&&e){var r=n.site,i=t.site,o=e.site;if(r!==o){var u=i[0],a=i[1],c=r[0]-u,s=r[1]-a,f=o[0]-u,l=o[1]-a,h=2*(c*l-s*f);if(!(h>=-_m)){var p=c*c+s*s,d=f*f+l*l,v=(l*p-s*d)/h,_=(c*d-f*p)/h,y=pm.pop()||new ju;y.arc=t,y.site=i,y.x=v+u,y.y=(y.cy=_+a)+Math.sqrt(v*v+_*_),t.circle=y;for(var g=null,m=lm._;m;)if(y.y<m.y||y.y===m.y&&y.x<=m.x){if(!m.L){g=m.P;break}m=m.L}else{if(!m.R){g=m;break}m=m.R}lm.insert(g,y),g||(cm=y)}}}}function Xu(t){var n=t.circle;n&&(n.P||(cm=n.N),lm.remove(n),pm.push(n),Su(n),t.circle=null)}function Vu(){Su(this),this.edge=this.site=this.circle=null}function Wu(t){var n=dm.pop()||new Vu;return n.site=t,n}function $u(t){Xu(t),sm.remove(t),dm.push(t),Su(t)}function Zu(t){var n=t.circle,e=n.x,r=n.cy,i=[e,r],o=t.P,u=t.N,a=[t];$u(t);for(var c=o;c.circle&&Math.abs(e-c.circle.x)<vm&&Math.abs(r-c.circle.cy)<vm;)o=c.P,a.unshift(c),$u(c),c=o;a.unshift(c),Xu(c);for(var s=u;s.circle&&Math.abs(e-s.circle.x)<vm&&Math.abs(r-s.circle.cy)<vm;)u=s.N,a.push(s),$u(s),s=u;a.push(s),Xu(s);var f,l=a.length;for(f=1;f<l;++f)s=a[f],c=a[f-1],Ru(s.edge,c.site,s.site,i);c=a[0],s=a[l-1],s.edge=zu(c.site,s.site,null,i),Hu(c),Hu(s)}function Gu(t){for(var n,e,r,i,o=t[0],u=t[1],a=sm._;a;)if(r=Ju(a,u)-o,r>vm)a=a.L;else{if(i=o-Qu(a,u),!(i>vm)){r>-vm?(n=a.P,e=a):i>-vm?(n=a,e=a.N):n=e=a;break}if(!a.R){n=a;break}a=a.R}Du(t);var c=Wu(t);if(sm.insert(n,c),n||e){if(n===e)return Xu(n),e=Wu(n.site),sm.insert(c,e),c.edge=e.edge=zu(n.site,c.site),Hu(n),void Hu(e);if(!e)return void(c.edge=zu(n.site,c.site));Xu(n),Xu(e);var s=n.site,f=s[0],l=s[1],h=t[0]-f,p=t[1]-l,d=e.site,v=d[0]-f,_=d[1]-l,y=2*(h*_-p*v),g=h*h+p*p,m=v*v+_*_,x=[(_*g-p*m)/y+f,(h*m-v*g)/y+l];Ru(e.edge,s,d,x),c.edge=zu(s,t,null,x),e.edge=zu(t,d,null,x),Hu(n),Hu(e)}}function Ju(t,n){var e=t.site,r=e[0],i=e[1],o=i-n;if(!o)return r;var u=t.P;if(!u)return-(1/0);e=u.site;var a=e[0],c=e[1],s=c-n;if(!s)return a;var f=a-r,l=1/o-1/s,h=f/s;return l?(-h+Math.sqrt(h*h-2*l*(f*f/(-2*s)-c+s/2+i-o/2)))/l+r:(r+a)/2}function Qu(t,n){var e=t.N;if(e)return Ju(e,n);var r=t.site;return r[1]===n?r[0]:1/0}function Ku(t,n,e){return(t[0]-e[0])*(n[1]-t[1])-(t[0]-n[0])*(e[1]-t[1])}function ta(t,n){return n[1]-t[1]||n[0]-t[0]}function na(t,n){var e,r,i,o=t.sort(ta).pop();for(hm=[],fm=new Array(t.length),sm=new ku,lm=new ku;;)if(i=cm,o&&(!i||o[1]<i.y||o[1]===i.y&&o[0]<i.x))o[0]===e&&o[1]===r||(Gu(o),e=o[0],r=o[1]),o=t.pop();else{if(!i)break;Zu(i.arc)}if(Yu(),n){var u=+n[0][0],a=+n[0][1],c=+n[1][0],s=+n[1][1];Uu(u,a,c,s),Bu(u,a,c,s)}this.edges=hm,this.cells=fm,sm=lm=hm=fm=null}function ea(t,n,e){this.target=t,this.type=n,this.transform=e}function ra(t,n,e){this.k=t,this.x=n,this.y=e}function ia(t){return t.__zoom||mm}function oa(){t.event.stopImmediatePropagation()}function ua(){return!t.event.button}function aa(){var t,n,e=this;return e instanceof SVGElement?(e=e.ownerSVGElement||e,t=e.width.baseVal.value,n=e.height.baseVal.value):(t=e.clientWidth,n=e.clientHeight),[[0,0],[t,n]]}function ca(){return this.__zoom||mm}function sa(){t.event.stopImmediatePropagation()}function fa(t){return{type:t}}function la(){return!t.event.button}function ha(){var t=this.ownerSVGElement||this;return[[0,0],[t.width.baseVal.value,t.height.baseVal.value]]}function pa(t){for(;!t.__brush;)if(!(t=t.parentNode))return;return t.__brush}function da(t){return t[0][0]===t[1][0]||t[0][1]===t[1][1]}function va(t){var n=t.__brush;return n?n.dim.output(n.selection):null}function _a(){return ga(Am)}function ya(){return ga(Cm)}function ga(n){function e(t){var e=t.property("__brush",a).selectAll(".overlay").data([fa("overlay")]);e.enter().append("rect").attr("class","overlay").attr("pointer-events","all").attr("cursor",Pm.overlay).merge(e).each(function(){var t=pa(this).extent;by(this).attr("x",t[0][0]).attr("y",t[0][1]).attr("width",t[1][0]-t[0][0]).attr("height",t[1][1]-t[0][1])}),t.selectAll(".selection").data([fa("selection")]).enter().append("rect").attr("class","selection").attr("cursor",Pm.selection).attr("fill","#777").attr("fill-opacity",.3).attr("stroke","#fff").attr("shape-rendering","crispEdges");var i=t.selectAll(".handle").data(n.handles,function(t){return t.type});i.exit().remove(),i.enter().append("rect").attr("class",function(t){return"handle handle--"+t.type}).attr("cursor",function(t){return Pm[t.type]}),t.each(r).attr("fill","none").attr("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush touchstart.brush",u)}function r(){var t=by(this),n=pa(this).selection;n?(t.selectAll(".selection").style("display",null).attr("x",n[0][0]).attr("y",n[0][1]).attr("width",n[1][0]-n[0][0]).attr("height",n[1][1]-n[0][1]),t.selectAll(".handle").style("display",null).attr("x",function(t){return"e"===t.type[t.type.length-1]?n[1][0]-h/2:n[0][0]-h/2}).attr("y",function(t){return"s"===t.type[0]?n[1][1]-h/2:n[0][1]-h/2}).attr("width",function(t){return"n"===t.type||"s"===t.type?n[1][0]-n[0][0]+h:h}).attr("height",function(t){return"e"===t.type||"w"===t.type?n[1][1]-n[0][1]+h:h})):t.selectAll(".selection,.handle").style("display","none").attr("x",null).attr("y",null).attr("width",null).attr("height",null)}function i(t,n){return t.__brush.emitter||new o(t,n)}function o(t,n){this.that=t,this.args=n,this.state=t.__brush,this.active=0}function u(){function e(){var t=F_(T);!U||w||M||(Math.abs(t[0]-O[0])>Math.abs(t[1]-O[1])?M=!0:w=!0),O=t,b=!0,Tm(),o()}function o(){var t;switch(m=O[0]-D[0],x=O[1]-D[1],k){case km:case Nm:S&&(m=Math.max(P-l,Math.min(q-v,m)),h=l+m,_=v+m),E&&(x=Math.max(R-p,Math.min(L-y,x)),d=p+x,g=y+x);break;case Sm:S<0?(m=Math.max(P-l,Math.min(q-l,m)),h=l+m,_=v):S>0&&(m=Math.max(P-v,Math.min(q-v,m)),h=l,_=v+m),E<0?(x=Math.max(R-p,Math.min(L-p,x)),d=p+x,g=y):E>0&&(x=Math.max(R-y,Math.min(L-y,x)),d=p,g=y+x);break;case Em:S&&(h=Math.max(P,Math.min(q,l-m*S)),_=Math.max(P,Math.min(q,v+m*S))),E&&(d=Math.max(R,Math.min(L,p-x*E)),g=Math.max(R,Math.min(L,y+x*E)))}_<h&&(S*=-1,t=l,l=v,v=t,t=h,h=_,_=t,N in Rm&&Y.attr("cursor",Pm[N=Rm[N]])),g<d&&(E*=-1,t=p,p=y,y=t,t=d,d=g,g=t,N in qm&&Y.attr("cursor",Pm[N=qm[N]])),A.selection&&(z=A.selection),w&&(h=z[0][0],_=z[1][0]),M&&(d=z[0][1],g=z[1][1]),z[0][0]===h&&z[0][1]===d&&z[1][0]===_&&z[1][1]===g||(A.selection=[[h,d],[_,g]],r.call(T),F.brush())}function u(){if(sa(),t.event.touches){if(t.event.touches.length)return;c&&clearTimeout(c),c=setTimeout(function(){c=null},500),I.on("touchmove.brush touchend.brush touchcancel.brush",null)}else mu(t.event.view,b),B.on("keydown.brush keyup.brush mousemove.brush mouseup.brush",null);I.attr("pointer-events","all"),Y.attr("cursor",Pm.overlay),A.selection&&(z=A.selection),da(z)&&(A.selection=null,r.call(T)),F.end()}function a(){switch(t.event.keyCode){case 16:U=S&&E;break;case 18:k===Sm&&(S&&(v=_-m*S,l=h+m*S),E&&(y=g-x*E,p=d+x*E),k=Em,o());break;case 32:k!==Sm&&k!==Em||(S<0?v=_-m:S>0&&(l=h-m),E<0?y=g-x:E>0&&(p=d-x),k=km,Y.attr("cursor",Pm.selection),o());break;default:return}Tm()}function s(){switch(t.event.keyCode){case 16:U&&(w=M=U=!1,o());break;case 18:k===Em&&(S<0?v=_:S>0&&(l=h),E<0?y=g:E>0&&(p=d),k=Sm,o());break;case 32:k===km&&(t.event.altKey?(S&&(v=_-m*S,l=h+m*S),E&&(y=g-x*E,p=d+x*E),k=Em):(S<0?v=_:S>0&&(l=h),E<0?y=g:E>0&&(p=d),k=Sm),Y.attr("cursor",Pm[N]),o());break;default:return}Tm()}if(t.event.touches){if(t.event.changedTouches.length<t.event.touches.length)return Tm()}else if(c)return;if(f.apply(this,arguments)){var l,h,p,d,v,_,y,g,m,x,b,w,M,T=this,N=t.event.target.__data__.type,k="selection"===(t.event.metaKey?N="overlay":N)?Nm:t.event.altKey?Em:Sm,S=n===Cm?null:Lm[N],E=n===Am?null:Um[N],A=pa(T),C=A.extent,z=A.selection,P=C[0][0],R=C[0][1],q=C[1][0],L=C[1][1],U=S&&E&&t.event.shiftKey,D=F_(T),O=D,F=i(T,arguments).beforestart();"overlay"===N?A.selection=z=[[l=n===Cm?P:D[0],p=n===Am?R:D[1]],[v=n===Cm?q:l,y=n===Am?L:p]]:(l=z[0][0],p=z[0][1],v=z[1][0],y=z[1][1]),h=l,d=p,_=v,g=y;var I=by(T).attr("pointer-events","none"),Y=I.selectAll(".overlay").attr("cursor",Pm[N]);if(t.event.touches)I.on("touchmove.brush",e,!0).on("touchend.brush touchcancel.brush",u,!0);else{var B=by(t.event.view).on("keydown.brush",a,!0).on("keyup.brush",s,!0).on("mousemove.brush",e,!0).on("mouseup.brush",u,!0);im(t.event.view)}sa(),Ly(T),r.call(T),F.start()}}function a(){var t=this.__brush||{selection:null};return t.extent=s.apply(this,arguments),t.dim=n,t}var c,s=ha,f=la,l=Pn(e,"start","brush","end"),h=6;return e.move=function(t,e){t.selection?t.on("start.brush",function(){i(this,arguments).beforestart().start()}).on("interrupt.brush end.brush",function(){i(this,arguments).end()}).tween("brush",function(){function t(t){u.selection=1===t&&da(s)?null:f(t),r.call(o),a.brush()}var o=this,u=o.__brush,a=i(o,arguments),c=u.selection,s=n.input("function"==typeof e?e.apply(this,arguments):e,u.extent),f=mp(c,s);
    return c&&s?t:t(1)}):t.each(function(){var t=this,o=arguments,u=t.__brush,a=n.input("function"==typeof e?e.apply(t,o):e,u.extent),c=i(t,o).beforestart();Ly(t),u.selection=null==a||da(a)?null:a,r.call(t),c.start().brush().end()})},o.prototype={beforestart:function(){return 1===++this.active&&(this.state.emitter=this,this.starting=!0),this},start:function(){return this.starting&&(this.starting=!1,this.emit("start")),this},brush:function(){return this.emit("brush"),this},end:function(){return 0===--this.active&&(delete this.state.emitter,this.emit("end")),this},emit:function(t){Xr(new Mm(e,t,n.output(this.state.selection)),l.apply,l,[t,this.that,this.args])}},e.extent=function(t){return arguments.length?(s="function"==typeof t?t:wm([[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]]),e):s},e.filter=function(t){return arguments.length?(f="function"==typeof t?t:wm(!!t),e):f},e.handleSize=function(t){return arguments.length?(h=+t,e):h},e.on=function(){var t=l.on.apply(l,arguments);return t===l?e:t},e}function ma(t){return function(n,e){return t(n.source.value+n.target.value,e.source.value+e.target.value)}}function xa(t){return t.source}function ba(t){return t.target}function wa(t){return t.radius}function Ma(t){return t.startAngle}function Ta(t){return t.endAngle}function Na(){this.reset()}function ka(t,n,e){var r=t.s=n+e,i=r-n,o=r-i;t.t=n-o+(e-i)}function Sa(t){return t>1?0:t<-1?Ax:Math.acos(t)}function Ea(t){return t>1?Cx:t<-1?-Cx:Math.asin(t)}function Aa(t){return(t=jx(t/2))*t}function Ca(){}function za(t,n){t&&$x.hasOwnProperty(t.type)&&$x[t.type](t,n)}function Pa(t,n,e){var r,i=-1,o=t.length-e;for(n.lineStart();++i<o;)r=t[i],n.point(r[0],r[1],r[2]);n.lineEnd()}function Ra(t,n){var e=-1,r=t.length;for(n.polygonStart();++e<r;)Pa(t[e],n,1);n.polygonEnd()}function qa(){Qx.point=Ua}function La(){Da(Zm,Gm)}function Ua(t,n){Qx.point=Da,Zm=t,Gm=n,t*=qx,n*=qx,Jm=t,Qm=Ox(n=n/2+zx),Km=jx(n)}function Da(t,n){t*=qx,n*=qx,n=n/2+zx;var e=t-Jm,r=e>=0?1:-1,i=r*e,o=Ox(n),u=jx(n),a=Km*u,c=Qm*o+a*Ox(i),s=a*r*jx(i);Gx.add(Dx(s,c)),Jm=t,Qm=o,Km=u}function Oa(t){return[Dx(t[1],t[0]),Ea(t[2])]}function Fa(t){var n=t[0],e=t[1],r=Ox(e);return[r*Ox(n),r*jx(n),jx(e)]}function Ia(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function Ya(t,n){return[t[1]*n[2]-t[2]*n[1],t[2]*n[0]-t[0]*n[2],t[0]*n[1]-t[1]*n[0]]}function Ba(t,n){t[0]+=n[0],t[1]+=n[1],t[2]+=n[2]}function ja(t,n){return[t[0]*n,t[1]*n,t[2]*n]}function Ha(t){var n=Xx(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=n,t[1]/=n,t[2]/=n}function Xa(t,n){cx.push(sx=[tx=t,ex=t]),n<nx&&(nx=n),n>rx&&(rx=n)}function Va(t,n){var e=Fa([t*qx,n*qx]);if(ax){var r=Ya(ax,e),i=[r[1],-r[0],0],o=Ya(i,r);Ha(o),o=Oa(o);var u,a=t-ix,c=a>0?1:-1,s=o[0]*Rx*c,f=Lx(a)>180;f^(c*ix<s&&s<c*t)?(u=o[1]*Rx,u>rx&&(rx=u)):(s=(s+360)%360-180,f^(c*ix<s&&s<c*t)?(u=-o[1]*Rx,u<nx&&(nx=u)):(n<nx&&(nx=n),n>rx&&(rx=n))),f?t<ix?Qa(tx,t)>Qa(tx,ex)&&(ex=t):Qa(t,ex)>Qa(tx,ex)&&(tx=t):ex>=tx?(t<tx&&(tx=t),t>ex&&(ex=t)):t>ix?Qa(tx,t)>Qa(tx,ex)&&(ex=t):Qa(t,ex)>Qa(tx,ex)&&(tx=t)}else Xa(t,n);ax=e,ix=t}function Wa(){nb.point=Va}function $a(){sx[0]=tx,sx[1]=ex,nb.point=Xa,ax=null}function Za(t,n){if(ax){var e=t-ix;tb.add(Lx(e)>180?e+(e>0?360:-360):e)}else ox=t,ux=n;Qx.point(t,n),Va(t,n)}function Ga(){Qx.lineStart()}function Ja(){Za(ox,ux),Qx.lineEnd(),Lx(tb)>Sx&&(tx=-(ex=180)),sx[0]=tx,sx[1]=ex,ax=null}function Qa(t,n){return(n-=t)<0?n+360:n}function Ka(t,n){return t[0]-n[0]}function tc(t,n){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}function nc(t,n){t*=qx,n*=qx;var e=Ox(n);ec(e*Ox(t),e*jx(t),jx(n))}function ec(t,n,e){++fx,hx+=(t-hx)/fx,px+=(n-px)/fx,dx+=(e-dx)/fx}function rc(){rb.point=ic}function ic(t,n){t*=qx,n*=qx;var e=Ox(n);Mx=e*Ox(t),Tx=e*jx(t),Nx=jx(n),rb.point=oc,ec(Mx,Tx,Nx)}function oc(t,n){t*=qx,n*=qx;var e=Ox(n),r=e*Ox(t),i=e*jx(t),o=jx(n),u=Dx(Xx((u=Tx*o-Nx*i)*u+(u=Nx*r-Mx*o)*u+(u=Mx*i-Tx*r)*u),Mx*r+Tx*i+Nx*o);lx+=u,vx+=u*(Mx+(Mx=r)),_x+=u*(Tx+(Tx=i)),yx+=u*(Nx+(Nx=o)),ec(Mx,Tx,Nx)}function uc(){rb.point=nc}function ac(){rb.point=sc}function cc(){fc(bx,wx),rb.point=nc}function sc(t,n){bx=t,wx=n,t*=qx,n*=qx,rb.point=fc;var e=Ox(n);Mx=e*Ox(t),Tx=e*jx(t),Nx=jx(n),ec(Mx,Tx,Nx)}function fc(t,n){t*=qx,n*=qx;var e=Ox(n),r=e*Ox(t),i=e*jx(t),o=jx(n),u=Tx*o-Nx*i,a=Nx*r-Mx*o,c=Mx*i-Tx*r,s=Xx(u*u+a*a+c*c),f=Mx*r+Tx*i+Nx*o,l=s&&-Sa(f)/s,h=Dx(s,f);gx+=l*u,mx+=l*a,xx+=l*c,lx+=h,vx+=h*(Mx+(Mx=r)),_x+=h*(Tx+(Tx=i)),yx+=h*(Nx+(Nx=o)),ec(Mx,Tx,Nx)}function lc(t,n){return[t>Ax?t-Px:t<-Ax?t+Px:t,n]}function hc(t,n,e){return(t%=Px)?n||e?ub(dc(t),vc(n,e)):dc(t):n||e?vc(n,e):lc}function pc(t){return function(n,e){return n+=t,[n>Ax?n-Px:n<-Ax?n+Px:n,e]}}function dc(t){var n=pc(t);return n.invert=pc(-t),n}function vc(t,n){function e(t,n){var e=Ox(n),a=Ox(t)*e,c=jx(t)*e,s=jx(n),f=s*r+a*i;return[Dx(c*o-f*u,a*r-s*i),Ea(f*o+c*u)]}var r=Ox(t),i=jx(t),o=Ox(n),u=jx(n);return e.invert=function(t,n){var e=Ox(n),a=Ox(t)*e,c=jx(t)*e,s=jx(n),f=s*o-c*u;return[Dx(c*o+s*u,a*r+f*i),Ea(f*r-a*i)]},e}function _c(t,n,e,r,i,o){if(e){var u=Ox(n),a=jx(n),c=r*e;null==i?(i=n+r*Px,o=n-c/2):(i=yc(u,i),o=yc(u,o),(r>0?i<o:i>o)&&(i+=r*Px));for(var s,f=i;r>0?f>o:f<o;f-=c)s=Oa([u,-a*Ox(f),-a*jx(f)]),t.point(s[0],s[1])}}function yc(t,n){n=Fa(n),n[0]-=t,Ha(n);var e=Sa(-n[1]);return((-n[2]<0?-e:e)+Px-Sx)%Px}function gc(t,n,e,r){this.x=t,this.z=n,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function mc(t){if(n=t.length){for(var n,e,r=0,i=t[0];++r<n;)i.n=e=t[r],e.p=i,i=e;i.n=e=t[0],e.p=i}}function xc(t,n,e,r){function i(i,o){return t<=i&&i<=e&&n<=o&&o<=r}function o(i,o,a,s){var f=0,l=0;if(null==i||(f=u(i,a))!==(l=u(o,a))||c(i,o)<0^a>0){do s.point(0===f||3===f?t:e,f>1?r:n);while((f=(f+a+4)%4)!==l)}else s.point(o[0],o[1])}function u(r,i){return Lx(r[0]-t)<Sx?i>0?0:3:Lx(r[0]-e)<Sx?i>0?2:1:Lx(r[1]-n)<Sx?i>0?1:0:i>0?3:2}function a(t,n){return c(t.x,n.x)}function c(t,n){var e=u(t,1),r=u(n,1);return e!==r?e-r:0===e?n[1]-t[1]:1===e?t[0]-n[0]:2===e?t[1]-n[1]:n[0]-t[0]}return function(u){function c(t,n){i(t,n)&&k.point(t,n)}function s(){for(var n=0,e=0,i=_.length;e<i;++e)for(var o,u,a=_[e],c=1,s=a.length,f=a[0],l=f[0],h=f[1];c<s;++c)o=l,u=h,f=a[c],l=f[0],h=f[1],u<=r?h>r&&(l-o)*(r-u)>(h-u)*(t-o)&&++n:h<=r&&(l-o)*(r-u)<(h-u)*(t-o)&&--n;return n}function f(){k=S,v=[],_=[],N=!0}function l(){var t=s(),n=N&&t,e=(v=Js(v)).length;(n||e)&&(u.polygonStart(),n&&(u.lineStart(),o(null,null,1,u),u.lineEnd()),e&&Mb(v,a,t,o,u),u.polygonEnd()),k=u,v=_=y=null}function h(){E.point=d,_&&_.push(y=[]),T=!0,M=!1,b=w=NaN}function p(){v&&(d(g,m),x&&M&&S.rejoin(),v.push(S.result())),E.point=c,M&&k.lineEnd()}function d(o,u){var a=i(o,u);if(_&&y.push([o,u]),T)g=o,m=u,x=a,T=!1,a&&(k.lineStart(),k.point(o,u));else if(a&&M)k.point(o,u);else{var c=[b=Math.max(Nb,Math.min(Tb,b)),w=Math.max(Nb,Math.min(Tb,w))],s=[o=Math.max(Nb,Math.min(Tb,o)),u=Math.max(Nb,Math.min(Tb,u))];bb(c,s,t,n,e,r)?(M||(k.lineStart(),k.point(c[0],c[1])),k.point(s[0],s[1]),a||k.lineEnd(),N=!1):a&&(k.lineStart(),k.point(o,u),N=!1)}b=o,w=u,M=a}var v,_,y,g,m,x,b,w,M,T,N,k=u,S=xb(),E={point:c,lineStart:h,lineEnd:p,polygonStart:f,polygonEnd:l};return E}}function bc(){Eb.point=Mc,Eb.lineEnd=wc}function wc(){Eb.point=Eb.lineEnd=Ca}function Mc(t,n){t*=qx,n*=qx,ab=t,cb=jx(n),sb=Ox(n),Eb.point=Tc}function Tc(t,n){t*=qx,n*=qx;var e=jx(n),r=Ox(n),i=Lx(t-ab),o=Ox(i),u=jx(i),a=r*u,c=sb*e-cb*r*o,s=cb*e+sb*r*o;Sb.add(Dx(Xx(a*a+c*c),s)),ab=t,cb=e,sb=r}function Nc(t,n,e){var r=Os(t,n-Sx,e).concat(n);return function(t){return r.map(function(n){return[t,n]})}}function kc(t,n,e){var r=Os(t,n-Sx,e).concat(n);return function(t){return r.map(function(n){return[n,t]})}}function Sc(){function t(){return{type:"MultiLineString",coordinates:n()}}function n(){return Os(Fx(o/_)*_,i,_).map(h).concat(Os(Fx(s/y)*y,c,y).map(p)).concat(Os(Fx(r/d)*d,e,d).filter(function(t){return Lx(t%_)>Sx}).map(f)).concat(Os(Fx(a/v)*v,u,v).filter(function(t){return Lx(t%y)>Sx}).map(l))}var e,r,i,o,u,a,c,s,f,l,h,p,d=10,v=d,_=90,y=360,g=2.5;return t.lines=function(){return n().map(function(t){return{type:"LineString",coordinates:t}})},t.outline=function(){return{type:"Polygon",coordinates:[h(o).concat(p(c).slice(1),h(i).reverse().slice(1),p(s).reverse().slice(1))]}},t.extent=function(n){return arguments.length?t.extentMajor(n).extentMinor(n):t.extentMinor()},t.extentMajor=function(n){return arguments.length?(o=+n[0][0],i=+n[1][0],s=+n[0][1],c=+n[1][1],o>i&&(n=o,o=i,i=n),s>c&&(n=s,s=c,c=n),t.precision(g)):[[o,s],[i,c]]},t.extentMinor=function(n){return arguments.length?(r=+n[0][0],e=+n[1][0],a=+n[0][1],u=+n[1][1],r>e&&(n=r,r=e,e=n),a>u&&(n=a,a=u,u=n),t.precision(g)):[[r,a],[e,u]]},t.step=function(n){return arguments.length?t.stepMajor(n).stepMinor(n):t.stepMinor()},t.stepMajor=function(n){return arguments.length?(_=+n[0],y=+n[1],t):[_,y]},t.stepMinor=function(n){return arguments.length?(d=+n[0],v=+n[1],t):[d,v]},t.precision=function(n){return arguments.length?(g=+n,f=Nc(a,u,90),l=kc(r,e,g),h=Nc(s,c,90),p=kc(o,i,g),t):g},t.extentMajor([[-180,-90+Sx],[180,90-Sx]]).extentMinor([[-180,-80-Sx],[180,80+Sx]])}function Ec(){return Sc()()}function Ac(){Db.point=Cc}function Cc(t,n){Db.point=zc,fb=hb=t,lb=pb=n}function zc(t,n){Ub.add(pb*t-hb*n),hb=t,pb=n}function Pc(){zc(fb,lb)}function Rc(t,n){t<Ob&&(Ob=t),t>Ib&&(Ib=t),n<Fb&&(Fb=n),n>Yb&&(Yb=n)}function qc(t,n){jb+=t,Hb+=n,++Xb}function Lc(){Qb.point=Uc}function Uc(t,n){Qb.point=Dc,qc(_b=t,yb=n)}function Dc(t,n){var e=t-_b,r=n-yb,i=Xx(e*e+r*r);Vb+=i*(_b+t)/2,Wb+=i*(yb+n)/2,$b+=i,qc(_b=t,yb=n)}function Oc(){Qb.point=qc}function Fc(){Qb.point=Yc}function Ic(){Bc(db,vb)}function Yc(t,n){Qb.point=Bc,qc(db=_b=t,vb=yb=n)}function Bc(t,n){var e=t-_b,r=n-yb,i=Xx(e*e+r*r);Vb+=i*(_b+t)/2,Wb+=i*(yb+n)/2,$b+=i,i=yb*t-_b*n,Zb+=i*(_b+t),Gb+=i*(yb+n),Jb+=3*i,qc(_b=t,yb=n)}function jc(t){this._context=t}function Hc(){this._string=[]}function Xc(t){return"m0,"+t+"a"+t+","+t+" 0 1,1 0,"+-2*t+"a"+t+","+t+" 0 1,1 0,"+2*t+"z"}function Vc(t){return t.length>1}function Wc(t,n){return((t=t.x)[0]<0?t[1]-Cx-Sx:Cx-t[1])-((n=n.x)[0]<0?n[1]-Cx-Sx:Cx-n[1])}function $c(t){var n,e=NaN,r=NaN,i=NaN;return{lineStart:function(){t.lineStart(),n=1},point:function(o,u){var a=o>0?Ax:-Ax,c=Lx(o-e);Lx(c-Ax)<Sx?(t.point(e,r=(r+u)/2>0?Cx:-Cx),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(a,r),t.point(o,r),n=0):i!==a&&c>=Ax&&(Lx(e-i)<Sx&&(e-=i*Sx),Lx(o-a)<Sx&&(o-=a*Sx),r=Zc(e,r,o,u),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(a,r),n=0),t.point(e=o,r=u),i=a},lineEnd:function(){t.lineEnd(),e=r=NaN},clean:function(){return 2-n}}}function Zc(t,n,e,r){var i,o,u=jx(t-e);return Lx(u)>Sx?Ux((jx(n)*(o=Ox(r))*jx(e)-jx(r)*(i=Ox(n))*jx(t))/(i*o*u)):(n+r)/2}function Gc(t,n,e,r){var i;if(null==t)i=e*Cx,r.point(-Ax,i),r.point(0,i),r.point(Ax,i),r.point(Ax,0),r.point(Ax,-i),r.point(0,-i),r.point(-Ax,-i),r.point(-Ax,0),r.point(-Ax,i);else if(Lx(t[0]-n[0])>Sx){var o=t[0]<n[0]?Ax:-Ax;i=e*o/2,r.point(-o,i),r.point(0,i),r.point(o,i)}else r.point(n[0],n[1])}function Jc(t){return function(n){var e=new Qc;for(var r in t)e[r]=t[r];return e.stream=n,e}}function Qc(){}function Kc(t,n,e){var r=n[1][0]-n[0][0],i=n[1][1]-n[0][1],o=t.clipExtent&&t.clipExtent();t.scale(150).translate([0,0]),null!=o&&t.clipExtent(null),Zx(e,t.stream(Bb));var u=Bb.result(),a=Math.min(r/(u[1][0]-u[0][0]),i/(u[1][1]-u[0][1])),c=+n[0][0]+(r-a*(u[1][0]+u[0][0]))/2,s=+n[0][1]+(i-a*(u[1][1]+u[0][1]))/2;return null!=o&&t.clipExtent(o),t.scale(150*a).translate([c,s])}function ts(t,n,e){return Kc(t,[[0,0],n],e)}function ns(t){return Jc({point:function(n,e){n=t(n,e),this.stream.point(n[0],n[1])}})}function es(t,n){function e(r,i,o,u,a,c,s,f,l,h,p,d,v,_){var y=s-r,g=f-i,m=y*y+g*g;if(m>4*n&&v--){var x=u+h,b=a+p,w=c+d,M=Xx(x*x+b*b+w*w),T=Ea(w/=M),N=Lx(Lx(w)-1)<Sx||Lx(o-l)<Sx?(o+l)/2:Dx(b,x),k=t(N,T),S=k[0],E=k[1],A=S-r,C=E-i,z=g*A-y*C;(z*z/m>n||Lx((y*A+g*C)/m-.5)>.3||u*h+a*p+c*d<aw)&&(e(r,i,o,u,a,c,S,E,N,x/=M,b/=M,w,v,_),_.point(S,E),e(S,E,N,x,b,w,s,f,l,h,p,d,v,_))}}return function(n){function r(e,r){e=t(e,r),n.point(e[0],e[1])}function i(){y=NaN,w.point=o,n.lineStart()}function o(r,i){var o=Fa([r,i]),u=t(r,i);e(y,g,_,m,x,b,y=u[0],g=u[1],_=r,m=o[0],x=o[1],b=o[2],uw,n),n.point(y,g)}function u(){w.point=r,n.lineEnd()}function a(){i(),w.point=c,w.lineEnd=s}function c(t,n){o(f=t,n),l=y,h=g,p=m,d=x,v=b,w.point=o}function s(){e(y,g,_,m,x,b,l,h,f,p,d,v,uw,n),w.lineEnd=u,u()}var f,l,h,p,d,v,_,y,g,m,x,b,w={point:r,lineStart:i,lineEnd:u,polygonStart:function(){n.polygonStart(),w.lineStart=a},polygonEnd:function(){n.polygonEnd(),w.lineStart=i}};return w}}function rs(t){return is(function(){return t})()}function is(t){function n(t){return t=f(t[0]*qx,t[1]*qx),[t[0]*_+a,c-t[1]*_]}function e(t){return t=f.invert((t[0]-a)/_,(c-t[1])/_),t&&[t[0]*Rx,t[1]*Rx]}function r(t,n){return t=u(t,n),[t[0]*_+a,c-t[1]*_]}function i(){f=ub(s=hc(b,w,M),u);var t=u(m,x);return a=y-t[0]*_,c=g+t[1]*_,o()}function o(){return d=v=null,n}var u,a,c,s,f,l,h,p,d,v,_=150,y=480,g=250,m=0,x=0,b=0,w=0,M=0,T=null,N=rw,k=null,S=qb,E=.5,A=cw(r,E);return n.stream=function(t){return d&&v===t?d:d=sw(N(s,A(S(v=t))))},n.clipAngle=function(t){return arguments.length?(N=+t?iw(T=t*qx,6*qx):(T=null,rw),o()):T*Rx},n.clipExtent=function(t){return arguments.length?(S=null==t?(k=l=h=p=null,qb):xc(k=+t[0][0],l=+t[0][1],h=+t[1][0],p=+t[1][1]),o()):null==k?null:[[k,l],[h,p]]},n.scale=function(t){return arguments.length?(_=+t,i()):_},n.translate=function(t){return arguments.length?(y=+t[0],g=+t[1],i()):[y,g]},n.center=function(t){return arguments.length?(m=t[0]%360*qx,x=t[1]%360*qx,i()):[m*Rx,x*Rx]},n.rotate=function(t){return arguments.length?(b=t[0]%360*qx,w=t[1]%360*qx,M=t.length>2?t[2]%360*qx:0,i()):[b*Rx,w*Rx,M*Rx]},n.precision=function(t){return arguments.length?(A=cw(r,E=t*t),o()):Xx(E)},n.fitExtent=function(t,e){return Kc(n,t,e)},n.fitSize=function(t,e){return ts(n,t,e)},function(){return u=t.apply(this,arguments),n.invert=u.invert&&e,i()}}function os(t){var n=0,e=Ax/3,r=is(t),i=r(n,e);return i.parallels=function(t){return arguments.length?r(n=t[0]*qx,e=t[1]*qx):[n*Rx,e*Rx]},i}function us(t){function n(t,n){return[t*e,jx(n)/e]}var e=Ox(t);return n.invert=function(t,n){return[t/e,Ea(n*e)]},n}function as(t,n){function e(t,n){var e=Xx(o-2*i*jx(n))/i;return[e*jx(t*=i),u-e*Ox(t)]}var r=jx(t),i=(r+jx(n))/2;if(Lx(i)<Sx)return us(t);var o=1+r*(2*i-r),u=Xx(o)/i;return e.invert=function(t,n){var e=u-n;return[Dx(t,Lx(e))/i*Hx(e),Ea((o-(t*t+e*e)*i*i)/(2*i))]},e}function cs(t){var n=t.length;return{point:function(e,r){for(var i=-1;++i<n;)t[i].point(e,r)},sphere:function(){for(var e=-1;++e<n;)t[e].sphere()},lineStart:function(){for(var e=-1;++e<n;)t[e].lineStart()},lineEnd:function(){for(var e=-1;++e<n;)t[e].lineEnd()},polygonStart:function(){for(var e=-1;++e<n;)t[e].polygonStart()},polygonEnd:function(){for(var e=-1;++e<n;)t[e].polygonEnd()}}}function ss(t){return function(n,e){var r=Ox(n),i=Ox(e),o=t(r*i);return[o*i*jx(n),o*jx(e)]}}function fs(t){return function(n,e){var r=Xx(n*n+e*e),i=t(r),o=jx(i),u=Ox(i);return[Dx(n*o,r*u),Ea(r&&e*o/r)]}}function ls(t,n){return[t,Yx(Vx((Cx+n)/2))]}function hs(t){var n,e=rs(t),r=e.scale,i=e.translate,o=e.clipExtent;return e.scale=function(t){return arguments.length?(r(t),n&&e.clipExtent(null),e):r()},e.translate=function(t){return arguments.length?(i(t),n&&e.clipExtent(null),e):i()},e.clipExtent=function(t){if(!arguments.length)return n?null:o();if(n=null==t){var u=Ax*r(),a=i();t=[[a[0]-u,a[1]-u],[a[0]+u,a[1]+u]]}return o(t),e},e.clipExtent(null)}function ps(t){return Vx((Cx+t)/2)}function ds(t,n){function e(t,n){o>0?n<-Cx+Sx&&(n=-Cx+Sx):n>Cx-Sx&&(n=Cx-Sx);var e=o/Bx(ps(n),i);return[e*jx(i*t),o-e*Ox(i*t)]}var r=Ox(t),i=t===n?jx(t):Yx(r/Ox(n))/Yx(ps(n)/ps(t)),o=r*Bx(ps(t),i)/i;return i?(e.invert=function(t,n){var e=o-n,r=Hx(i)*Xx(t*t+e*e);return[Dx(t,Lx(e))/i*Hx(e),2*Ux(Bx(o/r,1/i))-Cx]},e):ls}function vs(t,n){return[t,n]}function _s(t,n){function e(t,n){var e=o-n,r=i*t;return[e*jx(r),o-e*Ox(r)]}var r=Ox(t),i=t===n?jx(t):(r-Ox(n))/(n-t),o=r/i+t;return Lx(i)<Sx?vs:(e.invert=function(t,n){var e=o-n;return[Dx(t,Lx(e))/i*Hx(e),o-Hx(i)*Xx(t*t+e*e)]},e)}function ys(t,n){var e=Ox(n),r=Ox(t)*e;return[e*jx(t)/r,jx(n)/r]}function gs(t,n,e,r){return 1===t&&1===n&&0===e&&0===r?qb:Jc({point:function(i,o){this.stream.point(i*t+e,o*n+r)}})}function ms(t,n){return[Ox(n)*jx(t),jx(n)]}function xs(t,n){var e=Ox(n),r=1+Ox(t)*e;return[e*jx(t)/r,jx(n)/r]}function bs(t,n){return[Yx(Vx((Cx+n)/2)),-t]}var ws="4.4.0",Ms=function(t,n){return t<n?-1:t>n?1:t>=n?0:NaN},Ts=function(t){return 1===t.length&&(t=n(t)),{left:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)<0?r=o+1:i=o}return r},right:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var o=r+i>>>1;t(n[o],e)>0?i=o:r=o+1}return r}}},Ns=Ts(Ms),ks=Ns.right,Ss=Ns.left,Es=function(t,n){return n<t?-1:n>t?1:n>=t?0:NaN},As=function(t){return null===t?NaN:+t},Cs=function(t,n){var e,r,i=t.length,o=0,u=0,a=-1,c=0;if(null==n)for(;++a<i;)isNaN(e=As(t[a]))||(r=e-o,o+=r/++c,u+=r*(e-o));else for(;++a<i;)isNaN(e=As(n(t[a],a,t)))||(r=e-o,o+=r/++c,u+=r*(e-o));if(c>1)return u/(c-1)},zs=function(t,n){var e=Cs(t,n);return e?Math.sqrt(e):e},Ps=function(t,n){var e,r,i,o=-1,u=t.length;if(null==n){for(;++o<u;)if(null!=(r=t[o])&&r>=r){e=i=r;break}for(;++o<u;)null!=(r=t[o])&&(e>r&&(e=r),i<r&&(i=r))}else{for(;++o<u;)if(null!=(r=n(t[o],o,t))&&r>=r){e=i=r;break}for(;++o<u;)null!=(r=n(t[o],o,t))&&(e>r&&(e=r),i<r&&(i=r))}return[e,i]},Rs=Array.prototype,qs=Rs.slice,Ls=Rs.map,Us=function(t){return function(){return t}},Ds=function(t){return t},Os=function(t,n,e){t=+t,n=+n,e=(i=arguments.length)<2?(n=t,t=0,1):i<3?1:+e;for(var r=-1,i=0|Math.max(0,Math.ceil((n-t)/e)),o=new Array(i);++r<i;)o[r]=t+r*e;return o},Fs=Math.sqrt(50),Is=Math.sqrt(10),Ys=Math.sqrt(2),Bs=function(t,n,r){var i=e(t,n,r);return Os(Math.ceil(t/i)*i,Math.floor(n/i)*i+i/2,i)},js=function(t){return Math.ceil(Math.log(t.length)/Math.LN2)+1},Hs=function(){function t(t){var i,o,u=t.length,a=new Array(u);for(i=0;i<u;++i)a[i]=n(t[i],i,t);var c=e(a),s=c[0],f=c[1],l=r(a,s,f);Array.isArray(l)||(l=Bs(s,f,l));for(var h=l.length;l[0]<=s;)l.shift(),--h;for(;l[h-1]>=f;)l.pop(),--h;var p,d=new Array(h+1);for(i=0;i<=h;++i)p=d[i]=[],p.x0=i>0?l[i-1]:s,p.x1=i<h?l[i]:f;for(i=0;i<u;++i)o=a[i],s<=o&&o<=f&&d[ks(l,o,0,h)].push(t[i]);return d}var n=Ds,e=Ps,r=js;return t.value=function(e){return arguments.length?(n="function"==typeof e?e:Us(e),t):n},t.domain=function(n){return arguments.length?(e="function"==typeof n?n:Us([n[0],n[1]]),t):e},t.thresholds=function(n){return arguments.length?(r="function"==typeof n?n:Us(Array.isArray(n)?qs.call(n):n),t):r},t},Xs=function(t,n,e){if(null==e&&(e=As),r=t.length){if((n=+n)<=0||r<2)return+e(t[0],0,t);if(n>=1)return+e(t[r-1],r-1,t);var r,i=(r-1)*n,o=Math.floor(i),u=+e(t[o],o,t),a=+e(t[o+1],o+1,t);return u+(a-u)*(i-o)}},Vs=function(t,n,e){return t=Ls.call(t,As).sort(Ms),Math.ceil((e-n)/(2*(Xs(t,.75)-Xs(t,.25))*Math.pow(t.length,-1/3)))},Ws=function(t,n,e){return Math.ceil((e-n)/(3.5*zs(t)*Math.pow(t.length,-1/3)))},$s=function(t,n){var e,r,i=-1,o=t.length;if(null==n){for(;++i<o;)if(null!=(r=t[i])&&r>=r){e=r;break}for(;++i<o;)null!=(r=t[i])&&r>e&&(e=r)}else{for(;++i<o;)if(null!=(r=n(t[i],i,t))&&r>=r){e=r;break}for(;++i<o;)null!=(r=n(t[i],i,t))&&r>e&&(e=r)}return e},Zs=function(t,n){var e,r=0,i=t.length,o=-1,u=i;if(null==n)for(;++o<i;)isNaN(e=As(t[o]))?--u:r+=e;else for(;++o<i;)isNaN(e=As(n(t[o],o,t)))?--u:r+=e;if(u)return r/u},Gs=function(t,n){var e,r=[],i=t.length,o=-1;if(null==n)for(;++o<i;)isNaN(e=As(t[o]))||r.push(e);else for(;++o<i;)isNaN(e=As(n(t[o],o,t)))||r.push(e);return Xs(r.sort(Ms),.5)},Js=function(t){for(var n,e,r,i=t.length,o=-1,u=0;++o<i;)u+=t[o].length;for(e=new Array(u);--i>=0;)for(r=t[i],n=r.length;--n>=0;)e[--u]=r[n];return e},Qs=function(t,n){var e,r,i=-1,o=t.length;if(null==n){for(;++i<o;)if(null!=(r=t[i])&&r>=r){e=r;break}for(;++i<o;)null!=(r=t[i])&&e>r&&(e=r)}else{for(;++i<o;)if(null!=(r=n(t[i],i,t))&&r>=r){e=r;break}for(;++i<o;)null!=(r=n(t[i],i,t))&&e>r&&(e=r)}return e},Ks=function(t){for(var n=0,e=t.length-1,r=t[0],i=new Array(e<0?0:e);n<e;)i[n]=[r,r=t[++n]];return i},tf=function(t,n){for(var e=n.length,r=new Array(e);e--;)r[e]=t[n[e]];return r},nf=function(t,n){if(e=t.length){var e,r,i=0,o=0,u=t[o];for(n||(n=Ms);++i<e;)(n(r=t[i],u)<0||0!==n(u,u))&&(u=r,o=i);return 0===n(u,u)?o:void 0}},ef=function(t,n,e){for(var r,i,o=(null==e?t.length:e)-(n=null==n?0:+n);o;)i=Math.random()*o--|0,r=t[o+n],t[o+n]=t[i+n],t[i+n]=r;return t},rf=function(t,n){var e,r=0,i=t.length,o=-1;if(null==n)for(;++o<i;)(e=+t[o])&&(r+=e);else for(;++o<i;)(e=+n(t[o],o,t))&&(r+=e);return r},of=function(t){if(!(o=t.length))return[];for(var n=-1,e=Qs(t,r),i=new Array(e);++n<e;)for(var o,u=-1,a=i[n]=new Array(o);++u<o;)a[u]=t[u][n];return i},uf=function(){return of(arguments)},af="$";i.prototype=o.prototype={constructor:i,has:function(t){return af+t in this},get:function(t){return this[af+t]},set:function(t,n){return this[af+t]=n,this},remove:function(t){var n=af+t;return n in this&&delete this[n]},clear:function(){for(var t in this)t[0]===af&&delete this[t]},keys:function(){var t=[];for(var n in this)n[0]===af&&t.push(n.slice(1));return t},values:function(){var t=[];for(var n in this)n[0]===af&&t.push(this[n]);return t},entries:function(){var t=[];for(var n in this)n[0]===af&&t.push({key:n.slice(1),value:this[n]});return t},size:function(){var t=0;for(var n in this)n[0]===af&&++t;return t},empty:function(){for(var t in this)if(t[0]===af)return!1;return!0},each:function(t){for(var n in this)n[0]===af&&t(this[n],n.slice(1),this)}};var cf=function(){function t(n,i,u,a){if(i>=f.length)return null!=r?r(n):null!=e?n.sort(e):n;for(var c,s,l,h=-1,p=n.length,d=f[i++],v=o(),_=u();++h<p;)(l=v.get(c=d(s=n[h])+""))?l.push(s):v.set(c,[s]);return v.each(function(n,e){a(_,e,t(n,i,u,a))}),_}function n(t,e){if(++e>f.length)return t;var i,o=l[e-1];return null!=r&&e>=f.length?i=t.entries():(i=[],t.each(function(t,r){i.push({key:r,values:n(t,e)})})),null!=o?i.sort(function(t,n){return o(t.key,n.key)}):i}var e,r,i,f=[],l=[];return i={object:function(n){return t(n,0,u,a)},map:function(n){return t(n,0,c,s)},entries:function(e){return n(t(e,0,c,s),0)},key:function(t){return f.push(t),i},sortKeys:function(t){return l[f.length-1]=t,i},sortValues:function(t){return e=t,i},rollup:function(t){return r=t,i}}},sf=o.prototype;f.prototype=l.prototype={constructor:f,has:sf.has,add:function(t){return t+="",this[af+t]=t,this},remove:sf.remove,clear:sf.clear,values:sf.keys,size:sf.size,empty:sf.empty,each:sf.each};var ff=function(t){var n=[];for(var e in t)n.push(e);return n},lf=function(t){var n=[];for(var e in t)n.push(t[e]);return n},hf=function(t){var n=[];for(var e in t)n.push({key:e,value:t[e]});return n},pf=function(t,n){return t=null==t?0:+t,n=null==n?1:+n,1===arguments.length?(n=t,t=0):n-=t,function(){return Math.random()*n+t}},df=function(t,n){var e,r;return t=null==t?0:+t,n=null==n?1:+n,function(){var i;if(null!=e)i=e,e=null;else do e=2*Math.random()-1,i=2*Math.random()-1,r=e*e+i*i;while(!r||r>1);return t+n*i*Math.sqrt(-2*Math.log(r)/r)}},vf=function(){var t=df.apply(this,arguments);return function(){return Math.exp(t())}},_f=function(t){return function(){for(var n=0,e=0;e<t;++e)n+=Math.random();return n}},yf=function(t){var n=_f(t);return function(){return n()/t}},gf=function(t){return function(){return-Math.log(1-Math.random())/t}},mf=3,xf=function t(n){function e(t){return Math.pow(t,n)}return n=+n,e.exponent=t,e}(mf),bf=function t(n){function e(t){return 1-Math.pow(1-t,n)}return n=+n,e.exponent=t,e}(mf),wf=function t(n){function e(t){return((t*=2)<=1?Math.pow(t,n):2-Math.pow(2-t,n))/2}return n=+n,e.exponent=t,e}(mf),Mf=Math.PI,Tf=Mf/2,Nf=4/11,kf=6/11,Sf=8/11,Ef=.75,Af=9/11,Cf=10/11,zf=.9375,Pf=21/22,Rf=63/64,qf=1/Nf/Nf,Lf=1.70158,Uf=function t(n){function e(t){return t*t*((n+1)*t-n)}return n=+n,e.overshoot=t,e}(Lf),Df=function t(n){function e(t){return--t*t*((n+1)*t+n)+1}return n=+n,e.overshoot=t,e}(Lf),Of=function t(n){function e(t){return((t*=2)<1?t*t*((n+1)*t-n):(t-=2)*t*((n+1)*t+n)+2)/2}return n=+n,e.overshoot=t,e}(Lf),Ff=2*Math.PI,If=1,Yf=.3,Bf=function t(n,e){function r(t){return n*Math.pow(2,10*--t)*Math.sin((i-t)/e)}var i=Math.asin(1/(n=Math.max(1,n)))*(e/=Ff);return r.amplitude=function(n){return t(n,e*Ff)},r.period=function(e){return t(n,e)},r}(If,Yf),jf=function t(n,e){function r(t){return 1-n*Math.pow(2,-10*(t=+t))*Math.sin((t+i)/e)}var i=Math.asin(1/(n=Math.max(1,n)))*(e/=Ff);return r.amplitude=function(n){return t(n,e*Ff)},r.period=function(e){return t(n,e)},r}(If,Yf),Hf=function t(n,e){function r(t){return((t=2*t-1)<0?n*Math.pow(2,10*t)*Math.sin((i-t)/e):2-n*Math.pow(2,-10*t)*Math.sin((i+t)/e))/2}var i=Math.asin(1/(n=Math.max(1,n)))*(e/=Ff);return r.amplitude=function(n){return t(n,e*Ff)},r.period=function(e){return t(n,e)},r}(If,Yf),Xf=function(t){for(var n,e=-1,r=t.length,i=t[r-1],o=0;++e<r;)n=i,i=t[e],o+=n[1]*i[0]-n[0]*i[1];return o/2},Vf=function(t){for(var n,e,r=-1,i=t.length,o=0,u=0,a=t[i-1],c=0;++r<i;)n=a,a=t[r],c+=e=n[0]*a[1]-a[0]*n[1],o+=(n[0]+a[0])*e,u+=(n[1]+a[1])*e;return c*=3,[o/c,u/c]},Wf=function(t,n,e){return(n[0]-t[0])*(e[1]-t[1])-(n[1]-t[1])*(e[0]-t[0])},$f=function(t){if((e=t.length)<3)return null;var n,e,r=new Array(e),i=new Array(e);for(n=0;n<e;++n)r[n]=[+t[n][0],+t[n][1],n];for(r.sort(z),n=0;n<e;++n)i[n]=[r[n][0],-r[n][1]];var o=P(r),u=P(i),a=u[0]===o[0],c=u[u.length-1]===o[o.length-1],s=[];for(n=o.length-1;n>=0;--n)s.push(t[r[o[n]][2]]);for(n=+a;n<u.length-c;++n)s.push(t[r[u[n]][2]]);return s},Zf=function(t,n){for(var e,r,i=t.length,o=t[i-1],u=n[0],a=n[1],c=o[0],s=o[1],f=!1,l=0;l<i;++l)o=t[l],e=o[0],r=o[1],r>a!=s>a&&u<(c-e)*(a-r)/(s-r)+e&&(f=!f),c=e,s=r;return f},Gf=function(t){for(var n,e,r=-1,i=t.length,o=t[i-1],u=o[0],a=o[1],c=0;++r<i;)n=u,e=a,o=t[r],u=o[0],a=o[1],n-=u,e-=a,c+=Math.sqrt(n*n+e*e);return c},Jf=Math.PI,Qf=2*Jf,Kf=1e-6,tl=Qf-Kf;R.prototype=q.prototype={constructor:R,moveTo:function(t,n){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)},closePath:function(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(t,n){this._+="L"+(this._x1=+t)+","+(this._y1=+n)},quadraticCurveTo:function(t,n,e,r){this._+="Q"+ +t+","+ +n+","+(this._x1=+e)+","+(this._y1=+r)},bezierCurveTo:function(t,n,e,r,i,o){this._+="C"+ +t+","+ +n+","+ +e+","+ +r+","+(this._x1=+i)+","+(this._y1=+o)},arcTo:function(t,n,e,r,i){t=+t,n=+n,e=+e,r=+r,i=+i;var o=this._x1,u=this._y1,a=e-t,c=r-n,s=o-t,f=u-n,l=s*s+f*f;if(i<0)throw new Error("negative radius: "+i);if(null===this._x1)this._+="M"+(this._x1=t)+","+(this._y1=n);else if(l>Kf)if(Math.abs(f*a-c*s)>Kf&&i){var h=e-o,p=r-u,d=a*a+c*c,v=h*h+p*p,_=Math.sqrt(d),y=Math.sqrt(l),g=i*Math.tan((Jf-Math.acos((d+l-v)/(2*_*y)))/2),m=g/y,x=g/_;Math.abs(m-1)>Kf&&(this._+="L"+(t+m*s)+","+(n+m*f)),this._+="A"+i+","+i+",0,0,"+ +(f*h>s*p)+","+(this._x1=t+x*a)+","+(this._y1=n+x*c)}else this._+="L"+(this._x1=t)+","+(this._y1=n);else;},arc:function(t,n,e,r,i,o){t=+t,n=+n,e=+e;var u=e*Math.cos(r),a=e*Math.sin(r),c=t+u,s=n+a,f=1^o,l=o?r-i:i-r;if(e<0)throw new Error("negative radius: "+e);null===this._x1?this._+="M"+c+","+s:(Math.abs(this._x1-c)>Kf||Math.abs(this._y1-s)>Kf)&&(this._+="L"+c+","+s),e&&(l>tl?this._+="A"+e+","+e+",0,1,"+f+","+(t-u)+","+(n-a)+"A"+e+","+e+",0,1,"+f+","+(this._x1=c)+","+(this._y1=s):(l<0&&(l=l%Qf+Qf),this._+="A"+e+","+e+",0,"+ +(l>=Jf)+","+f+","+(this._x1=t+e*Math.cos(i))+","+(this._y1=n+e*Math.sin(i))))},rect:function(t,n,e,r){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)+"h"+ +e+"v"+ +r+"h"+-e+"Z"},toString:function(){return this._}};var nl=function(t){var n=+this._x.call(null,t),e=+this._y.call(null,t);return L(this.cover(n,e),n,e,t)},el=function(t,n){if(isNaN(t=+t)||isNaN(n=+n))return this;var e=this._x0,r=this._y0,i=this._x1,o=this._y1;if(isNaN(e))i=(e=Math.floor(t))+1,o=(r=Math.floor(n))+1;else{if(!(e>t||t>i||r>n||n>o))return this;var u,a,c=i-e,s=this._root;switch(a=(n<(r+o)/2)<<1|t<(e+i)/2){case 0:do u=new Array(4),u[a]=s,s=u;while(c*=2,i=e+c,o=r+c,t>i||n>o);break;case 1:do u=new Array(4),u[a]=s,s=u;while(c*=2,e=i-c,o=r+c,e>t||n>o);break;case 2:do u=new Array(4),u[a]=s,s=u;while(c*=2,i=e+c,r=o-c,t>i||r>n);break;case 3:do u=new Array(4),u[a]=s,s=u;while(c*=2,e=i-c,r=o-c,e>t||r>n)}this._root&&this._root.length&&(this._root=s)}return this._x0=e,this._y0=r,this._x1=i,this._y1=o,this},rl=function(){var t=[];return this.visit(function(n){if(!n.length)do t.push(n.data);while(n=n.next)}),t},il=function(t){return arguments.length?this.cover(+t[0][0],+t[0][1]).cover(+t[1][0],+t[1][1]):isNaN(this._x0)?void 0:[[this._x0,this._y0],[this._x1,this._y1]]},ol=function(t,n,e,r,i){this.node=t,this.x0=n,this.y0=e,this.x1=r,this.y1=i},ul=function(t,n,e){var r,i,o,u,a,c,s,f=this._x0,l=this._y0,h=this._x1,p=this._y1,d=[],v=this._root;for(v&&d.push(new ol(v,f,l,h,p)),null==e?e=1/0:(f=t-e,l=n-e,h=t+e,p=n+e,e*=e);c=d.pop();)if(!(!(v=c.node)||(i=c.x0)>h||(o=c.y0)>p||(u=c.x1)<f||(a=c.y1)<l))if(v.length){var _=(i+u)/2,y=(o+a)/2;d.push(new ol(v[3],_,y,u,a),new ol(v[2],i,y,_,a),new ol(v[1],_,o,u,y),new ol(v[0],i,o,_,y)),(s=(n>=y)<<1|t>=_)&&(c=d[d.length-1],d[d.length-1]=d[d.length-1-s],d[d.length-1-s]=c)}else{var g=t-+this._x.call(null,v.data),m=n-+this._y.call(null,v.data),x=g*g+m*m;if(x<e){var b=Math.sqrt(e=x);f=t-b,l=n-b,h=t+b,p=n+b,r=v.data}}return r},al=function(t){if(isNaN(o=+this._x.call(null,t))||isNaN(u=+this._y.call(null,t)))return this;var n,e,r,i,o,u,a,c,s,f,l,h,p=this._root,d=this._x0,v=this._y0,_=this._x1,y=this._y1;if(!p)return this;if(p.length)for(;;){if((s=o>=(a=(d+_)/2))?d=a:_=a,(f=u>=(c=(v+y)/2))?v=c:y=c,n=p,!(p=p[l=f<<1|s]))return this;if(!p.length)break;(n[l+1&3]||n[l+2&3]||n[l+3&3])&&(e=n,h=l)}for(;p.data!==t;)if(r=p,!(p=p.next))return this;return(i=p.next)&&delete p.next,r?(i?r.next=i:delete r.next,this):n?(i?n[l]=i:delete n[l],(p=n[0]||n[1]||n[2]||n[3])&&p===(n[3]||n[2]||n[1]||n[0])&&!p.length&&(e?e[h]=p:this._root=p),this):(this._root=i,this)},cl=function(){return this._root},sl=function(){var t=0;return this.visit(function(n){if(!n.length)do++t;while(n=n.next)}),t},fl=function(t){var n,e,r,i,o,u,a=[],c=this._root;for(c&&a.push(new ol(c,this._x0,this._y0,this._x1,this._y1));n=a.pop();)if(!t(c=n.node,r=n.x0,i=n.y0,o=n.x1,u=n.y1)&&c.length){var s=(r+o)/2,f=(i+u)/2;(e=c[3])&&a.push(new ol(e,s,f,o,u)),(e=c[2])&&a.push(new ol(e,r,f,s,u)),(e=c[1])&&a.push(new ol(e,s,i,o,f)),(e=c[0])&&a.push(new ol(e,r,i,s,f))}return this},ll=function(t){var n,e=[],r=[];for(this._root&&e.push(new ol(this._root,this._x0,this._y0,this._x1,this._y1));n=e.pop();){var i=n.node;if(i.length){var o,u=n.x0,a=n.y0,c=n.x1,s=n.y1,f=(u+c)/2,l=(a+s)/2;(o=i[0])&&e.push(new ol(o,u,a,f,l)),(o=i[1])&&e.push(new ol(o,f,a,c,l)),(o=i[2])&&e.push(new ol(o,u,l,f,s)),(o=i[3])&&e.push(new ol(o,f,l,c,s))}r.push(n)}for(;n=r.pop();)t(n.node,n.x0,n.y0,n.x1,n.y1);return this},hl=function(t){return arguments.length?(this._x=t,this):this._x},pl=function(t){return arguments.length?(this._y=t,this):this._y},dl=I.prototype=Y.prototype;dl.copy=function(){var t,n,e=new Y(this._x,this._y,this._x0,this._y0,this._x1,this._y1),r=this._root;if(!r)return e;if(!r.length)return e._root=B(r),e;for(t=[{source:r,target:e._root=new Array(4)}];r=t.pop();)for(var i=0;i<4;++i)(n=r.source[i])&&(n.length?t.push({source:n,target:r.target[i]=new Array(4)}):r.target[i]=B(n));return e},dl.add=nl,dl.addAll=U,dl.cover=el,dl.data=rl,dl.extent=il,dl.find=ul,dl.remove=al,dl.removeAll=D,dl.root=cl,dl.size=sl,dl.visit=fl,dl.visitAfter=ll,dl.x=hl,dl.y=pl;var vl=[].slice,_l={};j.prototype=Z.prototype={constructor:j,defer:function(t){if("function"!=typeof t||this._call)throw new Error;if(null!=this._error)return this;var n=vl.call(arguments,1);return n.push(t),++this._waiting,this._tasks.push(n),H(this),this},abort:function(){return null==this._error&&W(this,new Error("abort")),this},await:function(t){if("function"!=typeof t||this._call)throw new Error;return this._call=function(n,e){t.apply(null,[n].concat(e))},$(this),this},awaitAll:function(t){if("function"!=typeof t||this._call)throw new Error;return this._call=t,$(this),this}};var yl=function(t){return function(){
  return t}},gl=1e-12,ml=Math.PI,xl=ml/2,bl=2*ml,wl=function(){function t(){var t,s,f=+n.apply(this,arguments),l=+e.apply(this,arguments),h=o.apply(this,arguments)-xl,p=u.apply(this,arguments)-xl,d=Math.abs(p-h),v=p>h;if(c||(c=t=q()),l<f&&(s=l,l=f,f=s),l>gl)if(d>bl-gl)c.moveTo(l*Math.cos(h),l*Math.sin(h)),c.arc(0,0,l,h,p,!v),f>gl&&(c.moveTo(f*Math.cos(p),f*Math.sin(p)),c.arc(0,0,f,p,h,v));else{var _,y,g=h,m=p,x=h,b=p,w=d,M=d,T=a.apply(this,arguments)/2,N=T>gl&&(i?+i.apply(this,arguments):Math.sqrt(f*f+l*l)),k=Math.min(Math.abs(l-f)/2,+r.apply(this,arguments)),S=k,E=k;if(N>gl){var A=nt(N/f*Math.sin(T)),C=nt(N/l*Math.sin(T));(w-=2*A)>gl?(A*=v?1:-1,x+=A,b-=A):(w=0,x=b=(h+p)/2),(M-=2*C)>gl?(C*=v?1:-1,g+=C,m-=C):(M=0,g=m=(h+p)/2)}var z=l*Math.cos(g),P=l*Math.sin(g),R=f*Math.cos(b),L=f*Math.sin(b);if(k>gl){var U=l*Math.cos(m),D=l*Math.sin(m),O=f*Math.cos(x),F=f*Math.sin(x);if(d<ml){var I=w>gl?et(z,P,O,F,U,D,R,L):[R,L],Y=z-I[0],B=P-I[1],j=U-I[0],H=D-I[1],X=1/Math.sin(Math.acos((Y*j+B*H)/(Math.sqrt(Y*Y+B*B)*Math.sqrt(j*j+H*H)))/2),V=Math.sqrt(I[0]*I[0]+I[1]*I[1]);S=Math.min(k,(f-V)/(X-1)),E=Math.min(k,(l-V)/(X+1))}}M>gl?E>gl?(_=rt(O,F,z,P,l,E,v),y=rt(U,D,R,L,l,E,v),c.moveTo(_.cx+_.x01,_.cy+_.y01),E<k?c.arc(_.cx,_.cy,E,Math.atan2(_.y01,_.x01),Math.atan2(y.y01,y.x01),!v):(c.arc(_.cx,_.cy,E,Math.atan2(_.y01,_.x01),Math.atan2(_.y11,_.x11),!v),c.arc(0,0,l,Math.atan2(_.cy+_.y11,_.cx+_.x11),Math.atan2(y.cy+y.y11,y.cx+y.x11),!v),c.arc(y.cx,y.cy,E,Math.atan2(y.y11,y.x11),Math.atan2(y.y01,y.x01),!v))):(c.moveTo(z,P),c.arc(0,0,l,g,m,!v)):c.moveTo(z,P),f>gl&&w>gl?S>gl?(_=rt(R,L,U,D,f,-S,v),y=rt(z,P,O,F,f,-S,v),c.lineTo(_.cx+_.x01,_.cy+_.y01),S<k?c.arc(_.cx,_.cy,S,Math.atan2(_.y01,_.x01),Math.atan2(y.y01,y.x01),!v):(c.arc(_.cx,_.cy,S,Math.atan2(_.y01,_.x01),Math.atan2(_.y11,_.x11),!v),c.arc(0,0,f,Math.atan2(_.cy+_.y11,_.cx+_.x11),Math.atan2(y.cy+y.y11,y.cx+y.x11),v),c.arc(y.cx,y.cy,S,Math.atan2(y.y11,y.x11),Math.atan2(y.y01,y.x01),!v))):c.arc(0,0,f,b,x,v):c.lineTo(R,L)}else c.moveTo(0,0);if(c.closePath(),t)return c=null,t+""||null}var n=G,e=J,r=yl(0),i=null,o=Q,u=K,a=tt,c=null;return t.centroid=function(){var t=(+n.apply(this,arguments)+ +e.apply(this,arguments))/2,r=(+o.apply(this,arguments)+ +u.apply(this,arguments))/2-ml/2;return[Math.cos(r)*t,Math.sin(r)*t]},t.innerRadius=function(e){return arguments.length?(n="function"==typeof e?e:yl(+e),t):n},t.outerRadius=function(n){return arguments.length?(e="function"==typeof n?n:yl(+n),t):e},t.cornerRadius=function(n){return arguments.length?(r="function"==typeof n?n:yl(+n),t):r},t.padRadius=function(n){return arguments.length?(i=null==n?null:"function"==typeof n?n:yl(+n),t):i},t.startAngle=function(n){return arguments.length?(o="function"==typeof n?n:yl(+n),t):o},t.endAngle=function(n){return arguments.length?(u="function"==typeof n?n:yl(+n),t):u},t.padAngle=function(n){return arguments.length?(a="function"==typeof n?n:yl(+n),t):a},t.context=function(n){return arguments.length?(c=null==n?null:n,t):c},t};it.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:this._context.lineTo(t,n)}}};var Ml=function(t){return new it(t)},Tl=function(){function t(t){var a,c,s,f=t.length,l=!1;for(null==i&&(u=o(s=q())),a=0;a<=f;++a)!(a<f&&r(c=t[a],a,t))===l&&((l=!l)?u.lineStart():u.lineEnd()),l&&u.point(+n(c,a,t),+e(c,a,t));if(s)return u=null,s+""||null}var n=ot,e=ut,r=yl(!0),i=null,o=Ml,u=null;return t.x=function(e){return arguments.length?(n="function"==typeof e?e:yl(+e),t):n},t.y=function(n){return arguments.length?(e="function"==typeof n?n:yl(+n),t):e},t.defined=function(n){return arguments.length?(r="function"==typeof n?n:yl(!!n),t):r},t.curve=function(n){return arguments.length?(o=n,null!=i&&(u=o(i)),t):o},t.context=function(n){return arguments.length?(null==n?i=u=null:u=o(i=n),t):i},t},Nl=function(){function t(t){var n,f,l,h,p,d=t.length,v=!1,_=new Array(d),y=new Array(d);for(null==a&&(s=c(p=q())),n=0;n<=d;++n){if(!(n<d&&u(h=t[n],n,t))===v)if(v=!v)f=n,s.areaStart(),s.lineStart();else{for(s.lineEnd(),s.lineStart(),l=n-1;l>=f;--l)s.point(_[l],y[l]);s.lineEnd(),s.areaEnd()}v&&(_[n]=+e(h,n,t),y[n]=+i(h,n,t),s.point(r?+r(h,n,t):_[n],o?+o(h,n,t):y[n]))}if(p)return s=null,p+""||null}function n(){return Tl().defined(u).curve(c).context(a)}var e=ot,r=null,i=yl(0),o=ut,u=yl(!0),a=null,c=Ml,s=null;return t.x=function(n){return arguments.length?(e="function"==typeof n?n:yl(+n),r=null,t):e},t.x0=function(n){return arguments.length?(e="function"==typeof n?n:yl(+n),t):e},t.x1=function(n){return arguments.length?(r=null==n?null:"function"==typeof n?n:yl(+n),t):r},t.y=function(n){return arguments.length?(i="function"==typeof n?n:yl(+n),o=null,t):i},t.y0=function(n){return arguments.length?(i="function"==typeof n?n:yl(+n),t):i},t.y1=function(n){return arguments.length?(o=null==n?null:"function"==typeof n?n:yl(+n),t):o},t.lineX0=t.lineY0=function(){return n().x(e).y(i)},t.lineY1=function(){return n().x(e).y(o)},t.lineX1=function(){return n().x(r).y(i)},t.defined=function(n){return arguments.length?(u="function"==typeof n?n:yl(!!n),t):u},t.curve=function(n){return arguments.length?(c=n,null!=a&&(s=c(a)),t):c},t.context=function(n){return arguments.length?(null==n?a=s=null:s=c(a=n),t):a},t},kl=function(t,n){return n<t?-1:n>t?1:n>=t?0:NaN},Sl=function(t){return t},El=function(){function t(t){var a,c,s,f,l,h=t.length,p=0,d=new Array(h),v=new Array(h),_=+i.apply(this,arguments),y=Math.min(bl,Math.max(-bl,o.apply(this,arguments)-_)),g=Math.min(Math.abs(y)/h,u.apply(this,arguments)),m=g*(y<0?-1:1);for(a=0;a<h;++a)(l=v[d[a]=a]=+n(t[a],a,t))>0&&(p+=l);for(null!=e?d.sort(function(t,n){return e(v[t],v[n])}):null!=r&&d.sort(function(n,e){return r(t[n],t[e])}),a=0,s=p?(y-h*m)/p:0;a<h;++a,_=f)c=d[a],l=v[c],f=_+(l>0?l*s:0)+m,v[c]={data:t[c],index:a,value:l,startAngle:_,endAngle:f,padAngle:g};return v}var n=Sl,e=kl,r=null,i=yl(0),o=yl(bl),u=yl(0);return t.value=function(e){return arguments.length?(n="function"==typeof e?e:yl(+e),t):n},t.sortValues=function(n){return arguments.length?(e=n,r=null,t):e},t.sort=function(n){return arguments.length?(r=n,e=null,t):r},t.startAngle=function(n){return arguments.length?(i="function"==typeof n?n:yl(+n),t):i},t.endAngle=function(n){return arguments.length?(o="function"==typeof n?n:yl(+n),t):o},t.padAngle=function(n){return arguments.length?(u="function"==typeof n?n:yl(+n),t):u},t},Al=ct(Ml);at.prototype={areaStart:function(){this._curve.areaStart()},areaEnd:function(){this._curve.areaEnd()},lineStart:function(){this._curve.lineStart()},lineEnd:function(){this._curve.lineEnd()},point:function(t,n){this._curve.point(n*Math.sin(t),n*-Math.cos(t))}};var Cl=function(){return st(Tl().curve(Al))},zl=function(){var t=Nl().curve(Al),n=t.curve,e=t.lineX0,r=t.lineX1,i=t.lineY0,o=t.lineY1;return t.angle=t.x,delete t.x,t.startAngle=t.x0,delete t.x0,t.endAngle=t.x1,delete t.x1,t.radius=t.y,delete t.y,t.innerRadius=t.y0,delete t.y0,t.outerRadius=t.y1,delete t.y1,t.lineStartAngle=function(){return st(e())},delete t.lineX0,t.lineEndAngle=function(){return st(r())},delete t.lineX1,t.lineInnerRadius=function(){return st(i())},delete t.lineY0,t.lineOuterRadius=function(){return st(o())},delete t.lineY1,t.curve=function(t){return arguments.length?n(ct(t)):n()._curve},t},Pl={draw:function(t,n){var e=Math.sqrt(n/ml);t.moveTo(e,0),t.arc(0,0,e,0,bl)}},Rl={draw:function(t,n){var e=Math.sqrt(n/5)/2;t.moveTo(-3*e,-e),t.lineTo(-e,-e),t.lineTo(-e,-3*e),t.lineTo(e,-3*e),t.lineTo(e,-e),t.lineTo(3*e,-e),t.lineTo(3*e,e),t.lineTo(e,e),t.lineTo(e,3*e),t.lineTo(-e,3*e),t.lineTo(-e,e),t.lineTo(-3*e,e),t.closePath()}},ql=Math.sqrt(1/3),Ll=2*ql,Ul={draw:function(t,n){var e=Math.sqrt(n/Ll),r=e*ql;t.moveTo(0,-e),t.lineTo(r,0),t.lineTo(0,e),t.lineTo(-r,0),t.closePath()}},Dl=.8908130915292852,Ol=Math.sin(ml/10)/Math.sin(7*ml/10),Fl=Math.sin(bl/10)*Ol,Il=-Math.cos(bl/10)*Ol,Yl={draw:function(t,n){var e=Math.sqrt(n*Dl),r=Fl*e,i=Il*e;t.moveTo(0,-e),t.lineTo(r,i);for(var o=1;o<5;++o){var u=bl*o/5,a=Math.cos(u),c=Math.sin(u);t.lineTo(c*e,-a*e),t.lineTo(a*r-c*i,c*r+a*i)}t.closePath()}},Bl={draw:function(t,n){var e=Math.sqrt(n),r=-e/2;t.rect(r,r,e,e)}},jl=Math.sqrt(3),Hl={draw:function(t,n){var e=-Math.sqrt(n/(3*jl));t.moveTo(0,2*e),t.lineTo(-jl*e,-e),t.lineTo(jl*e,-e),t.closePath()}},Xl=-.5,Vl=Math.sqrt(3)/2,Wl=1/Math.sqrt(12),$l=3*(Wl/2+1),Zl={draw:function(t,n){var e=Math.sqrt(n/$l),r=e/2,i=e*Wl,o=r,u=e*Wl+e,a=-o,c=u;t.moveTo(r,i),t.lineTo(o,u),t.lineTo(a,c),t.lineTo(Xl*r-Vl*i,Vl*r+Xl*i),t.lineTo(Xl*o-Vl*u,Vl*o+Xl*u),t.lineTo(Xl*a-Vl*c,Vl*a+Xl*c),t.lineTo(Xl*r+Vl*i,Xl*i-Vl*r),t.lineTo(Xl*o+Vl*u,Xl*u-Vl*o),t.lineTo(Xl*a+Vl*c,Xl*c-Vl*a),t.closePath()}},Gl=[Pl,Rl,Ul,Bl,Yl,Hl,Zl],Jl=function(){function t(){var t;if(r||(r=t=q()),n.apply(this,arguments).draw(r,+e.apply(this,arguments)),t)return r=null,t+""||null}var n=yl(Pl),e=yl(64),r=null;return t.type=function(e){return arguments.length?(n="function"==typeof e?e:yl(e),t):n},t.size=function(n){return arguments.length?(e="function"==typeof n?n:yl(+n),t):e},t.context=function(n){return arguments.length?(r=null==n?null:n,t):r},t},Ql=function(){};lt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){switch(this._point){case 3:ft(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:ft(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}};var Kl=function(t){return new lt(t)};ht.prototype={areaStart:Ql,areaEnd:Ql,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x2,this._y2),this._context.closePath();break;case 2:this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3),this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3),this._context.closePath();break;case 3:this.point(this._x2,this._y2),this.point(this._x3,this._y3),this.point(this._x4,this._y4)}},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._x2=t,this._y2=n;break;case 1:this._point=2,this._x3=t,this._y3=n;break;case 2:this._point=3,this._x4=t,this._y4=n,this._context.moveTo((this._x0+4*this._x1+t)/6,(this._y0+4*this._y1+n)/6);break;default:ft(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}};var th=function(t){return new ht(t)};pt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var e=(this._x0+4*this._x1+t)/6,r=(this._y0+4*this._y1+n)/6;this._line?this._context.lineTo(e,r):this._context.moveTo(e,r);break;case 3:this._point=4;default:ft(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}};var nh=function(t){return new pt(t)};dt.prototype={lineStart:function(){this._x=[],this._y=[],this._basis.lineStart()},lineEnd:function(){var t=this._x,n=this._y,e=t.length-1;if(e>0)for(var r,i=t[0],o=n[0],u=t[e]-i,a=n[e]-o,c=-1;++c<=e;)r=c/e,this._basis.point(this._beta*t[c]+(1-this._beta)*(i+r*u),this._beta*n[c]+(1-this._beta)*(o+r*a));this._x=this._y=null,this._basis.lineEnd()},point:function(t,n){this._x.push(+t),this._y.push(+n)}};var eh=function t(n){function e(t){return 1===n?new lt(t):new dt(t,n)}return e.beta=function(n){return t(+n)},e}(.85);_t.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:vt(this,this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2,this._x1=t,this._y1=n;break;case 2:this._point=3;default:vt(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var rh=function t(n){function e(t){return new _t(t,n)}return e.tension=function(n){return t(+n)},e}(0);yt.prototype={areaStart:Ql,areaEnd:Ql,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._x3=t,this._y3=n;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=n);break;case 2:this._point=3,this._x5=t,this._y5=n;break;default:vt(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var ih=function t(n){function e(t){return new yt(t,n)}return e.tension=function(n){return t(+n)},e}(0);gt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:vt(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var oh=function t(n){function e(t){return new gt(t,n)}return e.tension=function(n){return t(+n)},e}(0);xt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3;default:mt(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var uh=function t(n){function e(t){return n?new xt(t,n):new _t(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);bt.prototype={areaStart:Ql,areaEnd:Ql,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._x3=t,this._y3=n;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=n);break;case 2:this._point=3,this._x5=t,this._y5=n;break;default:mt(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var ah=function t(n){function e(t){return n?new bt(t,n):new yt(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);wt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:mt(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var ch=function t(n){function e(t){return n?new wt(t,n):new gt(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);Mt.prototype={areaStart:Ql,areaEnd:Ql,lineStart:function(){this._point=0},lineEnd:function(){this._point&&this._context.closePath()},point:function(t,n){t=+t,n=+n,this._point?this._context.lineTo(t,n):(this._point=1,this._context.moveTo(t,n))}};var sh=function(t){return new Mt(t)};Et.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:St(this,this._t0,kt(this,this._t0))}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){var e=NaN;if(t=+t,n=+n,t!==this._x1||n!==this._y1){switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,St(this,kt(this,e=Nt(this,t,n)),e);break;default:St(this,this._t0,e=Nt(this,t,n))}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n,this._t0=e}}},(At.prototype=Object.create(Et.prototype)).point=function(t,n){Et.prototype.point.call(this,n,t)},Ct.prototype={moveTo:function(t,n){this._context.moveTo(n,t)},closePath:function(){this._context.closePath()},lineTo:function(t,n){this._context.lineTo(n,t)},bezierCurveTo:function(t,n,e,r,i,o){this._context.bezierCurveTo(n,t,r,e,o,i)}},Rt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=[],this._y=[]},lineEnd:function(){var t=this._x,n=this._y,e=t.length;if(e)if(this._line?this._context.lineTo(t[0],n[0]):this._context.moveTo(t[0],n[0]),2===e)this._context.lineTo(t[1],n[1]);else for(var r=qt(t),i=qt(n),o=0,u=1;u<e;++o,++u)this._context.bezierCurveTo(r[0][o],i[0][o],r[1][o],i[1][o],t[u],n[u]);(this._line||0!==this._line&&1===e)&&this._context.closePath(),this._line=1-this._line,this._x=this._y=null},point:function(t,n){this._x.push(+t),this._y.push(+n)}};var fh=function(t){return new Rt(t)};Lt.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=this._y=NaN,this._point=0},lineEnd:function(){0<this._t&&this._t<1&&2===this._point&&this._context.lineTo(this._x,this._y),(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line>=0&&(this._t=1-this._t,this._line=1-this._line)},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:if(this._t<=0)this._context.lineTo(this._x,n),this._context.lineTo(t,n);else{var e=this._x*(1-this._t)+t*this._t;this._context.lineTo(e,this._y),this._context.lineTo(e,n)}}this._x=t,this._y=n}};var lh=function(t){return new Lt(t,.5)},hh=Array.prototype.slice,ph=function(t,n){if((r=t.length)>1)for(var e,r,i=1,o=t[n[0]],u=o.length;i<r;++i){e=o,o=t[n[i]];for(var a=0;a<u;++a)o[a][1]+=o[a][0]=isNaN(e[a][1])?e[a][0]:e[a][1]}},dh=function(t){for(var n=t.length,e=new Array(n);--n>=0;)e[n]=n;return e},vh=function(){function t(t){var o,u,a=n.apply(this,arguments),c=t.length,s=a.length,f=new Array(s);for(o=0;o<s;++o){for(var l,h=a[o],p=f[o]=new Array(c),d=0;d<c;++d)p[d]=l=[0,+i(t[d],h,d,t)],l.data=t[d];p.key=h}for(o=0,u=e(f);o<s;++o)f[u[o]].index=o;return r(f,u),f}var n=yl([]),e=dh,r=ph,i=Ot;return t.keys=function(e){return arguments.length?(n="function"==typeof e?e:yl(hh.call(e)),t):n},t.value=function(n){return arguments.length?(i="function"==typeof n?n:yl(+n),t):i},t.order=function(n){return arguments.length?(e=null==n?dh:"function"==typeof n?n:yl(hh.call(n)),t):e},t.offset=function(n){return arguments.length?(r=null==n?ph:n,t):r},t},_h=function(t,n){if((r=t.length)>0){for(var e,r,i,o=0,u=t[0].length;o<u;++o){for(i=e=0;e<r;++e)i+=t[e][o][1]||0;if(i)for(e=0;e<r;++e)t[e][o][1]/=i}ph(t,n)}},yh=function(t,n){if((e=t.length)>0){for(var e,r=0,i=t[n[0]],o=i.length;r<o;++r){for(var u=0,a=0;u<e;++u)a+=t[u][r][1]||0;i[r][1]+=i[r][0]=-a/2}ph(t,n)}},gh=function(t,n){if((i=t.length)>0&&(r=(e=t[n[0]]).length)>0){for(var e,r,i,o=0,u=1;u<r;++u){for(var a=0,c=0,s=0;a<i;++a){for(var f=t[n[a]],l=f[u][1]||0,h=f[u-1][1]||0,p=(l-h)/2,d=0;d<a;++d){var v=t[n[d]],_=v[u][1]||0,y=v[u-1][1]||0;p+=_-y}c+=l,s+=p*l}e[u-1][1]+=e[u-1][0]=o,c&&(o-=s/c)}e[u-1][1]+=e[u-1][0]=o,ph(t,n)}},mh=function(t){var n=t.map(Ft);return dh(t).sort(function(t,e){return n[t]-n[e]})},xh=function(t){return mh(t).reverse()},bh=function(t){var n,e,r=t.length,i=t.map(Ft),o=dh(t).sort(function(t,n){return i[n]-i[t]}),u=0,a=0,c=[],s=[];for(n=0;n<r;++n)e=o[n],u<a?(u+=i[e],c.push(e)):(a+=i[e],s.push(e));return s.reverse().concat(c)},wh=function(t){return dh(t).reverse()},Mh=function(t,n,e){t.prototype=n.prototype=e,e.constructor=t},Th=.7,Nh=1/Th,kh="\\s*([+-]?\\d+)\\s*",Sh="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",Eh="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Ah=/^#([0-9a-f]{3})$/,Ch=/^#([0-9a-f]{6})$/,zh=new RegExp("^rgb\\("+[kh,kh,kh]+"\\)$"),Ph=new RegExp("^rgb\\("+[Eh,Eh,Eh]+"\\)$"),Rh=new RegExp("^rgba\\("+[kh,kh,kh,Sh]+"\\)$"),qh=new RegExp("^rgba\\("+[Eh,Eh,Eh,Sh]+"\\)$"),Lh=new RegExp("^hsl\\("+[Sh,Eh,Eh]+"\\)$"),Uh=new RegExp("^hsla\\("+[Sh,Eh,Eh,Sh]+"\\)$"),Dh={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};Mh(Yt,Bt,{displayable:function(){return this.rgb().displayable()},toString:function(){return this.rgb()+""}}),Mh(Wt,Vt,It(Yt,{brighter:function(t){return t=null==t?Nh:Math.pow(Nh,t),new Wt(this.r*t,this.g*t,this.b*t,this.opacity)},darker:function(t){return t=null==t?Th:Math.pow(Th,t),new Wt(this.r*t,this.g*t,this.b*t,this.opacity)},rgb:function(){return this},displayable:function(){return 0<=this.r&&this.r<=255&&0<=this.g&&this.g<=255&&0<=this.b&&this.b<=255&&0<=this.opacity&&this.opacity<=1},toString:function(){var t=this.opacity;return t=isNaN(t)?1:Math.max(0,Math.min(1,t)),(1===t?"rgb(":"rgba(")+Math.max(0,Math.min(255,Math.round(this.r)||0))+", "+Math.max(0,Math.min(255,Math.round(this.g)||0))+", "+Math.max(0,Math.min(255,Math.round(this.b)||0))+(1===t?")":", "+t+")")}})),Mh(Jt,Gt,It(Yt,{brighter:function(t){return t=null==t?Nh:Math.pow(Nh,t),new Jt(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?Th:Math.pow(Th,t),new Jt(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=this.h%360+360*(this.h<0),n=isNaN(t)||isNaN(this.s)?0:this.s,e=this.l,r=e+(e<.5?e:1-e)*n,i=2*e-r;return new Wt(Qt(t>=240?t-240:t+120,i,r),Qt(t,i,r),Qt(t<120?t+240:t-120,i,r),this.opacity)},displayable:function(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1}}));var Oh=Math.PI/180,Fh=180/Math.PI,Ih=18,Yh=.95047,Bh=1,jh=1.08883,Hh=4/29,Xh=6/29,Vh=3*Xh*Xh,Wh=Xh*Xh*Xh;Mh(nn,tn,It(Yt,{brighter:function(t){return new nn(this.l+Ih*(null==t?1:t),this.a,this.b,this.opacity)},darker:function(t){return new nn(this.l-Ih*(null==t?1:t),this.a,this.b,this.opacity)},rgb:function(){var t=(this.l+16)/116,n=isNaN(this.a)?t:t+this.a/500,e=isNaN(this.b)?t:t-this.b/200;return t=Bh*rn(t),n=Yh*rn(n),e=jh*rn(e),new Wt(on(3.2404542*n-1.5371385*t-.4985314*e),on(-.969266*n+1.8760108*t+.041556*e),on(.0556434*n-.2040259*t+1.0572252*e),this.opacity)}})),Mh(sn,cn,It(Yt,{brighter:function(t){return new sn(this.h,this.c,this.l+Ih*(null==t?1:t),this.opacity)},darker:function(t){return new sn(this.h,this.c,this.l-Ih*(null==t?1:t),this.opacity)},rgb:function(){return Kt(this).rgb()}}));var $h=-.14861,Zh=1.78277,Gh=-.29227,Jh=-.90649,Qh=1.97294,Kh=Qh*Jh,tp=Qh*Zh,np=Zh*Gh-Jh*$h;Mh(hn,ln,It(Yt,{brighter:function(t){return t=null==t?Nh:Math.pow(Nh,t),new hn(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?Th:Math.pow(Th,t),new hn(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=isNaN(this.h)?0:(this.h+120)*Oh,n=+this.l,e=isNaN(this.s)?0:this.s*n*(1-n),r=Math.cos(t),i=Math.sin(t);return new Wt(255*(n+e*($h*r+Zh*i)),255*(n+e*(Gh*r+Jh*i)),255*(n+e*(Qh*r)),this.opacity)}}));var ep,rp,ip,op,up=function(t){var n=t.length-1;return function(e){var r=e<=0?e=0:e>=1?(e=1,n-1):Math.floor(e*n),i=t[r],o=t[r+1],u=r>0?t[r-1]:2*i-o,a=r<n-1?t[r+2]:2*o-i;return pn((e-r/n)*n,u,i,o,a)}},ap=function(t){var n=t.length;return function(e){var r=Math.floor(((e%=1)<0?++e:e)*n),i=t[(r+n-1)%n],o=t[r%n],u=t[(r+1)%n],a=t[(r+2)%n];return pn((e-r/n)*n,i,o,u,a)}},cp=function(t){return function(){return t}},sp=function t(n){function e(t,n){var e=r((t=Vt(t)).r,(n=Vt(n)).r),i=r(t.g,n.g),o=r(t.b,n.b),u=r(t.opacity,n.opacity);return function(n){return t.r=e(n),t.g=i(n),t.b=o(n),t.opacity=u(n),t+""}}var r=yn(n);return e.gamma=t,e}(1),fp=mn(up),lp=mn(ap),hp=function(t,n){var e,r=n?n.length:0,i=t?Math.min(r,t.length):0,o=new Array(r),u=new Array(r);for(e=0;e<i;++e)o[e]=mp(t[e],n[e]);for(;e<r;++e)u[e]=n[e];return function(t){for(e=0;e<i;++e)u[e]=o[e](t);return u}},pp=function(t,n){var e=new Date;return t=+t,n-=t,function(r){return e.setTime(t+n*r),e}},dp=function(t,n){return t=+t,n-=t,function(e){return t+n*e}},vp=function(t,n){var e,r={},i={};null!==t&&"object"==typeof t||(t={}),null!==n&&"object"==typeof n||(n={});for(e in n)e in t?r[e]=mp(t[e],n[e]):i[e]=n[e];return function(t){for(e in r)i[e]=r[e](t);return i}},_p=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,yp=new RegExp(_p.source,"g"),gp=function(t,n){var e,r,i,o=_p.lastIndex=yp.lastIndex=0,u=-1,a=[],c=[];for(t+="",n+="";(e=_p.exec(t))&&(r=yp.exec(n));)(i=r.index)>o&&(i=n.slice(o,i),a[u]?a[u]+=i:a[++u]=i),(e=e[0])===(r=r[0])?a[u]?a[u]+=r:a[++u]=r:(a[++u]=null,c.push({i:u,x:dp(e,r)})),o=yp.lastIndex;return o<n.length&&(i=n.slice(o),a[u]?a[u]+=i:a[++u]=i),a.length<2?c[0]?bn(c[0].x):xn(n):(n=c.length,function(t){for(var e,r=0;r<n;++r)a[(e=c[r]).i]=e.x(t);return a.join("")})},mp=function(t,n){var e,r=typeof n;return null==n||"boolean"===r?cp(n):("number"===r?dp:"string"===r?(e=Bt(n))?(n=e,sp):gp:n instanceof Bt?sp:n instanceof Date?pp:Array.isArray(n)?hp:isNaN(n)?vp:dp)(t,n)},xp=function(t,n){return t=+t,n-=t,function(e){return Math.round(t+n*e)}},bp=180/Math.PI,wp={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1},Mp=function(t,n,e,r,i,o){var u,a,c;return(u=Math.sqrt(t*t+n*n))&&(t/=u,n/=u),(c=t*e+n*r)&&(e-=t*c,r-=n*c),(a=Math.sqrt(e*e+r*r))&&(e/=a,r/=a,c/=a),t*r<n*e&&(t=-t,n=-n,c=-c,u=-u),{translateX:i,translateY:o,rotate:Math.atan2(n,t)*bp,skewX:Math.atan(c)*bp,scaleX:u,scaleY:a}},Tp=Tn(wn,"px, ","px)","deg)"),Np=Tn(Mn,", ",")",")"),kp=Math.SQRT2,Sp=2,Ep=4,Ap=1e-12,Cp=function(t,n){var e,r,i=t[0],o=t[1],u=t[2],a=n[0],c=n[1],s=n[2],f=a-i,l=c-o,h=f*f+l*l;if(h<Ap)r=Math.log(s/u)/kp,e=function(t){return[i+t*f,o+t*l,u*Math.exp(kp*t*r)]};else{var p=Math.sqrt(h),d=(s*s-u*u+Ep*h)/(2*u*Sp*p),v=(s*s-u*u-Ep*h)/(2*s*Sp*p),_=Math.log(Math.sqrt(d*d+1)-d),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-_)/kp,e=function(t){var n=t*r,e=Nn(_),a=u/(Sp*p)*(e*Sn(kp*n+_)-kn(_));return[i+a*f,o+a*l,u*e/Nn(kp*n+_)]}}return e.duration=1e3*r,e},zp=En(_n),Pp=En(gn),Rp=Cn(_n),qp=Cn(gn),Lp=zn(_n),Up=zn(gn),Dp=function(t,n){for(var e=new Array(n),r=0;r<n;++r)e[r]=t(r/(n-1));return e},Op={value:function(){}};Rn.prototype=Pn.prototype={constructor:Rn,on:function(t,n){var e,r=this._,i=qn(t+"",r),o=-1,u=i.length;{if(!(arguments.length<2)){if(null!=n&&"function"!=typeof n)throw new Error("invalid callback: "+n);
  for(;++o<u;)if(e=(t=i[o]).type)r[e]=Un(r[e],t.name,n);else if(null==n)for(e in r)r[e]=Un(r[e],t.name,null);return this}for(;++o<u;)if((e=(t=i[o]).type)&&(e=Ln(r[e],t.name)))return e}},copy:function(){var t={},n=this._;for(var e in n)t[e]=n[e].slice();return new Rn(t)},call:function(t,n){if((e=arguments.length-2)>0)for(var e,r,i=new Array(e),o=0;o<e;++o)i[o]=arguments[o+2];if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(r=this._[t],o=0,e=r.length;o<e;++o)r[o].value.apply(n,i)},apply:function(t,n,e){if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(var r=this._[t],i=0,o=r.length;i<o;++i)r[i].value.apply(n,e)}};var Fp,Ip,Yp=function(t){function n(t,n){var r,i,o=e(t,function(t,e){return r?r(t,e-1):(i=t,void(r=n?On(t,n):Dn(t)))});return o.columns=i,o}function e(t,n){function e(){if(f>=s)return u;if(i)return i=!1,o;var n,e=f;if(34===t.charCodeAt(e)){for(var r=e;r++<s;)if(34===t.charCodeAt(r)){if(34!==t.charCodeAt(r+1))break;++r}return f=r+2,n=t.charCodeAt(r+1),13===n?(i=!0,10===t.charCodeAt(r+2)&&++f):10===n&&(i=!0),t.slice(e+1,r).replace(/""/g,'"')}for(;f<s;){var a=1;if(n=t.charCodeAt(f++),10===n)i=!0;else if(13===n)i=!0,10===t.charCodeAt(f)&&(++f,++a);else if(n!==c)continue;return t.slice(e,f-a)}return t.slice(e)}for(var r,i,o={},u={},a=[],s=t.length,f=0,l=0;(r=e())!==u;){for(var h=[];r!==o&&r!==u;)h.push(r),r=e();n&&null==(h=n(h,l++))||a.push(h)}return a}function r(n,e){return null==e&&(e=Fn(n)),[e.map(u).join(t)].concat(n.map(function(n){return e.map(function(t){return u(n[t])}).join(t)})).join("\n")}function i(t){return t.map(o).join("\n")}function o(n){return n.map(u).join(t)}function u(t){return null==t?"":a.test(t+="")?'"'+t.replace(/\"/g,'""')+'"':t}var a=new RegExp('["'+t+"\n]"),c=t.charCodeAt(0);return{parse:n,parseRows:e,format:r,formatRows:i}},Bp=Yp(","),jp=Bp.parse,Hp=Bp.parseRows,Xp=Bp.format,Vp=Bp.formatRows,Wp=Yp("\t"),$p=Wp.parse,Zp=Wp.parseRows,Gp=Wp.format,Jp=Wp.formatRows,Qp=function(t,n){function e(t){var n,e=f.status;if(!e&&Yn(f)||e>=200&&e<300||304===e){if(u)try{n=u.call(r,f)}catch(t){return void c.call("error",r,t)}else n=f;c.call("load",r,n)}else c.call("error",r,t)}var r,i,u,a,c=Pn("beforesend","progress","load","error"),s=o(),f=new XMLHttpRequest,l=null,h=null,p=0;if("undefined"==typeof XDomainRequest||"withCredentials"in f||!/^(http(s)?:)?\/\//.test(t)||(f=new XDomainRequest),"onload"in f?f.onload=f.onerror=f.ontimeout=e:f.onreadystatechange=function(t){f.readyState>3&&e(t)},f.onprogress=function(t){c.call("progress",r,t)},r={header:function(t,n){return t=(t+"").toLowerCase(),arguments.length<2?s.get(t):(null==n?s.remove(t):s.set(t,n+""),r)},mimeType:function(t){return arguments.length?(i=null==t?null:t+"",r):i},responseType:function(t){return arguments.length?(a=t,r):a},timeout:function(t){return arguments.length?(p=+t,r):p},user:function(t){return arguments.length<1?l:(l=null==t?null:t+"",r)},password:function(t){return arguments.length<1?h:(h=null==t?null:t+"",r)},response:function(t){return u=t,r},get:function(t,n){return r.send("GET",t,n)},post:function(t,n){return r.send("POST",t,n)},send:function(n,e,o){return f.open(n,t,!0,l,h),null==i||s.has("accept")||s.set("accept",i+",*/*"),f.setRequestHeader&&s.each(function(t,n){f.setRequestHeader(n,t)}),null!=i&&f.overrideMimeType&&f.overrideMimeType(i),null!=a&&(f.responseType=a),p>0&&(f.timeout=p),null==o&&"function"==typeof e&&(o=e,e=null),null!=o&&1===o.length&&(o=In(o)),null!=o&&r.on("error",o).on("load",function(t){o(null,t)}),c.call("beforesend",r,f),f.send(null==e?null:e),r},abort:function(){return f.abort(),r},on:function(){var t=c.on.apply(c,arguments);return t===c?r:t}},null!=n){if("function"!=typeof n)throw new Error("invalid callback: "+n);return r.get(n)}return r},Kp=function(t,n){return function(e,r){var i=Qp(e).mimeType(t).response(n);if(null!=r){if("function"!=typeof r)throw new Error("invalid callback: "+r);return i.get(r)}return i}},td=Kp("text/html",function(t){return document.createRange().createContextualFragment(t.responseText)}),nd=Kp("application/json",function(t){return JSON.parse(t.responseText)}),ed=Kp("text/plain",function(t){return t.responseText}),rd=Kp("application/xml",function(t){var n=t.responseXML;if(!n)throw new Error("parse error");return n}),id=function(t,n){return function(e,r,i){arguments.length<3&&(i=r,r=null);var o=Qp(e).mimeType(t);return o.row=function(t){return arguments.length?o.response(Bn(n,r=t)):r},o.row(r),i?o.get(i):o}},od=id("text/csv",jp),ud=id("text/tab-separated-values",$p),ad=0,cd=0,sd=0,fd=1e3,ld=0,hd=0,pd=0,dd="object"==typeof performance&&performance.now?performance:Date,vd="function"==typeof requestAnimationFrame?requestAnimationFrame:function(t){setTimeout(t,17)};Xn.prototype=Vn.prototype={constructor:Xn,restart:function(t,n,e){if("function"!=typeof t)throw new TypeError("callback is not a function");e=(null==e?jn():+e)+(null==n?0:+n),this._next||Ip===this||(Ip?Ip._next=this:Fp=this,Ip=this),this._call=t,this._time=e,Jn()},stop:function(){this._call&&(this._call=null,this._time=1/0,Jn())}};var _d=function(t,n,e){var r=new Xn;return n=null==n?0:+n,r.restart(function(e){r.stop(),t(e+n)},n,e),r},yd=function(t,n,e){var r=new Xn,i=n;return null==n?(r.restart(t,n,e),r):(n=+n,e=null==e?jn():+e,r.restart(function o(u){u+=i,r.restart(o,i+=n,e),t(u)},n,e),r)},gd=new Date,md=new Date,xd=Qn(function(){},function(t,n){t.setTime(+t+n)},function(t,n){return n-t});xd.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?Qn(function(n){n.setTime(Math.floor(n/t)*t)},function(n,e){n.setTime(+n+e*t)},function(n,e){return(e-n)/t}):xd:null};var bd=xd.range,wd=1e3,Md=6e4,Td=36e5,Nd=864e5,kd=6048e5,Sd=Qn(function(t){t.setTime(Math.floor(t/wd)*wd)},function(t,n){t.setTime(+t+n*wd)},function(t,n){return(n-t)/wd},function(t){return t.getUTCSeconds()}),Ed=Sd.range,Ad=Qn(function(t){t.setTime(Math.floor(t/Md)*Md)},function(t,n){t.setTime(+t+n*Md)},function(t,n){return(n-t)/Md},function(t){return t.getMinutes()}),Cd=Ad.range,zd=Qn(function(t){var n=t.getTimezoneOffset()*Md%Td;n<0&&(n+=Td),t.setTime(Math.floor((+t-n)/Td)*Td+n)},function(t,n){t.setTime(+t+n*Td)},function(t,n){return(n-t)/Td},function(t){return t.getHours()}),Pd=zd.range,Rd=Qn(function(t){t.setHours(0,0,0,0)},function(t,n){t.setDate(t.getDate()+n)},function(t,n){return(n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*Md)/Nd},function(t){return t.getDate()-1}),qd=Rd.range,Ld=Kn(0),Ud=Kn(1),Dd=Kn(2),Od=Kn(3),Fd=Kn(4),Id=Kn(5),Yd=Kn(6),Bd=Ld.range,jd=Ud.range,Hd=Dd.range,Xd=Od.range,Vd=Fd.range,Wd=Id.range,$d=Yd.range,Zd=Qn(function(t){t.setDate(1),t.setHours(0,0,0,0)},function(t,n){t.setMonth(t.getMonth()+n)},function(t,n){return n.getMonth()-t.getMonth()+12*(n.getFullYear()-t.getFullYear())},function(t){return t.getMonth()}),Gd=Zd.range,Jd=Qn(function(t){t.setMonth(0,1),t.setHours(0,0,0,0)},function(t,n){t.setFullYear(t.getFullYear()+n)},function(t,n){return n.getFullYear()-t.getFullYear()},function(t){return t.getFullYear()});Jd.every=function(t){return isFinite(t=Math.floor(t))&&t>0?Qn(function(n){n.setFullYear(Math.floor(n.getFullYear()/t)*t),n.setMonth(0,1),n.setHours(0,0,0,0)},function(n,e){n.setFullYear(n.getFullYear()+e*t)}):null};var Qd=Jd.range,Kd=Qn(function(t){t.setUTCSeconds(0,0)},function(t,n){t.setTime(+t+n*Md)},function(t,n){return(n-t)/Md},function(t){return t.getUTCMinutes()}),tv=Kd.range,nv=Qn(function(t){t.setUTCMinutes(0,0,0)},function(t,n){t.setTime(+t+n*Td)},function(t,n){return(n-t)/Td},function(t){return t.getUTCHours()}),ev=nv.range,rv=Qn(function(t){t.setUTCHours(0,0,0,0)},function(t,n){t.setUTCDate(t.getUTCDate()+n)},function(t,n){return(n-t)/Nd},function(t){return t.getUTCDate()-1}),iv=rv.range,ov=te(0),uv=te(1),av=te(2),cv=te(3),sv=te(4),fv=te(5),lv=te(6),hv=ov.range,pv=uv.range,dv=av.range,vv=cv.range,_v=sv.range,yv=fv.range,gv=lv.range,mv=Qn(function(t){t.setUTCDate(1),t.setUTCHours(0,0,0,0)},function(t,n){t.setUTCMonth(t.getUTCMonth()+n)},function(t,n){return n.getUTCMonth()-t.getUTCMonth()+12*(n.getUTCFullYear()-t.getUTCFullYear())},function(t){return t.getUTCMonth()}),xv=mv.range,bv=Qn(function(t){t.setUTCMonth(0,1),t.setUTCHours(0,0,0,0)},function(t,n){t.setUTCFullYear(t.getUTCFullYear()+n)},function(t,n){return n.getUTCFullYear()-t.getUTCFullYear()},function(t){return t.getUTCFullYear()});bv.every=function(t){return isFinite(t=Math.floor(t))&&t>0?Qn(function(n){n.setUTCFullYear(Math.floor(n.getUTCFullYear()/t)*t),n.setUTCMonth(0,1),n.setUTCHours(0,0,0,0)},function(n,e){n.setUTCFullYear(n.getUTCFullYear()+e*t)}):null};var wv,Mv=bv.range,Tv=function(t,n){if((e=(t=n?t.toExponential(n-1):t.toExponential()).indexOf("e"))<0)return null;var e,r=t.slice(0,e);return[r.length>1?r[0]+r.slice(2):r,+t.slice(e+1)]},Nv=function(t){return t=Tv(Math.abs(t)),t?t[1]:NaN},kv=function(t,n){return function(e,r){for(var i=e.length,o=[],u=0,a=t[0],c=0;i>0&&a>0&&(c+a+1>r&&(a=Math.max(1,r-c)),o.push(e.substring(i-=a,i+a)),!((c+=a+1)>r));)a=t[u=(u+1)%t.length];return o.reverse().join(n)}},Sv=function(t,n){t=t.toPrecision(n);t:for(var e,r=t.length,i=1,o=-1;i<r;++i)switch(t[i]){case".":o=e=i;break;case"0":0===o&&(o=i),e=i;break;case"e":break t;default:o>0&&(o=0)}return o>0?t.slice(0,o)+t.slice(e+1):t},Ev=function(t,n){var e=Tv(t,n);if(!e)return t+"";var r=e[0],i=e[1],o=i-(wv=3*Math.max(-8,Math.min(8,Math.floor(i/3))))+1,u=r.length;return o===u?r:o>u?r+new Array(o-u+1).join("0"):o>0?r.slice(0,o)+"."+r.slice(o):"0."+new Array(1-o).join("0")+Tv(t,Math.max(0,n+o-1))[0]},Av=function(t,n){var e=Tv(t,n);if(!e)return t+"";var r=e[0],i=e[1];return i<0?"0."+new Array(-i).join("0")+r:r.length>i+1?r.slice(0,i+1)+"."+r.slice(i+1):r+new Array(i-r.length+2).join("0")},Cv={"":Sv,"%":function(t,n){return(100*t).toFixed(n)},b:function(t){return Math.round(t).toString(2)},c:function(t){return t+""},d:function(t){return Math.round(t).toString(10)},e:function(t,n){return t.toExponential(n)},f:function(t,n){return t.toFixed(n)},g:function(t,n){return t.toPrecision(n)},o:function(t){return Math.round(t).toString(8)},p:function(t,n){return Av(100*t,n)},r:Av,s:Ev,X:function(t){return Math.round(t).toString(16).toUpperCase()},x:function(t){return Math.round(t).toString(16)}},zv=/^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i,Pv=function(t){return new ne(t)};ne.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(null==this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(null==this.precision?"":"."+Math.max(0,0|this.precision))+this.type};var Rv,qv=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"],Lv=function(t){function n(t){function n(t){var n,i,c,g=d,m=v;if("c"===p)m=_(t)+m,t="";else{t=+t;var x=(t<0||1/t<0)&&(t*=-1,!0);if(t=_(t,h),x)for(n=-1,i=t.length,x=!1;++n<i;)if(c=t.charCodeAt(n),48<c&&c<58||"x"===p&&96<c&&c<103||"X"===p&&64<c&&c<71){x=!0;break}if(g=(x?"("===a?a:"-":"-"===a||"("===a?"":a)+g,m=m+("s"===p?qv[8+wv/3]:"")+(x&&"("===a?")":""),y)for(n=-1,i=t.length;++n<i;)if(c=t.charCodeAt(n),48>c||c>57){m=(46===c?o+t.slice(n+1):t.slice(n))+m,t=t.slice(0,n);break}}l&&!s&&(t=r(t,1/0));var b=g.length+t.length+m.length,w=b<f?new Array(f-b+1).join(e):"";switch(l&&s&&(t=r(w+t,w.length?f-m.length:1/0),w=""),u){case"<":return g+t+m+w;case"=":return g+w+t+m;case"^":return w.slice(0,b=w.length>>1)+g+t+m+w.slice(b)}return w+g+t+m}t=Pv(t);var e=t.fill,u=t.align,a=t.sign,c=t.symbol,s=t.zero,f=t.width,l=t.comma,h=t.precision,p=t.type,d="$"===c?i[0]:"#"===c&&/[boxX]/.test(p)?"0"+p.toLowerCase():"",v="$"===c?i[1]:/[%p]/.test(p)?"%":"",_=Cv[p],y=!p||/[defgprs%]/.test(p);return h=null==h?p?6:12:/[gprs]/.test(p)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),n.toString=function(){return t+""},n}function e(t,e){var r=n((t=Pv(t),t.type="f",t)),i=3*Math.max(-8,Math.min(8,Math.floor(Nv(e)/3))),o=Math.pow(10,-i),u=qv[8+i/3];return function(t){return r(o*t)+u}}var r=t.grouping&&t.thousands?kv(t.grouping,t.thousands):ee,i=t.currency,o=t.decimal;return{format:n,formatPrefix:e}};re({decimal:".",thousands:",",grouping:[3],currency:["$",""]});var Uv,Dv=function(t){return Math.max(0,-Nv(Math.abs(t)))},Ov=function(t,n){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(Nv(n)/3)))-Nv(Math.abs(t)))},Fv=function(t,n){return t=Math.abs(t),n=Math.abs(n)-t,Math.max(0,Nv(n)-Nv(t))+1},Iv={"-":"",_:" ",0:"0"},Yv=/^\s*\d+/,Bv=/^%/,jv=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;nr({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});var Hv="%Y-%m-%dT%H:%M:%S.%LZ",Xv=Date.prototype.toISOString?er:t.utcFormat(Hv),Vv=+new Date("2000-01-01T00:00:00.000Z")?rr:t.utcParse(Hv),Wv=Array.prototype,$v=Wv.map,Zv=Wv.slice,Gv={name:"implicit"},Jv=function(t){return function(){return t}},Qv=function(t){return+t},Kv=[0,1],t_=function(n,r,i){var o,u=n[0],a=n[n.length-1],c=e(u,a,null==r?10:r);switch(i=Pv(null==i?",f":i),i.type){case"s":var s=Math.max(Math.abs(u),Math.abs(a));return null!=i.precision||isNaN(o=Ov(c,s))||(i.precision=o),t.formatPrefix(i,s);case"":case"e":case"g":case"p":case"r":null!=i.precision||isNaN(o=Fv(c,Math.max(Math.abs(u),Math.abs(a))))||(i.precision=o-("e"===i.type));break;case"f":case"%":null!=i.precision||isNaN(o=Dv(c))||(i.precision=o-2*("%"===i.type))}return t.format(i)},n_=function(t,n){t=t.slice();var e,r=0,i=t.length-1,o=t[r],u=t[i];return u<o&&(e=r,r=i,i=e,e=o,o=u,u=e),t[r]=n.floor(o),t[i]=n.ceil(u),t},e_=1e3,r_=60*e_,i_=60*r_,o_=24*i_,u_=7*o_,a_=30*o_,c_=365*o_,s_=function(){return Rr(Jd,Zd,Ld,Rd,zd,Ad,Sd,xd,t.timeFormat).domain([new Date(2e3,0,1),new Date(2e3,0,2)])},f_=function(){return Rr(bv,mv,ov,rv,nv,Kd,Sd,xd,t.utcFormat).domain([Date.UTC(2e3,0,1),Date.UTC(2e3,0,2)])},l_=function(t){return t.match(/.{6}/g).map(function(t){return"#"+t})},h_=l_("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),p_=l_("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"),d_=l_("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"),v_=l_("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"),__=Up(ln(300,.5,0),ln(-240,.5,1)),y_=Up(ln(-100,.75,.35),ln(80,1.5,.8)),g_=Up(ln(260,.75,.35),ln(80,1.5,.8)),m_=ln(),x_=function(t){(t<0||t>1)&&(t-=Math.floor(t));var n=Math.abs(t-.5);return m_.h=360*t-100,m_.s=1.5-1.5*n,m_.l=.8-.9*n,m_+""},b_=qr(l_("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")),w_=qr(l_("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),M_=qr(l_("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),T_=qr(l_("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")),N_="http://www.w3.org/1999/xhtml",k_={svg:"http://www.w3.org/2000/svg",xhtml:N_,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},S_=function(t){var n=t+="",e=n.indexOf(":");return e>=0&&"xmlns"!==(n=t.slice(0,e))&&(t=t.slice(e+1)),k_.hasOwnProperty(n)?{space:k_[n],local:t}:t},E_=function(t){var n=S_(t);return(n.local?Dr:Ur)(n)},A_=0;Fr.prototype=Or.prototype={constructor:Fr,get:function(t){for(var n=this._;!(n in t);)if(!(t=t.parentNode))return;return t[n]},set:function(t,n){return t[this._]=n},remove:function(t){return this._ in t&&delete t[this._]},toString:function(){return this._}};var C_=function(t){return function(){return this.matches(t)}};if("undefined"!=typeof document){var z_=document.documentElement;if(!z_.matches){var P_=z_.webkitMatchesSelector||z_.msMatchesSelector||z_.mozMatchesSelector||z_.oMatchesSelector;C_=function(t){return function(){return P_.call(this,t)}}}}var R_=C_,q_={};if(t.event=null,"undefined"!=typeof document){var L_=document.documentElement;"onmouseenter"in L_||(q_={mouseenter:"mouseover",mouseleave:"mouseout"})}var U_=function(t,n,e){var r,i,o=Br(t+""),u=o.length;{if(!(arguments.length<2)){for(a=n?Hr:jr,null==e&&(e=!1),r=0;r<u;++r)this.each(a(o[r],n,e));return this}var a=this.node().__on;if(a)for(var c,s=0,f=a.length;s<f;++s)for(r=0,c=a[s];r<u;++r)if((i=o[r]).type===c.type&&i.name===c.name)return c.value}},D_=function(){for(var n,e=t.event;n=e.sourceEvent;)e=n;return e},O_=function(t,n){var e=t.ownerSVGElement||t;if(e.createSVGPoint){var r=e.createSVGPoint();return r.x=n.clientX,r.y=n.clientY,r=r.matrixTransform(t.getScreenCTM().inverse()),[r.x,r.y]}var i=t.getBoundingClientRect();return[n.clientX-i.left-t.clientLeft,n.clientY-i.top-t.clientTop]},F_=function(t){var n=D_();return n.changedTouches&&(n=n.changedTouches[0]),O_(t,n)},I_=function(t){return null==t?Vr:function(){return this.querySelector(t)}},Y_=function(t){"function"!=typeof t&&(t=I_(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,u,a=n[i],c=a.length,s=r[i]=new Array(c),f=0;f<c;++f)(o=a[f])&&(u=t.call(o,o.__data__,f,a))&&("__data__"in o&&(u.__data__=o.__data__),s[f]=u);return new zi(r,this._parents)},B_=function(t){return null==t?Wr:function(){return this.querySelectorAll(t)}},j_=function(t){"function"!=typeof t&&(t=B_(t));for(var n=this._groups,e=n.length,r=[],i=[],o=0;o<e;++o)for(var u,a=n[o],c=a.length,s=0;s<c;++s)(u=a[s])&&(r.push(t.call(u,u.__data__,s,a)),i.push(u));return new zi(r,i)},H_=function(t){"function"!=typeof t&&(t=R_(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,u=n[i],a=u.length,c=r[i]=[],s=0;s<a;++s)(o=u[s])&&t.call(o,o.__data__,s,u)&&c.push(o);return new zi(r,this._parents)},X_=function(t){return new Array(t.length)},V_=function(){return new zi(this._enter||this._groups.map(X_),this._parents)};$r.prototype={constructor:$r,appendChild:function(t){return this._parent.insertBefore(t,this._next)},insertBefore:function(t,n){return this._parent.insertBefore(t,n)},querySelector:function(t){return this._parent.querySelector(t)},querySelectorAll:function(t){return this._parent.querySelectorAll(t)}};var W_=function(t){return function(){return t}},$_="$",Z_=function(t,n){if(!t)return p=new Array(this.size()),s=-1,this.each(function(t){p[++s]=t}),p;var e=n?Gr:Zr,r=this._parents,i=this._groups;"function"!=typeof t&&(t=W_(t));for(var o=i.length,u=new Array(o),a=new Array(o),c=new Array(o),s=0;s<o;++s){var f=r[s],l=i[s],h=l.length,p=t.call(f,f&&f.__data__,s,r),d=p.length,v=a[s]=new Array(d),_=u[s]=new Array(d),y=c[s]=new Array(h);e(f,l,v,_,y,p,n);for(var g,m,x=0,b=0;x<d;++x)if(g=v[x]){for(x>=b&&(b=x+1);!(m=_[b])&&++b<d;);g._next=m||null}}return u=new zi(u,r),u._enter=a,u._exit=c,u},G_=function(){return new zi(this._exit||this._groups.map(X_),this._parents)},J_=function(t){for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),u=new Array(r),a=0;a<o;++a)for(var c,s=n[a],f=e[a],l=s.length,h=u[a]=new Array(l),p=0;p<l;++p)(c=s[p]||f[p])&&(h[p]=c);for(;a<r;++a)u[a]=n[a];return new zi(u,this._parents)},Q_=function(){for(var t=this._groups,n=-1,e=t.length;++n<e;)for(var r,i=t[n],o=i.length-1,u=i[o];--o>=0;)(r=i[o])&&(u&&u!==r.nextSibling&&u.parentNode.insertBefore(r,u),u=r);return this},K_=function(t){function n(n,e){return n&&e?t(n.__data__,e.__data__):!n-!e}t||(t=Jr);for(var e=this._groups,r=e.length,i=new Array(r),o=0;o<r;++o){for(var u,a=e[o],c=a.length,s=i[o]=new Array(c),f=0;f<c;++f)(u=a[f])&&(s[f]=u);s.sort(n)}return new zi(i,this._parents).order()},ty=function(){var t=arguments[0];return arguments[0]=this,t.apply(null,arguments),this},ny=function(){var t=new Array(this.size()),n=-1;return this.each(function(){t[++n]=this}),t},ey=function(){for(var t=this._groups,n=0,e=t.length;n<e;++n)for(var r=t[n],i=0,o=r.length;i<o;++i){var u=r[i];if(u)return u}return null},ry=function(){var t=0;return this.each(function(){++t}),t},iy=function(){return!this.node()},oy=function(t){for(var n=this._groups,e=0,r=n.length;e<r;++e)for(var i,o=n[e],u=0,a=o.length;u<a;++u)(i=o[u])&&t.call(i,i.__data__,u,o);return this},uy=function(t,n){var e=S_(t);if(arguments.length<2){var r=this.node();return e.local?r.getAttributeNS(e.space,e.local):r.getAttribute(e)}return this.each((null==n?e.local?Kr:Qr:"function"==typeof n?e.local?ri:ei:e.local?ni:ti)(e,n))},ay=function(t){return t.ownerDocument&&t.ownerDocument.defaultView||t.document&&t||t.defaultView},cy=function(t,n,e){var r;return arguments.length>1?this.each((null==n?ii:"function"==typeof n?ui:oi)(t,n,null==e?"":e)):ay(r=this.node()).getComputedStyle(r,null).getPropertyValue(t)},sy=function(t,n){return arguments.length>1?this.each((null==n?ai:"function"==typeof n?si:ci)(t,n)):this.node()[t]};hi.prototype={add:function(t){var n=this._names.indexOf(t);n<0&&(this._names.push(t),this._node.setAttribute("class",this._names.join(" ")))},remove:function(t){var n=this._names.indexOf(t);n>=0&&(this._names.splice(n,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(t){return this._names.indexOf(t)>=0}};var fy=function(t,n){var e=fi(t+"");if(arguments.length<2){for(var r=li(this.node()),i=-1,o=e.length;++i<o;)if(!r.contains(e[i]))return!1;return!0}return this.each(("function"==typeof n?yi:n?vi:_i)(e,n))},ly=function(t){return arguments.length?this.each(null==t?gi:("function"==typeof t?xi:mi)(t)):this.node().textContent},hy=function(t){return arguments.length?this.each(null==t?bi:("function"==typeof t?Mi:wi)(t)):this.node().innerHTML},py=function(){return this.each(Ti)},dy=function(){return this.each(Ni)},vy=function(t){var n="function"==typeof t?t:E_(t);return this.select(function(){return this.appendChild(n.apply(this,arguments))})},_y=function(t,n){var e="function"==typeof t?t:E_(t),r=null==n?ki:"function"==typeof n?n:I_(n);return this.select(function(){return this.insertBefore(e.apply(this,arguments),r.apply(this,arguments)||null)})},yy=function(){return this.each(Si)},gy=function(t){return arguments.length?this.property("__data__",t):this.node().__data__},my=function(t,n){return this.each(("function"==typeof n?Ci:Ai)(t,n))},xy=[null];zi.prototype=Pi.prototype={constructor:zi,select:Y_,selectAll:j_,filter:H_,data:Z_,enter:V_,exit:G_,merge:J_,order:Q_,sort:K_,call:ty,nodes:ny,node:ey,size:ry,empty:iy,each:oy,attr:uy,style:cy,property:sy,classed:fy,text:ly,html:hy,raise:py,lower:dy,append:vy,insert:_y,remove:yy,datum:gy,on:U_,dispatch:my};var by=function(t){return"string"==typeof t?new zi([[document.querySelector(t)]],[document.documentElement]):new zi([[t]],xy)},wy=function(t){return"string"==typeof t?new zi([document.querySelectorAll(t)],[document.documentElement]):new zi([null==t?[]:t],xy)},My=function(t,n,e){arguments.length<3&&(e=n,n=D_().changedTouches);for(var r,i=0,o=n?n.length:0;i<o;++i)if((r=n[i]).identifier===e)return O_(t,r);return null},Ty=function(t,n){null==n&&(n=D_().touches);for(var e=0,r=n?n.length:0,i=new Array(r);e<r;++e)i[e]=O_(t,n[e]);return i},Ny=Pn("start","end","interrupt"),ky=[],Sy=0,Ey=1,Ay=2,Cy=3,zy=4,Py=5,Ry=6,qy=function(t,n,e,r,i,o){var u=t.__transition;if(u){if(e in u)return}else t.__transition={};Ui(t,e,{name:n,index:r,group:i,on:Ny,tween:ky,time:o.time,delay:o.delay,duration:o.duration,ease:o.ease,timer:null,state:Sy})},Ly=function(t,n){var e,r,i,o=t.__transition,u=!0;if(o){n=null==n?null:n+"";for(i in o)(e=o[i]).name===n?(r=e.state>Ay&&e.state<Py,e.state=Ry,e.timer.stop(),r&&e.on.call("interrupt",t,t.__data__,e.index,e.group),delete o[i]):u=!1;u&&delete t.__transition}},Uy=function(t){return this.each(function(){Ly(this,t)})},Dy=function(t,n){var e=this._id;if(t+="",arguments.length<2){for(var r,i=Li(this.node(),e).tween,o=0,u=i.length;o<u;++o)if((r=i[o]).name===t)return r.value;return null}return this.each((null==n?Di:Oi)(e,t,n))},Oy=function(t,n){var e;return("number"==typeof n?dp:n instanceof Bt?sp:(e=Bt(n))?(n=e,sp):gp)(t,n)},Fy=function(t,n){var e=S_(t),r="transform"===e?Np:Oy;return this.attrTween(t,"function"==typeof n?(e.local?Xi:Hi)(e,r,Fi(this,"attr."+t,n)):null==n?(e.local?Yi:Ii)(e):(e.local?ji:Bi)(e,r,n))},Iy=function(t,n){var e="attr."+t;if(arguments.length<2)return(e=this.tween(e))&&e._value;if(null==n)return this.tween(e,null);if("function"!=typeof n)throw new Error;var r=S_(t);return this.tween(e,(r.local?Vi:Wi)(r,n))},Yy=function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?$i:Zi)(n,t)):Li(this.node(),n).delay},By=function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?Gi:Ji)(n,t)):Li(this.node(),n).duration},jy=function(t){var n=this._id;return arguments.length?this.each(Qi(n,t)):Li(this.node(),n).ease},Hy=function(t){"function"!=typeof t&&(t=R_(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,u=n[i],a=u.length,c=r[i]=[],s=0;s<a;++s)(o=u[s])&&t.call(o,o.__data__,s,u)&&c.push(o);return new so(r,this._parents,this._name,this._id)},Xy=function(t){if(t._id!==this._id)throw new Error;for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),u=new Array(r),a=0;a<o;++a)for(var c,s=n[a],f=e[a],l=s.length,h=u[a]=new Array(l),p=0;p<l;++p)(c=s[p]||f[p])&&(h[p]=c);for(;a<r;++a)u[a]=n[a];return new so(u,this._parents,this._name,this._id)},Vy=function(t,n){var e=this._id;return arguments.length<2?Li(this.node(),e).on.on(t):this.each(to(e,t,n))},Wy=function(){return this.on("end.remove",no(this._id))},$y=function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=I_(t));for(var r=this._groups,i=r.length,o=new Array(i),u=0;u<i;++u)for(var a,c,s=r[u],f=s.length,l=o[u]=new Array(f),h=0;h<f;++h)(a=s[h])&&(c=t.call(a,a.__data__,h,s))&&("__data__"in a&&(c.__data__=a.__data__),l[h]=c,qy(l[h],n,e,h,l,Li(a,e)));return new so(o,this._parents,n,e)},Zy=function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=B_(t));for(var r=this._groups,i=r.length,o=[],u=[],a=0;a<i;++a)for(var c,s=r[a],f=s.length,l=0;l<f;++l)if(c=s[l]){for(var h,p=t.call(c,c.__data__,l,s),d=Li(c,e),v=0,_=p.length;v<_;++v)(h=p[v])&&qy(h,n,e,v,p,d);o.push(p),u.push(c)}return new so(o,u,n,e);
},Gy=Pi.prototype.constructor,Jy=function(){return new Gy(this._groups,this._parents)},Qy=function(t,n,e){var r="transform"==(t+="")?Tp:Oy;return null==n?this.styleTween(t,eo(t,r)).on("end.style."+t,ro(t)):this.styleTween(t,"function"==typeof n?oo(t,r,Fi(this,"style."+t,n)):io(t,r,n),e)},Ky=function(t,n,e){var r="style."+(t+="");if(arguments.length<2)return(r=this.tween(r))&&r._value;if(null==n)return this.tween(r,null);if("function"!=typeof n)throw new Error;return this.tween(r,uo(t,n,null==e?"":e))},tg=function(t){return this.tween("text","function"==typeof t?co(Fi(this,"text",t)):ao(null==t?"":t+""))},ng=function(){for(var t=this._name,n=this._id,e=lo(),r=this._groups,i=r.length,o=0;o<i;++o)for(var u,a=r[o],c=a.length,s=0;s<c;++s)if(u=a[s]){var f=Li(u,n);qy(u,t,e,s,a,{time:f.time+f.delay+f.duration,delay:0,duration:f.duration,ease:f.ease})}return new so(r,this._parents,t,e)},eg=0,rg=Pi.prototype;so.prototype=fo.prototype={constructor:so,select:$y,selectAll:Zy,filter:Hy,merge:Xy,selection:Jy,transition:ng,call:rg.call,nodes:rg.nodes,node:rg.node,size:rg.size,empty:rg.empty,each:rg.each,on:Vy,attr:Fy,attrTween:Iy,style:Qy,styleTween:Ky,text:tg,remove:Wy,tween:Dy,delay:Yy,duration:By,ease:jy};var ig={time:null,delay:0,duration:250,ease:g},og=function(t){var n,e;t instanceof so?(n=t._id,t=t._name):(n=lo(),(e=ig).time=jn(),t=null==t?null:t+"");for(var r=this._groups,i=r.length,o=0;o<i;++o)for(var u,a=r[o],c=a.length,s=0;s<c;++s)(u=a[s])&&qy(u,t,n,s,a,e||ho(u,n));return new so(r,this._parents,t,n)};Pi.prototype.interrupt=Uy,Pi.prototype.transition=og;var ug=[null],ag=function(t,n){var e,r,i=t.__transition;if(i){n=null==n?null:n+"";for(r in i)if((e=i[r]).state>Ey&&e.name===n)return new so([[t]],ug,n,+r)}return null},cg=Array.prototype.slice,sg=function(t){return t},fg=1,lg=2,hg=3,pg=4,dg=1e-6,vg=function(){function t(t){var o,u=0;t.eachAfter(function(t){var e=t.children;e?(t.x=To(e),t.y=ko(e)):(t.x=o?u+=n(t,o):0,t.y=0,o=t)});var a=Eo(t),c=Ao(t),s=a.x-n(a,c)/2,f=c.x+n(c,a)/2;return t.eachAfter(i?function(n){n.x=(n.x-t.x)*e,n.y=(t.y-n.y)*r}:function(n){n.x=(n.x-s)/(f-s)*e,n.y=(1-(t.y?n.y/t.y:1))*r})}var n=Mo,e=1,r=1,i=!1;return t.separation=function(e){return arguments.length?(n=e,t):n},t.size=function(n){return arguments.length?(i=!1,e=+n[0],r=+n[1],t):i?null:[e,r]},t.nodeSize=function(n){return arguments.length?(i=!0,e=+n[0],r=+n[1],t):i?[e,r]:null},t},_g=function(t){var n,e,r,i,o=this,u=[o];do for(n=u.reverse(),u=[];o=n.pop();)if(t(o),e=o.children)for(r=0,i=e.length;r<i;++r)u.push(e[r]);while(u.length);return this},yg=function(t){for(var n,e,r=this,i=[r];r=i.pop();)if(t(r),n=r.children)for(e=n.length-1;e>=0;--e)i.push(n[e]);return this},gg=function(t){for(var n,e,r,i=this,o=[i],u=[];i=o.pop();)if(u.push(i),n=i.children)for(e=0,r=n.length;e<r;++e)o.push(n[e]);for(;i=u.pop();)t(i);return this},mg=function(t){return this.eachAfter(function(n){for(var e=+t(n.data)||0,r=n.children,i=r&&r.length;--i>=0;)e+=r[i].value;n.value=e})},xg=function(t){return this.eachBefore(function(n){n.children&&n.children.sort(t)})},bg=function(t){for(var n=this,e=Co(n,t),r=[n];n!==e;)n=n.parent,r.push(n);for(var i=r.length;t!==e;)r.splice(i,0,t),t=t.parent;return r},wg=function(){for(var t=this,n=[t];t=t.parent;)n.push(t);return n},Mg=function(){var t=[];return this.each(function(n){t.push(n)}),t},Tg=function(){var t=[];return this.eachBefore(function(n){n.children||t.push(n)}),t},Ng=function(){var t=this,n=[];return t.each(function(e){e!==t&&n.push({source:e.parent,target:e})}),n};Uo.prototype=zo.prototype={constructor:Uo,each:_g,eachAfter:gg,eachBefore:yg,sum:mg,sort:xg,path:bg,ancestors:wg,descendants:Mg,leaves:Tg,links:Ng,copy:Po};var kg=function(t){for(var n,e=(t=t.slice()).length,r=null,i=r;e;){var o=new Do(t[e-1]);i=i?i.next=o:r=o,t[n]=t[--e]}return{head:r,tail:i}},Sg=function(t){return Fo(kg(t),[])},Eg=function(t){return Wo(t),t},Ag=function(t){return function(){return t}},Cg=function(){function t(t){return t.x=e/2,t.y=r/2,n?t.eachBefore(Qo(n)).eachAfter(Ko(i,.5)).eachBefore(tu(1)):t.eachBefore(Qo(Jo)).eachAfter(Ko(Go,1)).eachAfter(Ko(i,t.r/Math.min(e,r))).eachBefore(tu(Math.min(e,r)/(2*t.r))),t}var n=null,e=1,r=1,i=Go;return t.radius=function(e){return arguments.length?(n=$o(e),t):n},t.size=function(n){return arguments.length?(e=+n[0],r=+n[1],t):[e,r]},t.padding=function(n){return arguments.length?(i="function"==typeof n?n:Ag(+n),t):i},t},zg=function(t){t.x0=Math.round(t.x0),t.y0=Math.round(t.y0),t.x1=Math.round(t.x1),t.y1=Math.round(t.y1)},Pg=function(t,n,e,r,i){for(var o,u=t.children,a=-1,c=u.length,s=t.value&&(r-n)/t.value;++a<c;)o=u[a],o.y0=e,o.y1=i,o.x0=n,o.x1=n+=o.value*s},Rg=function(){function t(t){var u=t.height+1;return t.x0=t.y0=i,t.x1=e,t.y1=r/u,t.eachBefore(n(r,u)),o&&t.eachBefore(zg),t}function n(t,n){return function(e){e.children&&Pg(e,e.x0,t*(e.depth+1)/n,e.x1,t*(e.depth+2)/n);var r=e.x0,o=e.y0,u=e.x1-i,a=e.y1-i;u<r&&(r=u=(r+u)/2),a<o&&(o=a=(o+a)/2),e.x0=r,e.y0=o,e.x1=u,e.y1=a}}var e=1,r=1,i=0,o=!1;return t.round=function(n){return arguments.length?(o=!!n,t):o},t.size=function(n){return arguments.length?(e=+n[0],r=+n[1],t):[e,r]},t.padding=function(n){return arguments.length?(i=+n,t):i},t},qg="$",Lg={depth:-1},Ug={},Dg=function(){function t(t){var r,i,o,u,a,c,s,f=t.length,l=new Array(f),h={};for(i=0;i<f;++i)r=t[i],a=l[i]=new Uo(r),null!=(c=n(r,i,t))&&(c+="")&&(s=qg+(a.id=c),h[s]=s in h?Ug:a);for(i=0;i<f;++i)if(a=l[i],c=e(t[i],i,t),null!=c&&(c+="")){if(u=h[qg+c],!u)throw new Error("missing: "+c);if(u===Ug)throw new Error("ambiguous: "+c);u.children?u.children.push(a):u.children=[a],a.parent=u}else{if(o)throw new Error("multiple roots");o=a}if(!o)throw new Error("no root");if(o.parent=Lg,o.eachBefore(function(t){t.depth=t.parent.depth+1,--f}).eachBefore(Lo),o.parent=null,f>0)throw new Error("cycle");return o}var n=nu,e=eu;return t.id=function(e){return arguments.length?(n=Zo(e),t):n},t.parentId=function(n){return arguments.length?(e=Zo(n),t):e},t};su.prototype=Object.create(Uo.prototype);var Og=function(){function t(t){var r=fu(t);if(r.eachAfter(n),r.parent.m=-r.z,r.eachBefore(e),c)t.eachBefore(i);else{var s=t,f=t,l=t;t.eachBefore(function(t){t.x<s.x&&(s=t),t.x>f.x&&(f=t),t.depth>l.depth&&(l=t)});var h=s===f?1:o(s,f)/2,p=h-s.x,d=u/(f.x+h+p),v=a/(l.depth||1);t.eachBefore(function(t){t.x=(t.x+p)*d,t.y=t.depth*v})}return t}function n(t){var n=t.children,e=t.parent.children,i=t.i?e[t.i-1]:null;if(n){au(t);var u=(n[0].z+n[n.length-1].z)/2;i?(t.z=i.z+o(t._,i._),t.m=t.z-u):t.z=u}else i&&(t.z=i.z+o(t._,i._));t.parent.A=r(t,i,t.parent.A||e[0])}function e(t){t._.x=t.z+t.parent.m,t.m+=t.parent.m}function r(t,n,e){if(n){for(var r,i=t,u=t,a=n,c=i.parent.children[0],s=i.m,f=u.m,l=a.m,h=c.m;a=ou(a),i=iu(i),a&&i;)c=iu(c),u=ou(u),u.a=t,r=a.z+l-i.z-s+o(a._,i._),r>0&&(uu(cu(a,t,e),t,r),s+=r,f+=r),l+=a.m,s+=i.m,h+=c.m,f+=u.m;a&&!ou(u)&&(u.t=a,u.m+=l-f),i&&!iu(c)&&(c.t=i,c.m+=s-h,e=t)}return e}function i(t){t.x*=u,t.y=t.depth*a}var o=ru,u=1,a=1,c=null;return t.separation=function(n){return arguments.length?(o=n,t):o},t.size=function(n){return arguments.length?(c=!1,u=+n[0],a=+n[1],t):c?null:[u,a]},t.nodeSize=function(n){return arguments.length?(c=!0,u=+n[0],a=+n[1],t):c?[u,a]:null},t},Fg=function(t,n,e,r,i){for(var o,u=t.children,a=-1,c=u.length,s=t.value&&(i-e)/t.value;++a<c;)o=u[a],o.x0=n,o.x1=r,o.y0=e,o.y1=e+=o.value*s},Ig=(1+Math.sqrt(5))/2,Yg=function t(n){function e(t,e,r,i,o){lu(n,t,e,r,i,o)}return e.ratio=function(n){return t((n=+n)>1?n:1)},e}(Ig),Bg=function(){function t(t){return t.x0=t.y0=0,t.x1=i,t.y1=o,t.eachBefore(n),u=[0],r&&t.eachBefore(zg),t}function n(t){var n=u[t.depth],r=t.x0+n,i=t.y0+n,o=t.x1-n,h=t.y1-n;o<r&&(r=o=(r+o)/2),h<i&&(i=h=(i+h)/2),t.x0=r,t.y0=i,t.x1=o,t.y1=h,t.children&&(n=u[t.depth+1]=a(t)/2,r+=l(t)-n,i+=c(t)-n,o-=s(t)-n,h-=f(t)-n,o<r&&(r=o=(r+o)/2),h<i&&(i=h=(i+h)/2),e(t,r,i,o,h))}var e=Yg,r=!1,i=1,o=1,u=[0],a=Go,c=Go,s=Go,f=Go,l=Go;return t.round=function(n){return arguments.length?(r=!!n,t):r},t.size=function(n){return arguments.length?(i=+n[0],o=+n[1],t):[i,o]},t.tile=function(n){return arguments.length?(e=Zo(n),t):e},t.padding=function(n){return arguments.length?t.paddingInner(n).paddingOuter(n):t.paddingInner()},t.paddingInner=function(n){return arguments.length?(a="function"==typeof n?n:Ag(+n),t):a},t.paddingOuter=function(n){return arguments.length?t.paddingTop(n).paddingRight(n).paddingBottom(n).paddingLeft(n):t.paddingTop()},t.paddingTop=function(n){return arguments.length?(c="function"==typeof n?n:Ag(+n),t):c},t.paddingRight=function(n){return arguments.length?(s="function"==typeof n?n:Ag(+n),t):s},t.paddingBottom=function(n){return arguments.length?(f="function"==typeof n?n:Ag(+n),t):f},t.paddingLeft=function(n){return arguments.length?(l="function"==typeof n?n:Ag(+n),t):l},t},jg=function(t,n,e,r,i){function o(t,n,e,r,i,u,a){if(t>=n-1){var s=c[t];return s.x0=r,s.y0=i,s.x1=u,s.y1=a,void 0}for(var l=f[t],h=e/2+l,p=t+1,d=n-1;p<d;){var v=p+d>>>1;f[v]<h?p=v+1:d=v}var _=f[p]-l,y=e-_;if(a-i>u-r){var g=(i*y+a*_)/e;o(t,p,_,r,i,u,g),o(p,n,y,r,g,u,a)}else{var m=(r*y+u*_)/e;o(t,p,_,r,i,m,a),o(p,n,y,m,i,u,a)}}var u,a,c=t.children,s=c.length,f=new Array(s+1);for(f[0]=a=u=0;u<s;++u)f[u+1]=a+=c[u].value;o(0,s,t.value,n,e,r,i)},Hg=function(t,n,e,r,i){(1&t.depth?Fg:Pg)(t,n,e,r,i)},Xg=function t(n){function e(t,e,r,i,o){if((u=t._squarify)&&u.ratio===n)for(var u,a,c,s,f,l=-1,h=u.length,p=t.value;++l<h;){for(a=u[l],c=a.children,s=a.value=0,f=c.length;s<f;++s)a.value+=c[s].value;a.dice?Pg(a,e,r,i,r+=(o-r)*a.value/p):Fg(a,e,r,e+=(i-e)*a.value/p,o),p-=a.value}else t._squarify=u=lu(n,t,e,r,i,o),u.ratio=n}return e.ratio=function(n){return t((n=+n)>1?n:1)},e}(Ig),Vg=function(t,n){function e(){var e,i,o=r.length,u=0,a=0;for(e=0;e<o;++e)i=r[e],u+=i.x,a+=i.y;for(u=u/o-t,a=a/o-n,e=0;e<o;++e)i=r[e],i.x-=u,i.y-=a}var r;return null==t&&(t=0),null==n&&(n=0),e.initialize=function(t){r=t},e.x=function(n){return arguments.length?(t=+n,e):t},e.y=function(t){return arguments.length?(n=+t,e):n},e},Wg=function(t){return function(){return t}},$g=function(){return 1e-6*(Math.random()-.5)},Zg=function(t){function n(){function t(t,n,e,r,i){var o=t.data,a=t.r,p=l+a;{if(!o)return n>s+p||r<s-p||e>f+p||i<f-p;if(o.index>c.index){var d=s-o.x-o.vx,v=f-o.y-o.vy,_=d*d+v*v;_<p*p&&(0===d&&(d=$g(),_+=d*d),0===v&&(v=$g(),_+=v*v),_=(p-(_=Math.sqrt(_)))/_*u,c.vx+=(d*=_)*(p=(a*=a)/(h+a)),c.vy+=(v*=_)*p,o.vx-=d*(p=1-p),o.vy-=v*p)}}}for(var n,r,c,s,f,l,h,p=i.length,d=0;d<a;++d)for(r=I(i,hu,pu).visitAfter(e),n=0;n<p;++n)c=i[n],l=o[c.index],h=l*l,s=c.x+c.vx,f=c.y+c.vy,r.visit(t)}function e(t){if(t.data)return t.r=o[t.data.index];for(var n=t.r=0;n<4;++n)t[n]&&t[n].r>t.r&&(t.r=t[n].r)}function r(){if(i){var n,e,r=i.length;for(o=new Array(r),n=0;n<r;++n)e=i[n],o[e.index]=+t(e,n,i)}}var i,o,u=1,a=1;return"function"!=typeof t&&(t=Wg(null==t?1:+t)),n.initialize=function(t){i=t,r()},n.iterations=function(t){return arguments.length?(a=+t,n):a},n.strength=function(t){return arguments.length?(u=+t,n):u},n.radius=function(e){return arguments.length?(t="function"==typeof e?e:Wg(+e),r(),n):t},n},Gg=function(t){function n(t){return 1/Math.min(f[t.source.index],f[t.target.index])}function e(n){for(var e=0,r=t.length;e<v;++e)for(var i,o,u,s,f,h,p,d=0;d<r;++d)i=t[d],o=i.source,u=i.target,s=u.x+u.vx-o.x-o.vx||$g(),f=u.y+u.vy-o.y-o.vy||$g(),h=Math.sqrt(s*s+f*f),h=(h-c[d])/h*n*a[d],s*=h,f*=h,u.vx-=s*(p=l[d]),u.vy-=f*p,o.vx+=s*(p=1-p),o.vy+=f*p}function r(){if(s){var n,e,r=s.length,p=t.length,d=o(s,h);for(n=0,f=new Array(r);n<p;++n)e=t[n],e.index=n,"object"!=typeof e.source&&(e.source=vu(d,e.source)),"object"!=typeof e.target&&(e.target=vu(d,e.target)),f[e.source.index]=(f[e.source.index]||0)+1,f[e.target.index]=(f[e.target.index]||0)+1;for(n=0,l=new Array(p);n<p;++n)e=t[n],l[n]=f[e.source.index]/(f[e.source.index]+f[e.target.index]);a=new Array(p),i(),c=new Array(p),u()}}function i(){if(s)for(var n=0,e=t.length;n<e;++n)a[n]=+p(t[n],n,t)}function u(){if(s)for(var n=0,e=t.length;n<e;++n)c[n]=+d(t[n],n,t)}var a,c,s,f,l,h=du,p=n,d=Wg(30),v=1;return null==t&&(t=[]),e.initialize=function(t){s=t,r()},e.links=function(n){return arguments.length?(t=n,r(),e):t},e.id=function(t){return arguments.length?(h=t,e):h},e.iterations=function(t){return arguments.length?(v=+t,e):v},e.strength=function(t){return arguments.length?(p="function"==typeof t?t:Wg(+t),i(),e):p},e.distance=function(t){return arguments.length?(d="function"==typeof t?t:Wg(+t),u(),e):d},e},Jg=10,Qg=Math.PI*(3-Math.sqrt(5)),Kg=function(t){function n(){e(),d.call("tick",u),a<c&&(p.stop(),d.call("end",u))}function e(){var n,e,r=t.length;for(a+=(f-a)*s,h.each(function(t){t(a)}),n=0;n<r;++n)e=t[n],null==e.fx?e.x+=e.vx*=l:(e.x=e.fx,e.vx=0),null==e.fy?e.y+=e.vy*=l:(e.y=e.fy,e.vy=0)}function r(){for(var n,e=0,r=t.length;e<r;++e){if(n=t[e],n.index=e,isNaN(n.x)||isNaN(n.y)){var i=Jg*Math.sqrt(e),o=e*Qg;n.x=i*Math.cos(o),n.y=i*Math.sin(o)}(isNaN(n.vx)||isNaN(n.vy))&&(n.vx=n.vy=0)}}function i(n){return n.initialize&&n.initialize(t),n}var u,a=1,c=.001,s=1-Math.pow(c,1/300),f=0,l=.6,h=o(),p=Vn(n),d=Pn("tick","end");return null==t&&(t=[]),r(),u={tick:e,restart:function(){return p.restart(n),u},stop:function(){return p.stop(),u},nodes:function(n){return arguments.length?(t=n,r(),h.each(i),u):t},alpha:function(t){return arguments.length?(a=+t,u):a},alphaMin:function(t){return arguments.length?(c=+t,u):c},alphaDecay:function(t){return arguments.length?(s=+t,u):+s},alphaTarget:function(t){return arguments.length?(f=+t,u):f},velocityDecay:function(t){return arguments.length?(l=1-t,u):1-l},force:function(t,n){return arguments.length>1?(null==n?h.remove(t):h.set(t,i(n)),u):h.get(t)},find:function(n,e,r){var i,o,u,a,c,s=0,f=t.length;for(null==r?r=1/0:r*=r,s=0;s<f;++s)a=t[s],i=n-a.x,o=e-a.y,u=i*i+o*o,u<r&&(c=a,r=u);return c},on:function(t,n){return arguments.length>1?(d.on(t,n),u):d.on(t)}}},tm=function(){function t(t){var n,a=i.length,c=I(i,_u,yu).visitAfter(e);for(u=t,n=0;n<a;++n)o=i[n],c.visit(r)}function n(){if(i){var t,n,e=i.length;for(a=new Array(e),t=0;t<e;++t)n=i[t],a[n.index]=+c(n,t,i)}}function e(t){var n,e,r,i,o,u=0;if(t.length){for(r=i=o=0;o<4;++o)(n=t[o])&&(e=n.value)&&(u+=e,r+=e*n.x,i+=e*n.y);t.x=r/u,t.y=i/u}else{n=t,n.x=n.data.x,n.y=n.data.y;do u+=a[n.data.index];while(n=n.next)}t.value=u}function r(t,n,e,r){if(!t.value)return!0;var i=t.x-o.x,c=t.y-o.y,h=r-n,p=i*i+c*c;if(h*h/l<p)return p<f&&(0===i&&(i=$g(),p+=i*i),0===c&&(c=$g(),p+=c*c),p<s&&(p=Math.sqrt(s*p)),o.vx+=i*t.value*u/p,o.vy+=c*t.value*u/p),!0;if(!(t.length||p>=f)){(t.data!==o||t.next)&&(0===i&&(i=$g(),p+=i*i),0===c&&(c=$g(),p+=c*c),p<s&&(p=Math.sqrt(s*p)));do t.data!==o&&(h=a[t.data.index]*u/p,o.vx+=i*h,o.vy+=c*h);while(t=t.next)}}var i,o,u,a,c=Wg(-30),s=1,f=1/0,l=.81;return t.initialize=function(t){i=t,n()},t.strength=function(e){return arguments.length?(c="function"==typeof e?e:Wg(+e),n(),t):c},t.distanceMin=function(n){return arguments.length?(s=n*n,t):Math.sqrt(s)},t.distanceMax=function(n){return arguments.length?(f=n*n,t):Math.sqrt(f)},t.theta=function(n){return arguments.length?(l=n*n,t):Math.sqrt(l)},t},nm=function(t){function n(t){for(var n,e=0,u=r.length;e<u;++e)n=r[e],n.vx+=(o[e]-n.x)*i[e]*t}function e(){if(r){var n,e=r.length;for(i=new Array(e),o=new Array(e),n=0;n<e;++n)i[n]=isNaN(o[n]=+t(r[n],n,r))?0:+u(r[n],n,r)}}var r,i,o,u=Wg(.1);return"function"!=typeof t&&(t=Wg(null==t?0:+t)),n.initialize=function(t){r=t,e()},n.strength=function(t){return arguments.length?(u="function"==typeof t?t:Wg(+t),e(),n):u},n.x=function(r){return arguments.length?(t="function"==typeof r?r:Wg(+r),e(),n):t},n},em=function(t){function n(t){for(var n,e=0,u=r.length;e<u;++e)n=r[e],n.vy+=(o[e]-n.y)*i[e]*t}function e(){if(r){var n,e=r.length;for(i=new Array(e),o=new Array(e),n=0;n<e;++n)i[n]=isNaN(o[n]=+t(r[n],n,r))?0:+u(r[n],n,r)}}var r,i,o,u=Wg(.1);return"function"!=typeof t&&(t=Wg(null==t?0:+t)),n.initialize=function(t){r=t,e()},n.strength=function(t){return arguments.length?(u="function"==typeof t?t:Wg(+t),e(),n):u},n.y=function(r){return arguments.length?(t="function"==typeof r?r:Wg(+r),e(),n):t},n},rm=function(){t.event.preventDefault(),t.event.stopImmediatePropagation()},im=function(t){var n=t.document.documentElement,e=by(t).on("dragstart.drag",rm,!0);"onselectstart"in n?e.on("selectstart.drag",rm,!0):(n.__noselect=n.style.MozUserSelect,n.style.MozUserSelect="none")},om=function(t){return function(){return t}};xu.prototype.on=function(){var t=this._.on.apply(this._,arguments);return t===this._?this:t};var um=function(){function n(t){t.on("mousedown.drag",e).on("touchstart.drag",o).on("touchmove.drag",u).on("touchend.drag touchcancel.drag",a).style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function e(){if(!f&&l.apply(this,arguments)){var n=c("mouse",h.apply(this,arguments),F_,this,arguments);n&&(by(t.event.view).on("mousemove.drag",r,!0).on("mouseup.drag",i,!0),im(t.event.view),gu(),s=!1,n("start"))}}function r(){rm(),s=!0,d.mouse("drag")}function i(){by(t.event.view).on("mousemove.drag mouseup.drag",null),mu(t.event.view,s),rm(),d.mouse("end")}function o(){if(l.apply(this,arguments)){var n,e,r=t.event.changedTouches,i=h.apply(this,arguments),o=r.length;for(n=0;n<o;++n)(e=c(r[n].identifier,i,My,this,arguments))&&(gu(),e("start"))}}function u(){var n,e,r=t.event.changedTouches,i=r.length;for(n=0;n<i;++n)(e=d[r[n].identifier])&&(rm(),e("drag"))}function a(){var n,e,r=t.event.changedTouches,i=r.length;for(f&&clearTimeout(f),f=setTimeout(function(){f=null},500),n=0;n<i;++n)(e=d[r[n].identifier])&&(gu(),e("end"))}function c(e,r,i,o,u){var a,c,s,f=i(r,e),l=v.copy();if(Xr(new xu(n,"beforestart",a,e,_,f[0],f[1],0,0,l),function(){return null!=(t.event.subject=a=p.apply(o,u))&&(c=a.x-f[0]||0,s=a.y-f[1]||0,!0)}))return function t(h){var p,v=f;switch(h){case"start":d[e]=t,p=_++;break;case"end":delete d[e],--_;case"drag":f=i(r,e),p=_}Xr(new xu(n,h,a,e,p,f[0]+c,f[1]+s,f[0]-v[0],f[1]-v[1],l),l.apply,l,[h,o,u])}}var s,f,l=bu,h=wu,p=Mu,d={},v=Pn("start","drag","end"),_=0;return n.filter=function(t){return arguments.length?(l="function"==typeof t?t:om(!!t),n):l},n.container=function(t){return arguments.length?(h="function"==typeof t?t:om(t),n):h},n.subject=function(t){return arguments.length?(p="function"==typeof t?t:om(t),n):p},n.on=function(){var t=v.on.apply(v,arguments);return t===v?n:t},n},am=function(t){return function(){return t}};ku.prototype={constructor:ku,insert:function(t,n){var e,r,i;if(t){if(n.P=t,n.N=t.N,t.N&&(t.N.P=n),t.N=n,t.R){for(t=t.R;t.L;)t=t.L;t.L=n}else t.R=n;e=t}else this._?(t=Cu(this._),n.P=null,n.N=t,t.P=t.L=n,e=t):(n.P=n.N=null,this._=n,e=null);for(n.L=n.R=null,n.U=e,n.C=!0,t=n;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.R&&(Eu(this,e),t=e,e=t.U),e.C=!1,r.C=!0,Au(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.L&&(Au(this,e),t=e,e=t.U),e.C=!1,r.C=!0,Eu(this,r))),e=t.U;this._.C=!1},remove:function(t){t.N&&(t.N.P=t.P),t.P&&(t.P.N=t.N),t.N=t.P=null;var n,e,r,i=t.U,o=t.L,u=t.R;if(e=o?u?Cu(u):o:u,i?i.L===t?i.L=e:i.R=e:this._=e,o&&u?(r=e.C,e.C=t.C,e.L=o,o.U=e,e!==u?(i=e.U,e.U=t.U,t=e.R,i.L=t,e.R=u,u.U=e):(e.U=i,i=e,t=e.R)):(r=t.C,t=e),t&&(t.U=i),!r){if(t&&t.C)return void(t.C=!1);do{if(t===this._)break;if(t===i.L){if(n=i.R,n.C&&(n.C=!1,i.C=!0,Eu(this,i),n=i.R),n.L&&n.L.C||n.R&&n.R.C){n.R&&n.R.C||(n.L.C=!1,n.C=!0,Au(this,n),n=i.R),n.C=i.C,i.C=n.R.C=!1,Eu(this,i),t=this._;break}}else if(n=i.L,n.C&&(n.C=!1,i.C=!0,Au(this,i),n=i.L),n.L&&n.L.C||n.R&&n.R.C){n.L&&n.L.C||(n.R.C=!1,n.C=!0,Eu(this,n),n=i.L),n.C=i.C,i.C=n.L.C=!1,Au(this,i),t=this._;break}n.C=!0,t=i,i=i.U}while(!t.C);t&&(t.C=!1)}}};var cm,sm,fm,lm,hm,pm=[],dm=[],vm=1e-6,_m=1e-12;na.prototype={constructor:na,polygons:function(){var t=this.edges;return this.cells.map(function(n){var e=n.halfedges.map(function(e){return Fu(n,t[e])});return e.data=n.site.data,e})},triangles:function(){var t=[],n=this.edges;return this.cells.forEach(function(e,r){for(var i,o=e.site,u=e.halfedges,a=-1,c=u.length,s=n[u[c-1]],f=s.left===o?s.right:s.left;++a<c;)i=f,s=n[u[a]],f=s.left===o?s.right:s.left,i&&f&&r<i.index&&r<f.index&&Ku(o,i,f)<0&&t.push([o.data,i.data,f.data])}),t},links:function(){return this.edges.filter(function(t){return t.right}).map(function(t){return{source:t.left.data,target:t.right.data}})},find:function(t,n,e){var r,i=this,o=i._found||0,u=i.cells[o]||i.cells[o=0],a=t-u.site[0],c=n-u.site[1],s=a*a+c*c;do u=i.cells[r=o],o=null,u.halfedges.forEach(function(e){var r=i.edges[e],a=r.left;if(a!==u.site&&a||(a=r.right)){var c=t-a[0],f=n-a[1],l=c*c+f*f;l<s&&(s=l,o=a.index)}});while(null!==o);return i._found=r,null==e||s<=e*e?u.site:null}};var ym=function(){function t(t){return new na(t.map(function(r,i){var o=[Math.round(n(r,i,t)/vm)*vm,Math.round(e(r,i,t)/vm)*vm];return o.index=i,o.data=r,o}),r)}var n=Tu,e=Nu,r=null;return t.polygons=function(n){return t(n).polygons()},t.links=function(n){return t(n).links()},t.triangles=function(n){return t(n).triangles()},t.x=function(e){return arguments.length?(n="function"==typeof e?e:am(+e),t):n},t.y=function(n){return arguments.length?(e="function"==typeof n?n:am(+n),t):e},t.extent=function(n){return arguments.length?(r=null==n?null:[[+n[0][0],+n[0][1]],[+n[1][0],+n[1][1]]],t):r&&[[r[0][0],r[0][1]],[r[1][0],r[1][1]]]},t.size=function(n){return arguments.length?(r=null==n?null:[[0,0],[+n[0],+n[1]]],t):r&&[r[1][0]-r[0][0],r[1][1]-r[0][1]]},t},gm=function(t){return function(){return t}};ra.prototype={constructor:ra,scale:function(t){return 1===t?this:new ra(this.k*t,this.x,this.y)},translate:function(t,n){return 0===t&0===n?this:new ra(this.k,this.x+this.k*t,this.y+this.k*n)},apply:function(t){return[t[0]*this.k+this.x,t[1]*this.k+this.y]},applyX:function(t){return t*this.k+this.x},applyY:function(t){return t*this.k+this.y},invert:function(t){return[(t[0]-this.x)/this.k,(t[1]-this.y)/this.k]},invertX:function(t){return(t-this.x)/this.k},invertY:function(t){return(t-this.y)/this.k},rescaleX:function(t){return t.copy().domain(t.range().map(this.invertX,this).map(t.invert,t))},rescaleY:function(t){return t.copy().domain(t.range().map(this.invertY,this).map(t.invert,t))},toString:function(){return"translate("+this.x+","+this.y+") scale("+this.k+")"}};var mm=new ra(1,0,0);ia.prototype=ra.prototype;var xm=function(){t.event.preventDefault(),t.event.stopImmediatePropagation()},bm=function(){function n(t){t.on("wheel.zoom",s).on("mousedown.zoom",f).on("dblclick.zoom",l).on("touchstart.zoom",h).on("touchmove.zoom",p).on("touchend.zoom touchcancel.zoom",d).style("-webkit-tap-highlight-color","rgba(0,0,0,0)").property("__zoom",ca)}function e(t,n){return n=Math.max(m,Math.min(x,n)),n===t.k?t:new ra(n,t.x,t.y)}function r(t,n,e){var r=n[0]-e[0]*t.k,i=n[1]-e[1]*t.k;return r===t.x&&i===t.y?t:new ra(t.k,r,i)}function i(t,n){var e=t.invertX(n[0][0])-b,r=t.invertX(n[1][0])-w,i=t.invertY(n[0][1])-M,o=t.invertY(n[1][1])-T;return t.translate(r>e?(e+r)/2:Math.min(0,e)||Math.max(0,r),o>i?(i+o)/2:Math.min(0,i)||Math.max(0,o))}function o(t){return[(+t[0][0]+ +t[1][0])/2,(+t[0][1]+ +t[1][1])/2]}function u(t,n,e){t.on("start.zoom",function(){a(this,arguments).start()}).on("interrupt.zoom end.zoom",function(){a(this,arguments).end()}).tween("zoom",function(){var t=this,r=arguments,i=a(t,r),u=g.apply(t,r),c=e||o(u),s=Math.max(u[1][0]-u[0][0],u[1][1]-u[0][1]),f=t.__zoom,l="function"==typeof n?n.apply(t,r):n,h=k(f.invert(c).concat(s/f.k),l.invert(c).concat(s/l.k));return function(t){if(1===t)t=l;else{var n=h(t),e=s/n[2];t=new ra(e,c[0]-n[0]*e,c[1]-n[1]*e)}i.zoom(null,t)}})}function a(t,n){for(var e,r=0,i=S.length;r<i;++r)if((e=S[r]).that===t)return e;return new c(t,n)}function c(t,n){this.that=t,this.args=n,this.index=-1,this.active=0,this.extent=g.apply(t,n)}function s(){function n(){o.wheel=null,o.end()}if(y.apply(this,arguments)){var o=a(this,arguments),u=this.__zoom,c=Math.max(m,Math.min(x,u.k*Math.pow(2,-t.event.deltaY*(t.event.deltaMode?120:1)/500))),s=F_(this);if(o.wheel)o.mouse[0][0]===s[0]&&o.mouse[0][1]===s[1]||(o.mouse[1]=u.invert(o.mouse[0]=s)),clearTimeout(o.wheel);else{if(u.k===c)return;o.mouse=[s,u.invert(s)],Ly(this),o.start()}xm(),o.wheel=setTimeout(n,C),o.zoom("mouse",i(r(e(u,c),o.mouse[0],o.mouse[1]),o.extent))}}function f(){function n(){xm(),o.moved=!0,o.zoom("mouse",i(r(o.that.__zoom,o.mouse[0]=F_(o.that),o.mouse[1]),o.extent))}function e(){u.on("mousemove.zoom mouseup.zoom",null),mu(t.event.view,o.moved),xm(),o.end()}if(!_&&y.apply(this,arguments)){var o=a(this,arguments),u=by(t.event.view).on("mousemove.zoom",n,!0).on("mouseup.zoom",e,!0),c=F_(this);im(t.event.view),oa(),o.mouse=[c,this.__zoom.invert(c)],Ly(this),o.start()}}function l(){if(y.apply(this,arguments)){var o=this.__zoom,a=F_(this),c=o.invert(a),s=o.k*(t.event.shiftKey?.5:2),f=i(r(e(o,s),a,c),g.apply(this,arguments));xm(),N>0?by(this).transition().duration(N).call(u,f,a):by(this).call(n.transform,f)}}function h(){if(y.apply(this,arguments)){var n,e,r,i=a(this,arguments),o=t.event.changedTouches,u=o.length;for(oa(),n=0;n<u;++n)e=o[n],r=My(this,o,e.identifier),r=[r,this.__zoom.invert(r),e.identifier],i.touch0?i.touch1||(i.touch1=r):i.touch0=r;return v&&(v=clearTimeout(v),!i.touch1)?(i.end(),r=by(this).on("dblclick.zoom"),void(r&&r.apply(this,arguments))):void(t.event.touches.length===u&&(v=setTimeout(function(){v=null},A),Ly(this),i.start()))}}function p(){var n,o,u,c,s=a(this,arguments),f=t.event.changedTouches,l=f.length;for(xm(),v&&(v=clearTimeout(v)),n=0;n<l;++n)o=f[n],u=My(this,f,o.identifier),s.touch0&&s.touch0[2]===o.identifier?s.touch0[0]=u:s.touch1&&s.touch1[2]===o.identifier&&(s.touch1[0]=u);if(o=s.that.__zoom,s.touch1){var h=s.touch0[0],p=s.touch0[1],d=s.touch1[0],_=s.touch1[1],y=(y=d[0]-h[0])*y+(y=d[1]-h[1])*y,g=(g=_[0]-p[0])*g+(g=_[1]-p[1])*g;o=e(o,Math.sqrt(y/g)),u=[(h[0]+d[0])/2,(h[1]+d[1])/2],c=[(p[0]+_[0])/2,(p[1]+_[1])/2]}else{if(!s.touch0)return;u=s.touch0[0],c=s.touch0[1]}s.zoom("touch",i(r(o,u,c),s.extent))}function d(){var n,e,r=a(this,arguments),i=t.event.changedTouches,o=i.length;for(oa(),_&&clearTimeout(_),_=setTimeout(function(){_=null},A),n=0;n<o;++n)e=i[n],r.touch0&&r.touch0[2]===e.identifier?delete r.touch0:r.touch1&&r.touch1[2]===e.identifier&&delete r.touch1;r.touch1&&!r.touch0&&(r.touch0=r.touch1,delete r.touch1),r.touch0||r.end()}var v,_,y=ua,g=aa,m=0,x=1/0,b=-x,w=x,M=b,T=w,N=250,k=Cp,S=[],E=Pn("start","zoom","end"),A=500,C=150;return n.transform=function(t,n){var e=t.selection?t.selection():t;e.property("__zoom",ca),t!==e?u(t,n):e.interrupt().each(function(){a(this,arguments).start().zoom(null,"function"==typeof n?n.apply(this,arguments):n).end()})},n.scaleBy=function(t,e){n.scaleTo(t,function(){var t=this.__zoom.k,n="function"==typeof e?e.apply(this,arguments):e;return t*n})},n.scaleTo=function(t,u){n.transform(t,function(){var t=g.apply(this,arguments),n=this.__zoom,a=o(t),c=n.invert(a),s="function"==typeof u?u.apply(this,arguments):u;return i(r(e(n,s),a,c),t)})},n.translateBy=function(t,e,r){n.transform(t,function(){return i(this.__zoom.translate("function"==typeof e?e.apply(this,arguments):e,"function"==typeof r?r.apply(this,arguments):r),g.apply(this,arguments))})},c.prototype={start:function(){return 1===++this.active&&(this.index=S.push(this)-1,this.emit("start")),this},zoom:function(t,n){return this.mouse&&"mouse"!==t&&(this.mouse[1]=n.invert(this.mouse[0])),this.touch0&&"touch"!==t&&(this.touch0[1]=n.invert(this.touch0[0])),this.touch1&&"touch"!==t&&(this.touch1[1]=n.invert(this.touch1[0])),this.that.__zoom=n,this.emit("zoom"),this},end:function(){return 0===--this.active&&(S.splice(this.index,1),this.index=-1,this.emit("end")),this},emit:function(t){Xr(new ea(n,t,this.that.__zoom),E.apply,E,[t,this.that,this.args])}},n.filter=function(t){return arguments.length?(y="function"==typeof t?t:gm(!!t),n):y},n.extent=function(t){return arguments.length?(g="function"==typeof t?t:gm([[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]]),n):g},n.scaleExtent=function(t){return arguments.length?(m=+t[0],x=+t[1],n):[m,x]},n.translateExtent=function(t){return arguments.length?(b=+t[0][0],w=+t[1][0],M=+t[0][1],T=+t[1][1],n):[[b,M],[w,T]]},n.duration=function(t){return arguments.length?(N=+t,n):N},n.interpolate=function(t){return arguments.length?(k=t,n):k},n.on=function(){var t=E.on.apply(E,arguments);return t===E?n:t},n},wm=function(t){return function(){return t}},Mm=function(t,n,e){this.target=t,this.type=n,this.selection=e},Tm=function(){t.event.preventDefault(),t.event.stopImmediatePropagation()},Nm={name:"drag"},km={name:"space"},Sm={name:"handle"},Em={name:"center"},Am={name:"x",handles:["e","w"].map(fa),input:function(t,n){return t&&[[t[0],n[0][1]],[t[1],n[1][1]]]},output:function(t){return t&&[t[0][0],t[1][0]]}},Cm={name:"y",handles:["n","s"].map(fa),input:function(t,n){return t&&[[n[0][0],t[0]],[n[1][0],t[1]]]},output:function(t){return t&&[t[0][1],t[1][1]]}},zm={name:"xy",handles:["n","e","s","w","nw","ne","se","sw"].map(fa),input:function(t){return t},output:function(t){return t}},Pm={overlay:"crosshair",selection:"move",n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Rm={e:"w",w:"e",nw:"ne",ne:"nw",se:"sw",sw:"se"},qm={n:"s",s:"n",nw:"sw",ne:"se",se:"ne",sw:"nw"},Lm={overlay:1,selection:1,n:null,e:1,s:null,w:-1,nw:-1,ne:1,se:1,sw:-1},Um={overlay:1,selection:1,n:-1,e:null,s:1,w:null,nw:-1,ne:-1,se:1,sw:1},Dm=function(){return ga(zm)},Om=Math.cos,Fm=Math.sin,Im=Math.PI,Ym=Im/2,Bm=2*Im,jm=Math.max,Hm=function(){function t(t){var o,u,a,c,s,f,l=t.length,h=[],p=Os(l),d=[],v=[],_=v.groups=new Array(l),y=new Array(l*l);for(o=0,s=-1;++s<l;){for(u=0,f=-1;++f<l;)u+=t[s][f];h.push(u),d.push(Os(l)),o+=u}for(e&&p.sort(function(t,n){return e(h[t],h[n])}),r&&d.forEach(function(n,e){n.sort(function(n,i){return r(t[e][n],t[e][i])})}),o=jm(0,Bm-n*l)/o,c=o?n:Bm/l,u=0,s=-1;++s<l;){for(a=u,f=-1;++f<l;){var g=p[s],m=d[g][f],x=t[g][m],b=u,w=u+=x*o;y[m*l+g]={index:g,subindex:m,startAngle:b,endAngle:w,value:x}}_[g]={index:g,startAngle:a,endAngle:u,value:h[g]},u+=c}for(s=-1;++s<l;)for(f=s-1;++f<l;){var M=y[f*l+s],T=y[s*l+f];(M.value||T.value)&&v.push(M.value<T.value?{source:T,target:M}:{source:M,target:T})}return i?v.sort(i):v}var n=0,e=null,r=null,i=null;return t.padAngle=function(e){return arguments.length?(n=jm(0,e),t):n},t.sortGroups=function(n){return arguments.length?(e=n,t):e},t.sortSubgroups=function(n){return arguments.length?(r=n,t):r},t.sortChords=function(n){return arguments.length?(null==n?i=null:(i=ma(n))._=n,t):i&&i._},t},Xm=Array.prototype.slice,Vm=function(t){return function(){return t}},Wm=function(){function t(){var t,a=Xm.call(arguments),c=n.apply(this,a),s=e.apply(this,a),f=+r.apply(this,(a[0]=c,a)),l=i.apply(this,a)-Ym,h=o.apply(this,a)-Ym,p=f*Om(l),d=f*Fm(l),v=+r.apply(this,(a[0]=s,a)),_=i.apply(this,a)-Ym,y=o.apply(this,a)-Ym;if(u||(u=t=q()),u.moveTo(p,d),u.arc(0,0,f,l,h),l===_&&h===y||(u.quadraticCurveTo(0,0,v*Om(_),v*Fm(_)),u.arc(0,0,v,_,y)),u.quadraticCurveTo(0,0,p,d),u.closePath(),t)return u=null,t+""||null}var n=xa,e=ba,r=wa,i=Ma,o=Ta,u=null;return t.radius=function(n){return arguments.length?(r="function"==typeof n?n:Vm(+n),t):r},t.startAngle=function(n){return arguments.length?(i="function"==typeof n?n:Vm(+n),t):i},t.endAngle=function(n){return arguments.length?(o="function"==typeof n?n:Vm(+n),t):o},t.source=function(e){return arguments.length?(n=e,t):n},t.target=function(n){return arguments.length?(e=n,t):e},t.context=function(n){return arguments.length?(u=null==n?null:n,t):u},t},$m=function(){return new Na};Na.prototype={constructor:Na,reset:function(){this.s=this.t=0},add:function(t){ka(kx,t,this.t),ka(this,kx.s,this.s),this.s?this.t+=kx.t:this.s=kx.t},valueOf:function(){return this.s}};var Zm,Gm,Jm,Qm,Km,tx,nx,ex,rx,ix,ox,ux,ax,cx,sx,fx,lx,hx,px,dx,vx,_x,yx,gx,mx,xx,bx,wx,Mx,Tx,Nx,kx=new Na,Sx=1e-6,Ex=1e-12,Ax=Math.PI,Cx=Ax/2,zx=Ax/4,Px=2*Ax,Rx=180/Ax,qx=Ax/180,Lx=Math.abs,Ux=Math.atan,Dx=Math.atan2,Ox=Math.cos,Fx=Math.ceil,Ix=Math.exp,Yx=Math.log,Bx=Math.pow,jx=Math.sin,Hx=Math.sign||function(t){return t>0?1:t<0?-1:0},Xx=Math.sqrt,Vx=Math.tan,Wx={Feature:function(t,n){za(t.geometry,n);
},FeatureCollection:function(t,n){for(var e=t.features,r=-1,i=e.length;++r<i;)za(e[r].geometry,n)}},$x={Sphere:function(t,n){n.sphere()},Point:function(t,n){t=t.coordinates,n.point(t[0],t[1],t[2])},MultiPoint:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)t=e[r],n.point(t[0],t[1],t[2])},LineString:function(t,n){Pa(t.coordinates,n,0)},MultiLineString:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)Pa(e[r],n,0)},Polygon:function(t,n){Ra(t.coordinates,n)},MultiPolygon:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)Ra(e[r],n)},GeometryCollection:function(t,n){for(var e=t.geometries,r=-1,i=e.length;++r<i;)za(e[r],n)}},Zx=function(t,n){t&&Wx.hasOwnProperty(t.type)?Wx[t.type](t,n):za(t,n)},Gx=$m(),Jx=$m(),Qx={point:Ca,lineStart:Ca,lineEnd:Ca,polygonStart:function(){Gx.reset(),Qx.lineStart=qa,Qx.lineEnd=La},polygonEnd:function(){var t=+Gx;Jx.add(t<0?Px+t:t),this.lineStart=this.lineEnd=this.point=Ca},sphere:function(){Jx.add(Px)}},Kx=function(t){return Jx.reset(),Zx(t,Qx),2*Jx},tb=$m(),nb={point:Xa,lineStart:Wa,lineEnd:$a,polygonStart:function(){nb.point=Za,nb.lineStart=Ga,nb.lineEnd=Ja,tb.reset(),Qx.polygonStart()},polygonEnd:function(){Qx.polygonEnd(),nb.point=Xa,nb.lineStart=Wa,nb.lineEnd=$a,Gx<0?(tx=-(ex=180),nx=-(rx=90)):tb>Sx?rx=90:tb<-Sx&&(nx=-90),sx[0]=tx,sx[1]=ex}},eb=function(t){var n,e,r,i,o,u,a;if(rx=ex=-(tx=nx=1/0),cx=[],Zx(t,nb),e=cx.length){for(cx.sort(Ka),n=1,r=cx[0],o=[r];n<e;++n)i=cx[n],tc(r,i[0])||tc(r,i[1])?(Qa(r[0],i[1])>Qa(r[0],r[1])&&(r[1]=i[1]),Qa(i[0],r[1])>Qa(r[0],r[1])&&(r[0]=i[0])):o.push(r=i);for(u=-(1/0),e=o.length-1,n=0,r=o[e];n<=e;r=i,++n)i=o[n],(a=Qa(r[1],i[0]))>u&&(u=a,tx=i[0],ex=r[1])}return cx=sx=null,tx===1/0||nx===1/0?[[NaN,NaN],[NaN,NaN]]:[[tx,nx],[ex,rx]]},rb={sphere:Ca,point:nc,lineStart:rc,lineEnd:uc,polygonStart:function(){rb.lineStart=ac,rb.lineEnd=cc},polygonEnd:function(){rb.lineStart=rc,rb.lineEnd=uc}},ib=function(t){fx=lx=hx=px=dx=vx=_x=yx=gx=mx=xx=0,Zx(t,rb);var n=gx,e=mx,r=xx,i=n*n+e*e+r*r;return i<Ex&&(n=vx,e=_x,r=yx,lx<Sx&&(n=hx,e=px,r=dx),i=n*n+e*e+r*r,i<Ex)?[NaN,NaN]:[Dx(e,n)*Rx,Ea(r/Xx(i))*Rx]},ob=function(t){return function(){return t}},ub=function(t,n){function e(e,r){return e=t(e,r),n(e[0],e[1])}return t.invert&&n.invert&&(e.invert=function(e,r){return e=n.invert(e,r),e&&t.invert(e[0],e[1])}),e};lc.invert=lc;var ab,cb,sb,fb,lb,hb,pb,db,vb,_b,yb,gb=function(t){function n(n){return n=t(n[0]*qx,n[1]*qx),n[0]*=Rx,n[1]*=Rx,n}return t=hc(t[0]*qx,t[1]*qx,t.length>2?t[2]*qx:0),n.invert=function(n){return n=t.invert(n[0]*qx,n[1]*qx),n[0]*=Rx,n[1]*=Rx,n},n},mb=function(){function t(t,n){e.push(t=r(t,n)),t[0]*=Rx,t[1]*=Rx}function n(){var t=i.apply(this,arguments),n=o.apply(this,arguments)*qx,c=u.apply(this,arguments)*qx;return e=[],r=hc(-t[0]*qx,-t[1]*qx,0).invert,_c(a,n,c,1),t={type:"Polygon",coordinates:[e]},e=r=null,t}var e,r,i=ob([0,0]),o=ob(90),u=ob(6),a={point:t};return n.center=function(t){return arguments.length?(i="function"==typeof t?t:ob([+t[0],+t[1]]),n):i},n.radius=function(t){return arguments.length?(o="function"==typeof t?t:ob(+t),n):o},n.precision=function(t){return arguments.length?(u="function"==typeof t?t:ob(+t),n):u},n},xb=function(){var t,n=[];return{point:function(n,e){t.push([n,e])},lineStart:function(){n.push(t=[])},lineEnd:Ca,rejoin:function(){n.length>1&&n.push(n.pop().concat(n.shift()))},result:function(){var e=n;return n=[],t=null,e}}},bb=function(t,n,e,r,i,o){var u,a=t[0],c=t[1],s=n[0],f=n[1],l=0,h=1,p=s-a,d=f-c;if(u=e-a,p||!(u>0)){if(u/=p,p<0){if(u<l)return;u<h&&(h=u)}else if(p>0){if(u>h)return;u>l&&(l=u)}if(u=i-a,p||!(u<0)){if(u/=p,p<0){if(u>h)return;u>l&&(l=u)}else if(p>0){if(u<l)return;u<h&&(h=u)}if(u=r-c,d||!(u>0)){if(u/=d,d<0){if(u<l)return;u<h&&(h=u)}else if(d>0){if(u>h)return;u>l&&(l=u)}if(u=o-c,d||!(u<0)){if(u/=d,d<0){if(u>h)return;u>l&&(l=u)}else if(d>0){if(u<l)return;u<h&&(h=u)}return l>0&&(t[0]=a+l*p,t[1]=c+l*d),h<1&&(n[0]=a+h*p,n[1]=c+h*d),!0}}}}},wb=function(t,n){return Lx(t[0]-n[0])<Sx&&Lx(t[1]-n[1])<Sx},Mb=function(t,n,e,r,i){var o,u,a=[],c=[];if(t.forEach(function(t){if(!((n=t.length-1)<=0)){var n,e,r=t[0],u=t[n];if(wb(r,u)){for(i.lineStart(),o=0;o<n;++o)i.point((r=t[o])[0],r[1]);return void i.lineEnd()}a.push(e=new gc(r,t,null,!0)),c.push(e.o=new gc(r,null,e,!1)),a.push(e=new gc(u,t,null,!1)),c.push(e.o=new gc(u,null,e,!0))}}),a.length){for(c.sort(n),mc(a),mc(c),o=0,u=c.length;o<u;++o)c[o].e=e=!e;for(var s,f,l=a[0];;){for(var h=l,p=!0;h.v;)if((h=h.n)===l)return;s=h.z,i.lineStart();do{if(h.v=h.o.v=!0,h.e){if(p)for(o=0,u=s.length;o<u;++o)i.point((f=s[o])[0],f[1]);else r(h.x,h.n.x,1,i);h=h.n}else{if(p)for(s=h.p.z,o=s.length-1;o>=0;--o)i.point((f=s[o])[0],f[1]);else r(h.x,h.p.x,-1,i);h=h.p}h=h.o,s=h.z,p=!p}while(!h.v);i.lineEnd()}}},Tb=1e9,Nb=-Tb,kb=function(){var t,n,e,r=0,i=0,o=960,u=500;return e={stream:function(e){return t&&n===e?t:t=xc(r,i,o,u)(n=e)},extent:function(a){return arguments.length?(r=+a[0][0],i=+a[0][1],o=+a[1][0],u=+a[1][1],t=n=null,e):[[r,i],[o,u]]}}},Sb=$m(),Eb={sphere:Ca,point:Ca,lineStart:bc,lineEnd:Ca,polygonStart:Ca,polygonEnd:Ca},Ab=function(t){return Sb.reset(),Zx(t,Eb),+Sb},Cb=[null,null],zb={type:"LineString",coordinates:Cb},Pb=function(t,n){return Cb[0]=t,Cb[1]=n,Ab(zb)},Rb=function(t,n){var e=t[0]*qx,r=t[1]*qx,i=n[0]*qx,o=n[1]*qx,u=Ox(r),a=jx(r),c=Ox(o),s=jx(o),f=u*Ox(e),l=u*jx(e),h=c*Ox(i),p=c*jx(i),d=2*Ea(Xx(Aa(o-r)+u*c*Aa(i-e))),v=jx(d),_=d?function(t){var n=jx(t*=d)/v,e=jx(d-t)/v,r=e*f+n*h,i=e*l+n*p,o=e*a+n*s;return[Dx(i,r)*Rx,Dx(o,Xx(r*r+i*i))*Rx]}:function(){return[e*Rx,r*Rx]};return _.distance=d,_},qb=function(t){return t},Lb=$m(),Ub=$m(),Db={point:Ca,lineStart:Ca,lineEnd:Ca,polygonStart:function(){Db.lineStart=Ac,Db.lineEnd=Pc},polygonEnd:function(){Db.lineStart=Db.lineEnd=Db.point=Ca,Lb.add(Lx(Ub)),Ub.reset()},result:function(){var t=Lb/2;return Lb.reset(),t}},Ob=1/0,Fb=Ob,Ib=-Ob,Yb=Ib,Bb={point:Rc,lineStart:Ca,lineEnd:Ca,polygonStart:Ca,polygonEnd:Ca,result:function(){var t=[[Ob,Fb],[Ib,Yb]];return Ib=Yb=-(Fb=Ob=1/0),t}},jb=0,Hb=0,Xb=0,Vb=0,Wb=0,$b=0,Zb=0,Gb=0,Jb=0,Qb={point:qc,lineStart:Lc,lineEnd:Oc,polygonStart:function(){Qb.lineStart=Fc,Qb.lineEnd=Ic},polygonEnd:function(){Qb.point=qc,Qb.lineStart=Lc,Qb.lineEnd=Oc},result:function(){var t=Jb?[Zb/Jb,Gb/Jb]:$b?[Vb/$b,Wb/$b]:Xb?[jb/Xb,Hb/Xb]:[NaN,NaN];return jb=Hb=Xb=Vb=Wb=$b=Zb=Gb=Jb=0,t}};jc.prototype={_radius:4.5,pointRadius:function(t){return this._radius=t,this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._context.closePath(),this._point=NaN},point:function(t,n){switch(this._point){case 0:this._context.moveTo(t,n),this._point=1;break;case 1:this._context.lineTo(t,n);break;default:this._context.moveTo(t+this._radius,n),this._context.arc(t,n,this._radius,0,Px)}},result:Ca},Hc.prototype={_circle:Xc(4.5),pointRadius:function(t){return this._circle=Xc(t),this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._string.push("Z"),this._point=NaN},point:function(t,n){switch(this._point){case 0:this._string.push("M",t,",",n),this._point=1;break;case 1:this._string.push("L",t,",",n);break;default:this._string.push("M",t,",",n,this._circle)}},result:function(){if(this._string.length){var t=this._string.join("");return this._string=[],t}}};var Kb=function(t,n){function e(t){return t&&("function"==typeof o&&i.pointRadius(+o.apply(this,arguments)),Zx(t,r(i))),i.result()}var r,i,o=4.5;return e.area=function(t){return Zx(t,r(Db)),Db.result()},e.bounds=function(t){return Zx(t,r(Bb)),Bb.result()},e.centroid=function(t){return Zx(t,r(Qb)),Qb.result()},e.projection=function(n){return arguments.length?(r=null==n?(t=null,qb):(t=n).stream,e):t},e.context=function(t){return arguments.length?(i=null==t?(n=null,new Hc):new jc(n=t),"function"!=typeof o&&i.pointRadius(o),e):n},e.pointRadius=function(t){return arguments.length?(o="function"==typeof t?t:(i.pointRadius(+t),+t),e):o},e.projection(t).context(n)},tw=$m(),nw=function(t,n){var e=n[0],r=n[1],i=[jx(e),-Ox(e),0],o=0,u=0;tw.reset();for(var a=0,c=t.length;a<c;++a)if(f=(s=t[a]).length)for(var s,f,l=s[f-1],h=l[0],p=l[1]/2+zx,d=jx(p),v=Ox(p),_=0;_<f;++_,h=g,d=x,v=b,l=y){var y=s[_],g=y[0],m=y[1]/2+zx,x=jx(m),b=Ox(m),w=g-h,M=w>=0?1:-1,T=M*w,N=T>Ax,k=d*x;if(tw.add(Dx(k*M*jx(T),v*b+k*Ox(T))),o+=N?w+M*Px:w,N^h>=e^g>=e){var S=Ya(Fa(l),Fa(y));Ha(S);var E=Ya(i,S);Ha(E);var A=(N^w>=0?-1:1)*Ea(E[2]);(r>A||r===A&&(S[0]||S[1]))&&(u+=N^w>=0?1:-1)}}return(o<-Sx||o<Sx&&tw<-Sx)^1&u},ew=function(t,n,e,r){return function(i,o){function u(n,e){var r=i(n,e);t(n=r[0],e=r[1])&&o.point(n,e)}function a(t,n){var e=i(t,n);_.point(e[0],e[1])}function c(){b.point=a,_.lineStart()}function s(){b.point=u,_.lineEnd()}function f(t,n){v.push([t,n]);var e=i(t,n);m.point(e[0],e[1])}function l(){m.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),m.lineEnd();var t,n,e,r,i=m.clean(),u=g.result(),a=u.length;if(v.pop(),p.push(v),v=null,a)if(1&i){if(e=u[0],(n=e.length-1)>0){for(x||(o.polygonStart(),x=!0),o.lineStart(),t=0;t<n;++t)o.point((r=e[t])[0],r[1]);o.lineEnd()}}else a>1&&2&i&&u.push(u.pop().concat(u.shift())),d.push(u.filter(Vc))}var p,d,v,_=n(o),y=i.invert(r[0],r[1]),g=xb(),m=n(g),x=!1,b={point:u,lineStart:c,lineEnd:s,polygonStart:function(){b.point=f,b.lineStart=l,b.lineEnd=h,d=[],p=[]},polygonEnd:function(){b.point=u,b.lineStart=c,b.lineEnd=s,d=Js(d);var t=nw(p,y);d.length?(x||(o.polygonStart(),x=!0),Mb(d,Wc,t,e,o)):t&&(x||(o.polygonStart(),x=!0),o.lineStart(),e(null,null,1,o),o.lineEnd()),x&&(o.polygonEnd(),x=!1),d=p=null},sphere:function(){o.polygonStart(),o.lineStart(),e(null,null,1,o),o.lineEnd(),o.polygonEnd()}};return b}},rw=ew(function(){return!0},$c,Gc,[-Ax,-Cx]),iw=function(t,n){function e(e,r,i,o){_c(o,t,n,i,e,r)}function r(t,n){return Ox(t)*Ox(n)>a}function i(t){var n,e,i,a,f;return{lineStart:function(){a=i=!1,f=1},point:function(l,h){var p,d=[l,h],v=r(l,h),_=c?v?0:u(l,h):v?u(l+(l<0?Ax:-Ax),h):0;if(!n&&(a=i=v)&&t.lineStart(),v!==i&&(p=o(n,d),(wb(n,p)||wb(d,p))&&(d[0]+=Sx,d[1]+=Sx,v=r(d[0],d[1]))),v!==i)f=0,v?(t.lineStart(),p=o(d,n),t.point(p[0],p[1])):(p=o(n,d),t.point(p[0],p[1]),t.lineEnd()),n=p;else if(s&&n&&c^v){var y;_&e||!(y=o(d,n,!0))||(f=0,c?(t.lineStart(),t.point(y[0][0],y[0][1]),t.point(y[1][0],y[1][1]),t.lineEnd()):(t.point(y[1][0],y[1][1]),t.lineEnd(),t.lineStart(),t.point(y[0][0],y[0][1])))}!v||n&&wb(n,d)||t.point(d[0],d[1]),n=d,i=v,e=_},lineEnd:function(){i&&t.lineEnd(),n=null},clean:function(){return f|(a&&i)<<1}}}function o(t,n,e){var r=Fa(t),i=Fa(n),o=[1,0,0],u=Ya(r,i),c=Ia(u,u),s=u[0],f=c-s*s;if(!f)return!e&&t;var l=a*c/f,h=-a*s/f,p=Ya(o,u),d=ja(o,l),v=ja(u,h);Ba(d,v);var _=p,y=Ia(d,_),g=Ia(_,_),m=y*y-g*(Ia(d,d)-1);if(!(m<0)){var x=Xx(m),b=ja(_,(-y-x)/g);if(Ba(b,d),b=Oa(b),!e)return b;var w,M=t[0],T=n[0],N=t[1],k=n[1];T<M&&(w=M,M=T,T=w);var S=T-M,E=Lx(S-Ax)<Sx,A=E||S<Sx;if(!E&&k<N&&(w=N,N=k,k=w),A?E?N+k>0^b[1]<(Lx(b[0]-M)<Sx?N:k):N<=b[1]&&b[1]<=k:S>Ax^(M<=b[0]&&b[0]<=T)){var C=ja(_,(-y+x)/g);return Ba(C,d),[b,Oa(C)]}}}function u(n,e){var r=c?t:Ax-t,i=0;return n<-r?i|=1:n>r&&(i|=2),e<-r?i|=4:e>r&&(i|=8),i}var a=Ox(t),c=a>0,s=Lx(a)>Sx;return ew(r,i,e,c?[0,-t]:[-Ax,t-Ax])},ow=function(t){return{stream:Jc(t)}};Qc.prototype={constructor:Qc,point:function(t,n){this.stream.point(t,n)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var uw=16,aw=Ox(30*qx),cw=function(t,n){return+n?es(t,n):ns(t)},sw=Jc({point:function(t,n){this.stream.point(t*qx,n*qx)}}),fw=function(){return os(as).scale(155.424).center([0,33.6442])},lw=function(){return fw().parallels([29.5,45.5]).scale(1070).translate([480,250]).rotate([96,0]).center([-.6,38.7])},hw=function(){function t(t){var n=t[0],e=t[1];return a=null,i.point(n,e),a||(o.point(n,e),a)||(u.point(n,e),a)}function n(){return e=r=null,t}var e,r,i,o,u,a,c=lw(),s=fw().rotate([154,0]).center([-2,58.5]).parallels([55,65]),f=fw().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(t,n){a=[t,n]}};return t.invert=function(t){var n=c.scale(),e=c.translate(),r=(t[0]-e[0])/n,i=(t[1]-e[1])/n;return(i>=.12&&i<.234&&r>=-.425&&r<-.214?s:i>=.166&&i<.234&&r>=-.214&&r<-.115?f:c).invert(t)},t.stream=function(t){return e&&r===t?e:e=cs([c.stream(r=t),s.stream(t),f.stream(t)])},t.precision=function(t){return arguments.length?(c.precision(t),s.precision(t),f.precision(t),n()):c.precision()},t.scale=function(n){return arguments.length?(c.scale(n),s.scale(.35*n),f.scale(n),t.translate(c.translate())):c.scale()},t.translate=function(t){if(!arguments.length)return c.translate();var e=c.scale(),r=+t[0],a=+t[1];return i=c.translate(t).clipExtent([[r-.455*e,a-.238*e],[r+.455*e,a+.238*e]]).stream(l),o=s.translate([r-.307*e,a+.201*e]).clipExtent([[r-.425*e+Sx,a+.12*e+Sx],[r-.214*e-Sx,a+.234*e-Sx]]).stream(l),u=f.translate([r-.205*e,a+.212*e]).clipExtent([[r-.214*e+Sx,a+.166*e+Sx],[r-.115*e-Sx,a+.234*e-Sx]]).stream(l),n()},t.fitExtent=function(n,e){return Kc(t,n,e)},t.fitSize=function(n,e){return ts(t,n,e)},t.scale(1070)},pw=ss(function(t){return Xx(2/(1+t))});pw.invert=fs(function(t){return 2*Ea(t/2)});var dw=function(){return rs(pw).scale(124.75).clipAngle(179.999)},vw=ss(function(t){return(t=Sa(t))&&t/jx(t)});vw.invert=fs(function(t){return t});var _w=function(){return rs(vw).scale(79.4188).clipAngle(179.999)};ls.invert=function(t,n){return[t,2*Ux(Ix(n))-Cx]};var yw=function(){return hs(ls).scale(961/Px)},gw=function(){return os(ds).scale(109.5).parallels([30,30])};vs.invert=vs;var mw=function(){return rs(vs).scale(152.63)},xw=function(){return os(_s).scale(131.154).center([0,13.9389])};ys.invert=fs(Ux);var bw=function(){return rs(ys).scale(144.049).clipAngle(60)},ww=function(){function t(){return i=o=null,u}var n,e,r,i,o,u,a=1,c=0,s=0,f=1,l=1,h=qb,p=null,d=qb;return u={stream:function(t){return i&&o===t?i:i=h(d(o=t))},clipExtent:function(i){return arguments.length?(d=null==i?(p=n=e=r=null,qb):xc(p=+i[0][0],n=+i[0][1],e=+i[1][0],r=+i[1][1]),t()):null==p?null:[[p,n],[e,r]]},scale:function(n){return arguments.length?(h=gs((a=+n)*f,a*l,c,s),t()):a},translate:function(n){return arguments.length?(h=gs(a*f,a*l,c=+n[0],s=+n[1]),t()):[c,s]},reflectX:function(n){return arguments.length?(h=gs(a*(f=n?-1:1),a*l,c,s),t()):f<0},reflectY:function(n){return arguments.length?(h=gs(a*f,a*(l=n?-1:1),c,s),t()):l<0},fitExtent:function(t,n){return Kc(u,t,n)},fitSize:function(t,n){return ts(u,t,n)}}};ms.invert=fs(Ea);var Mw=function(){return rs(ms).scale(249.5).clipAngle(90+Sx)};xs.invert=fs(function(t){return 2*Ux(t)});var Tw=function(){return rs(xs).scale(250).clipAngle(142)};bs.invert=function(t,n){return[-n,2*Ux(Ix(t))-Cx]};var Nw=function(){var t=hs(bs),n=t.center,e=t.rotate;return t.center=function(t){return arguments.length?n([-t[1],t[0]]):(t=n(),[t[1],-t[0]])},t.rotate=function(t){return arguments.length?e([t[0],t[1],t.length>2?t[2]+90:90]):(t=e(),[t[0],t[1],t[2]-90])},e([0,0,90]).scale(159.155)};t.version=ws,t.bisect=ks,t.bisectRight=ks,t.bisectLeft=Ss,t.ascending=Ms,t.bisector=Ts,t.descending=Es,t.deviation=zs,t.extent=Ps,t.histogram=Hs,t.thresholdFreedmanDiaconis=Vs,t.thresholdScott=Ws,t.thresholdSturges=js,t.max=$s,t.mean=Zs,t.median=Gs,t.merge=Js,t.min=Qs,t.pairs=Ks,t.permute=tf,t.quantile=Xs,t.range=Os,t.scan=nf,t.shuffle=ef,t.sum=rf,t.ticks=Bs,t.tickStep=e,t.transpose=of,t.variance=Cs,t.zip=uf,t.entries=hf,t.keys=ff,t.values=lf,t.map=o,t.set=l,t.nest=cf,t.randomUniform=pf,t.randomNormal=df,t.randomLogNormal=vf,t.randomBates=yf,t.randomIrwinHall=_f,t.randomExponential=gf,t.easeLinear=h,t.easeQuad=v,t.easeQuadIn=p,t.easeQuadOut=d,t.easeQuadInOut=v,t.easeCubic=g,t.easeCubicIn=_,t.easeCubicOut=y,t.easeCubicInOut=g,t.easePoly=wf,t.easePolyIn=xf,t.easePolyOut=bf,t.easePolyInOut=wf,t.easeSin=b,t.easeSinIn=m,t.easeSinOut=x,t.easeSinInOut=b,t.easeExp=T,t.easeExpIn=w,t.easeExpOut=M,t.easeExpInOut=T,t.easeCircle=S,t.easeCircleIn=N,t.easeCircleOut=k,t.easeCircleInOut=S,t.easeBounce=A,t.easeBounceIn=E,t.easeBounceOut=A,t.easeBounceInOut=C,t.easeBack=Of,t.easeBackIn=Uf,t.easeBackOut=Df,t.easeBackInOut=Of,t.easeElastic=jf,t.easeElasticIn=Bf,t.easeElasticOut=jf,t.easeElasticInOut=Hf,t.polygonArea=Xf,t.polygonCentroid=Vf,t.polygonHull=$f,t.polygonContains=Zf,t.polygonLength=Gf,t.path=q,t.quadtree=I,t.queue=Z,t.arc=wl,t.area=Nl,t.line=Tl,t.pie=El,t.radialArea=zl,t.radialLine=Cl,t.symbol=Jl,t.symbols=Gl,t.symbolCircle=Pl,t.symbolCross=Rl,t.symbolDiamond=Ul,t.symbolSquare=Bl,t.symbolStar=Yl,t.symbolTriangle=Hl,t.symbolWye=Zl,t.curveBasisClosed=th,t.curveBasisOpen=nh,t.curveBasis=Kl,t.curveBundle=eh,t.curveCardinalClosed=ih,t.curveCardinalOpen=oh,t.curveCardinal=rh,t.curveCatmullRomClosed=ah,t.curveCatmullRomOpen=ch,t.curveCatmullRom=uh,t.curveLinearClosed=sh,t.curveLinear=Ml,t.curveMonotoneX=zt,t.curveMonotoneY=Pt,t.curveNatural=fh,t.curveStep=lh,t.curveStepAfter=Dt,t.curveStepBefore=Ut,t.stack=vh,t.stackOffsetExpand=_h,t.stackOffsetNone=ph,t.stackOffsetSilhouette=yh,t.stackOffsetWiggle=gh,t.stackOrderAscending=mh,t.stackOrderDescending=xh,t.stackOrderInsideOut=bh,t.stackOrderNone=dh,t.stackOrderReverse=wh,t.color=Bt,t.rgb=Vt,t.hsl=Gt,t.lab=tn,t.hcl=cn,t.cubehelix=ln,t.interpolate=mp,t.interpolateArray=hp,t.interpolateDate=pp,t.interpolateNumber=dp,t.interpolateObject=vp,t.interpolateRound=xp,t.interpolateString=gp,t.interpolateTransformCss=Tp,t.interpolateTransformSvg=Np,t.interpolateZoom=Cp,t.interpolateRgb=sp,t.interpolateRgbBasis=fp,t.interpolateRgbBasisClosed=lp,t.interpolateHsl=zp,t.interpolateHslLong=Pp,t.interpolateLab=An,t.interpolateHcl=Rp,t.interpolateHclLong=qp,t.interpolateCubehelix=Lp,t.interpolateCubehelixLong=Up,t.interpolateBasis=up,t.interpolateBasisClosed=ap,t.quantize=Dp,t.dispatch=Pn,t.dsvFormat=Yp,t.csvParse=jp,t.csvParseRows=Hp,t.csvFormat=Xp,t.csvFormatRows=Vp,t.tsvParse=$p,t.tsvParseRows=Zp,t.tsvFormat=Gp,t.tsvFormatRows=Jp,t.request=Qp,t.html=td,t.json=nd,t.text=ed,t.xml=rd,t.csv=od,t.tsv=ud,t.now=jn,t.timer=Vn,t.timerFlush=Wn,t.timeout=_d,t.interval=yd,t.timeInterval=Qn,t.timeMillisecond=xd,t.timeMilliseconds=bd,t.timeSecond=Sd,t.timeSeconds=Ed,t.timeMinute=Ad,t.timeMinutes=Cd,t.timeHour=zd,t.timeHours=Pd,t.timeDay=Rd,t.timeDays=qd,t.timeWeek=Ld,t.timeWeeks=Bd,t.timeSunday=Ld,t.timeSundays=Bd,t.timeMonday=Ud,t.timeMondays=jd,t.timeTuesday=Dd,t.timeTuesdays=Hd;t.timeWednesday=Od;t.timeWednesdays=Xd,t.timeThursday=Fd,t.timeThursdays=Vd,t.timeFriday=Id,t.timeFridays=Wd,t.timeSaturday=Yd,t.timeSaturdays=$d,t.timeMonth=Zd,t.timeMonths=Gd,t.timeYear=Jd,t.timeYears=Qd,t.utcMillisecond=xd,t.utcMilliseconds=bd,t.utcSecond=Sd,t.utcSeconds=Ed,t.utcMinute=Kd,t.utcMinutes=tv,t.utcHour=nv,t.utcHours=ev,t.utcDay=rv,t.utcDays=iv,t.utcWeek=ov,t.utcWeeks=hv,t.utcSunday=ov,t.utcSundays=hv,t.utcMonday=uv,t.utcMondays=pv,t.utcTuesday=av,t.utcTuesdays=dv,t.utcWednesday=cv,t.utcWednesdays=vv,t.utcThursday=sv,t.utcThursdays=_v,t.utcFriday=fv,t.utcFridays=yv,t.utcSaturday=lv,t.utcSaturdays=gv,t.utcMonth=mv,t.utcMonths=xv,t.utcYear=bv,t.utcYears=Mv,t.formatLocale=Lv,t.formatDefaultLocale=re,t.formatSpecifier=Pv,t.precisionFixed=Dv,t.precisionPrefix=Ov,t.precisionRound=Fv,t.isoFormat=Xv,t.isoParse=Vv,t.timeFormatLocale=ae,t.timeFormatDefaultLocale=nr,t.scaleBand=or,t.scalePoint=ar,t.scaleIdentity=yr,t.scaleLinear=_r,t.scaleLog=Tr,t.scaleOrdinal=ir,t.scaleImplicit=Gv,t.scalePow=kr,t.scaleSqrt=Sr,t.scaleQuantile=Er,t.scaleQuantize=Ar,t.scaleThreshold=Cr,t.scaleTime=s_,t.scaleUtc=f_,t.schemeCategory10=h_,t.schemeCategory20b=p_,t.schemeCategory20c=d_,t.schemeCategory20=v_,t.scaleSequential=Lr,t.interpolateCubehelixDefault=__,t.interpolateRainbow=x_,t.interpolateWarm=y_,t.interpolateCool=g_,t.interpolateViridis=b_,t.interpolateMagma=w_,t.interpolateInferno=M_,t.interpolatePlasma=T_,t.creator=E_,t.customEvent=Xr,t.local=Or,t.matcher=R_,t.mouse=F_,t.namespace=S_,t.namespaces=k_,t.select=by,t.selectAll=wy,t.selection=Pi,t.selector=I_,t.selectorAll=B_,t.touch=My,t.touches=Ty,t.window=ay,t.active=ag,t.interrupt=Ly,t.transition=fo,t.axisTop=mo,t.axisRight=xo,t.axisBottom=bo,t.axisLeft=wo,t.cluster=vg,t.hierarchy=zo,t.pack=Cg,t.packSiblings=Eg,t.packEnclose=Sg,t.partition=Rg,t.stratify=Dg,t.tree=Og,t.treemap=Bg,t.treemapBinary=jg,t.treemapDice=Pg,t.treemapSlice=Fg,t.treemapSliceDice=Hg,t.treemapSquarify=Yg,t.treemapResquarify=Xg,t.forceCenter=Vg,t.forceCollide=Zg,t.forceLink=Gg,t.forceManyBody=tm,t.forceSimulation=Kg,t.forceX=nm,t.forceY=em,t.drag=um,t.dragDisable=im,t.dragEnable=mu,t.voronoi=ym,t.zoom=bm,t.zoomIdentity=mm,t.zoomTransform=ia,t.brush=Dm,t.brushX=_a,t.brushY=ya,t.brushSelection=va,t.chord=Hm,t.ribbon=Wm,t.geoAlbers=lw,t.geoAlbersUsa=hw,t.geoArea=Kx,t.geoAzimuthalEqualArea=dw,t.geoAzimuthalEqualAreaRaw=pw,t.geoAzimuthalEquidistant=_w,t.geoAzimuthalEquidistantRaw=vw,t.geoBounds=eb,t.geoCentroid=ib,t.geoCircle=mb,t.geoClipExtent=kb,t.geoConicConformal=gw,t.geoConicConformalRaw=ds,t.geoConicEqualArea=fw,t.geoConicEqualAreaRaw=as,t.geoConicEquidistant=xw,t.geoConicEquidistantRaw=_s,t.geoDistance=Pb,t.geoEquirectangular=mw,t.geoEquirectangularRaw=vs,t.geoGnomonic=bw,t.geoGnomonicRaw=ys,t.geoGraticule=Sc,t.geoGraticule10=Ec,t.geoIdentity=ww,t.geoInterpolate=Rb,t.geoLength=Ab,t.geoMercator=yw,t.geoMercatorRaw=ls,t.geoOrthographic=Mw,t.geoOrthographicRaw=ms,t.geoPath=Kb,t.geoProjection=rs,t.geoProjectionMutator=is,t.geoRotation=gb,t.geoStereographic=Tw,t.geoStereographicRaw=xs,t.geoStream=Zx,t.geoTransform=ow,t.geoTransverseMercator=Nw,t.geoTransverseMercatorRaw=bs,Object.defineProperty(t,"__esModule",{value:!0})});
},{}],7:[function(require,module,exports){
/**
 * @preserve
 * jquery.layout 1.4.4
 * $Date: 2014-11-29 08:00:00 (Sat, 29 November 2014) $
 * $Rev: 1.0404 $
 *
 * Copyright (c) 2014 Kevin Dalman (http://jquery-dev.com)
 * Based on work by Fabrizio Balliano (http://www.fabrizioballiano.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * SEE: http://layout.jquery-dev.com/LICENSE.txt
 *
 * Changelog: http://layout.jquery-dev.com/changelog.cfm
 *
 * Docs: http://layout.jquery-dev.com/documentation.html
 * Tips: http://layout.jquery-dev.com/tips.html
 * Help: http://groups.google.com/group/jquery-ui-layout
 */

/* JavaDoc Info: http://code.google.com/closure/compiler/docs/js-for-compiler.html
 * {!Object}	non-nullable type (never NULL)
 * {?string}	nullable type (sometimes NULL) - default for {Object}
 * {number=}	optional parameter
 * {*}			ALL types
 */
/*	TODO for jQ 2.x
 *	check $.fn.disableSelection - this is in jQuery UI 1.9.x
 */

// NOTE: For best readability, view with a fixed-width font and tabs equal to 4-chars

;(function ($) {

// alias Math methods - used a lot!
  var	min		= Math.min
    ,	max		= Math.max
    ,	round	= Math.floor

    ,	isStr	=  function (v) { return $.type(v) === "string"; }

    /**
     * @param {!Object}			Instance
     * @param {Array.<string>}	a_fn
     */
    ,	runPluginCallbacks = function (Instance, a_fn) {
      if ($.isArray(a_fn))
        for (var i=0, c=a_fn.length; i<c; i++) {
          var fn = a_fn[i];
          try {
            if (isStr(fn)) // 'name' of a function
              fn = eval(fn);
            if ($.isFunction(fn))
              g(fn)( Instance );
          } catch (ex) {}
        }
      function g (f) { return f; }; // compiler hack
    }
  ;

  /*
   *	GENERIC $.layout METHODS - used by all layouts
   */
  $.layout = {

    version:	"1.4.4"
    ,	revision:	1.0404 // eg: ver 1.4.4 = rev 1.0404 - major(n+).minor(nn)+patch(nn+)

    // $.layout.browser REPLACES $.browser
    ,	browser:	{} // set below

    // *PREDEFINED* EFFECTS & DEFAULTS
    // MUST list effect here - OR MUST set an fxSettings option (can be an empty hash: {})
    ,	effects: {

      //	Pane Open/Close Animations
      slide: {
        all:	{ duration:  "fast"	} // eg: duration: 1000, easing: "easeOutBounce"
        ,	north:	{ direction: "up"	}
        ,	south:	{ direction: "down"	}
        ,	east:	{ direction: "right"}
        ,	west:	{ direction: "left"	}
      }
      ,	drop: {
        all:	{ duration:  "slow"	}
        ,	north:	{ direction: "up"	}
        ,	south:	{ direction: "down"	}
        ,	east:	{ direction: "right"}
        ,	west:	{ direction: "left"	}
      }
      ,	scale: {
        all:	{ duration:	"fast"	}
      }
      //	these are not recommended, but can be used
      ,	blind:		{}
      ,	clip:		{}
      ,	explode:	{}
      ,	fade:		{}
      ,	fold:		{}
      ,	puff:		{}

      //	Pane Resize Animations
      ,	size: {
        all:	{ easing:	"swing"	}
      }
    }

    // INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
    ,	config: {
      optionRootKeys:	"effects,panes,north,south,west,east,center".split(",")
      ,	allPanes:		"north,south,west,east,center".split(",")
      ,	borderPanes:	"north,south,west,east".split(",")
      ,	oppositeEdge: {
        north:	"south"
        ,	south:	"north"
        ,	east: 	"west"
        ,	west: 	"east"
      }
      //	offscreen data
      ,	offscreenCSS:	{ left: "-99999px", right: "auto" } // used by hide/close if useOffscreenClose=true
      ,	offscreenReset:	"offscreenReset" // key used for data
      //	CSS used in multiple places
      ,	hidden:		{ visibility: "hidden" }
      ,	visible:	{ visibility: "visible" }
      //	layout element settings
      ,	resizers: {
        cssReq: {
          position: 	"absolute"
          ,	padding: 	0
          ,	margin: 	0
          ,	fontSize:	"1px"
          ,	textAlign:	"left"	// to counter-act "center" alignment!
          ,	overflow: 	"hidden" // prevent toggler-button from overflowing
          //	SEE $.layout.defaults.zIndexes.resizer_normal
        }
        ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
          background: "#DDD"
          ,	border:		"none"
        }
      }
      ,	togglers: {
        cssReq: {
          position: 	"absolute"
          ,	display: 	"block"
          ,	padding: 	0
          ,	margin: 	0
          ,	overflow:	"hidden"
          ,	textAlign:	"center"
          ,	fontSize:	"1px"
          ,	cursor: 	"pointer"
          ,	zIndex: 	1
        }
        ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
          background: "#AAA"
        }
      }
      ,	content: {
        cssReq: {
          position:	"relative" /* contain floated or positioned elements */
        }
        ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
          overflow:	"auto"
          ,	padding:	"10px"
        }
        ,	cssDemoPane: { // DEMO CSS - REMOVE scrolling from 'pane' when it has a content-div
          overflow:	"hidden"
          ,	padding:	0
        }
      }
      ,	panes: { // defaults for ALL panes - overridden by 'per-pane settings' below
        cssReq: {
          position: 	"absolute"
          ,	margin:		0
          //	$.layout.defaults.zIndexes.pane_normal
        }
        ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
          padding:	"10px"
          ,	background:	"#FFF"
          ,	border:		"1px solid #BBB"
          ,	overflow:	"auto"
        }
      }
      ,	north: {
        side:			"top"
        ,	sizeType:		"Height"
        ,	dir:			"horz"
        ,	cssReq: {
          top: 		0
          ,	bottom: 	"auto"
          ,	left: 		0
          ,	right: 		0
          ,	width: 		"auto"
          //	height: 	DYNAMIC
        }
      }
      ,	south: {
        side:			"bottom"
        ,	sizeType:		"Height"
        ,	dir:			"horz"
        ,	cssReq: {
          top: 		"auto"
          ,	bottom: 	0
          ,	left: 		0
          ,	right: 		0
          ,	width: 		"auto"
          //	height: 	DYNAMIC
        }
      }
      ,	east: {
        side:			"right"
        ,	sizeType:		"Width"
        ,	dir:			"vert"
        ,	cssReq: {
          left: 		"auto"
          ,	right: 		0
          ,	top: 		"auto" // DYNAMIC
          ,	bottom: 	"auto" // DYNAMIC
          ,	height: 	"auto"
          //	width: 		DYNAMIC
        }
      }
      ,	west: {
        side:			"left"
        ,	sizeType:		"Width"
        ,	dir:			"vert"
        ,	cssReq: {
          left: 		0
          ,	right: 		"auto"
          ,	top: 		"auto" // DYNAMIC
          ,	bottom: 	"auto" // DYNAMIC
          ,	height: 	"auto"
          //	width: 		DYNAMIC
        }
      }
      ,	center: {
        dir:			"center"
        ,	cssReq: {
          left: 		"auto" // DYNAMIC
          ,	right: 		"auto" // DYNAMIC
          ,	top: 		"auto" // DYNAMIC
          ,	bottom: 	"auto" // DYNAMIC
          ,	height: 	"auto"
          ,	width: 		"auto"
        }
      }
    }

    // CALLBACK FUNCTION NAMESPACE - used to store reusable callback functions
    ,	callbacks: {}

    ,	getParentPaneElem: function (el) {
      // must pass either a container or pane element
      var $el = $(el)
        ,	layout = $el.data("layout") || $el.data("parentLayout");
      if (layout) {
        var $cont = layout.container;
        // see if this container is directly-nested inside an outer-pane
        if ($cont.data("layoutPane")) return $cont;
        var $pane = $cont.closest("."+ $.layout.defaults.panes.paneClass);
        // if a pane was found, return it
        if ($pane.data("layoutPane")) return $pane;
      }
      return null;
    }

    ,	getParentPaneInstance: function (el) {
      // must pass either a container or pane element
      var $pane = $.layout.getParentPaneElem(el);
      return $pane ? $pane.data("layoutPane") : null;
    }

    ,	getParentLayoutInstance: function (el) {
      // must pass either a container or pane element
      var $pane = $.layout.getParentPaneElem(el);
      return $pane ? $pane.data("parentLayout") : null;
    }

    ,	getEventObject: function (evt) {
      return typeof evt === "object" && evt.stopPropagation ? evt : null;
    }
    ,	parsePaneName: function (evt_or_pane) {
      var evt = $.layout.getEventObject( evt_or_pane )
        ,	pane = evt_or_pane;
      if (evt) {
        // ALWAYS stop propagation of events triggered in Layout!
        evt.stopPropagation();
        pane = $(this).data("layoutEdge");
      }
      if (pane && !/^(west|east|north|south|center)$/.test(pane)) {
        $.layout.msg('LAYOUT ERROR - Invalid pane-name: "'+ pane +'"');
        pane = "error";
      }
      return pane;
    }


    // LAYOUT-PLUGIN REGISTRATION
    // more plugins can added beyond this default list
    ,	plugins: {
      draggable:		!!$.fn.draggable // resizing
      ,	effects: {
        core:		!!$.effects		// animimations (specific effects tested by initOptions)
        ,	slide:		$.effects && ($.effects.slide || ($.effects.effect && $.effects.effect.slide)) // default effect
      }
    }

//	arrays of plugin or other methods to be triggered for events in *each layout* - will be passed 'Instance'
    ,	onCreate:	[]	// runs when layout is just starting to be created - right after options are set
    ,	onLoad:		[]	// runs after layout container and global events init, but before initPanes is called
    ,	onReady:	[]	// runs after initialization *completes* - ie, after initPanes completes successfully
    ,	onDestroy:	[]	// runs after layout is destroyed
    ,	onUnload:	[]	// runs after layout is destroyed OR when page unloads
    ,	afterOpen:	[]	// runs after setAsOpen() completes
    ,	afterClose:	[]	// runs after setAsClosed() completes

    /*
     *	GENERIC UTILITY METHODS
     */

    // calculate and return the scrollbar width, as an integer
    ,	scrollbarWidth:		function () { return window.scrollbarWidth  || $.layout.getScrollbarSize('width'); }
    ,	scrollbarHeight:	function () { return window.scrollbarHeight || $.layout.getScrollbarSize('height'); }
    ,	getScrollbarSize:	function (dim) {
      var $c	= $('<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; border: 0; overflow: scroll;"></div>').appendTo("body")
        ,	d	= { width: $c.outerWidth - $c[0].clientWidth, height: 100 - $c[0].clientHeight };
      $c.remove();
      window.scrollbarWidth	= d.width;
      window.scrollbarHeight	= d.height;
      return dim.match(/^(width|height)$/) ? d[dim] : d;
    }


    ,	disableTextSelection: function () {
      var $d	= $(document)
        ,	s	= 'textSelectionDisabled'
        ,	x	= 'textSelectionInitialized'
      ;
      if ($.fn.disableSelection) {
        if (!$d.data(x)) // document hasn't been initialized yet
          $d.on('mouseup', $.layout.enableTextSelection ).data(x, true);
        if (!$d.data(s))
          $d.disableSelection().data(s, true);
      }
    }
    ,	enableTextSelection: function () {
      var $d	= $(document)
        ,	s	= 'textSelectionDisabled';
      if ($.fn.enableSelection && $d.data(s))
        $d.enableSelection().data(s, false);
    }


    /**
     * Returns hash container 'display' and 'visibility'
     *
     * @see	$.swap() - swaps CSS, runs callback, resets CSS
     * @param  {!Object}		$E				jQuery element
     * @param  {boolean=}	[force=false]	Run even if display != none
     * @return {!Object}						Returns current style props, if applicable
     */
    ,	showInvisibly: function ($E, force) {
      if ($E && $E.length && (force || $E.css("display") === "none")) { // only if not *already hidden*
        var s = $E[0].style
          // save ONLY the 'style' props because that is what we must restore
          ,	CSS = { display: s.display || '', visibility: s.visibility || '' };
        // show element 'invisibly' so can be measured
        $E.css({ display: "block", visibility: "hidden" });
        return CSS;
      }
      return {};
    }

    /**
     * Returns data for setting size of an element (container or a pane).
     *
     * @see  _create(), onWindowResize() for container, plus others for pane
     * @return JSON  Returns a hash of all dimensions: top, bottom, left, right, outerWidth, innerHeight, etc
     */
    ,	getElementDimensions: function ($E, inset) {
      var
        //	dimensions hash - start with current data IF passed
        d	= { css: {}, inset: {} }
        ,	x	= d.css			// CSS hash
        ,	i	= { bottom: 0 }	// TEMP insets (bottom = complier hack)
        ,	N	= $.layout.cssNum
        ,	R	= Math.round
        ,	off = $E.offset()
        ,	b, p, ei			// TEMP border, padding
      ;
      d.offsetLeft = off.left;
      d.offsetTop  = off.top;

      if (!inset) inset = {}; // simplify logic below

      $.each("Left,Right,Top,Bottom".split(","), function (idx, e) { // e = edge
        b = x["border" + e] = $.layout.borderWidth($E, e);
        p = x["padding"+ e] = $.layout.cssNum($E, "padding"+e);
        ei = e.toLowerCase();
        d.inset[ei] = inset[ei] >= 0 ? inset[ei] : p; // any missing insetX value = paddingX
        i[ei] = d.inset[ei] + b; // total offset of content from outer side
      });

      x.width		= R($E.width());
      x.height	= R($E.height());
      x.top		= N($E,"top",true);
      x.bottom	= N($E,"bottom",true);
      x.left		= N($E,"left",true);
      x.right		= N($E,"right",true);

      d.outerWidth	= R($E.outerWidth());
      d.outerHeight	= R($E.outerHeight());
      // calc the TRUE inner-dimensions, even in quirks-mode!
      d.innerWidth	= max(0, d.outerWidth  - i.left - i.right);
      d.innerHeight	= max(0, d.outerHeight - i.top  - i.bottom);
      // layoutWidth/Height is used in calcs for manual resizing
      // layoutW/H only differs from innerW/H when in quirks-mode - then is like outerW/H
      d.layoutWidth	= R($E.innerWidth());
      d.layoutHeight	= R($E.innerHeight());

      //if ($E.prop('tagName') === 'BODY') { debugData( d, $E.prop('tagName') ); } // DEBUG

      //d.visible	= $E.is(":visible");// && x.width > 0 && x.height > 0;

      return d;
    }

    ,	getElementStyles: function ($E, list) {
      var
        CSS	= {}
        ,	style	= $E[0].style
        ,	props	= list.split(",")
        ,	sides	= "Top,Bottom,Left,Right".split(",")
        ,	attrs	= "Color,Style,Width".split(",")
        ,	p, s, a, i, j, k
      ;
      for (i=0; i < props.length; i++) {
        p = props[i];
        if (p.match(/(border|padding|margin)$/))
          for (j=0; j < 4; j++) {
            s = sides[j];
            if (p === "border")
              for (k=0; k < 3; k++) {
                a = attrs[k];
                CSS[p+s+a] = style[p+s+a];
              }
            else
              CSS[p+s] = style[p+s];
          }
        else
          CSS[p] = style[p];
      };
      return CSS
    }

    /**
     * Return the innerWidth for the current browser/doctype
     *
     * @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
     * @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
     * @param  {number=}			outerWidth (optional) Can pass a width, allowing calculations BEFORE element is resized
     * @return {number}			Returns the innerWidth of the elem by subtracting padding and borders
     */
    ,	cssWidth: function ($E, outerWidth) {
      // a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
      if (outerWidth <= 0) return 0;

      var lb	= $.layout.browser
        ,	bs	= !lb.boxModel ? "border-box" : lb.boxSizing ? $E.css("boxSizing") : "content-box"
        ,	b	= $.layout.borderWidth
        ,	n	= $.layout.cssNum
        ,	W	= outerWidth
      ;
      // strip border and/or padding from outerWidth to get CSS Width
      if (bs !== "border-box")
        W -= (b($E, "Left") + b($E, "Right"));
      if (bs === "content-box")
        W -= (n($E, "paddingLeft") + n($E, "paddingRight"));
      return max(0,W);
    }

    /**
     * Return the innerHeight for the current browser/doctype
     *
     * @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
     * @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
     * @param  {number=}			outerHeight  (optional) Can pass a width, allowing calculations BEFORE element is resized
     * @return {number}			Returns the innerHeight of the elem by subtracting padding and borders
     */
    ,	cssHeight: function ($E, outerHeight) {
      // a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
      if (outerHeight <= 0) return 0;

      var lb	= $.layout.browser
        ,	bs	= !lb.boxModel ? "border-box" : lb.boxSizing ? $E.css("boxSizing") : "content-box"
        ,	b	= $.layout.borderWidth
        ,	n	= $.layout.cssNum
        ,	H	= outerHeight
      ;
      // strip border and/or padding from outerHeight to get CSS Height
      if (bs !== "border-box")
        H -= (b($E, "Top") + b($E, "Bottom"));
      if (bs === "content-box")
        H -= (n($E, "paddingTop") + n($E, "paddingBottom"));
      return max(0,H);
    }

    /**
     * Returns the 'current CSS numeric value' for a CSS property - 0 if property does not exist
     *
     * @see  Called by many methods
     * @param {Array.<Object>}	$E					Must pass a jQuery object - first element is processed
     * @param {string}			prop				The name of the CSS property, eg: top, width, etc.
     * @param {boolean=}			[allowAuto=false]	true = return 'auto' if that is value; false = return 0
     * @return {(string|number)}						Usually used to get an integer value for position (top, left) or size (height, width)
     */
    ,	cssNum: function ($E, prop, allowAuto) {
      if (!$E.jquery) $E = $($E);
      var CSS = $.layout.showInvisibly($E)
        ,	p	= $.css($E[0], prop, true)
        ,	v	= allowAuto && p=="auto" ? p : Math.round(parseFloat(p) || 0);
      $E.css( CSS ); // RESET
      return v;
    }

    ,	borderWidth: function (el, side) {
      if (el.jquery) el = el[0];
      var b = "border"+ side.substr(0,1).toUpperCase() + side.substr(1); // left => Left
      return $.css(el, b+"Style", true) === "none" ? 0 : Math.round(parseFloat($.css(el, b+"Width", true)) || 0);
    }

    /**
     * Mouse-tracking utility - FUTURE REFERENCE
     *
     * init: if (!window.mouse) {
	 *			window.mouse = { x: 0, y: 0 };
	 *			$(document).mousemove( $.layout.trackMouse );
	 *		}
     *
     * @param {Object}		evt
     *
     ,	trackMouse: function (evt) {
		window.mouse = { x: evt.clientX, y: evt.clientY };
	}
     */

    /**
     * SUBROUTINE for preventPrematureSlideClose option
     *
     * @param {Object}		evt
     * @param {Object=}		el
     */
    ,	isMouseOverElem: function (evt, el) {
      var
        $E	= $(el || this)
        ,	d	= $E.offset()
        ,	T	= d.top
        ,	L	= d.left
        ,	R	= L + $E.outerWidth()
        ,	B	= T + $E.outerHeight()
        ,	x	= evt.pageX	// evt.clientX ?
        ,	y	= evt.pageY	// evt.clientY ?
      ;
      // if X & Y are < 0, probably means is over an open SELECT
      return ($.layout.browser.msie && x < 0 && y < 0) || ((x >= L && x <= R) && (y >= T && y <= B));
    }

    /**
     * Message/Logging Utility
     *
     * @example $.layout.msg("My message");				// log text
     * @example $.layout.msg("My message", true);		// alert text
     * @example $.layout.msg({ foo: "bar" }, "Title");	// log hash-data, with custom title
     * @example $.layout.msg({ foo: "bar" }, true, "Title", { sort: false }); -OR-
     * @example $.layout.msg({ foo: "bar" }, "Title", { sort: false, display: true }); // alert hash-data
     *
     * @param {(Object|string)}			info			String message OR Hash/Array
     * @param {(Boolean|string|Object)=}	[popup=false]	True means alert-box - can be skipped
     * @param {(Object|string)=}			[debugTitle=""]	Title for Hash data - can be skipped
     * @param {Object=}					[debugOpts]		Extra options for debug output
     */
    ,	msg: function (info, popup, debugTitle, debugOpts) {
      if ($.isPlainObject(info) && window.debugData) {
        if (typeof popup === "string") {
          debugOpts	= debugTitle;
          debugTitle	= popup;
        }
        else if (typeof debugTitle === "object") {
          debugOpts	= debugTitle;
          debugTitle	= null;
        }
        var t = debugTitle || "log( <object> )"
          ,	o = $.extend({ sort: false, returnHTML: false, display: false }, debugOpts);
        if (popup === true || o.display)
          debugData( info, t, o );
        else if (window.console)
          console.log(debugData( info, t, o ));
      }
      else if (popup)
        alert(info);
      else if (window.console)
        console.log(info);
      else {
        var id	= "#layoutLogger"
          ,	$l = $(id);
        if (!$l.length)
          $l = createLog();
        $l.children("ul").append('<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">'+ info.replace(/\</g,"&lt;").replace(/\>/g,"&gt;") +'</li>');
      }

      function createLog () {
        var pos = $.support.fixedPosition ? 'fixed' : 'absolute'
          ,	$e = $('<div id="layoutLogger" style="position: '+ pos +'; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">'
          +	'<div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;">'
          +	'<span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest(\'#layoutLogger\').remove()">X</span>Layout console.log</div>'
          +	'<ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul>'
          + '</div>'
        ).appendTo("body");
        $e.css('left', $(window).width() - $e.outerWidth() - 5)
        if ($.ui.draggable) $e.draggable({ handle: ':first-child' });
        return $e;
      };
    }

  };


  /*
   *	$.layout.browser REPLACES removed $.browser, with extra data
   *	Parsing code here adapted from jQuery 1.8 $.browse
   */
  (function(){
    var u = navigator.userAgent.toLowerCase()
      ,	m = /(chrome)[ \/]([\w.]+)/.exec( u )
      ||	/(webkit)[ \/]([\w.]+)/.exec( u )
      ||	/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( u )
      ||	/(msie) ([\w.]+)/.exec( u )
      ||	u.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( u )
      ||	[]
      ,	b = m[1] || ""
      ,	v = m[2] || 0
      ,	ie = b === "msie"
      ,	cm = document.compatMode
      ,	$s = $.support
      ,	bs = $s.boxSizing !== undefined ? $s.boxSizing : $s.boxSizingReliable
      ,	bm = !ie || !cm || cm === "CSS1Compat" || $s.boxModel || false
      ,	lb = $.layout.browser = {
      version:	v
      ,	safari:		b === "webkit"	// webkit (NOT chrome) = safari
      ,	webkit:		b === "chrome"	// chrome = webkit
      ,	msie:		ie
      ,	isIE6:		ie && v == 6
      // ONLY IE reverts to old box-model - Note that compatMode was deprecated as of IE8
      ,	boxModel:	bm
      ,	boxSizing:	!!(typeof bs === "function" ? bs() : bs)
    };
    ;
    if (b) lb[b] = true; // set CURRENT browser
    /*	OLD versions of jQuery only set $.support.boxModel after page is loaded
     *	so if this is IE, use support.boxModel to test for quirks-mode (ONLY IE changes boxModel) */
    if (!bm && !cm) $(function(){ lb.boxModel = $s.boxModel; });
  })();


// DEFAULT OPTIONS
  $.layout.defaults = {
    /*
     *	LAYOUT & LAYOUT-CONTAINER OPTIONS
     *	- none of these options are applicable to individual panes
     */
    name:						""			// Not required, but useful for buttons and used for the state-cookie
    ,	containerClass:				"ui-layout-container" // layout-container element
    ,	inset:						null		// custom container-inset values (override padding)
    ,	scrollToBookmarkOnLoad:		true		// after creating a layout, scroll to bookmark in URL (.../page.htm#myBookmark)
    ,	resizeWithWindow:			true		// bind thisLayout.resizeAll() to the window.resize event
    ,	resizeWithWindowDelay:		200			// delay calling resizeAll because makes window resizing very jerky
    ,	resizeWithWindowMaxDelay:	0			// 0 = none - force resize every XX ms while window is being resized
    ,	maskPanesEarly:				false		// true = create pane-masks on resizer.mouseDown instead of waiting for resizer.dragstart
    ,	onresizeall_start:			null		// CALLBACK when resizeAll() STARTS	- NOT pane-specific
    ,	onresizeall_end:			null		// CALLBACK when resizeAll() ENDS	- NOT pane-specific
    ,	onload_start:				null		// CALLBACK when Layout inits - after options initialized, but before elements
    ,	onload_end:					null		// CALLBACK when Layout inits - after EVERYTHING has been initialized
    ,	onunload_start:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
    ,	onunload_end:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
    ,	initPanes:					true		// false = DO NOT initialize the panes onLoad - will init later
    ,	showErrorMessages:			true		// enables fatal error messages to warn developers of common errors
    ,	showDebugMessages:			false		// display console-and-alert debug msgs - IF this Layout version _has_ debugging code!
//	Changing this zIndex value will cause other zIndex values to automatically change
    ,	zIndex:						null		// the PANE zIndex - resizers and masks will be +1
//	DO NOT CHANGE the zIndex values below unless you clearly understand their relationships
    ,	zIndexes: {								// set _default_ z-index values here...
      pane_normal:			0			// normal z-index for panes
      ,	content_mask:			1			// applied to overlays used to mask content INSIDE panes during resizing
      ,	resizer_normal:			2			// normal z-index for resizer-bars
      ,	pane_sliding:			100			// applied to *BOTH* the pane and its resizer when a pane is 'slid open'
      ,	pane_animate:			1000		// applied to the pane when being animated - not applied to the resizer
      ,	resizer_drag:			10000		// applied to the CLONED resizer-bar when being 'dragged'
    }
    ,	errors: {
      pane:					"pane"		// description of "layout pane element" - used only in error messages
      ,	selector:				"selector"	// description of "jQuery-selector" - used only in error messages
      ,	addButtonError:			"Error Adding Button\nInvalid "
      ,	containerMissing:		"UI Layout Initialization Error\nThe specified layout-container does not exist."
      ,	centerPaneMissing:		"UI Layout Initialization Error\nThe center-pane element does not exist.\nThe center-pane is a required element."
      ,	noContainerHeight:		"UI Layout Initialization Warning\nThe layout-container \"CONTAINER\" has no height.\nTherefore the layout is 0-height and hence 'invisible'!"
      ,	callbackError:			"UI Layout Callback Error\nThe EVENT callback is not a valid function."
    }
    /*
     *	PANE DEFAULT SETTINGS
     *	- settings under the 'panes' key become the default settings for *all panes*
     *	- ALL pane-options can also be set specifically for each panes, which will override these 'default values'
     */
    ,	panes: { // default options for 'all panes' - will be overridden by 'per-pane settings'
      applyDemoStyles: 		false		// NOTE: renamed from applyDefaultStyles for clarity
      ,	closable:				true		// pane can open & close
      ,	resizable:				true		// when open, pane can be resized
      ,	slidable:				true		// when closed, pane can 'slide open' over other panes - closes on mouse-out
      ,	initClosed:				false		// true = init pane as 'closed'
      ,	initHidden: 			false 		// true = init pane as 'hidden' - no resizer-bar/spacing
      //	SELECTORS
      //,	paneSelector:			""			// MUST be pane-specific - jQuery selector for pane
      ,	contentSelector:		".ui-layout-content" // INNER div/element to auto-size so only it scrolls, not the entire pane!
      ,	contentIgnoreSelector:	".ui-layout-ignore"	// element(s) to 'ignore' when measuring 'content'
      ,	findNestedContent:		false		// true = $P.find(contentSelector), false = $P.children(contentSelector)
      //	GENERIC ROOT-CLASSES - for auto-generated classNames
      ,	paneClass:				"ui-layout-pane"	// Layout Pane
      ,	resizerClass:			"ui-layout-resizer"	// Resizer Bar
      ,	togglerClass:			"ui-layout-toggler"	// Toggler Button
      ,	buttonClass:			"ui-layout-button"	// CUSTOM Buttons	- eg: '[ui-layout-button]-toggle/-open/-close/-pin'
      //	ELEMENT SIZE & SPACING
      //,	size:					100			// MUST be pane-specific -initial size of pane
      ,	minSize:				0			// when manually resizing a pane
      ,	maxSize:				0			// ditto, 0 = no limit
      ,	spacing_open:			6			// space between pane and adjacent panes - when pane is 'open'
      ,	spacing_closed:			6			// ditto - when pane is 'closed'
      ,	togglerLength_open:		50			// Length = WIDTH of toggler button on north/south sides - HEIGHT on east/west sides
      ,	togglerLength_closed: 	50			// 100% OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
      ,	togglerAlign_open:		"center"	// top/left, bottom/right, center, OR...
      ,	togglerAlign_closed:	"center"	// 1 => nn = offset from top/left, -1 => -nn == offset from bottom/right
      ,	togglerContent_open:	""			// text or HTML to put INSIDE the toggler
      ,	togglerContent_closed:	""			// ditto
      //	RESIZING OPTIONS
      ,	resizerDblClickToggle:	true		//
      ,	autoResize:				true		// IF size is 'auto' or a percentage, then recalc 'pixel size' whenever the layout resizes
      ,	autoReopen:				true		// IF a pane was auto-closed due to noRoom, reopen it when there is room? False = leave it closed
      ,	resizerDragOpacity:		1			// option for ui.draggable
      //,	resizerCursor:			""			// MUST be pane-specific - cursor when over resizer-bar
      ,	maskContents:			false		// true = add DIV-mask over-or-inside this pane so can 'drag' over IFRAMES
      ,	maskObjects:			false		// true = add IFRAME-mask over-or-inside this pane to cover objects/applets - content-mask will overlay this mask
      ,	maskZindex:				null		// will override zIndexes.content_mask if specified - not applicable to iframe-panes
      ,	resizingGrid:			false		// grid size that the resizers will snap-to during resizing, eg: [20,20]
      ,	livePaneResizing:		false		// true = LIVE Resizing as resizer is dragged
      ,	liveContentResizing:	false		// true = re-measure header/footer heights as resizer is dragged
      ,	liveResizingTolerance:	1			// how many px change before pane resizes, to control performance
      //	SLIDING OPTIONS
      ,	sliderCursor:			"pointer"	// cursor when resizer-bar will trigger 'sliding'
      ,	slideTrigger_open:		"click"		// click, dblclick, mouseenter
      ,	slideTrigger_close:		"mouseleave"// click, mouseleave
      ,	slideDelay_open:		300			// applies only for mouseenter event - 0 = instant open
      ,	slideDelay_close:		300			// applies only for mouseleave event (300ms is the minimum!)
      ,	hideTogglerOnSlide:		false		// when pane is slid-open, should the toggler show?
      ,	preventQuickSlideClose:	$.layout.browser.webkit // Chrome triggers slideClosed as it is opening
      ,	preventPrematureSlideClose: false	// handle incorrect mouseleave trigger, like when over a SELECT-list in IE
      //	PANE-SPECIFIC TIPS & MESSAGES
      ,	tips: {
        Open:				"Open"		// eg: "Open Pane"
        ,	Close:				"Close"
        ,	Resize:				"Resize"
        ,	Slide:				"Slide Open"
        ,	Pin:				"Pin"
        ,	Unpin:				"Un-Pin"
        ,	noRoomToOpen:		"Not enough room to show this panel."	// alert if user tries to open a pane that cannot
        ,	minSizeWarning:		"Panel has reached its minimum size"	// displays in browser statusbar
        ,	maxSizeWarning:		"Panel has reached its maximum size"	// ditto
      }
      //	HOT-KEYS & MISC
      ,	showOverflowOnHover:	false		// will bind allowOverflow() utility to pane.onMouseOver
      ,	enableCursorHotkey:		true		// enabled 'cursor' hotkeys
      //,	customHotkey:			""			// MUST be pane-specific - EITHER a charCode OR a character
      ,	customHotkeyModifier:	"SHIFT"		// either 'SHIFT', 'CTRL' or 'CTRL+SHIFT' - NOT 'ALT'
      //	PANE ANIMATION
      //	NOTE: fxSss_open, fxSss_close & fxSss_size options (eg: fxName_open) are auto-generated if not passed
      ,	fxName:					"slide" 	// ('none' or blank), slide, drop, scale -- only relevant to 'open' & 'close', NOT 'size'
      ,	fxSpeed:				null		// slow, normal, fast, 200, nnn - if passed, will OVERRIDE fxSettings.duration
      ,	fxSettings:				{}			// can be passed, eg: { easing: "easeOutBounce", duration: 1500 }
      ,	fxOpacityFix:			true		// tries to fix opacity in IE to restore anti-aliasing after animation
      ,	animatePaneSizing:		false		// true = animate resizing after dragging resizer-bar OR sizePane() is called
      /*  NOTE: Action-specific FX options are auto-generated from the options above if not specifically set:
       fxName_open:			"slide"		// 'Open' pane animation
       fnName_close:			"slide"		// 'Close' pane animation
       fxName_size:			"slide"		// 'Size' pane animation - when animatePaneSizing = true
       fxSpeed_open:			null
       fxSpeed_close:			null
       fxSpeed_size:			null
       fxSettings_open:		{}
       fxSettings_close:		{}
       fxSettings_size:		{}
       */
      //	CHILD/NESTED LAYOUTS
      ,	children:				null		// Layout-options for nested/child layout - even {} is valid as options
      ,	containerSelector:		''			// if child is NOT 'directly nested', a selector to find it/them (can have more than one child layout!)
      ,	initChildren:			true		// true = child layout will be created as soon as _this_ layout completes initialization
      ,	destroyChildren:		true		// true = destroy child-layout if this pane is destroyed
      ,	resizeChildren:			true		// true = trigger child-layout.resizeAll() when this pane is resized
      //	EVENT TRIGGERING
      ,	triggerEventsOnLoad:	false		// true = trigger onopen OR onclose callbacks when layout initializes
      ,	triggerEventsDuringLiveResize: true	// true = trigger onresize callback REPEATEDLY if livePaneResizing==true
      //	PANE CALLBACKS
      ,	onshow_start:			null		// CALLBACK when pane STARTS to Show	- BEFORE onopen/onhide_start
      ,	onshow_end:				null		// CALLBACK when pane ENDS being Shown	- AFTER  onopen/onhide_end
      ,	onhide_start:			null		// CALLBACK when pane STARTS to Close	- BEFORE onclose_start
      ,	onhide_end:				null		// CALLBACK when pane ENDS being Closed	- AFTER  onclose_end
      ,	onopen_start:			null		// CALLBACK when pane STARTS to Open
      ,	onopen_end:				null		// CALLBACK when pane ENDS being Opened
      ,	onclose_start:			null		// CALLBACK when pane STARTS to Close
      ,	onclose_end:			null		// CALLBACK when pane ENDS being Closed
      ,	onresize_start:			null		// CALLBACK when pane STARTS being Resized ***FOR ANY REASON***
      ,	onresize_end:			null		// CALLBACK when pane ENDS being Resized ***FOR ANY REASON***
      ,	onsizecontent_start:	null		// CALLBACK when sizing of content-element STARTS
      ,	onsizecontent_end:		null		// CALLBACK when sizing of content-element ENDS
      ,	onswap_start:			null		// CALLBACK when pane STARTS to Swap
      ,	onswap_end:				null		// CALLBACK when pane ENDS being Swapped
      ,	ondrag_start:			null		// CALLBACK when pane STARTS being ***MANUALLY*** Resized
      ,	ondrag_end:				null		// CALLBACK when pane ENDS being ***MANUALLY*** Resized
    }
    /*
     *	PANE-SPECIFIC SETTINGS
     *	- options listed below MUST be specified per-pane - they CANNOT be set under 'panes'
     *	- all options under the 'panes' key can also be set specifically for any pane
     *	- most options under the 'panes' key apply only to 'border-panes' - NOT the the center-pane
     */
    ,	north: {
      paneSelector:			".ui-layout-north"
      ,	size:					"auto"		// eg: "auto", "30%", .30, 200
      ,	resizerCursor:			"n-resize"	// custom = url(myCursor.cur)
      ,	customHotkey:			""			// EITHER a charCode (43) OR a character ("o")
    }
    ,	south: {
      paneSelector:			".ui-layout-south"
      ,	size:					"auto"
      ,	resizerCursor:			"s-resize"
      ,	customHotkey:			""
    }
    ,	east: {
      paneSelector:			".ui-layout-east"
      ,	size:					200
      ,	resizerCursor:			"e-resize"
      ,	customHotkey:			""
    }
    ,	west: {
      paneSelector:			".ui-layout-west"
      ,	size:					200
      ,	resizerCursor:			"w-resize"
      ,	customHotkey:			""
    }
    ,	center: {
      paneSelector:			".ui-layout-center"
      ,	minWidth:				0
      ,	minHeight:				0
    }
  };

  $.layout.optionsMap = {
    // layout/global options - NOT pane-options
    layout: ("name,instanceKey,stateManagement,effects,inset,zIndexes,errors,"
    +	"zIndex,scrollToBookmarkOnLoad,showErrorMessages,maskPanesEarly,"
    +	"outset,resizeWithWindow,resizeWithWindowDelay,resizeWithWindowMaxDelay,"
    +	"onresizeall,onresizeall_start,onresizeall_end,onload,onload_start,onload_end,onunload,onunload_start,onunload_end").split(",")
//	borderPanes: [ ALL options that are NOT specified as 'layout' ]
    // default.panes options that apply to the center-pane (most options apply _only_ to border-panes)
    ,	center: ("paneClass,contentSelector,contentIgnoreSelector,findNestedContent,applyDemoStyles,triggerEventsOnLoad,"
    +	"showOverflowOnHover,maskContents,maskObjects,liveContentResizing,"
    +	"containerSelector,children,initChildren,resizeChildren,destroyChildren,"
    +	"onresize,onresize_start,onresize_end,onsizecontent,onsizecontent_start,onsizecontent_end").split(",")
    // options that MUST be specifically set 'per-pane' - CANNOT set in the panes (defaults) key
    ,	noDefault: ("paneSelector,resizerCursor,customHotkey").split(",")
  };

  /**
   * Processes options passed in converts flat-format data into subkey (JSON) format
   * In flat-format, subkeys are _currently_ separated with 2 underscores, like north__optName
   * Plugins may also call this method so they can transform their own data
   *
   * @param  {!Object}	hash			Data/options passed by user - may be a single level or nested levels
   * @param  {boolean=}	[addKeys=false]	Should the primary layout.options keys be added if they do not exist?
   * @return {Object}						Returns hash of minWidth & minHeight
   */
  $.layout.transformData = function (hash, addKeys) {
    var	json = addKeys ? { panes: {}, center: {} } : {} // init return object
      ,	branch, optKey, keys, key, val, i, c;

    if (typeof hash !== "object") return json; // no options passed

    // convert all 'flat-keys' to 'sub-key' format
    for (optKey in hash) {
      branch	= json;
      val		= hash[ optKey ];
      keys	= optKey.split("__"); // eg: west__size or north__fxSettings__duration
      c		= keys.length - 1;
      // convert underscore-delimited to subkeys
      for (i=0; i <= c; i++) {
        key = keys[i];
        if (i === c) {	// last key = value
          if ($.isPlainObject( val ))
            branch[key] = $.layout.transformData( val ); // RECURSE
          else
            branch[key] = val;
        }
        else {
          if (!branch[key])
            branch[key] = {}; // create the subkey
          // recurse to sub-key for next loop - if not done
          branch = branch[key];
        }
      }
    }
    return json;
  };

// INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
  $.layout.backwardCompatibility = {
    // data used by renameOldOptions()
    map: {
      //	OLD Option Name:			NEW Option Name
      applyDefaultStyles:			"applyDemoStyles"
      //	CHILD/NESTED LAYOUTS
      ,	childOptions:				"children"
      ,	initChildLayout:			"initChildren"
      ,	destroyChildLayout:			"destroyChildren"
      ,	resizeChildLayout:			"resizeChildren"
      ,	resizeNestedLayout:			"resizeChildren"
      //	MISC Options
      ,	resizeWhileDragging:		"livePaneResizing"
      ,	resizeContentWhileDragging:	"liveContentResizing"
      ,	triggerEventsWhileDragging:	"triggerEventsDuringLiveResize"
      ,	maskIframesOnResize:		"maskContents"
      //	STATE MANAGEMENT
      ,	useStateCookie:				"stateManagement.enabled"
      ,	"cookie.autoLoad":			"stateManagement.autoLoad"
      ,	"cookie.autoSave":			"stateManagement.autoSave"
      ,	"cookie.keys":				"stateManagement.stateKeys"
      ,	"cookie.name":				"stateManagement.cookie.name"
      ,	"cookie.domain":			"stateManagement.cookie.domain"
      ,	"cookie.path":				"stateManagement.cookie.path"
      ,	"cookie.expires":			"stateManagement.cookie.expires"
      ,	"cookie.secure":			"stateManagement.cookie.secure"
      //	OLD Language options
      ,	noRoomToOpenTip:			"tips.noRoomToOpen"
      ,	togglerTip_open:			"tips.Close"	// open   = Close
      ,	togglerTip_closed:			"tips.Open"		// closed = Open
      ,	resizerTip:					"tips.Resize"
      ,	sliderTip:					"tips.Slide"
    }

    /**
     * @param {Object}	opts
     */
    ,	renameOptions: function (opts) {
      var map = $.layout.backwardCompatibility.map
        ,	oldData, newData, value
      ;
      for (var itemPath in map) {
        oldData	= getBranch( itemPath );
        value	= oldData.branch[ oldData.key ];
        if (value !== undefined) {
          newData = getBranch( map[itemPath], true );
          newData.branch[ newData.key ] = value;
          delete oldData.branch[ oldData.key ];
        }
      }

      /**
       * @param {string}	path
       * @param {boolean=}	[create=false]	Create path if does not exist
       */
      function getBranch (path, create) {
        var a = path.split(".") // split keys into array
          ,	c = a.length - 1
          ,	D = { branch: opts, key: a[c] } // init branch at top & set key (last item)
          ,	i = 0, k, undef;
        for (; i<c; i++) { // skip the last key (data)
          k = a[i];
          if (D.branch[ k ] == undefined) { // child-key does not exist
            if (create) {
              D.branch = D.branch[ k ] = {}; // create child-branch
            }
            else // can't go any farther
              D.branch = {}; // branch is undefined
          }
          else
            D.branch = D.branch[ k ]; // get child-branch
        }
        return D;
      };
    }

    /**
     * @param {Object}	opts
     */
    ,	renameAllOptions: function (opts) {
      var ren = $.layout.backwardCompatibility.renameOptions;
      // rename root (layout) options
      ren( opts );
      // rename 'defaults' to 'panes'
      if (opts.defaults) {
        if (typeof opts.panes !== "object")
          opts.panes = {};
        $.extend(true, opts.panes, opts.defaults);
        delete opts.defaults;
      }
      // rename options in the the options.panes key
      if (opts.panes) ren( opts.panes );
      // rename options inside *each pane key*, eg: options.west
      $.each($.layout.config.allPanes, function (i, pane) {
        if (opts[pane]) ren( opts[pane] );
      });
      return opts;
    }
  };




  /*	============================================================
   *	BEGIN WIDGET: $( selector ).layout( {options} );
   *	============================================================
   */
  $.fn.layout = function (opts) {
    var

      // local aliases to global data
      browser	= $.layout.browser
      ,	_c		= $.layout.config

      // local aliases to utlity methods
      ,	cssW	= $.layout.cssWidth
      ,	cssH	= $.layout.cssHeight
      ,	elDims	= $.layout.getElementDimensions
      ,	styles	= $.layout.getElementStyles
      ,	evtObj	= $.layout.getEventObject
      ,	evtPane	= $.layout.parsePaneName

      /**
       * options - populated by initOptions()
       */
      ,	options = $.extend(true, {}, $.layout.defaults)
      ,	effects	= options.effects = $.extend(true, {}, $.layout.effects)

      /**
       * layout-state object
       */
      ,	state = {
        // generate unique ID to use for event.namespace so can unbind only events added by 'this layout'
        id:				"layout"+ $.now()	// code uses alias: sID
        ,	initialized:	false
        ,	paneResizing:	false
        ,	panesSliding:	{}
        ,	container:	{ 	// list all keys referenced in code to avoid compiler error msgs
          innerWidth:		0
          ,	innerHeight:	0
          ,	outerWidth:		0
          ,	outerHeight:	0
          ,	layoutWidth:	0
          ,	layoutHeight:	0
        }
        ,	north:		{ childIdx: 0 }
        ,	south:		{ childIdx: 0 }
        ,	east:		{ childIdx: 0 }
        ,	west:		{ childIdx: 0 }
        ,	center:		{ childIdx: 0 }
      }

      /**
       * parent/child-layout pointers
       */
//,	hasParentLayout	= false	- exists ONLY inside Instance so can be set externally
      ,	children = {
        north:		null
        ,	south:		null
        ,	east:		null
        ,	west:		null
        ,	center:		null
      }

      /*
       * ###########################
       *  INTERNAL HELPER FUNCTIONS
       * ###########################
       */

      /**
       * Manages all internal timers
       */
      ,	timer = {
        data:	{}
        ,	set:	function (s, fn, ms) { timer.clear(s); timer.data[s] = setTimeout(fn, ms); }
        ,	clear:	function (s) { var t=timer.data; if (t[s]) {clearTimeout(t[s]); delete t[s];} }
      }

      /**
       * Alert or console.log a message - IF option is enabled.
       *
       * @param {(string|!Object)}	msg				Message (or debug-data) to display
       * @param {boolean=}			[popup=false]	True by default, means 'alert', false means use console.log
       * @param {boolean=}			[debug=false]	True means is a widget debugging message
       */
      ,	_log = function (msg, popup, debug) {
        var o = options;
        if ((o.showErrorMessages && !debug) || (debug && o.showDebugMessages))
          $.layout.msg( o.name +' / '+ msg, (popup !== false) );
        return false;
      }

      /**
       * Executes a Callback function after a trigger event, like resize, open or close
       *
       * @param {string}				evtName					Name of the layout callback, eg "onresize_start"
       * @param {(string|boolean)=}	[pane=""]				This is passed only so we can pass the 'pane object' to the callback
       * @param {(string|boolean)=}	[skipBoundEvents=false]	True = do not run events bound to the elements - only the callbacks set in options
       */
      ,	_runCallbacks = function (evtName, pane, skipBoundEvents) {
        var	hasPane	= pane && isStr(pane)
          ,	s		= hasPane ? state[pane] : state
          ,	o		= hasPane ? options[pane] : options
          ,	lName	= options.name
          // names like onopen and onopen_end separate are interchangeable in options...
          ,	lng		= evtName + (evtName.match(/_/) ? "" : "_end")
          ,	shrt	= lng.match(/_end$/) ? lng.substr(0, lng.length - 4) : ""
          ,	fn		= o[lng] || o[shrt]
          ,	retVal	= "NC" // NC = No Callback
          ,	args	= []
          ,	$P		= hasPane ? $Ps[pane] : 0
        ;
        if (hasPane && !$P) // a pane is specified, but does not exist!
          return retVal;
        if ( !hasPane && $.type(pane) === "boolean" ) {
          skipBoundEvents = pane; // allow pane param to be skipped for Layout callback
          pane = "";
        }

        // first trigger the callback set in the options
        if (fn) {
          try {
            // convert function name (string) to function object
            if (isStr( fn )) {
              if (fn.match(/,/)) {
                // function name cannot contain a comma,
                // so must be a function name AND a parameter to pass
                args = fn.split(",")
                  ,	fn = eval(args[0]);
              }
              else // just the name of an external function?
                fn = eval(fn);
            }
            // execute the callback, if exists
            if ($.isFunction( fn )) {
              if (args.length)
                retVal = g(fn)(args[1]); // pass the argument parsed from 'list'
              else if ( hasPane )
              // pass data: pane-name, pane-element, pane-state, pane-options, and layout-name
                retVal = g(fn)( pane, $Ps[pane], s, o, lName );
              else // must be a layout/container callback - pass suitable info
                retVal = g(fn)( Instance, s, o, lName );
            }
          }
          catch (ex) {
            _log( options.errors.callbackError.replace(/EVENT/, $.trim((pane || "") +" "+ lng)), false );
            if ($.type(ex) === "string" && string.length)
              _log("Exception:  "+ ex, false );
          }
        }

        // trigger additional events bound directly to the pane
        if (!skipBoundEvents && retVal !== false) {
          if ( hasPane ) { // PANE events can be bound to each pane-elements
            o	= options[pane];
            s	= state[pane];
            $P.triggerHandler("layoutpane"+ lng, [ pane, $P, s, o, lName ]);
            if (shrt)
              $P.triggerHandler("layoutpane"+ shrt, [ pane, $P, s, o, lName ]);
          }
          else { // LAYOUT events can be bound to the container-element
            $N.triggerHandler("layout"+ lng, [ Instance, s, o, lName ]);
            if (shrt)
              $N.triggerHandler("layout"+ shrt, [ Instance, s, o, lName ]);
          }
        }

        // ALWAYS resizeChildren after an onresize_end event - even during initialization
        // IGNORE onsizecontent_end event because causes child-layouts to resize TWICE
        if (hasPane && evtName === "onresize_end") // BAD: || evtName === "onsizecontent_end"
          resizeChildren(pane+"", true); // compiler hack -force string

        return retVal;

        function g (f) { return f; }; // compiler hack
      }


      /**
       * cure iframe display issues in IE & other browsers
       */
      ,	_fixIframe = function (pane) {
        if (browser.mozilla) return; // skip FireFox - it auto-refreshes iframes onShow
        var $P = $Ps[pane];
        // if the 'pane' is an iframe, do it
        if (state[pane].tagName === "IFRAME")
          $P.css(_c.hidden).css(_c.visible);
        else // ditto for any iframes INSIDE the pane
          $P.find('IFRAME').css(_c.hidden).css(_c.visible);
      }

      /**
       * @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
       * @param  {number=}		outerSize	(optional) Can pass a width, allowing calculations BEFORE element is resized
       * @return {number}		Returns the innerHeight/Width of el by subtracting padding and borders
       */
      ,	cssSize = function (pane, outerSize) {
        var fn = _c[pane].dir=="horz" ? cssH : cssW;
        return fn($Ps[pane], outerSize);
      }

      /**
       * @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
       * @return {Object}		Returns hash of minWidth & minHeight
       */
      ,	cssMinDims = function (pane) {
        // minWidth/Height means CSS width/height = 1px
        var	$P	= $Ps[pane]
          ,	dir	= _c[pane].dir
          ,	d	= {
            minWidth:	1001 - cssW($P, 1000)
            ,	minHeight:	1001 - cssH($P, 1000)
          }
        ;
        if (dir === "horz") d.minSize = d.minHeight;
        if (dir === "vert") d.minSize = d.minWidth;
        return d;
      }

      // TODO: see if these methods can be made more useful...
      // TODO: *maybe* return cssW/H from these so caller can use this info

      /**
       * @param {(string|!Object)}		el
       * @param {number=}				outerWidth
       * @param {boolean=}				[autoHide=false]
       */
      ,	setOuterWidth = function (el, outerWidth, autoHide) {
        var $E = el, w;
        if (isStr(el)) $E = $Ps[el]; // west
        else if (!el.jquery) $E = $(el);
        w = cssW($E, outerWidth);
        $E.css({ width: w });
        if (w > 0) {
          if (autoHide && $E.data('autoHidden') && $E.innerHeight() > 0) {
            $E.show().data('autoHidden', false);
            if (!browser.mozilla) // FireFox refreshes iframes - IE does not
            // make hidden, then visible to 'refresh' display after animation
              $E.css(_c.hidden).css(_c.visible);
          }
        }
        else if (autoHide && !$E.data('autoHidden'))
          $E.hide().data('autoHidden', true);
      }

      /**
       * @param {(string|!Object)}		el
       * @param {number=}				outerHeight
       * @param {boolean=}				[autoHide=false]
       */
      ,	setOuterHeight = function (el, outerHeight, autoHide) {
        var $E = el, h;
        if (isStr(el)) $E = $Ps[el]; // west
        else if (!el.jquery) $E = $(el);
        h = cssH($E, outerHeight);
        $E.css({ height: h, visibility: "visible" }); // may have been 'hidden' by sizeContent
        if (h > 0 && $E.innerWidth() > 0) {
          if (autoHide && $E.data('autoHidden')) {
            $E.show().data('autoHidden', false);
            if (!browser.mozilla) // FireFox refreshes iframes - IE does not
              $E.css(_c.hidden).css(_c.visible);
          }
        }
        else if (autoHide && !$E.data('autoHidden'))
          $E.hide().data('autoHidden', true);
      }


      /**
       * Converts any 'size' params to a pixel/integer size, if not already
       * If 'auto' or a decimal/percentage is passed as 'size', a pixel-size is calculated
       *
       /**
       * @param  {string}				pane
       * @param  {(string|number)=}	size
       * @param  {string=}				[dir]
       * @return {number}
       */
      ,	_parseSize = function (pane, size, dir) {
        if (!dir) dir = _c[pane].dir;

        if (isStr(size) && size.match(/%/))
          size = (size === '100%') ? -1 : parseInt(size, 10) / 100; // convert % to decimal

        if (size === 0)
          return 0;
        else if (size >= 1)
          return parseInt(size, 10);

        var o = options, avail = 0;
        if (dir=="horz") // north or south or center.minHeight
          avail = sC.innerHeight - ($Ps.north ? o.north.spacing_open : 0) - ($Ps.south ? o.south.spacing_open : 0);
        else if (dir=="vert") // east or west or center.minWidth
          avail = sC.innerWidth - ($Ps.west ? o.west.spacing_open : 0) - ($Ps.east ? o.east.spacing_open : 0);

        if (size === -1) // -1 == 100%
          return avail;
        else if (size > 0) // percentage, eg: .25
          return round(avail * size);
        else if (pane=="center")
          return 0;
        else { // size < 0 || size=='auto' || size==Missing || size==Invalid
          // auto-size the pane
          var	dim	= (dir === "horz" ? "height" : "width")
            ,	$P	= $Ps[pane]
            ,	$C	= dim === 'height' ? $Cs[pane] : false
            ,	vis	= $.layout.showInvisibly($P) // show pane invisibly if hidden
            ,	szP	= $P.css(dim) // SAVE current pane size
            ,	szC	= $C ? $C.css(dim) : 0 // SAVE current content size
          ;
          $P.css(dim, "auto");
          if ($C) $C.css(dim, "auto");
          size = (dim === "height") ? $P.outerHeight() : $P.outerWidth(); // MEASURE
          $P.css(dim, szP).css(vis); // RESET size & visibility
          if ($C) $C.css(dim, szC);
          return size;
        }
      }

      /**
       * Calculates current 'size' (outer-width or outer-height) of a border-pane - optionally with 'pane-spacing' added
       *
       * @param  {(string|!Object)}	pane
       * @param  {boolean=}			[inclSpace=false]
       * @return {number}				Returns EITHER Width for east/west panes OR Height for north/south panes
       */
      ,	getPaneSize = function (pane, inclSpace) {
        var
          $P	= $Ps[pane]
          ,	o	= options[pane]
          ,	s	= state[pane]
          ,	oSp	= (inclSpace ? o.spacing_open : 0)
          ,	cSp	= (inclSpace ? o.spacing_closed : 0)
        ;
        if (!$P || s.isHidden)
          return 0;
        else if (s.isClosed || (s.isSliding && inclSpace))
          return cSp;
        else if (_c[pane].dir === "horz")
          return $P.outerHeight() + oSp;
        else // dir === "vert"
          return $P.outerWidth() + oSp;
      }

      /**
       * Calculate min/max pane dimensions and limits for resizing
       *
       * @param  {string}		pane
       * @param  {boolean=}	[slide=false]
       */
      ,	setSizeLimits = function (pane, slide) {
        if (!isInitialized()) return;
        var
          o				= options[pane]
          ,	s				= state[pane]
          ,	c				= _c[pane]
          ,	dir				= c.dir
          ,	type			= c.sizeType.toLowerCase()
          ,	isSliding		= (slide != undefined ? slide : s.isSliding) // only open() passes 'slide' param
          ,	$P				= $Ps[pane]
          ,	paneSpacing		= o.spacing_open
          //	measure the pane on the *opposite side* from this pane
          ,	altPane			= _c.oppositeEdge[pane]
          ,	altS			= state[altPane]
          ,	$altP			= $Ps[altPane]
          ,	altPaneSize		= (!$altP || altS.isVisible===false || altS.isSliding ? 0 : (dir=="horz" ? $altP.outerHeight() : $altP.outerWidth()))
          ,	altPaneSpacing	= ((!$altP || altS.isHidden ? 0 : options[altPane][ altS.isClosed !== false ? "spacing_closed" : "spacing_open" ]) || 0)
          //	limitSize prevents this pane from 'overlapping' opposite pane
          ,	containerSize	= (dir=="horz" ? sC.innerHeight : sC.innerWidth)
          ,	minCenterDims	= cssMinDims("center")
          ,	minCenterSize	= dir=="horz" ? max(options.center.minHeight, minCenterDims.minHeight) : max(options.center.minWidth, minCenterDims.minWidth)
          //	if pane is 'sliding', then ignore center and alt-pane sizes - because 'overlays' them
          ,	limitSize		= (containerSize - paneSpacing - (isSliding ? 0 : (_parseSize("center", minCenterSize, dir) + altPaneSize + altPaneSpacing)))
          ,	minSize			= s.minSize = max( _parseSize(pane, o.minSize), cssMinDims(pane).minSize )
          ,	maxSize			= s.maxSize = min( (o.maxSize ? _parseSize(pane, o.maxSize) : 100000), limitSize )
          ,	r				= s.resizerPosition = {} // used to set resizing limits
          ,	top				= sC.inset.top
          ,	left			= sC.inset.left
          ,	W				= sC.innerWidth
          ,	H				= sC.innerHeight
          ,	rW				= o.spacing_open // subtract resizer-width to get top/left position for south/east
        ;
        switch (pane) {
          case "north":	r.min = top + minSize;
            r.max = top + maxSize;
            break;
          case "west":	r.min = left + minSize;
            r.max = left + maxSize;
            break;
          case "south":	r.min = top + H - maxSize - rW;
            r.max = top + H - minSize - rW;
            break;
          case "east":	r.min = left + W - maxSize - rW;
            r.max = left + W - minSize - rW;
            break;
        };
      }

      /**
       * Returns data for setting the size/position of center pane. Also used to set Height for east/west panes
       *
       * @return JSON  Returns a hash of all dimensions: top, bottom, left, right, (outer) width and (outer) height
       */
      ,	calcNewCenterPaneDims = function () {
        var d = {
          top:	getPaneSize("north", true) // true = include 'spacing' value for pane
          ,	bottom:	getPaneSize("south", true)
          ,	left:	getPaneSize("west", true)
          ,	right:	getPaneSize("east", true)
          ,	width:	0
          ,	height:	0
        };

        // NOTE: sC = state.container
        // calc center-pane outer dimensions
        d.width		= sC.innerWidth - d.left - d.right;  // outerWidth
        d.height	= sC.innerHeight - d.bottom - d.top; // outerHeight
        // add the 'container border/padding' to get final positions relative to the container
        d.top		+= sC.inset.top;
        d.bottom	+= sC.inset.bottom;
        d.left		+= sC.inset.left;
        d.right		+= sC.inset.right;

        return d;
      }


      /**
       * @param {!Object}		el
       * @param {boolean=}		[allStates=false]
       */
      ,	getHoverClasses = function (el, allStates) {
        var
          $El		= $(el)
          ,	type	= $El.data("layoutRole")
          ,	pane	= $El.data("layoutEdge")
          ,	o		= options[pane]
          ,	root	= o[type +"Class"]
          ,	_pane	= "-"+ pane // eg: "-west"
          ,	_open	= "-open"
          ,	_closed	= "-closed"
          ,	_slide	= "-sliding"
          ,	_hover	= "-hover " // NOTE the trailing space
          ,	_state	= $El.hasClass(root+_closed) ? _closed : _open
          ,	_alt	= _state === _closed ? _open : _closed
          ,	classes = (root+_hover) + (root+_pane+_hover) + (root+_state+_hover) + (root+_pane+_state+_hover)
        ;
        if (allStates) // when 'removing' classes, also remove alternate-state classes
          classes += (root+_alt+_hover) + (root+_pane+_alt+_hover);

        if (type=="resizer" && $El.hasClass(root+_slide))
          classes += (root+_slide+_hover) + (root+_pane+_slide+_hover);

        return $.trim(classes);
      }
      ,	addHover	= function (evt, el) {
        var $E = $(el || this);
        if (evt && $E.data("layoutRole") === "toggler")
          evt.stopPropagation(); // prevent triggering 'slide' on Resizer-bar
        $E.addClass( getHoverClasses($E) );
      }
      ,	removeHover	= function (evt, el) {
        var $E = $(el || this);
        $E.removeClass( getHoverClasses($E, true) );
      }

      ,	onResizerEnter	= function (evt) { // ALSO called by toggler.mouseenter
        var pane	= $(this).data("layoutEdge")
          ,	s		= state[pane]
          ,	$d		= $(document)
        ;
        // ignore closed-panes and mouse moving back & forth over resizer!
        // also ignore if ANY pane is currently resizing
        if ( s.isResizing || state.paneResizing ) return;

        if (options.maskPanesEarly)
          showMasks( pane, { resizing: true });
      }
      ,	onResizerLeave	= function (evt, el) {
        var	e		= el || this // el is only passed when called by the timer
          ,	pane	= $(e).data("layoutEdge")
          ,	name	= pane +"ResizerLeave"
          ,	$d		= $(document)
        ;
        timer.clear(pane+"_openSlider"); // cancel slideOpen timer, if set
        timer.clear(name); // cancel enableSelection timer - may re/set below
        // this method calls itself on a timer because it needs to allow
        // enough time for dragging to kick-in and set the isResizing flag
        // dragging has a 100ms delay set, so this delay must be >100
        if (!el) // 1st call - mouseleave event
          timer.set(name, function(){ onResizerLeave(evt, e); }, 200);
        // if user is resizing, dragStop will reset everything, so skip it here
        else if (options.maskPanesEarly && !state.paneResizing) // 2nd call - by timer
          hideMasks();
      }

      /*
       * ###########################
       *   INITIALIZATION METHODS
       * ###########################
       */

      /**
       * Initialize the layout - called automatically whenever an instance of layout is created
       *
       * @see  none - triggered onInit
       * @return  mixed	true = fully initialized | false = panes not initialized (yet) | 'cancel' = abort
       */
      ,	_create = function () {
        // initialize config/options
        initOptions();
        var o = options
          ,	s = state;

        // TEMP state so isInitialized returns true during init process
        s.creatingLayout = true;

        // init plugins for this layout, if there are any (eg: stateManagement)
        runPluginCallbacks( Instance, $.layout.onCreate );

        // options & state have been initialized, so now run beforeLoad callback
        // onload will CANCEL layout creation if it returns false
        if (false === _runCallbacks("onload_start"))
          return 'cancel';

        // initialize the container element
        _initContainer();

        // bind hotkey function - keyDown - if required
        initHotkeys();

        // bind window.onunload
        $(window).bind("unload."+ sID, unload);

        // init plugins for this layout, if there are any (eg: customButtons)
        runPluginCallbacks( Instance, $.layout.onLoad );

        // if layout elements are hidden, then layout WILL NOT complete initialization!
        // initLayoutElements will set initialized=true and run the onload callback IF successful
        if (o.initPanes) _initLayoutElements();

        delete s.creatingLayout;

        return state.initialized;
      }

      /**
       * Initialize the layout IF not already
       *
       * @see  All methods in Instance run this test
       * @return  boolean	true = layoutElements have been initialized | false = panes are not initialized (yet)
       */
      ,	isInitialized = function () {
        if (state.initialized || state.creatingLayout) return true;	// already initialized
        else return _initLayoutElements();	// try to init panes NOW
      }

      /**
       * Initialize the layout - called automatically whenever an instance of layout is created
       *
       * @see  _create() & isInitialized
       * @param {boolean=}		[retry=false]	// indicates this is a 2nd try
       * @return  An object pointer to the instance created
       */
      ,	_initLayoutElements = function (retry) {
        // initialize config/options
        var o = options;
        // CANNOT init panes inside a hidden container!
        if (!$N.is(":visible")) {
          // handle Chrome bug where popup window 'has no height'
          // if layout is BODY element, try again in 50ms
          // SEE: http://layout.jquery-dev.com/samples/test_popup_window.html
          if ( !retry && browser.webkit && $N[0].tagName === "BODY" )
            setTimeout(function(){ _initLayoutElements(true); }, 50);
          return false;
        }

        // a center pane is required, so make sure it exists
        if (!getPane("center").length) {
          return _log( o.errors.centerPaneMissing );
        }

        // TEMP state so isInitialized returns true during init process
        state.creatingLayout = true;

        // update Container dims
        $.extend(sC, elDims( $N, o.inset )); // passing inset means DO NOT include insetX values

        // initialize all layout elements
        initPanes();	// size & position panes - calls initHandles() - which calls initResizable()

        if (o.scrollToBookmarkOnLoad) {
          var l = self.location;
          if (l.hash) l.replace( l.hash ); // scrollTo Bookmark
        }

        // check to see if this layout 'nested' inside a pane
        if (Instance.hasParentLayout)
          o.resizeWithWindow = false;
        // bind resizeAll() for 'this layout instance' to window.resize event
        else if (o.resizeWithWindow)
          $(window).bind("resize."+ sID, windowResize);

        delete state.creatingLayout;
        state.initialized = true;

        // init plugins for this layout, if there are any
        runPluginCallbacks( Instance, $.layout.onReady );

        // now run the onload callback, if exists
        _runCallbacks("onload_end");

        return true; // elements initialized successfully
      }

      /**
       * Initialize nested layouts for a specific pane - can optionally pass layout-options
       *
       * @param {(string|Object)}	evt_or_pane	The pane being opened, ie: north, south, east, or west
       * @param {Object=}			[opts]		Layout-options - if passed, will OVERRRIDE options[pane].children
       * @return  An object pointer to the layout instance created - or null
       */
      ,	createChildren = function (evt_or_pane, opts) {
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$P	= $Ps[pane]
        ;
        if (!$P) return;
        var	$C	= $Cs[pane]
          ,	s	= state[pane]
          ,	o	= options[pane]
          ,	sm	= options.stateManagement || {}
          ,	cos = opts ? (o.children = opts) : o.children
        ;
        if ( $.isPlainObject( cos ) )
          cos = [ cos ]; // convert a hash to a 1-elem array
        else if (!cos || !$.isArray( cos ))
          return;

        $.each( cos, function (idx, co) {
          if ( !$.isPlainObject( co ) ) return;

          // determine which element is supposed to be the 'child container'
          // if pane has a 'containerSelector' OR a 'content-div', use those instead of the pane
          var $containers = co.containerSelector ? $P.find( co.containerSelector ) : ($C || $P);

          $containers.each(function(){
            var $cont	= $(this)
              ,	child	= $cont.data("layout") //	see if a child-layout ALREADY exists on this element
            ;
            // if no layout exists, but children are set, try to create the layout now
            if (!child) {
              // TODO: see about moving this to the stateManagement plugin, as a method
              // set a unique child-instance key for this layout, if not already set
              setInstanceKey({ container: $cont, options: co }, s );
              // If THIS layout has a hash in stateManagement.autoLoad,
              // then see if it also contains state-data for this child-layout
              // If so, copy the stateData to child.options.stateManagement.autoLoad
              if ( sm.includeChildren && state.stateData[pane] ) {
                //	THIS layout's state was cached when its state was loaded
                var	paneChildren = state.stateData[pane].children || {}
                  ,	childState	= paneChildren[ co.instanceKey ]
                  ,	co_sm		= co.stateManagement || (co.stateManagement = { autoLoad: true })
                ;
                // COPY the stateData into the autoLoad key
                if ( co_sm.autoLoad === true && childState ) {
                  co_sm.autoSave			= false; // disable autoSave because saving handled by parent-layout
                  co_sm.includeChildren	= true;  // cascade option - FOR NOW
                  co_sm.autoLoad = $.extend(true, {}, childState); // COPY the state-hash
                }
              }

              // create the layout
              child = $cont.layout( co );

              // if successful, update data
              if (child) {
                // add the child and update all layout-pointers
                // MAY have already been done by child-layout calling parent.refreshChildren()
                refreshChildren( pane, child );
              }
            }
          });
        });
      }

      ,	setInstanceKey = function (child, parentPaneState) {
        // create a named key for use in state and instance branches
        var	$c	= child.container
          ,	o	= child.options
          ,	sm	= o.stateManagement
          ,	key	= o.instanceKey || $c.data("layoutInstanceKey")
        ;
        if (!key) key = (sm && sm.cookie ? sm.cookie.name : '') || o.name; // look for a name/key
        if (!key) key = "layout"+ (++parentPaneState.childIdx);	// if no name/key found, generate one
        else key = key.replace(/[^\w-]/gi, '_').replace(/_{2,}/g, '_');	 // ensure is valid as a hash key
        o.instanceKey = key;
        $c.data("layoutInstanceKey", key); // useful if layout is destroyed and then recreated
        return key;
      }

      /**
       * @param {string}		pane		The pane being opened, ie: north, south, east, or west
       * @param {Object=}		newChild	New child-layout Instance to add to this pane
       */
      ,	refreshChildren = function (pane, newChild) {
        var	$P	= $Ps[pane]
          ,	pC	= children[pane]
          ,	s	= state[pane]
          ,	o
        ;
        // check for destroy()ed layouts and update the child pointers & arrays
        if ($.isPlainObject( pC )) {
          $.each( pC, function (key, child) {
            if (child.destroyed) delete pC[key]
          });
          // if no more children, remove the children hash
          if ($.isEmptyObject( pC ))
            pC = children[pane] = null; // clear children hash
        }

        // see if there is a directly-nested layout inside this pane
        // if there is, then there can be only ONE child-layout, so check that...
        if (!newChild && !pC) {
          newChild = $P.data("layout");
        }

        // if a newChild instance was passed, add it to children[pane]
        if (newChild) {
          // update child.state
          newChild.hasParentLayout = true; // set parent-flag in child
          // instanceKey is a key-name used in both state and children
          o = newChild.options;
          // set a unique child-instance key for this layout, if not already set
          setInstanceKey( newChild, s );
          // add pointer to pane.children hash
          if (!pC) pC = children[pane] = {}; // create an empty children hash
          pC[ o.instanceKey ] = newChild.container.data("layout"); // add childLayout instance
        }

        // ALWAYS refresh the pane.children alias, even if null
        Instance[pane].children = children[pane];

        // if newChild was NOT passed - see if there is a child layout NOW
        if (!newChild) {
          createChildren(pane); // MAY create a child and re-call this method
        }
      }

      ,	windowResize = function () {
        var	o = options
          ,	delay = Number(o.resizeWithWindowDelay);
        if (delay < 10) delay = 100; // MUST have a delay!
        // resizing uses a delay-loop because the resize event fires repeatly - except in FF, but delay anyway
        timer.clear("winResize"); // if already running
        timer.set("winResize", function(){
          timer.clear("winResize");
          timer.clear("winResizeRepeater");
          var dims = elDims( $N, o.inset );
          // only trigger resizeAll() if container has changed size
          if (dims.innerWidth !== sC.innerWidth || dims.innerHeight !== sC.innerHeight)
            resizeAll();
        }, delay);
        // ALSO set fixed-delay timer, if not already running
        if (!timer.data["winResizeRepeater"]) setWindowResizeRepeater();
      }

      ,	setWindowResizeRepeater = function () {
        var delay = Number(options.resizeWithWindowMaxDelay);
        if (delay > 0)
          timer.set("winResizeRepeater", function(){ setWindowResizeRepeater(); resizeAll(); }, delay);
      }

      ,	unload = function () {
        var o = options;

        _runCallbacks("onunload_start");

        // trigger plugin callabacks for this layout (eg: stateManagement)
        runPluginCallbacks( Instance, $.layout.onUnload );

        _runCallbacks("onunload_end");
      }

      /**
       * Validate and initialize container CSS and events
       *
       * @see  _create()
       */
      ,	_initContainer = function () {
        var
          N		= $N[0]
          ,	$H		= $("html")
          ,	tag		= sC.tagName = N.tagName
          ,	id		= sC.id = N.id
          ,	cls		= sC.className = N.className
          ,	o		= options
          ,	name	= o.name
          ,	props	= "position,margin,padding,border"
          ,	css		= "layoutCSS"
          ,	CSS		= {}
          ,	hid		= "hidden" // used A LOT!
          //	see if this container is a 'pane' inside an outer-layout
          ,	parent	= $N.data("parentLayout")	// parent-layout Instance
          ,	pane	= $N.data("layoutEdge")		// pane-name in parent-layout
          ,	isChild	= parent && pane
          ,	num		= $.layout.cssNum
          ,	$parent, n
        ;
        // sC = state.container
        //sC.selector = $N.selector.split(".slice")[0];
        sC.ref		= (o.name ? o.name +' layout / ' : '') + tag + (id ? "#"+id : cls ? '.['+cls+']' : ''); // used in messages
        sC.isBody	= (tag === "BODY");

        // try to find a parent-layout
        if (!isChild && !sC.isBody) {
          $parent = $N.closest("."+ $.layout.defaults.panes.paneClass);
          parent	= $parent.data("parentLayout");
          pane	= $parent.data("layoutEdge");
          isChild	= parent && pane;
        }

        $N	.data({
          layout: Instance
          ,	layoutContainer: sID // FLAG to indicate this is a layout-container - contains unique internal ID
        })
          .addClass(o.containerClass)
        ;
        var layoutMethods = {
          destroy:	''
          ,	initPanes:	''
          ,	resizeAll:	'resizeAll'
          ,	resize:		'resizeAll'
        };
        // loop hash and bind all methods - include layoutID namespacing
        for (name in layoutMethods) {
          $N.bind("layout"+ name.toLowerCase() +"."+ sID, Instance[ layoutMethods[name] || name ]);
        }

        // if this container is another layout's 'pane', then set child/parent pointers
        if (isChild) {
          // update parent flag
          Instance.hasParentLayout = true;
          // set pointers to THIS child-layout (Instance) in parent-layout
          parent.refreshChildren( pane, Instance );
        }

        // SAVE original container CSS for use in destroy()
        if (!$N.data(css)) {
          // handle props like overflow different for BODY & HTML - has 'system default' values
          if (sC.isBody) {
            // SAVE <BODY> CSS
            $N.data(css, $.extend( styles($N, props), {
              height:		$N.css("height")
              ,	overflow:	$N.css("overflow")
              ,	overflowX:	$N.css("overflowX")
              ,	overflowY:	$N.css("overflowY")
            }));
            // ALSO SAVE <HTML> CSS
            $H.data(css, $.extend( styles($H, 'padding'), {
              height:		"auto" // FF would return a fixed px-size!
              ,	overflow:	$H.css("overflow")
              ,	overflowX:	$H.css("overflowX")
              ,	overflowY:	$H.css("overflowY")
            }));
          }
          else // handle props normally for non-body elements
            $N.data(css, styles($N, props+",top,bottom,left,right,width,height,overflow,overflowX,overflowY") );
        }

        try {
          // common container CSS
          CSS = {
            overflow:	hid
            ,	overflowX:	hid
            ,	overflowY:	hid
          };
          $N.css( CSS );

          if (o.inset && !$.isPlainObject(o.inset)) {
            // can specify a single number for equal outset all-around
            n = parseInt(o.inset, 10) || 0
            o.inset = {
              top:	n
              ,	bottom:	n
              ,	left:	n
              ,	right:	n
            };
          }

          // format html & body if this is a full page layout
          if (sC.isBody) {
            // if HTML has padding, use this as an outer-spacing around BODY
            if (!o.outset) {
              // use padding from parent-elem (HTML) as outset
              o.outset = {
                top:	num($H, "paddingTop")
                ,	bottom:	num($H, "paddingBottom")
                ,	left:	num($H, "paddingLeft")
                ,	right:	num($H, "paddingRight")
              };
            }
            else if (!$.isPlainObject(o.outset)) {
              // can specify a single number for equal outset all-around
              n = parseInt(o.outset, 10) || 0
              o.outset = {
                top:	n
                ,	bottom:	n
                ,	left:	n
                ,	right:	n
              };
            }
            // HTML
            $H.css( CSS ).css({
              height:		"100%"
              ,	border:		"none"	// no border or padding allowed when using height = 100%
              ,	padding:	0		// ditto
              ,	margin:		0
            });
            // BODY
            if (browser.isIE6) {
              // IE6 CANNOT use the trick of setting absolute positioning on all 4 sides - must have 'height'
              $N.css({
                width:		"100%"
                ,	height:		"100%"
                ,	border:		"none"	// no border or padding allowed when using height = 100%
                ,	padding:	0		// ditto
                ,	margin:		0
                ,	position:	"relative"
              });
              // convert body padding to an inset option - the border cannot be measured in IE6!
              if (!o.inset) o.inset = elDims( $N ).inset;
            }
            else { // use absolute positioning for BODY to allow borders & padding without overflow
              $N.css({
                width:		"auto"
                ,	height:		"auto"
                ,	margin:		0
                ,	position:	"absolute"	// allows for border and padding on BODY
              });
              // apply edge-positioning created above
              $N.css( o.outset );
            }
            // set current layout-container dimensions
            $.extend(sC, elDims( $N, o.inset )); // passing inset means DO NOT include insetX values
          }
          else {
            // container MUST have 'position'
            var	p = $N.css("position");
            if (!p || !p.match(/(fixed|absolute|relative)/))
              $N.css("position","relative");

            // set current layout-container dimensions
            if ( $N.is(":visible") ) {
              $.extend(sC, elDims( $N, o.inset )); // passing inset means DO NOT change insetX (padding) values
              if (sC.innerHeight < 1) // container has no 'height' - warn developer
                _log( o.errors.noContainerHeight.replace(/CONTAINER/, sC.ref) );
            }
          }

          // if container has min-width/height, then enable scrollbar(s)
          if ( num($N, "minWidth")  ) $N.parent().css("overflowX","auto");
          if ( num($N, "minHeight") ) $N.parent().css("overflowY","auto");

        } catch (ex) {}
      }

      /**
       * Bind layout hotkeys - if options enabled
       *
       * @see  _create() and addPane()
       * @param {string=}	[panes=""]	The edge(s) to process
       */
      ,	initHotkeys = function (panes) {
        panes = panes ? panes.split(",") : _c.borderPanes;
        // bind keyDown to capture hotkeys, if option enabled for ANY pane
        $.each(panes, function (i, pane) {
          var o = options[pane];
          if (o.enableCursorHotkey || o.customHotkey) {
            $(document).bind("keydown."+ sID, keyDown); // only need to bind this ONCE
            return false; // BREAK - binding was done
          }
        });
      }

      /**
       * Build final OPTIONS data
       *
       * @see  _create()
       */
      ,	initOptions = function () {
        var data, d, pane, key, val, i, c, o;

        // reprocess user's layout-options to have correct options sub-key structure
        opts = $.layout.transformData( opts, true ); // panes = default subkey

        // auto-rename old options for backward compatibility
        opts = $.layout.backwardCompatibility.renameAllOptions( opts );

        // if user-options has 'panes' key (pane-defaults), clean it...
        if (!$.isEmptyObject(opts.panes)) {
          // REMOVE any pane-defaults that MUST be set per-pane
          data = $.layout.optionsMap.noDefault;
          for (i=0, c=data.length; i<c; i++) {
            key = data[i];
            delete opts.panes[key]; // OK if does not exist
          }
          // REMOVE any layout-options specified under opts.panes
          data = $.layout.optionsMap.layout;
          for (i=0, c=data.length; i<c; i++) {
            key = data[i];
            delete opts.panes[key]; // OK if does not exist
          }
        }

        // MOVE any NON-layout-options from opts-root to opts.panes
        data = $.layout.optionsMap.layout;
        var rootKeys = $.layout.config.optionRootKeys;
        for (key in opts) {
          val = opts[key];
          if ($.inArray(key, rootKeys) < 0 && $.inArray(key, data) < 0) {
            if (!opts.panes[key])
              opts.panes[key] = $.isPlainObject(val) ? $.extend(true, {}, val) : val;
            delete opts[key]
          }
        }

        // START by updating ALL options from opts
        $.extend(true, options, opts);

        // CREATE final options (and config) for EACH pane
        $.each(_c.allPanes, function (i, pane) {

          // apply 'pane-defaults' to CONFIG.[PANE]
          _c[pane] = $.extend(true, {}, _c.panes, _c[pane]);

          d = options.panes;
          o = options[pane];

          // center-pane uses SOME keys in defaults.panes branch
          if (pane === 'center') {
            // ONLY copy keys from opts.panes listed in: $.layout.optionsMap.center
            data = $.layout.optionsMap.center;		// list of 'center-pane keys'
            for (i=0, c=data.length; i<c; i++) {	// loop the list...
              key = data[i];
              // only need to use pane-default if pane-specific value not set
              if (!opts.center[key] && (opts.panes[key] || !o[key]))
                o[key] = d[key]; // pane-default
            }
          }
          else {
            // border-panes use ALL keys in defaults.panes branch
            o = options[pane] = $.extend(true, {}, d, o); // re-apply pane-specific opts AFTER pane-defaults
            createFxOptions( pane );
            // ensure all border-pane-specific base-classes exist
            if (!o.resizerClass)	o.resizerClass	= "ui-layout-resizer";
            if (!o.togglerClass)	o.togglerClass	= "ui-layout-toggler";
          }
          // ensure we have base pane-class (ALL panes)
          if (!o.paneClass) o.paneClass = "ui-layout-pane";
        });

        // update options.zIndexes if a zIndex-option specified
        var zo	= opts.zIndex
          ,	z	= options.zIndexes;
        if (zo > 0) {
          z.pane_normal		= zo;
          z.content_mask		= max(zo+1, z.content_mask);	// MIN = +1
          z.resizer_normal	= max(zo+2, z.resizer_normal);	// MIN = +2
        }

        // DELETE 'panes' key now that we are done - values were copied to EACH pane
        delete options.panes;


        function createFxOptions ( pane ) {
          var	o = options[pane]
            ,	d = options.panes;
          // ensure fxSettings key to avoid errors
          if (!o.fxSettings) o.fxSettings = {};
          if (!d.fxSettings) d.fxSettings = {};

          $.each(["_open","_close","_size"], function (i,n) {
            var
              sName		= "fxName"+ n
              ,	sSpeed		= "fxSpeed"+ n
              ,	sSettings	= "fxSettings"+ n
              // recalculate fxName according to specificity rules
              ,	fxName = o[sName] =
                o[sName]	// options.west.fxName_open
                ||	d[sName]	// options.panes.fxName_open
                ||	o.fxName	// options.west.fxName
                ||	d.fxName	// options.panes.fxName
                ||	"none"		// MEANS $.layout.defaults.panes.fxName == "" || false || null || 0
              ,	fxExists	= $.effects && ($.effects[fxName] || ($.effects.effect && $.effects.effect[fxName]))
            ;
            // validate fxName to ensure is valid effect - MUST have effect-config data in options.effects
            if (fxName === "none" || !options.effects[fxName] || !fxExists)
              fxName = o[sName] = "none"; // effect not loaded OR unrecognized fxName

            // set vars for effects subkeys to simplify logic
            var	fx		= options.effects[fxName] || {}	// effects.slide
              ,	fx_all	= fx.all	|| null				// effects.slide.all
              ,	fx_pane	= fx[pane]	|| null				// effects.slide.west
            ;
            // create fxSpeed[_open|_close|_size]
            o[sSpeed] =
              o[sSpeed]				// options.west.fxSpeed_open
              ||	d[sSpeed]				// options.west.fxSpeed_open
              ||	o.fxSpeed				// options.west.fxSpeed
              ||	d.fxSpeed				// options.panes.fxSpeed
              ||	null					// DEFAULT - let fxSetting.duration control speed
            ;
            // create fxSettings[_open|_close|_size]
            o[sSettings] = $.extend(
              true
              ,	{}
              ,	fx_all					// effects.slide.all
              ,	fx_pane					// effects.slide.west
              ,	d.fxSettings			// options.panes.fxSettings
              ,	o.fxSettings			// options.west.fxSettings
              ,	d[sSettings]			// options.panes.fxSettings_open
              ,	o[sSettings]			// options.west.fxSettings_open
            );
          });

          // DONE creating action-specific-settings for this pane,
          // so DELETE generic options - are no longer meaningful
          delete o.fxName;
          delete o.fxSpeed;
          delete o.fxSettings;
        }
      }

      /**
       * Initialize module objects, styling, size and position for all panes
       *
       * @see  _initElements()
       * @param {string}	pane		The pane to process
       */
      ,	getPane = function (pane) {
        var sel = options[pane].paneSelector
        if (sel.substr(0,1)==="#") // ID selector
        // NOTE: elements selected 'by ID' DO NOT have to be 'children'
          return $N.find(sel).eq(0);
        else { // class or other selector
          var $P = $N.children(sel).eq(0);
          // look for the pane nested inside a 'form' element
          return $P.length ? $P : $N.children("form:first").children(sel).eq(0);
        }
      }

      /**
       * @param {Object=}		evt
       */
      ,	initPanes = function (evt) {
        // stopPropagation if called by trigger("layoutinitpanes") - use evtPane utility
        evtPane(evt);

        // NOTE: do north & south FIRST so we can measure their height - do center LAST
        $.each(_c.allPanes, function (idx, pane) {
          addPane( pane, true );
        });

        // init the pane-handles NOW in case we have to hide or close the pane below
        initHandles();

        // now that all panes have been initialized and initially-sized,
        // make sure there is really enough space available for each pane
        $.each(_c.borderPanes, function (i, pane) {
          if ($Ps[pane] && state[pane].isVisible) { // pane is OPEN
            setSizeLimits(pane);
            makePaneFit(pane); // pane may be Closed, Hidden or Resized by makePaneFit()
          }
        });
        // size center-pane AGAIN in case we 'closed' a border-pane in loop above
        sizeMidPanes("center");

        //	Chrome/Webkit sometimes fires callbacks BEFORE it completes resizing!
        //	Before RC30.3, there was a 10ms delay here, but that caused layout
        //	to load asynchrously, which is BAD, so try skipping delay for now

        // process pane contents and callbacks, and init/resize child-layout if exists
        $.each(_c.allPanes, function (idx, pane) {
          afterInitPane(pane);
        });
      }

      /**
       * Add a pane to the layout - subroutine of initPanes()
       *
       * @see  initPanes()
       * @param {string}	pane			The pane to process
       * @param {boolean=}	[force=false]	Size content after init
       */
      ,	addPane = function (pane, force) {
        if ( !force && !isInitialized() ) return;
        var
          o		= options[pane]
          ,	s		= state[pane]
          ,	c		= _c[pane]
          ,	dir		= c.dir
          ,	fx		= s.fx
          ,	spacing	= o.spacing_open || 0
          ,	isCenter = (pane === "center")
          ,	CSS		= {}
          ,	$P		= $Ps[pane]
          ,	size, minSize, maxSize, child
        ;
        // if pane-pointer already exists, remove the old one first
        if ($P)
          removePane( pane, false, true, false );
        else
          $Cs[pane] = false; // init

        $P = $Ps[pane] = getPane(pane);
        if (!$P.length) {
          $Ps[pane] = false; // logic
          return;
        }

        // SAVE original Pane CSS
        if (!$P.data("layoutCSS")) {
          var props = "position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border";
          $P.data("layoutCSS", styles($P, props));
        }

        // create alias for pane data in Instance - initHandles will add more
        Instance[pane] = {
          name:		pane
          ,	pane:		$Ps[pane]
          ,	content:	$Cs[pane]
          ,	options:	options[pane]
          ,	state:		state[pane]
          ,	children:	children[pane]
        };

        // add classes, attributes & events
        $P	.data({
          parentLayout:	Instance		// pointer to Layout Instance
          ,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
          ,	layoutEdge:		pane
          ,	layoutRole:		"pane"
        })
          .css(c.cssReq).css("zIndex", options.zIndexes.pane_normal)
          .css(o.applyDemoStyles ? c.cssDemo : {}) // demo styles
          .addClass( o.paneClass +" "+ o.paneClass+"-"+pane ) // default = "ui-layout-pane ui-layout-pane-west" - may be a dupe of 'paneSelector'
          .bind("mouseenter."+ sID, addHover )
          .bind("mouseleave."+ sID, removeHover )
        ;
        var paneMethods = {
          hide:				''
          ,	show:				''
          ,	toggle:				''
          ,	close:				''
          ,	open:				''
          ,	slideOpen:			''
          ,	slideClose:			''
          ,	slideToggle:		''
          ,	size:				'sizePane'
          ,	sizePane:			'sizePane'
          ,	sizeContent:		''
          ,	sizeHandles:		''
          ,	enableClosable:		''
          ,	disableClosable:	''
          ,	enableSlideable:	''
          ,	disableSlideable:	''
          ,	enableResizable:	''
          ,	disableResizable:	''
          ,	swapPanes:			'swapPanes'
          ,	swap:				'swapPanes'
          ,	move:				'swapPanes'
          ,	removePane:			'removePane'
          ,	remove:				'removePane'
          ,	createChildren:		''
          ,	resizeChildren:		''
          ,	resizeAll:			'resizeAll'
          ,	resizeLayout:		'resizeAll'
        }
          ,	name;
        // loop hash and bind all methods - include layoutID namespacing
        for (name in paneMethods) {
          $P.bind("layoutpane"+ name.toLowerCase() +"."+ sID, Instance[ paneMethods[name] || name ]);
        }

        // see if this pane has a 'scrolling-content element'
        initContent(pane, false); // false = do NOT sizeContent() - called later

        if (!isCenter) {
          // call _parseSize AFTER applying pane classes & styles - but before making visible (if hidden)
          // if o.size is auto or not valid, then MEASURE the pane and use that as its 'size'
          size	= s.size = _parseSize(pane, o.size);
          minSize	= _parseSize(pane,o.minSize) || 1;
          maxSize	= _parseSize(pane,o.maxSize) || 100000;
          if (size > 0) size = max(min(size, maxSize), minSize);
          s.autoResize = o.autoResize; // used with percentage sizes

          // state for border-panes
          s.isClosed  = false; // true = pane is closed
          s.isSliding = false; // true = pane is currently open by 'sliding' over adjacent panes
          s.isResizing= false; // true = pane is in process of being resized
          s.isHidden	= false; // true = pane is hidden - no spacing, resizer or toggler is visible!

          // array for 'pin buttons' whose classNames are auto-updated on pane-open/-close
          if (!s.pins) s.pins = [];
        }
        //	states common to ALL panes
        s.tagName	= $P[0].tagName;
        s.edge		= pane;		// useful if pane is (or about to be) 'swapped' - easy find out where it is (or is going)
        s.noRoom	= false;	// true = pane 'automatically' hidden due to insufficient room - will unhide automatically
        s.isVisible	= true;		// false = pane is invisible - closed OR hidden - simplify logic

        // init pane positioning
        setPanePosition( pane );

        // if pane is not visible,
        if (dir === "horz") // north or south pane
          CSS.height = cssH($P, size);
        else if (dir === "vert") // east or west pane
          CSS.width = cssW($P, size);
        //else if (isCenter) {}

        $P.css(CSS); // apply size -- top, bottom & height will be set by sizeMidPanes
        if (dir != "horz") sizeMidPanes(pane, true); // true = skipCallback

        // if manually adding a pane AFTER layout initialization, then...
        if (state.initialized) {
          initHandles( pane );
          initHotkeys( pane );
        }

        // close or hide the pane if specified in settings
        if (o.initClosed && o.closable && !o.initHidden)
          close(pane, true, true); // true, true = force, noAnimation
        else if (o.initHidden || o.initClosed)
          hide(pane); // will be completely invisible - no resizer or spacing
        else if (!s.noRoom)
        // make the pane visible - in case was initially hidden
          $P.css("display","block");
        // ELSE setAsOpen() - called later by initHandles()

        // RESET visibility now - pane will appear IF display:block
        $P.css("visibility","visible");

        // check option for auto-handling of pop-ups & drop-downs
        if (o.showOverflowOnHover)
          $P.hover( allowOverflow, resetOverflow );

        // if manually adding a pane AFTER layout initialization, then...
        if (state.initialized) {
          afterInitPane( pane );
        }
      }

      ,	afterInitPane = function (pane) {
        var	$P	= $Ps[pane]
          ,	s	= state[pane]
          ,	o	= options[pane]
        ;
        if (!$P) return;

        // see if there is a directly-nested layout inside this pane
        if ($P.data("layout"))
          refreshChildren( pane, $P.data("layout") );

        // process pane contents and callbacks, and init/resize child-layout if exists
        if (s.isVisible) { // pane is OPEN
          if (state.initialized) // this pane was added AFTER layout was created
            resizeAll(); // will also sizeContent
          else
            sizeContent(pane);

          if (o.triggerEventsOnLoad)
            _runCallbacks("onresize_end", pane);
          else // automatic if onresize called, otherwise call it specifically
          // resize child - IF inner-layout already exists (created before this layout)
            resizeChildren(pane, true); // a previously existing childLayout
        }

        // init childLayouts - even if pane is not visible
        if (o.initChildren && o.children)
          createChildren(pane);
      }

      /**
       * @param {string=}	panes		The pane(s) to process
       */
      ,	setPanePosition = function (panes) {
        panes = panes ? panes.split(",") : _c.borderPanes;

        // create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
        $.each(panes, function (i, pane) {
          var $P	= $Ps[pane]
            ,	$R	= $Rs[pane]
            ,	o	= options[pane]
            ,	s	= state[pane]
            ,	side =  _c[pane].side
            ,	CSS	= {}
          ;
          if (!$P) return; // pane does not exist - skip

          // set css-position to account for container borders & padding
          switch (pane) {
            case "north": 	CSS.top 	= sC.inset.top;
              CSS.left 	= sC.inset.left;
              CSS.right	= sC.inset.right;
              break;
            case "south": 	CSS.bottom	= sC.inset.bottom;
              CSS.left 	= sC.inset.left;
              CSS.right 	= sC.inset.right;
              break;
            case "west": 	CSS.left 	= sC.inset.left; // top, bottom & height set by sizeMidPanes()
              break;
            case "east": 	CSS.right 	= sC.inset.right; // ditto
              break;
            case "center":	// top, left, width & height set by sizeMidPanes()
          }
          // apply position
          $P.css(CSS);

          // update resizer position
          if ($R && s.isClosed)
            $R.css(side, sC.inset[side]);
          else if ($R && !s.isHidden)
            $R.css(side, sC.inset[side] + getPaneSize(pane));
        });
      }

      /**
       * Initialize module objects, styling, size and position for all resize bars and toggler buttons
       *
       * @see  _create()
       * @param {string=}	[panes=""]	The edge(s) to process
       */
      ,	initHandles = function (panes) {
        panes = panes ? panes.split(",") : _c.borderPanes;

        // create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
        $.each(panes, function (i, pane) {
          var $P		= $Ps[pane];
          $Rs[pane]	= false; // INIT
          $Ts[pane]	= false;
          if (!$P) return; // pane does not exist - skip

          var	o		= options[pane]
            ,	s		= state[pane]
            ,	c		= _c[pane]
            ,	paneId	= o.paneSelector.substr(0,1) === "#" ? o.paneSelector.substr(1) : ""
            ,	rClass	= o.resizerClass
            ,	tClass	= o.togglerClass
            ,	spacing	= (s.isVisible ? o.spacing_open : o.spacing_closed)
            ,	_pane	= "-"+ pane // used for classNames
            ,	_state	= (s.isVisible ? "-open" : "-closed") // used for classNames
            ,	I		= Instance[pane]
            // INIT RESIZER BAR
            ,	$R		= I.resizer = $Rs[pane] = $("<div></div>")
            // INIT TOGGLER BUTTON
            ,	$T		= I.toggler = (o.closable ? $Ts[pane] = $("<div></div>") : false)
          ;

          //if (s.isVisible && o.resizable) ... handled by initResizable
          if (!s.isVisible && o.slidable)
            $R.attr("title", o.tips.Slide).css("cursor", o.sliderCursor);

          $R	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "paneLeft-resizer"
            .attr("id", paneId ? paneId +"-resizer" : "" )
            .data({
              parentLayout:	Instance
              ,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
              ,	layoutEdge:		pane
              ,	layoutRole:		"resizer"
            })
            .css(_c.resizers.cssReq).css("zIndex", options.zIndexes.resizer_normal)
            .css(o.applyDemoStyles ? _c.resizers.cssDemo : {}) // add demo styles
            .addClass(rClass +" "+ rClass+_pane)
            .hover(addHover, removeHover) // ALWAYS add hover-classes, even if resizing is not enabled - handle with CSS instead
            .hover(onResizerEnter, onResizerLeave) // ALWAYS NEED resizer.mouseleave to balance toggler.mouseenter
            .mousedown($.layout.disableTextSelection)	// prevent text-selection OUTSIDE resizer
            .mouseup($.layout.enableTextSelection)		// not really necessary, but just in case
            .appendTo($N) // append DIV to container
          ;
          if ($.fn.disableSelection)
            $R.disableSelection(); // prevent text-selection INSIDE resizer
          if (o.resizerDblClickToggle)
            $R.bind("dblclick."+ sID, toggle );

          if ($T) {
            $T	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "#paneLeft-toggler"
              .attr("id", paneId ? paneId +"-toggler" : "" )
              .data({
                parentLayout:	Instance
                ,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
                ,	layoutEdge:		pane
                ,	layoutRole:		"toggler"
              })
              .css(_c.togglers.cssReq) // add base/required styles
              .css(o.applyDemoStyles ? _c.togglers.cssDemo : {}) // add demo styles
              .addClass(tClass +" "+ tClass+_pane)
              .hover(addHover, removeHover) // ALWAYS add hover-classes, even if toggling is not enabled - handle with CSS instead
              .bind("mouseenter", onResizerEnter) // NEED toggler.mouseenter because mouseenter MAY NOT fire on resizer
              .appendTo($R) // append SPAN to resizer DIV
            ;
            // ADD INNER-SPANS TO TOGGLER
            if (o.togglerContent_open) // ui-layout-open
              $("<span>"+ o.togglerContent_open +"</span>")
                .data({
                  layoutEdge:		pane
                  ,	layoutRole:		"togglerContent"
                })
                .data("layoutRole", "togglerContent")
                .data("layoutEdge", pane)
                .addClass("content content-open")
                .css("display","none")
                .appendTo( $T )
              //.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-open instead!
              ;
            if (o.togglerContent_closed) // ui-layout-closed
              $("<span>"+ o.togglerContent_closed +"</span>")
                .data({
                  layoutEdge:		pane
                  ,	layoutRole:		"togglerContent"
                })
                .addClass("content content-closed")
                .css("display","none")
                .appendTo( $T )
              //.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-closed instead!
              ;
            // ADD TOGGLER.click/.hover
            enableClosable(pane);
          }

          // add Draggable events
          initResizable(pane);

          // ADD CLASSNAMES & SLIDE-BINDINGS - eg: class="resizer resizer-west resizer-open"
          if (s.isVisible)
            setAsOpen(pane);	// onOpen will be called, but NOT onResize
          else {
            setAsClosed(pane);	// onClose will be called
            bindStartSlidingEvents(pane, true); // will enable events IF option is set
          }

        });

        // SET ALL HANDLE DIMENSIONS
        sizeHandles();
      }


      /**
       * Initialize scrolling ui-layout-content div - if exists
       *
       * @see  initPane() - or externally after an Ajax injection
       * @param {string}	pane			The pane to process
       * @param {boolean=}	[resize=true]	Size content after init
       */
      ,	initContent = function (pane, resize) {
        if (!isInitialized()) return;
        var
          o	= options[pane]
          ,	sel	= o.contentSelector
          ,	I	= Instance[pane]
          ,	$P	= $Ps[pane]
          ,	$C
        ;
        if (sel) $C = I.content = $Cs[pane] = (o.findNestedContent)
          ? $P.find(sel).eq(0) // match 1-element only
          : $P.children(sel).eq(0)
        ;
        if ($C && $C.length) {
          $C.data("layoutRole", "content");
          // SAVE original Content CSS
          if (!$C.data("layoutCSS"))
            $C.data("layoutCSS", styles($C, "height"));
          $C.css( _c.content.cssReq );
          if (o.applyDemoStyles) {
            $C.css( _c.content.cssDemo ); // add padding & overflow: auto to content-div
            $P.css( _c.content.cssDemoPane ); // REMOVE padding/scrolling from pane
          }
          // ensure no vertical scrollbar on pane - will mess up measurements
          if ($P.css("overflowX").match(/(scroll|auto)/)) {
            $P.css("overflow", "hidden");
          }
          state[pane].content = {}; // init content state
          if (resize !== false) sizeContent(pane);
          // sizeContent() is called AFTER init of all elements
        }
        else
          I.content = $Cs[pane] = false;
      }


      /**
       * Add resize-bars to all panes that specify it in options
       * -dependancy: $.fn.resizable - will skip if not found
       *
       * @see  _create()
       * @param {string=}	[panes=""]	The edge(s) to process
       */
      ,	initResizable = function (panes) {
        var	draggingAvailable = $.layout.plugins.draggable
          ,	side // set in start()
        ;
        panes = panes ? panes.split(",") : _c.borderPanes;

        $.each(panes, function (idx, pane) {
          var o = options[pane];
          if (!draggingAvailable || !$Ps[pane] || !o.resizable) {
            o.resizable = false;
            return true; // skip to next
          }

          var s		= state[pane]
            ,	z		= options.zIndexes
            ,	c		= _c[pane]
            ,	side	= c.dir=="horz" ? "top" : "left"
            ,	$P 		= $Ps[pane]
            ,	$R		= $Rs[pane]
            ,	base	= o.resizerClass
            ,	lastPos	= 0 // used when live-resizing
            ,	r, live // set in start because may change
            //	'drag' classes are applied to the ORIGINAL resizer-bar while dragging is in process
            ,	resizerClass		= base+"-drag"				// resizer-drag
            ,	resizerPaneClass	= base+"-"+pane+"-drag"		// resizer-north-drag
            //	'helper' class is applied to the CLONED resizer-bar while it is being dragged
            ,	helperClass			= base+"-dragging"			// resizer-dragging
            ,	helperPaneClass		= base+"-"+pane+"-dragging" // resizer-north-dragging
            ,	helperLimitClass	= base+"-dragging-limit"	// resizer-drag
            ,	helperPaneLimitClass = base+"-"+pane+"-dragging-limit"	// resizer-north-drag
            ,	helperClassesSet	= false 					// logic var
          ;

          if (!s.isClosed)
            $R.attr("title", o.tips.Resize)
              .css("cursor", o.resizerCursor); // n-resize, s-resize, etc

          $R.draggable({
            containment:	$N[0] // limit resizing to layout container
            ,	axis:			(c.dir=="horz" ? "y" : "x") // limit resizing to horz or vert axis
            ,	delay:			0
            ,	distance:		1
            ,	grid:			o.resizingGrid
            //	basic format for helper - style it using class: .ui-draggable-dragging
            ,	helper:			"clone"
            ,	opacity:		o.resizerDragOpacity
            ,	addClasses:		false // avoid ui-state-disabled class when disabled
            //,	iframeFix:		o.draggableIframeFix // TODO: consider using when bug is fixed
            ,	zIndex:			z.resizer_drag

            ,	start: function (e, ui) {
              // REFRESH options & state pointers in case we used swapPanes
              o = options[pane];
              s = state[pane];
              // re-read options
              live = o.livePaneResizing;

              // ondrag_start callback - will CANCEL hide if returns false
              // TODO: dragging CANNOT be cancelled like this, so see if there is a way?
              if (false === _runCallbacks("ondrag_start", pane)) return false;

              s.isResizing		= true; // prevent pane from closing while resizing
              state.paneResizing	= pane; // easy to see if ANY pane is resizing
              timer.clear(pane+"_closeSlider"); // just in case already triggered

              // SET RESIZER LIMITS - used in drag()
              setSizeLimits(pane); // update pane/resizer state
              r = s.resizerPosition;
              lastPos = ui.position[ side ]

              $R.addClass( resizerClass +" "+ resizerPaneClass ); // add drag classes
              helperClassesSet = false; // reset logic var - see drag()

              // MASK PANES CONTAINING IFRAMES, APPLETS OR OTHER TROUBLESOME ELEMENTS
              showMasks( pane, { resizing: true });
            }

            ,	drag: function (e, ui) {
              if (!helperClassesSet) { // can only add classes after clone has been added to the DOM
                //$(".ui-draggable-dragging")
                ui.helper
                  .addClass( helperClass +" "+ helperPaneClass ) // add helper classes
                  .css({ right: "auto", bottom: "auto" })	// fix dir="rtl" issue
                  .children().css("visibility","hidden")	// hide toggler inside dragged resizer-bar
                ;
                helperClassesSet = true;
                // draggable bug!? RE-SET zIndex to prevent E/W resize-bar showing through N/S pane!
                if (s.isSliding) $Ps[pane].css("zIndex", z.pane_sliding);
              }
              // CONTAIN RESIZER-BAR TO RESIZING LIMITS
              var limit = 0;
              if (ui.position[side] < r.min) {
                ui.position[side] = r.min;
                limit = -1;
              }
              else if (ui.position[side] > r.max) {
                ui.position[side] = r.max;
                limit = 1;
              }
              // ADD/REMOVE dragging-limit CLASS
              if (limit) {
                ui.helper.addClass( helperLimitClass +" "+ helperPaneLimitClass ); // at dragging-limit
                window.defaultStatus = (limit>0 && pane.match(/(north|west)/)) || (limit<0 && pane.match(/(south|east)/)) ? o.tips.maxSizeWarning : o.tips.minSizeWarning;
              }
              else {
                ui.helper.removeClass( helperLimitClass +" "+ helperPaneLimitClass ); // not at dragging-limit
                window.defaultStatus = "";
              }
              // DYNAMICALLY RESIZE PANES IF OPTION ENABLED
              // won't trigger unless resizer has actually moved!
              if (live && Math.abs(ui.position[side] - lastPos) >= o.liveResizingTolerance) {
                lastPos = ui.position[side];
                resizePanes(e, ui, pane)
              }
            }

            ,	stop: function (e, ui) {
              $('body').enableSelection(); // RE-ENABLE TEXT SELECTION
              window.defaultStatus = ""; // clear 'resizing limit' message from statusbar
              $R.removeClass( resizerClass +" "+ resizerPaneClass ); // remove drag classes from Resizer
              s.isResizing		= false;
              state.paneResizing	= false; // easy to see if ANY pane is resizing
              resizePanes(e, ui, pane, true); // true = resizingDone
            }

          });
        });

        /**
         * resizePanes
         *
         * Sub-routine called from stop() - and drag() if livePaneResizing
         *
         * @param {!Object}		evt
         * @param {!Object}		ui
         * @param {string}		pane
         * @param {boolean=}		[resizingDone=false]
         */
        var resizePanes = function (evt, ui, pane, resizingDone) {
          var	dragPos	= ui.position
            ,	c		= _c[pane]
            ,	o		= options[pane]
            ,	s		= state[pane]
            ,	resizerPos
          ;
          switch (pane) {
            case "north":	resizerPos = dragPos.top; break;
            case "west":	resizerPos = dragPos.left; break;
            case "south":	resizerPos = sC.layoutHeight - dragPos.top  - o.spacing_open; break;
            case "east":	resizerPos = sC.layoutWidth  - dragPos.left - o.spacing_open; break;
          };
          // remove container margin from resizer position to get the pane size
          var newSize = resizerPos - sC.inset[c.side];

          // Disable OR Resize Mask(s) created in drag.start
          if (!resizingDone) {
            // ensure we meet liveResizingTolerance criteria
            if (Math.abs(newSize - s.size) < o.liveResizingTolerance)
              return; // SKIP resize this time
            // resize the pane
            manualSizePane(pane, newSize, false, true); // true = noAnimation
            sizeMasks(); // resize all visible masks
          }
          else { // resizingDone
            // ondrag_end callback
            if (false !== _runCallbacks("ondrag_end", pane))
              manualSizePane(pane, newSize, false, true); // true = noAnimation
            hideMasks(true); // true = force hiding all masks even if one is 'sliding'
            if (s.isSliding) // RE-SHOW 'object-masks' so objects won't show through sliding pane
              showMasks( pane, { resizing: true });
          }
        };
      }

      /**
       *	sizeMask
       *
       *	Needed to overlay a DIV over an IFRAME-pane because mask CANNOT be *inside* the pane
       *	Called when mask created, and during livePaneResizing
       */
      ,	sizeMask = function () {
        var $M		= $(this)
          ,	pane	= $M.data("layoutMask") // eg: "west"
          ,	s		= state[pane]
        ;
        // only masks over an IFRAME-pane need manual resizing
        if (s.tagName == "IFRAME" && s.isVisible) // no need to mask closed/hidden panes
          $M.css({
            top:	s.offsetTop
            ,	left:	s.offsetLeft
            ,	width:	s.outerWidth
            ,	height:	s.outerHeight
          });
        /* ALT Method...
         var $P = $Ps[pane];
         $M.css( $P.position() ).css({ width: $P[0].offsetWidth, height: $P[0].offsetHeight });
         */
      }
      ,	sizeMasks = function () {
        $Ms.each( sizeMask ); // resize all 'visible' masks
      }

      /**
       * @param {string}	pane		The pane being resized, animated or isSliding
       * @param {Object=}	[args]		(optional) Options: which masks to apply, and to which panes
       */
      ,	showMasks = function (pane, args) {
        var	c		= _c[pane]
          ,	panes	=  ["center"]
          ,	z		= options.zIndexes
          ,	a		= $.extend({
            objectsOnly:	false
            ,	animation:		false
            ,	resizing:		true
            ,	sliding:		state[pane].isSliding
          },	args )
          ,	o, s
        ;
        if (a.resizing)
          panes.push( pane );
        if (a.sliding)
          panes.push( _c.oppositeEdge[pane] ); // ADD the oppositeEdge-pane

        if (c.dir === "horz") {
          panes.push("west");
          panes.push("east");
        }

        $.each(panes, function(i,p){
          s = state[p];
          o = options[p];
          if (s.isVisible && ( o.maskObjects || (!a.objectsOnly && o.maskContents) )) {
            getMasks(p).each(function(){
              sizeMask.call(this);
              this.style.zIndex = s.isSliding ? z.pane_sliding+1 : z.pane_normal+1
              this.style.display = "block";
            });
          }
        });
      }

      /**
       * @param {boolean=}	force		Hide masks even if a pane is sliding
       */
      ,	hideMasks = function (force) {
        // ensure no pane is resizing - could be a timing issue
        if (force || !state.paneResizing) {
          $Ms.hide(); // hide ALL masks
        }
        // if ANY pane is sliding, then DO NOT remove masks from panes with maskObjects enabled
        else if (!force && !$.isEmptyObject( state.panesSliding )) {
          var	i = $Ms.length - 1
            ,	p, $M;
          for (; i >= 0; i--) {
            $M	= $Ms.eq(i);
            p	= $M.data("layoutMask");
            if (!options[p].maskObjects) {
              $M.hide();
            }
          }
        }
      }

      /**
       * @param {string}	pane
       */
      ,	getMasks = function (pane) {
        var $Masks	= $([])
          ,	$M, i = 0, c = $Ms.length
        ;
        for (; i<c; i++) {
          $M = $Ms.eq(i);
          if ($M.data("layoutMask") === pane)
            $Masks = $Masks.add( $M );
        }
        if ($Masks.length)
          return $Masks;
        else
          return createMasks(pane);
      }

      /**
       * createMasks
       *
       * Generates both DIV (ALWAYS used) and IFRAME (optional) elements as masks
       * An IFRAME mask is created *under* the DIV when maskObjects=true, because a DIV cannot mask an applet
       *
       * @param {string}	pane
       */
      ,	createMasks = function (pane) {
        var
          $P	= $Ps[pane]
          ,	s	= state[pane]
          ,	o	= options[pane]
          ,	z	= options.zIndexes
          ,	isIframe, el, $M, css, i
        ;
        if (!o.maskContents && !o.maskObjects) return $([]);
        // if o.maskObjects=true, then loop TWICE to create BOTH kinds of mask, else only create a DIV
        for (i=0; i < (o.maskObjects ? 2 : 1); i++) {
          isIframe = o.maskObjects && i==0;
          el = document.createElement( isIframe ? "iframe" : "div" );
          $M = $(el).data("layoutMask", pane); // add data to relate mask to pane
          el.className = "ui-layout-mask ui-layout-mask-"+ pane; // for user styling
          css = el.style;
          // Both DIVs and IFRAMES
          css.background	= "#FFF";
          css.position	= "absolute";
          css.display		= "block";
          if (isIframe) { // IFRAME-only props
            el.src		= "about:blank";
            el.frameborder = 0;
            css.border	= 0;
            css.opacity	= 0;
            css.filter	= "Alpha(Opacity='0')";
            //el.allowTransparency = true; - for IE, but breaks masking ability!
          }
          else { // DIV-only props
            css.opacity	= 0.001;
            css.filter	= "Alpha(Opacity='1')";
          }
          // if pane IS an IFRAME, then must mask the pane itself
          if (s.tagName == "IFRAME") {
            // NOTE sizing done by a subroutine so can be called during live-resizing
            css.zIndex	= z.pane_normal+1; // 1-higher than pane
            $N.append( el ); // append to LAYOUT CONTAINER
          }
          // otherwise put masks *inside the pane* to mask its contents
          else {
            $M.addClass("ui-layout-mask-inside-pane");
            css.zIndex	= o.maskZindex || z.content_mask; // usually 1, but customizable
            css.top		= 0;
            css.left	= 0;
            css.width	= "100%";
            css.height	= "100%";
            $P.append( el ); // append INSIDE pane element
          }
          // add Mask to cached array so can be resized & reused
          $Ms = $Ms.add( el );
        }
        return $Ms;
      }


      /**
       * Destroy this layout and reset all elements
       *
       * @param {boolean=}	[destroyChildren=false]		Destory Child-Layouts first?
       */
      ,	destroy = function (evt_or_destroyChildren, destroyChildren) {
        // UNBIND layout events and remove global object
        $(window).unbind("."+ sID);		// resize & unload
        $(document).unbind("."+ sID);	// keyDown (hotkeys)

        if (typeof evt_or_destroyChildren === "object")
        // stopPropagation if called by trigger("layoutdestroy") - use evtPane utility
          evtPane(evt_or_destroyChildren);
        else // no event, so transfer 1st param to destroyChildren param
          destroyChildren = evt_or_destroyChildren;

        // need to look for parent layout BEFORE we remove the container data, else skips a level
        //var parentPane = Instance.hasParentLayout ? $.layout.getParentPaneInstance( $N ) : null;

        // reset layout-container
        $N	.clearQueue()
          .removeData("layout")
          .removeData("layoutContainer")
          .removeClass(options.containerClass)
          .unbind("."+ sID) // remove ALL Layout events
        ;

        // remove all mask elements that have been created
        $Ms.remove();

        // loop all panes to remove layout classes, attributes and bindings
        $.each(_c.allPanes, function (i, pane) {
          removePane( pane, false, true, destroyChildren ); // true = skipResize
        });

        // do NOT reset container CSS if is a 'pane' (or 'content') in an outer-layout - ie, THIS layout is 'nested'
        var css = "layoutCSS";
        if ($N.data(css) && !$N.data("layoutRole")) // RESET CSS
          $N.css( $N.data(css) ).removeData(css);

        // for full-page layouts, also reset the <HTML> CSS
        if (sC.tagName === "BODY" && ($N = $("html")).data(css)) // RESET <HTML> CSS
          $N.css( $N.data(css) ).removeData(css);

        // trigger plugins for this layout, if there are any
        runPluginCallbacks( Instance, $.layout.onDestroy );

        // trigger state-management and onunload callback
        unload();

        // clear the Instance of everything except for container & options (so could recreate)
        // RE-CREATE: myLayout = myLayout.container.layout( myLayout.options );
        for (var n in Instance)
          if (!n.match(/^(container|options)$/)) delete Instance[ n ];
        // add a 'destroyed' flag to make it easy to check
        Instance.destroyed = true;

        // if this is a child layout, CLEAR the child-pointer in the parent
        /* for now the pointer REMAINS, but with only container, options and destroyed keys
         if (parentPane) {
         var layout	= parentPane.pane.data("parentLayout")
         ,	key		= layout.options.instanceKey || 'error';
         // THIS SYNTAX MAY BE WRONG!
         parentPane.children[key] = layout.children[ parentPane.name ].children[key] = null;
         }
         */

        return Instance; // for coding convenience
      }

      /**
       * Remove a pane from the layout - subroutine of destroy()
       *
       * @see  destroy()
       * @param {(string|Object)}	evt_or_pane			The pane to process
       * @param {boolean=}			[remove=false]		Remove the DOM element?
       * @param {boolean=}			[skipResize=false]	Skip calling resizeAll()?
       * @param {boolean=}			[destroyChild=true]	Destroy Child-layouts? If not passed, obeys options setting
       */
      ,	removePane = function (evt_or_pane, remove, skipResize, destroyChild) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$P	= $Ps[pane]
          ,	$C	= $Cs[pane]
          ,	$R	= $Rs[pane]
          ,	$T	= $Ts[pane]
        ;
        // NOTE: elements can still exist even after remove()
        //		so check for missing data(), which is cleared by removed()
        if ($P && $.isEmptyObject( $P.data() )) $P = false;
        if ($C && $.isEmptyObject( $C.data() )) $C = false;
        if ($R && $.isEmptyObject( $R.data() )) $R = false;
        if ($T && $.isEmptyObject( $T.data() )) $T = false;

        if ($P) $P.stop(true, true);

        var	o	= options[pane]
          ,	s	= state[pane]
          ,	d	= "layout"
          ,	css	= "layoutCSS"
          ,	pC	= children[pane]
          ,	hasChildren	= $.isPlainObject( pC ) && !$.isEmptyObject( pC )
          ,	destroy		= destroyChild !== undefined ? destroyChild : o.destroyChildren
        ;
        // FIRST destroy the child-layout(s)
        if (hasChildren && destroy) {
          $.each( pC, function (key, child) {
            if (!child.destroyed)
              child.destroy(true);// tell child-layout to destroy ALL its child-layouts too
            if (child.destroyed)	// destroy was successful
              delete pC[key];
          });
          // if no more children, remove the children hash
          if ($.isEmptyObject( pC )) {
            pC = children[pane] = null; // clear children hash
            hasChildren = false;
          }
        }

        // Note: can't 'remove' a pane element with non-destroyed children
        if ($P && remove && !hasChildren)
          $P.remove(); // remove the pane-element and everything inside it
        else if ($P && $P[0]) {
          //	create list of ALL pane-classes that need to be removed
          var	root	= o.paneClass // default="ui-layout-pane"
            ,	pRoot	= root +"-"+ pane // eg: "ui-layout-pane-west"
            ,	_open	= "-open"
            ,	_sliding= "-sliding"
            ,	_closed	= "-closed"
            ,	classes	= [	root, root+_open, root+_closed, root+_sliding,		// generic classes
            pRoot, pRoot+_open, pRoot+_closed, pRoot+_sliding ]	// pane-specific classes
          ;
          $.merge(classes, getHoverClasses($P, true)); // ADD hover-classes
          // remove all Layout classes from pane-element
          $P	.removeClass( classes.join(" ") ) // remove ALL pane-classes
            .removeData("parentLayout")
            .removeData("layoutPane")
            .removeData("layoutRole")
            .removeData("layoutEdge")
            .removeData("autoHidden")	// in case set
            .unbind("."+ sID) // remove ALL Layout events
          // TODO: remove these extra unbind commands when jQuery is fixed
          //.unbind("mouseenter"+ sID)
          //.unbind("mouseleave"+ sID)
          ;
          // do NOT reset CSS if this pane/content is STILL the container of a nested layout!
          // the nested layout will reset its 'container' CSS when/if it is destroyed
          if (hasChildren && $C) {
            // a content-div may not have a specific width, so give it one to contain the Layout
            $C.width( $C.width() );
            $.each( pC, function (key, child) {
              child.resizeAll(); // resize the Layout
            });
          }
          else if ($C)
            $C.css( $C.data(css) ).removeData(css).removeData("layoutRole");
          // remove pane AFTER content in case there was a nested layout
          if (!$P.data(d))
            $P.css( $P.data(css) ).removeData(css);
        }

        // REMOVE pane resizer and toggler elements
        if ($T) $T.remove();
        if ($R) $R.remove();

        // CLEAR all pointers and state data
        Instance[pane] = $Ps[pane] = $Cs[pane] = $Rs[pane] = $Ts[pane] = false;
        s = { removed: true };

        if (!skipResize)
          resizeAll();
      }


      /*
       * ###########################
       *	   ACTION METHODS
       * ###########################
       */

      /**
       * @param {string}	pane
       */
      ,	_hidePane = function (pane) {
        var $P	= $Ps[pane]
          ,	o	= options[pane]
          ,	s	= $P[0].style
        ;
        if (o.useOffscreenClose) {
          if (!$P.data(_c.offscreenReset))
            $P.data(_c.offscreenReset, { left: s.left, right: s.right });
          $P.css( _c.offscreenCSS );
        }
        else
          $P.hide().removeData(_c.offscreenReset);
      }

      /**
       * @param {string}	pane
       */
      ,	_showPane = function (pane) {
        var $P	= $Ps[pane]
          ,	o	= options[pane]
          ,	off	= _c.offscreenCSS
          ,	old	= $P.data(_c.offscreenReset)
          ,	s	= $P[0].style
        ;
        $P	.show() // ALWAYS show, just in case
          .removeData(_c.offscreenReset);
        if (o.useOffscreenClose && old) {
          if (s.left == off.left)
            s.left = old.left;
          if (s.right == off.right)
            s.right = old.right;
        }
      }


      /**
       * Completely 'hides' a pane, including its spacing - as if it does not exist
       * The pane is not actually 'removed' from the source, so can use 'show' to un-hide it
       *
       * @param {(string|Object)}	evt_or_pane			The pane being hidden, ie: north, south, east, or west
       * @param {boolean=}			[noAnimation=false]
       */
      ,	hide = function (evt_or_pane, noAnimation) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	o	= options[pane]
          ,	s	= state[pane]
          ,	$P	= $Ps[pane]
          ,	$R	= $Rs[pane]
        ;
        if (pane === "center" || !$P || s.isHidden) return; // pane does not exist OR is already hidden

        // onhide_start callback - will CANCEL hide if returns false
        if (state.initialized && false === _runCallbacks("onhide_start", pane)) return;

        s.isSliding = false; // just in case
        delete state.panesSliding[pane];

        // now hide the elements
        if ($R) $R.hide(); // hide resizer-bar
        if (!state.initialized || s.isClosed) {
          s.isClosed = true; // to trigger open-animation on show()
          s.isHidden  = true;
          s.isVisible = false;
          if (!state.initialized)
            _hidePane(pane); // no animation when loading page
          sizeMidPanes(_c[pane].dir === "horz" ? "" : "center");
          if (state.initialized || o.triggerEventsOnLoad)
            _runCallbacks("onhide_end", pane);
        }
        else {
          s.isHiding = true; // used by onclose
          close(pane, false, noAnimation); // adjust all panes to fit
        }
      }

      /**
       * Show a hidden pane - show as 'closed' by default unless openPane = true
       *
       * @param {(string|Object)}	evt_or_pane			The pane being opened, ie: north, south, east, or west
       * @param {boolean=}			[openPane=false]
       * @param {boolean=}			[noAnimation=false]
       * @param {boolean=}			[noAlert=false]
       */
      ,	show = function (evt_or_pane, openPane, noAnimation, noAlert) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	o	= options[pane]
          ,	s	= state[pane]
          ,	$P	= $Ps[pane]
          ,	$R	= $Rs[pane]
        ;
        if (pane === "center" || !$P || !s.isHidden) return; // pane does not exist OR is not hidden

        // onshow_start callback - will CANCEL show if returns false
        if (false === _runCallbacks("onshow_start", pane)) return;

        s.isShowing = true; // used by onopen/onclose
        //s.isHidden  = false; - will be set by open/close - if not cancelled
        s.isSliding = false; // just in case
        delete state.panesSliding[pane];

        // now show the elements
        //if ($R) $R.show(); - will be shown by open/close
        if (openPane === false)
          close(pane, true); // true = force
        else
          open(pane, false, noAnimation, noAlert); // adjust all panes to fit
      }


      /**
       * Toggles a pane open/closed by calling either open or close
       *
       * @param {(string|Object)}	evt_or_pane		The pane being toggled, ie: north, south, east, or west
       * @param {boolean=}			[slide=false]
       */
      ,	toggle = function (evt_or_pane, slide) {
        if (!isInitialized()) return;
        var	evt		= evtObj(evt_or_pane)
          ,	pane	= evtPane.call(this, evt_or_pane)
          ,	s		= state[pane]
        ;
        if (evt) // called from to $R.dblclick OR triggerPaneEvent
          evt.stopImmediatePropagation();
        if (s.isHidden)
          show(pane); // will call 'open' after unhiding it
        else if (s.isClosed)
          open(pane, !!slide);
        else
          close(pane);
      }


      /**
       * Utility method used during init or other auto-processes
       *
       * @param {string}	pane   The pane being closed
       * @param {boolean=}	[setHandles=false]
       */
      ,	_closePane = function (pane, setHandles) {
        var
          $P	= $Ps[pane]
          ,	s	= state[pane]
        ;
        _hidePane(pane);
        s.isClosed = true;
        s.isVisible = false;
        if (setHandles) setAsClosed(pane);
      }

      /**
       * Close the specified pane (animation optional), and resize all other panes as needed
       *
       * @param {(string|Object)}	evt_or_pane			The pane being closed, ie: north, south, east, or west
       * @param {boolean=}			[force=false]
       * @param {boolean=}			[noAnimation=false]
       * @param {boolean=}			[skipCallback=false]
       */
      ,	close = function (evt_or_pane, force, noAnimation, skipCallback) {
        var	pane = evtPane.call(this, evt_or_pane);
        if (pane === "center") return; // validate
        // if pane has been initialized, but NOT the complete layout, close pane instantly
        if (!state.initialized && $Ps[pane]) {
          _closePane(pane, true); // INIT pane as closed
          return;
        }
        if (!isInitialized()) return;

        var
          $P	= $Ps[pane]
          ,	$R	= $Rs[pane]
          ,	$T	= $Ts[pane]
          ,	o	= options[pane]
          ,	s	= state[pane]
          ,	c	= _c[pane]
          ,	doFX, isShowing, isHiding, wasSliding;

        // QUEUE in case another action/animation is in progress
        $N.queue(function( queueNext ){

          if ( !$P
            ||	(!o.closable && !s.isShowing && !s.isHiding)	// invalid request // (!o.resizable && !o.closable) ???
            ||	(!force && s.isClosed && !s.isShowing)			// already closed
          ) return queueNext();

          // onclose_start callback - will CANCEL hide if returns false
          // SKIP if just 'showing' a hidden pane as 'closed'
          var abort = !s.isShowing && false === _runCallbacks("onclose_start", pane);

          // transfer logic vars to temp vars
          isShowing	= s.isShowing;
          isHiding	= s.isHiding;
          wasSliding	= s.isSliding;
          // now clear the logic vars (REQUIRED before aborting)
          delete s.isShowing;
          delete s.isHiding;

          if (abort) return queueNext();

          doFX		= !noAnimation && !s.isClosed && (o.fxName_close != "none");
          s.isMoving	= true;
          s.isClosed	= true;
          s.isVisible	= false;
          // update isHidden BEFORE sizing panes
          if (isHiding) s.isHidden = true;
          else if (isShowing) s.isHidden = false;

          if (s.isSliding) // pane is being closed, so UNBIND trigger events
            bindStopSlidingEvents(pane, false); // will set isSliding=false
          else // resize panes adjacent to this one
            sizeMidPanes(_c[pane].dir === "horz" ? "" : "center", false); // false = NOT skipCallback

          // if this pane has a resizer bar, move it NOW - before animation
          setAsClosed(pane);

          // CLOSE THE PANE
          if (doFX) { // animate the close
            lockPaneForFX(pane, true);	// need to set left/top so animation will work
            $P.hide( o.fxName_close, o.fxSettings_close, o.fxSpeed_close, function () {
              lockPaneForFX(pane, false); // undo
              if (s.isClosed) close_2();
              queueNext();
            });
          }
          else { // hide the pane without animation
            _hidePane(pane);
            close_2();
            queueNext();
          };
        });

        // SUBROUTINE
        function close_2 () {
          s.isMoving	= false;
          bindStartSlidingEvents(pane, true); // will enable if o.slidable = true

          // if opposite-pane was autoClosed, see if it can be autoOpened now
          var altPane = _c.oppositeEdge[pane];
          if (state[ altPane ].noRoom) {
            setSizeLimits( altPane );
            makePaneFit( altPane );
          }

          if (!skipCallback && (state.initialized || o.triggerEventsOnLoad)) {
            // onclose callback - UNLESS just 'showing' a hidden pane as 'closed'
            if (!isShowing)	_runCallbacks("onclose_end", pane);
            // onhide OR onshow callback
            if (isShowing)	_runCallbacks("onshow_end", pane);
            if (isHiding)	_runCallbacks("onhide_end", pane);
          }
        }
      }

      /**
       * @param {string}	pane	The pane just closed, ie: north, south, east, or west
       */
      ,	setAsClosed = function (pane) {
        if (!$Rs[pane]) return; // handles not initialized yet!
        var
          $P		= $Ps[pane]
          ,	$R		= $Rs[pane]
          ,	$T		= $Ts[pane]
          ,	o		= options[pane]
          ,	s		= state[pane]
          ,	side	= _c[pane].side
          ,	rClass	= o.resizerClass
          ,	tClass	= o.togglerClass
          ,	_pane	= "-"+ pane // used for classNames
          ,	_open	= "-open"
          ,	_sliding= "-sliding"
          ,	_closed	= "-closed"
        ;
        $R
          .css(side, sC.inset[side]) // move the resizer
          .removeClass( rClass+_open +" "+ rClass+_pane+_open )
          .removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
          .addClass( rClass+_closed +" "+ rClass+_pane+_closed )
        ;
        // handle already-hidden panes in case called by swap() or a similar method
        if (s.isHidden) $R.hide(); // hide resizer-bar

        // DISABLE 'resizing' when closed - do this BEFORE bindStartSlidingEvents?
        if (o.resizable && $.layout.plugins.draggable)
          $R
            .draggable("disable")
            .removeClass("ui-state-disabled") // do NOT apply disabled styling - not suitable here
            .css("cursor", "default")
            .attr("title","")
          ;

        // if pane has a toggler button, adjust that too
        if ($T) {
          $T
            .removeClass( tClass+_open +" "+ tClass+_pane+_open )
            .addClass( tClass+_closed +" "+ tClass+_pane+_closed )
            .attr("title", o.tips.Open) // may be blank
          ;
          // toggler-content - if exists
          $T.children(".content-open").hide();
          $T.children(".content-closed").css("display","block");
        }

        // sync any 'pin buttons'
        syncPinBtns(pane, false);

        if (state.initialized) {
          // resize 'length' and position togglers for adjacent panes
          sizeHandles();
        }
      }

      /**
       * Open the specified pane (animation optional), and resize all other panes as needed
       *
       * @param {(string|Object)}	evt_or_pane			The pane being opened, ie: north, south, east, or west
       * @param {boolean=}			[slide=false]
       * @param {boolean=}			[noAnimation=false]
       * @param {boolean=}			[noAlert=false]
       */
      ,	open = function (evt_or_pane, slide, noAnimation, noAlert) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$P	= $Ps[pane]
          ,	$R	= $Rs[pane]
          ,	$T	= $Ts[pane]
          ,	o	= options[pane]
          ,	s	= state[pane]
          ,	c	= _c[pane]
          ,	doFX, isShowing
        ;
        if (pane === "center") return; // validate
        // QUEUE in case another action/animation is in progress
        $N.queue(function( queueNext ){

          if ( !$P
            ||	(!o.resizable && !o.closable && !s.isShowing)	// invalid request
            ||	(s.isVisible && !s.isSliding)					// already open
          ) return queueNext();

          // pane can ALSO be unhidden by just calling show(), so handle this scenario
          if (s.isHidden && !s.isShowing) {
            queueNext(); // call before show() because it needs the queue free
            show(pane, true);
            return;
          }

          if (s.autoResize && s.size != o.size) // resize pane to original size set in options
            sizePane(pane, o.size, true, true, true); // true=skipCallback/noAnimation/forceResize
          else
          // make sure there is enough space available to open the pane
            setSizeLimits(pane, slide);

          // onopen_start callback - will CANCEL open if returns false
          var cbReturn = _runCallbacks("onopen_start", pane);

          if (cbReturn === "abort")
            return queueNext();

          // update pane-state again in case options were changed in onopen_start
          if (cbReturn !== "NC") // NC = "No Callback"
            setSizeLimits(pane, slide);

          if (s.minSize > s.maxSize) { // INSUFFICIENT ROOM FOR PANE TO OPEN!
            syncPinBtns(pane, false); // make sure pin-buttons are reset
            if (!noAlert && o.tips.noRoomToOpen)
              alert(o.tips.noRoomToOpen);
            return queueNext(); // ABORT
          }

          if (slide) // START Sliding - will set isSliding=true
            bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
          else if (s.isSliding) // PIN PANE (stop sliding) - open pane 'normally' instead
            bindStopSlidingEvents(pane, false); // UNBIND trigger events - will set isSliding=false
          else if (o.slidable)
            bindStartSlidingEvents(pane, false); // UNBIND trigger events

          s.noRoom = false; // will be reset by makePaneFit if 'noRoom'
          makePaneFit(pane);

          // transfer logic var to temp var
          isShowing = s.isShowing;
          // now clear the logic var
          delete s.isShowing;

          doFX		= !noAnimation && s.isClosed && (o.fxName_open != "none");
          s.isMoving	= true;
          s.isVisible	= true;
          s.isClosed	= false;
          // update isHidden BEFORE sizing panes - WHY??? Old?
          if (isShowing) s.isHidden = false;

          if (doFX) { // ANIMATE
            // mask adjacent panes with objects
            lockPaneForFX(pane, true);	// need to set left/top so animation will work
            $P.show( o.fxName_open, o.fxSettings_open, o.fxSpeed_open, function() {
              lockPaneForFX(pane, false); // undo
              if (s.isVisible) open_2(); // continue
              queueNext();
            });
          }
          else { // no animation
            _showPane(pane);// just show pane and...
            open_2();		// continue
            queueNext();
          };
        });

        // SUBROUTINE
        function open_2 () {
          s.isMoving	= false;

          // cure iframe display issues
          _fixIframe(pane);

          // NOTE: if isSliding, then other panes are NOT 'resized'
          if (!s.isSliding) { // resize all panes adjacent to this one
            sizeMidPanes(_c[pane].dir=="vert" ? "center" : "", false); // false = NOT skipCallback
          }

          // set classes, position handles and execute callbacks...
          setAsOpen(pane);
        };

      }

      /**
       * @param {string}	pane		The pane just opened, ie: north, south, east, or west
       * @param {boolean=}	[skipCallback=false]
       */
      ,	setAsOpen = function (pane, skipCallback) {
        var
          $P		= $Ps[pane]
          ,	$R		= $Rs[pane]
          ,	$T		= $Ts[pane]
          ,	o		= options[pane]
          ,	s		= state[pane]
          ,	side	= _c[pane].side
          ,	rClass	= o.resizerClass
          ,	tClass	= o.togglerClass
          ,	_pane	= "-"+ pane // used for classNames
          ,	_open	= "-open"
          ,	_closed	= "-closed"
          ,	_sliding= "-sliding"
        ;
        $R
          .css(side, sC.inset[side] + getPaneSize(pane)) // move the resizer
          .removeClass( rClass+_closed +" "+ rClass+_pane+_closed )
          .addClass( rClass+_open +" "+ rClass+_pane+_open )
        ;
        if (s.isSliding)
          $R.addClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
        else // in case 'was sliding'
          $R.removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )

        removeHover( 0, $R ); // remove hover classes
        if (o.resizable && $.layout.plugins.draggable)
          $R	.draggable("enable")
            .css("cursor", o.resizerCursor)
            .attr("title", o.tips.Resize);
        else if (!s.isSliding)
          $R.css("cursor", "default"); // n-resize, s-resize, etc

        // if pane also has a toggler button, adjust that too
        if ($T) {
          $T	.removeClass( tClass+_closed +" "+ tClass+_pane+_closed )
            .addClass( tClass+_open +" "+ tClass+_pane+_open )
            .attr("title", o.tips.Close); // may be blank
          removeHover( 0, $T ); // remove hover classes
          // toggler-content - if exists
          $T.children(".content-closed").hide();
          $T.children(".content-open").css("display","block");
        }

        // sync any 'pin buttons'
        syncPinBtns(pane, !s.isSliding);

        // update pane-state dimensions - BEFORE resizing content
        $.extend(s, elDims($P));

        if (state.initialized) {
          // resize resizer & toggler sizes for all panes
          sizeHandles();
          // resize content every time pane opens - to be sure
          sizeContent(pane, true); // true = remeasure headers/footers, even if 'pane.isMoving'
        }

        if (!skipCallback && (state.initialized || o.triggerEventsOnLoad) && $P.is(":visible")) {
          // onopen callback
          _runCallbacks("onopen_end", pane);
          // onshow callback - TODO: should this be here?
          if (s.isShowing) _runCallbacks("onshow_end", pane);

          // ALSO call onresize because layout-size *may* have changed while pane was closed
          if (state.initialized)
            _runCallbacks("onresize_end", pane);
        }

        // TODO: Somehow sizePane("north") is being called after this point???
      }


      /**
       * slideOpen / slideClose / slideToggle
       *
       * Pass-though methods for sliding
       */
      ,	slideOpen = function (evt_or_pane) {
        if (!isInitialized()) return;
        var	evt		= evtObj(evt_or_pane)
          ,	pane	= evtPane.call(this, evt_or_pane)
          ,	s		= state[pane]
          ,	delay	= options[pane].slideDelay_open
        ;
        if (pane === "center") return; // validate
        // prevent event from triggering on NEW resizer binding created below
        if (evt) evt.stopImmediatePropagation();

        if (s.isClosed && evt && evt.type === "mouseenter" && delay > 0)
        // trigger = mouseenter - use a delay
          timer.set(pane+"_openSlider", open_NOW, delay);
        else
          open_NOW(); // will unbind events if is already open

        /**
         * SUBROUTINE for timed open
         */
        function open_NOW () {
          if (!s.isClosed) // skip if no longer closed!
            bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
          else if (!s.isMoving)
            open(pane, true); // true = slide - open() will handle binding
        };
      }

      ,	slideClose = function (evt_or_pane) {
        if (!isInitialized()) return;
        var	evt		= evtObj(evt_or_pane)
          ,	pane	= evtPane.call(this, evt_or_pane)
          ,	o		= options[pane]
          ,	s		= state[pane]
          ,	delay	= s.isMoving ? 1000 : 300 // MINIMUM delay - option may override
        ;
        if (pane === "center") return; // validate
        if (s.isClosed || s.isResizing)
          return; // skip if already closed OR in process of resizing
        else if (o.slideTrigger_close === "click")
          close_NOW(); // close immediately onClick
        else if (o.preventQuickSlideClose && s.isMoving)
          return; // handle Chrome quick-close on slide-open
        else if (o.preventPrematureSlideClose && evt && $.layout.isMouseOverElem(evt, $Ps[pane]))
          return; // handle incorrect mouseleave trigger, like when over a SELECT-list in IE
        else if (evt) // trigger = mouseleave - use a delay
        // 1 sec delay if 'opening', else .3 sec
          timer.set(pane+"_closeSlider", close_NOW, max(o.slideDelay_close, delay));
        else // called programically
          close_NOW();

        /**
         * SUBROUTINE for timed close
         */
        function close_NOW () {
          if (s.isClosed) // skip 'close' if already closed!
            bindStopSlidingEvents(pane, false); // UNBIND trigger events - TODO: is this needed here?
          else if (!s.isMoving)
            close(pane); // close will handle unbinding
        };
      }

      /**
       * @param {(string|Object)}	evt_or_pane		The pane being opened, ie: north, south, east, or west
       */
      ,	slideToggle = function (evt_or_pane) {
        var pane = evtPane.call(this, evt_or_pane);
        toggle(pane, true);
      }


      /**
       * Must set left/top on East/South panes so animation will work properly
       *
       * @param {string}	pane	The pane to lock, 'east' or 'south' - any other is ignored!
       * @param {boolean}	doLock  true = set left/top, false = remove
       */
      ,	lockPaneForFX = function (pane, doLock) {
        var $P	= $Ps[pane]
          ,	s	= state[pane]
          ,	o	= options[pane]
          ,	z	= options.zIndexes
        ;
        if (doLock) {
          showMasks( pane, { animation: true, objectsOnly: true });
          $P.css({ zIndex: z.pane_animate }); // overlay all elements during animation
          if (pane=="south")
            $P.css({ top: sC.inset.top + sC.innerHeight - $P.outerHeight() });
          else if (pane=="east")
            $P.css({ left: sC.inset.left + sC.innerWidth - $P.outerWidth() });
        }
        else { // animation DONE - RESET CSS
          hideMasks();
          $P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
          if (pane=="south")
            $P.css({ top: "auto" });
          // if pane is positioned 'off-screen', then DO NOT screw with it!
          else if (pane=="east" && !$P.css("left").match(/\-99999/))
            $P.css({ left: "auto" });
          // fix anti-aliasing in IE - only needed for animations that change opacity
          if (browser.msie && o.fxOpacityFix && o.fxName_open != "slide" && $P.css("filter") && $P.css("opacity") == 1)
            $P[0].style.removeAttribute('filter');
        }
      }


      /**
       * Toggle sliding functionality of a specific pane on/off by adding removing 'slide open' trigger
       *
       * @see  open(), close()
       * @param {string}	pane	The pane to enable/disable, 'north', 'south', etc.
       * @param {boolean}	enable	Enable or Disable sliding?
       */
      ,	bindStartSlidingEvents = function (pane, enable) {
        var o		= options[pane]
          ,	$P		= $Ps[pane]
          ,	$R		= $Rs[pane]
          ,	evtName	= o.slideTrigger_open.toLowerCase()
        ;
        if (!$R || (enable && !o.slidable)) return;

        // make sure we have a valid event
        if (evtName.match(/mouseover/))
          evtName = o.slideTrigger_open = "mouseenter";
        else if (!evtName.match(/(click|dblclick|mouseenter)/))
          evtName = o.slideTrigger_open = "click";

        // must remove double-click-toggle when using dblclick-slide
        if (o.resizerDblClickToggle && evtName.match(/click/)) {
          $R[enable ? "unbind" : "bind"]('dblclick.'+ sID, toggle)
        }

        $R
          // add or remove event
          [enable ? "bind" : "unbind"](evtName +'.'+ sID, slideOpen)
        // set the appropriate cursor & title/tip
          .css("cursor", enable ? o.sliderCursor : "default")
          .attr("title", enable ? o.tips.Slide : "")
        ;
      }

      /**
       * Add or remove 'mouseleave' events to 'slide close' when pane is 'sliding' open or closed
       * Also increases zIndex when pane is sliding open
       * See bindStartSlidingEvents for code to control 'slide open'
       *
       * @see  slideOpen(), slideClose()
       * @param {string}	pane	The pane to process, 'north', 'south', etc.
       * @param {boolean}	enable	Enable or Disable events?
       */
      ,	bindStopSlidingEvents = function (pane, enable) {
        var	o		= options[pane]
          ,	s		= state[pane]
          ,	c		= _c[pane]
          ,	z		= options.zIndexes
          ,	evtName	= o.slideTrigger_close.toLowerCase()
          ,	action	= (enable ? "bind" : "unbind")
          ,	$P		= $Ps[pane]
          ,	$R		= $Rs[pane]
        ;
        timer.clear(pane+"_closeSlider"); // just in case

        if (enable) {
          s.isSliding = true;
          state.panesSliding[pane] = true;
          // remove 'slideOpen' event from resizer
          // ALSO will raise the zIndex of the pane & resizer
          bindStartSlidingEvents(pane, false);
        }
        else {
          s.isSliding = false;
          delete state.panesSliding[pane];
        }

        // RE/SET zIndex - increases when pane is sliding-open, resets to normal when not
        $P.css("zIndex", enable ? z.pane_sliding : z.pane_normal);
        $R.css("zIndex", enable ? z.pane_sliding+2 : z.resizer_normal); // NOTE: mask = pane_sliding+1

        // make sure we have a valid event
        if (!evtName.match(/(click|mouseleave)/))
          evtName = o.slideTrigger_close = "mouseleave"; // also catches 'mouseout'

        // add/remove slide triggers
        $R[action](evtName, slideClose); // base event on resize
        // need extra events for mouseleave
        if (evtName === "mouseleave") {
          // also close on pane.mouseleave
          $P[action]("mouseleave."+ sID, slideClose);
          // cancel timer when mouse moves between 'pane' and 'resizer'
          $R[action]("mouseenter."+ sID, cancelMouseOut);
          $P[action]("mouseenter."+ sID, cancelMouseOut);
        }

        if (!enable)
          timer.clear(pane+"_closeSlider");
        else if (evtName === "click" && !o.resizable) {
          // IF pane is not resizable (which already has a cursor and tip)
          // then set the a cursor & title/tip on resizer when sliding
          $R.css("cursor", enable ? o.sliderCursor : "default");
          $R.attr("title", enable ? o.tips.Close : ""); // use Toggler-tip, eg: "Close Pane"
        }

        // SUBROUTINE for mouseleave timer clearing
        function cancelMouseOut (evt) {
          timer.clear(pane+"_closeSlider");
          evt.stopPropagation();
        }
      }


      /**
       * Hides/closes a pane if there is insufficient room - reverses this when there is room again
       * MUST have already called setSizeLimits() before calling this method
       *
       * @param {string}	pane					The pane being resized
       * @param {boolean=}	[isOpening=false]		Called from onOpen?
       * @param {boolean=}	[skipCallback=false]	Should the onresize callback be run?
       * @param {boolean=}	[force=false]
       */
      ,	makePaneFit = function (pane, isOpening, skipCallback, force) {
        var	o	= options[pane]
          ,	s	= state[pane]
          ,	c	= _c[pane]
          ,	$P	= $Ps[pane]
          ,	$R	= $Rs[pane]
          ,	isSidePane 	= c.dir==="vert"
          ,	hasRoom		= false
        ;
        // special handling for center & east/west panes
        if (pane === "center" || (isSidePane && s.noVerticalRoom)) {
          // see if there is enough room to display the pane
          // ERROR: hasRoom = s.minHeight <= s.maxHeight && (isSidePane || s.minWidth <= s.maxWidth);
          hasRoom = (s.maxHeight >= 0);
          if (hasRoom && s.noRoom) { // previously hidden due to noRoom, so show now
            _showPane(pane);
            if ($R) $R.show();
            s.isVisible = true;
            s.noRoom = false;
            if (isSidePane) s.noVerticalRoom = false;
            _fixIframe(pane);
          }
          else if (!hasRoom && !s.noRoom) { // not currently hidden, so hide now
            _hidePane(pane);
            if ($R) $R.hide();
            s.isVisible = false;
            s.noRoom = true;
          }
        }

        // see if there is enough room to fit the border-pane
        if (pane === "center") {
          // ignore center in this block
        }
        else if (s.minSize <= s.maxSize) { // pane CAN fit
          hasRoom = true;
          if (s.size > s.maxSize) // pane is too big - shrink it
            sizePane(pane, s.maxSize, skipCallback, true, force); // true = noAnimation
          else if (s.size < s.minSize) // pane is too small - enlarge it
            sizePane(pane, s.minSize, skipCallback, true, force); // true = noAnimation
          // need s.isVisible because new pseudoClose method keeps pane visible, but off-screen
          else if ($R && s.isVisible && $P.is(":visible")) {
            // make sure resizer-bar is positioned correctly
            // handles situation where nested layout was 'hidden' when initialized
            var	pos = s.size + sC.inset[c.side];
            if ($.layout.cssNum( $R, c.side ) != pos) $R.css( c.side, pos );
          }

          // if was previously hidden due to noRoom, then RESET because NOW there is room
          if (s.noRoom) {
            // s.noRoom state will be set by open or show
            if (s.wasOpen && o.closable) {
              if (o.autoReopen)
                open(pane, false, true, true); // true = noAnimation, true = noAlert
              else // leave the pane closed, so just update state
                s.noRoom = false;
            }
            else
              show(pane, s.wasOpen, true, true); // true = noAnimation, true = noAlert
          }
        }
        else { // !hasRoom - pane CANNOT fit
          if (!s.noRoom) { // pane not set as noRoom yet, so hide or close it now...
            s.noRoom = true; // update state
            s.wasOpen = !s.isClosed && !s.isSliding;
            if (s.isClosed){} // SKIP
            else if (o.closable) // 'close' if possible
              close(pane, true, true); // true = force, true = noAnimation
            else // 'hide' pane if cannot just be closed
              hide(pane, true); // true = noAnimation
          }
        }
      }


      /**
       * manualSizePane is an exposed flow-through method allowing extra code when pane is 'manually resized'
       *
       * @param {(string|Object)}	evt_or_pane				The pane being resized
       * @param {number}			size					The *desired* new size for this pane - will be validated
       * @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
       * @param {boolean=}			[noAnimation=false]
       * @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
       */
      ,	manualSizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	o	= options[pane]
          ,	s	= state[pane]
          //	if resizing callbacks have been delayed and resizing is now DONE, force resizing to complete...
          ,	forceResize = force || (o.livePaneResizing && !s.isResizing)
        ;
        if (pane === "center") return; // validate
        // ANY call to manualSizePane disables autoResize - ie, percentage sizing
        s.autoResize = false;
        // flow-through...
        sizePane(pane, size, skipCallback, noAnimation, forceResize); // will animate resize if option enabled
      }

      /**
       * sizePane is called only by internal methods whenever a pane needs to be resized
       *
       * @param {(string|Object)}	evt_or_pane				The pane being resized
       * @param {number}			size					The *desired* new size for this pane - will be validated
       * @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
       * @param {boolean=}			[noAnimation=false]
       * @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
       */
      ,	sizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
        if (!isInitialized()) return;
        var	pane	= evtPane.call(this, evt_or_pane) // probably NEVER called from event?
          ,	o		= options[pane]
          ,	s		= state[pane]
          ,	$P		= $Ps[pane]
          ,	$R		= $Rs[pane]
          ,	side	= _c[pane].side
          ,	dimName	= _c[pane].sizeType.toLowerCase()
          ,	skipResizeWhileDragging = s.isResizing && !o.triggerEventsDuringLiveResize
          ,	doFX	= noAnimation !== true && o.animatePaneSizing
          ,	oldSize, newSize
        ;
        if (pane === "center") return; // validate
        // QUEUE in case another action/animation is in progress
        $N.queue(function( queueNext ){
          // calculate 'current' min/max sizes
          setSizeLimits(pane); // update pane-state
          oldSize = s.size;
          size = _parseSize(pane, size); // handle percentages & auto
          size = max(size, _parseSize(pane, o.minSize));
          size = min(size, s.maxSize);
          if (size < s.minSize) { // not enough room for pane!
            queueNext(); // call before makePaneFit() because it needs the queue free
            makePaneFit(pane, false, skipCallback);	// will hide or close pane
            return;
          }

          // IF newSize is same as oldSize, then nothing to do - abort
          if (!force && size === oldSize)
            return queueNext();

          s.newSize = size;

          // onresize_start callback CANNOT cancel resizing because this would break the layout!
          if (!skipCallback && state.initialized && s.isVisible)
            _runCallbacks("onresize_start", pane);

          // resize the pane, and make sure its visible
          newSize = cssSize(pane, size);

          if (doFX && $P.is(":visible")) { // ANIMATE
            var fx		= $.layout.effects.size[pane] || $.layout.effects.size.all
              ,	easing	= o.fxSettings_size.easing || fx.easing
              ,	z		= options.zIndexes
              ,	props	= {};
            props[ dimName ] = newSize +'px';
            s.isMoving = true;
            // overlay all elements during animation
            $P.css({ zIndex: z.pane_animate })
              .show().animate( props, o.fxSpeed_size, easing, function(){
              // reset zIndex after animation
              $P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
              s.isMoving = false;
              delete s.newSize;
              sizePane_2(); // continue
              queueNext();
            });
          }
          else { // no animation
            $P.css( dimName, newSize );	// resize pane
            delete s.newSize;
            // if pane is visible, then
            if ($P.is(":visible"))
              sizePane_2(); // continue
            else {
              // pane is NOT VISIBLE, so just update state data...
              // when pane is *next opened*, it will have the new size
              s.size = size;				// update state.size
              //$.extend(s, elDims($P));	// update state dimensions - CANNOT do this when not visible!				}
            }
            queueNext();
          };

        });

        // SUBROUTINE
        function sizePane_2 () {
          /*	Panes are sometimes not sized precisely in some browsers!?
           *	This code will resize the pane up to 3 times to nudge the pane to the correct size
           */
          var	actual	= dimName==='width' ? $P.outerWidth() : $P.outerHeight()
            ,	tries	= [{
              pane:		pane
              ,	count:		1
              ,	target:		size
              ,	actual:		actual
              ,	correct:	(size === actual)
              ,	attempt:	size
              ,	cssSize:	newSize
            }]
            ,	lastTry = tries[0]
            ,	thisTry	= {}
            ,	msg		= 'Inaccurate size after resizing the '+ pane +'-pane.'
          ;
          while ( !lastTry.correct ) {
            thisTry = { pane: pane, count: lastTry.count+1, target: size };

            if (lastTry.actual > size)
              thisTry.attempt = max(0, lastTry.attempt - (lastTry.actual - size));
            else // lastTry.actual < size
              thisTry.attempt = max(0, lastTry.attempt + (size - lastTry.actual));

            thisTry.cssSize = cssSize(pane, thisTry.attempt);
            $P.css( dimName, thisTry.cssSize );

            thisTry.actual	= dimName=='width' ? $P.outerWidth() : $P.outerHeight();
            thisTry.correct	= (size === thisTry.actual);

            // log attempts and alert the user of this *non-fatal error* (if showDebugMessages)
            if ( tries.length === 1) {
              _log(msg, false, true);
              _log(lastTry, false, true);
            }
            _log(thisTry, false, true);
            // after 4 tries, is as close as its gonna get!
            if (tries.length > 3) break;

            tries.push( thisTry );
            lastTry = tries[ tries.length - 1 ];
          }
          // END TESTING CODE

          // update pane-state dimensions
          s.size	= size;
          $.extend(s, elDims($P));

          if (s.isVisible && $P.is(":visible")) {
            // reposition the resizer-bar
            if ($R) $R.css( side, size + sC.inset[side] );
            // resize the content-div
            sizeContent(pane);
          }

          if (!skipCallback && !skipResizeWhileDragging && state.initialized && s.isVisible)
            _runCallbacks("onresize_end", pane);

          // resize all the adjacent panes, and adjust their toggler buttons
          // when skipCallback passed, it means the controlling method will handle 'other panes'
          if (!skipCallback) {
            // also no callback if live-resize is in progress and NOT triggerEventsDuringLiveResize
            if (!s.isSliding) sizeMidPanes(_c[pane].dir=="horz" ? "" : "center", skipResizeWhileDragging, force);
            sizeHandles();
          }

          // if opposite-pane was autoClosed, see if it can be autoOpened now
          var altPane = _c.oppositeEdge[pane];
          if (size < oldSize && state[ altPane ].noRoom) {
            setSizeLimits( altPane );
            makePaneFit( altPane, false, skipCallback );
          }

          // DEBUG - ALERT user/developer so they know there was a sizing problem
          if (tries.length > 1)
            _log(msg +'\nSee the Error Console for details.', true, true);
        }
      }

      /**
       * @see  initPanes(), sizePane(), 	resizeAll(), open(), close(), hide()
       * @param {(Array.<string>|string)}	panes					The pane(s) being resized, comma-delmited string
       * @param {boolean=}					[skipCallback=false]	Should the onresize callback be run?
       * @param {boolean=}					[force=false]
       */
      ,	sizeMidPanes = function (panes, skipCallback, force) {
        panes = (panes ? panes : "east,west,center").split(",");

        $.each(panes, function (i, pane) {
          if (!$Ps[pane]) return; // NO PANE - skip
          var
            o		= options[pane]
            ,	s		= state[pane]
            ,	$P		= $Ps[pane]
            ,	$R		= $Rs[pane]
            ,	isCenter= (pane=="center")
            ,	hasRoom	= true
            ,	CSS		= {}
            //	if pane is not visible, show it invisibly NOW rather than for *each call* in this script
            ,	visCSS	= $.layout.showInvisibly($P)

            ,	newCenter	= calcNewCenterPaneDims()
          ;

          // update pane-state dimensions
          $.extend(s, elDims($P));

          if (pane === "center") {
            if (!force && s.isVisible && newCenter.width === s.outerWidth && newCenter.height === s.outerHeight) {
              $P.css(visCSS);
              return true; // SKIP - pane already the correct size
            }
            // set state for makePaneFit() logic
            $.extend(s, cssMinDims(pane), {
              maxWidth:	newCenter.width
              ,	maxHeight:	newCenter.height
            });
            CSS = newCenter;
            s.newWidth	= CSS.width;
            s.newHeight	= CSS.height;
            // convert OUTER width/height to CSS width/height
            CSS.width	= cssW($P, CSS.width);
            // NEW - allow pane to extend 'below' visible area rather than hide it
            CSS.height	= cssH($P, CSS.height);
            hasRoom		= CSS.width >= 0 && CSS.height >= 0; // height >= 0 = ALWAYS TRUE NOW

            // during layout init, try to shrink east/west panes to make room for center
            if (!state.initialized && o.minWidth > newCenter.width) {
              var
                reqPx	= o.minWidth - s.outerWidth
                ,	minE	= options.east.minSize || 0
                ,	minW	= options.west.minSize || 0
                ,	sizeE	= state.east.size
                ,	sizeW	= state.west.size
                ,	newE	= sizeE
                ,	newW	= sizeW
              ;
              if (reqPx > 0 && state.east.isVisible && sizeE > minE) {
                newE = max( sizeE-minE, sizeE-reqPx );
                reqPx -= sizeE-newE;
              }
              if (reqPx > 0 && state.west.isVisible && sizeW > minW) {
                newW = max( sizeW-minW, sizeW-reqPx );
                reqPx -= sizeW-newW;
              }
              // IF we found enough extra space, then resize the border panes as calculated
              if (reqPx === 0) {
                if (sizeE && sizeE != minE)
                  sizePane('east', newE, true, true, force); // true = skipCallback/noAnimation - initPanes will handle when done
                if (sizeW && sizeW != minW)
                  sizePane('west', newW, true, true, force); // true = skipCallback/noAnimation
                // now start over!
                sizeMidPanes('center', skipCallback, force);
                $P.css(visCSS);
                return; // abort this loop
              }
            }
          }
          else { // for east and west, set only the height, which is same as center height
            // set state.min/maxWidth/Height for makePaneFit() logic
            if (s.isVisible && !s.noVerticalRoom)
              $.extend(s, elDims($P), cssMinDims(pane))
            if (!force && !s.noVerticalRoom && newCenter.height === s.outerHeight) {
              $P.css(visCSS);
              return true; // SKIP - pane already the correct size
            }
            // east/west have same top, bottom & height as center
            CSS.top		= newCenter.top;
            CSS.bottom	= newCenter.bottom;
            s.newSize	= newCenter.height
            // NEW - allow pane to extend 'below' visible area rather than hide it
            CSS.height	= cssH($P, newCenter.height);
            s.maxHeight	= CSS.height;
            hasRoom		= (s.maxHeight >= 0); // ALWAYS TRUE NOW
            if (!hasRoom) s.noVerticalRoom = true; // makePaneFit() logic
          }

          if (hasRoom) {
            // resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
            if (!skipCallback && state.initialized)
              _runCallbacks("onresize_start", pane);

            $P.css(CSS); // apply the CSS to pane
            if (pane !== "center")
              sizeHandles(pane); // also update resizer length
            if (s.noRoom && !s.isClosed && !s.isHidden)
              makePaneFit(pane); // will re-open/show auto-closed/hidden pane
            if (s.isVisible) {
              $.extend(s, elDims($P)); // update pane dimensions
              if (state.initialized) sizeContent(pane); // also resize the contents, if exists
            }
          }
          else if (!s.noRoom && s.isVisible) // no room for pane
            makePaneFit(pane); // will hide or close pane

          // reset visibility, if necessary
          $P.css(visCSS);

          delete s.newSize;
          delete s.newWidth;
          delete s.newHeight;

          if (!s.isVisible)
            return true; // DONE - next pane

          /*
           * Extra CSS for IE6 or IE7 in Quirks-mode - add 'width' to NORTH/SOUTH panes
           * Normally these panes have only 'left' & 'right' positions so pane auto-sizes
           * ALSO required when pane is an IFRAME because will NOT default to 'full width'
           *	TODO: Can I use width:100% for a north/south iframe?
           *	TODO: Sounds like a job for $P.outerWidth( sC.innerWidth ) SETTER METHOD
           */
          if (pane === "center") { // finished processing midPanes
            var fix = browser.isIE6 || !browser.boxModel;
            if ($Ps.north && (fix || state.north.tagName=="IFRAME"))
              $Ps.north.css("width", cssW($Ps.north, sC.innerWidth));
            if ($Ps.south && (fix || state.south.tagName=="IFRAME"))
              $Ps.south.css("width", cssW($Ps.south, sC.innerWidth));
          }

          // resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
          if (!skipCallback && state.initialized)
            _runCallbacks("onresize_end", pane);
        });
      }


      /**
       * @see  window.onresize(), callbacks or custom code
       * @param {(Object|boolean)=}	evt_or_refresh	If 'true', then also reset pane-positioning
       */
      ,	resizeAll = function (evt_or_refresh) {
        var	oldW	= sC.innerWidth
          ,	oldH	= sC.innerHeight
        ;
        // stopPropagation if called by trigger("layoutdestroy") - use evtPane utility
        evtPane(evt_or_refresh);

        // cannot size layout when 'container' is hidden or collapsed
        if (!$N.is(":visible")) return;

        if (!state.initialized) {
          _initLayoutElements();
          return; // no need to resize since we just initialized!
        }

        if (evt_or_refresh === true && $.isPlainObject(options.outset)) {
          // update container CSS in case outset option has changed
          $N.css( options.outset );
        }
        // UPDATE container dimensions
        $.extend(sC, elDims( $N, options.inset ));
        if (!sC.outerHeight) return;

        // if 'true' passed, refresh pane & handle positioning too
        if (evt_or_refresh === true) {
          setPanePosition();
        }

        // onresizeall_start will CANCEL resizing if returns false
        // state.container has already been set, so user can access this info for calcuations
        if (false === _runCallbacks("onresizeall_start")) return false;

        var	// see if container is now 'smaller' than before
          shrunkH	= (sC.innerHeight < oldH)
          ,	shrunkW	= (sC.innerWidth < oldW)
          ,	$P, o, s
        ;
        // NOTE special order for sizing: S-N-E-W
        $.each(["south","north","east","west"], function (i, pane) {
          if (!$Ps[pane]) return; // no pane - SKIP
          o = options[pane];
          s = state[pane];
          if (s.autoResize && s.size != o.size) // resize pane to original size set in options
            sizePane(pane, o.size, true, true, true); // true=skipCallback/noAnimation/forceResize
          else {
            setSizeLimits(pane);
            makePaneFit(pane, false, true, true); // true=skipCallback/forceResize
          }
        });

        sizeMidPanes("", true, true); // true=skipCallback/forceResize
        sizeHandles(); // reposition the toggler elements

        // trigger all individual pane callbacks AFTER layout has finished resizing
        $.each(_c.allPanes, function (i, pane) {
          $P = $Ps[pane];
          if (!$P) return; // SKIP
          if (state[pane].isVisible) // undefined for non-existent panes
            _runCallbacks("onresize_end", pane); // callback - if exists
        });

        _runCallbacks("onresizeall_end");
        //_triggerLayoutEvent(pane, 'resizeall');
      }

      /**
       * Whenever a pane resizes or opens that has a nested layout, trigger resizeAll
       *
       * @param {(string|Object)}	evt_or_pane		The pane just resized or opened
       */
      ,	resizeChildren = function (evt_or_pane, skipRefresh) {
        var	pane = evtPane.call(this, evt_or_pane);

        if (!options[pane].resizeChildren) return;

        // ensure the pane-children are up-to-date
        if (!skipRefresh) refreshChildren( pane );
        var pC = children[pane];
        if ($.isPlainObject( pC )) {
          // resize one or more children
          $.each( pC, function (key, child) {
            if (!child.destroyed) child.resizeAll();
          });
        }
      }

      /**
       * IF pane has a content-div, then resize all elements inside pane to fit pane-height
       *
       * @param {(string|Object)}	evt_or_panes		The pane(s) being resized
       * @param {boolean=}			[remeasure=false]	Should the content (header/footer) be remeasured?
       */
      ,	sizeContent = function (evt_or_panes, remeasure) {
        if (!isInitialized()) return;

        var panes = evtPane.call(this, evt_or_panes);
        panes = panes ? panes.split(",") : _c.allPanes;

        $.each(panes, function (idx, pane) {
          var
            $P	= $Ps[pane]
            ,	$C	= $Cs[pane]
            ,	o	= options[pane]
            ,	s	= state[pane]
            ,	m	= s.content // m = measurements
          ;
          if (!$P || !$C || !$P.is(":visible")) return true; // NOT VISIBLE - skip

          // if content-element was REMOVED, update OR remove the pointer
          if (!$C.length) {
            initContent(pane, false);	// false = do NOT sizeContent() - already there!
            if (!$C) return;			// no replacement element found - pointer have been removed
          }

          // onsizecontent_start will CANCEL resizing if returns false
          if (false === _runCallbacks("onsizecontent_start", pane)) return;

          // skip re-measuring offsets if live-resizing
          if ((!s.isMoving && !s.isResizing) || o.liveContentResizing || remeasure || m.top == undefined) {
            _measure();
            // if any footers are below pane-bottom, they may not measure correctly,
            // so allow pane overflow and re-measure
            if (m.hiddenFooters > 0 && $P.css("overflow") === "hidden") {
              $P.css("overflow", "visible");
              _measure(); // remeasure while overflowing
              $P.css("overflow", "hidden");
            }
          }
          // NOTE: spaceAbove/Below *includes* the pane paddingTop/Bottom, but not pane.borders
          var newH = s.innerHeight - (m.spaceAbove - s.css.paddingTop) - (m.spaceBelow - s.css.paddingBottom);

          if (!$C.is(":visible") || m.height != newH) {
            // size the Content element to fit new pane-size - will autoHide if not enough room
            setOuterHeight($C, newH, true); // true=autoHide
            m.height = newH; // save new height
          };

          if (state.initialized)
            _runCallbacks("onsizecontent_end", pane);

          function _below ($E) {
            return max(s.css.paddingBottom, (parseInt($E.css("marginBottom"), 10) || 0));
          };

          function _measure () {
            var
              ignore	= options[pane].contentIgnoreSelector
              ,	$Fs		= $C.nextAll().not(".ui-layout-mask").not(ignore || ":lt(0)") // not :lt(0) = ALL
              ,	$Fs_vis	= $Fs.filter(':visible')
              ,	$F		= $Fs_vis.filter(':last')
            ;
            m = {
              top:			$C[0].offsetTop
              ,	height:			$C.outerHeight()
              ,	numFooters:		$Fs.length
              ,	hiddenFooters:	$Fs.length - $Fs_vis.length
              ,	spaceBelow:		0 // correct if no content footer ($E)
            }
            m.spaceAbove	= m.top; // just for state - not used in calc
            m.bottom		= m.top + m.height;
            if ($F.length)
            //spaceBelow = (LastFooter.top + LastFooter.height) [footerBottom] - Content.bottom + max(LastFooter.marginBottom, pane.paddingBotom)
              m.spaceBelow = ($F[0].offsetTop + $F.outerHeight()) - m.bottom + _below($F);
            else // no footer - check marginBottom on Content element itself
              m.spaceBelow = _below($C);
          };
        });
      }


      /**
       * Called every time a pane is opened, closed, or resized to slide the togglers to 'center' and adjust their length if necessary
       *
       * @see  initHandles(), open(), close(), resizeAll()
       * @param {(string|Object)=}		evt_or_panes	The pane(s) being resized
       */
      ,	sizeHandles = function (evt_or_panes) {
        var panes = evtPane.call(this, evt_or_panes)
        panes = panes ? panes.split(",") : _c.borderPanes;

        $.each(panes, function (i, pane) {
          var
            o	= options[pane]
            ,	s	= state[pane]
            ,	$P	= $Ps[pane]
            ,	$R	= $Rs[pane]
            ,	$T	= $Ts[pane]
            ,	$TC
          ;
          if (!$P || !$R) return;

          var
            dir			= _c[pane].dir
            ,	_state		= (s.isClosed ? "_closed" : "_open")
            ,	spacing		= o["spacing"+ _state]
            ,	togAlign	= o["togglerAlign"+ _state]
            ,	togLen		= o["togglerLength"+ _state]
            ,	paneLen
            ,	left
            ,	offset
            ,	CSS = {}
          ;

          if (spacing === 0) {
            $R.hide();
            return;
          }
          else if (!s.noRoom && !s.isHidden) // skip if resizer was hidden for any reason
            $R.show(); // in case was previously hidden

          // Resizer Bar is ALWAYS same width/height of pane it is attached to
          if (dir === "horz") { // north/south
            //paneLen = $P.outerWidth(); // s.outerWidth ||
            paneLen = sC.innerWidth; // handle offscreen-panes
            s.resizerLength = paneLen;
            left = $.layout.cssNum($P, "left")
            $R.css({
              width:	cssW($R, paneLen) // account for borders & padding
              ,	height:	cssH($R, spacing) // ditto
              ,	left:	left > -9999 ? left : sC.inset.left // handle offscreen-panes
            });
          }
          else { // east/west
            paneLen = $P.outerHeight(); // s.outerHeight ||
            s.resizerLength = paneLen;
            $R.css({
              height:	cssH($R, paneLen) // account for borders & padding
              ,	width:	cssW($R, spacing) // ditto
              ,	top:	sC.inset.top + getPaneSize("north", true) // TODO: what if no North pane?
              //,	top:	$.layout.cssNum($Ps["center"], "top")
            });
          }

          // remove hover classes
          removeHover( o, $R );

          if ($T) {
            if (togLen === 0 || (s.isSliding && o.hideTogglerOnSlide)) {
              $T.hide(); // always HIDE the toggler when 'sliding'
              return;
            }
            else
              $T.show(); // in case was previously hidden

            if (!(togLen > 0) || togLen === "100%" || togLen > paneLen) {
              togLen = paneLen;
              offset = 0;
            }
            else { // calculate 'offset' based on options.PANE.togglerAlign_open/closed
              if (isStr(togAlign)) {
                switch (togAlign) {
                  case "top":
                  case "left":	offset = 0;
                    break;
                  case "bottom":
                  case "right":	offset = paneLen - togLen;
                    break;
                  case "middle":
                  case "center":
                  default:		offset = round((paneLen - togLen) / 2); // 'default' catches typos
                }
              }
              else { // togAlign = number
                var x = parseInt(togAlign, 10); //
                if (togAlign >= 0) offset = x;
                else offset = paneLen - togLen + x; // NOTE: x is negative!
              }
            }

            if (dir === "horz") { // north/south
              var width = cssW($T, togLen);
              $T.css({
                width:	width  // account for borders & padding
                ,	height:	cssH($T, spacing) // ditto
                ,	left:	offset // TODO: VERIFY that toggler  positions correctly for ALL values
                ,	top:	0
              });
              // CENTER the toggler content SPAN
              $T.children(".content").each(function(){
                $TC = $(this);
                $TC.css("marginLeft", round((width-$TC.outerWidth())/2)); // could be negative
              });
            }
            else { // east/west
              var height = cssH($T, togLen);
              $T.css({
                height:	height // account for borders & padding
                ,	width:	cssW($T, spacing) // ditto
                ,	top:	offset // POSITION the toggler
                ,	left:	0
              });
              // CENTER the toggler content SPAN
              $T.children(".content").each(function(){
                $TC = $(this);
                $TC.css("marginTop", round((height-$TC.outerHeight())/2)); // could be negative
              });
            }

            // remove ALL hover classes
            removeHover( 0, $T );
          }

          // DONE measuring and sizing this resizer/toggler, so can be 'hidden' now
          if (!state.initialized && (o.initHidden || s.isHidden)) {
            $R.hide();
            if ($T) $T.hide();
          }
        });
      }


      /**
       * @param {(string|Object)}	evt_or_pane
       */
      ,	enableClosable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$T	= $Ts[pane]
          ,	o	= options[pane]
        ;
        if (!$T) return;
        o.closable = true;
        $T	.bind("click."+ sID, function(evt){ evt.stopPropagation(); toggle(pane); })
          .css("visibility", "visible")
          .css("cursor", "pointer")
          .attr("title", state[pane].isClosed ? o.tips.Open : o.tips.Close) // may be blank
          .show();
      }
      /**
       * @param {(string|Object)}	evt_or_pane
       * @param {boolean=}			[hide=false]
       */
      ,	disableClosable = function (evt_or_pane, hide) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$T	= $Ts[pane]
        ;
        if (!$T) return;
        options[pane].closable = false;
        // is closable is disable, then pane MUST be open!
        if (state[pane].isClosed) open(pane, false, true);
        $T	.unbind("."+ sID)
          .css("visibility", hide ? "hidden" : "visible") // instead of hide(), which creates logic issues
          .css("cursor", "default")
          .attr("title", "");
      }


      /**
       * @param {(string|Object)}	evt_or_pane
       */
      ,	enableSlidable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$R	= $Rs[pane]
        ;
        if (!$R || !$R.data('draggable')) return;
        options[pane].slidable = true;
        if (state[pane].isClosed)
          bindStartSlidingEvents(pane, true);
      }
      /**
       * @param {(string|Object)}	evt_or_pane
       */
      ,	disableSlidable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$R	= $Rs[pane]
        ;
        if (!$R) return;
        options[pane].slidable = false;
        if (state[pane].isSliding)
          close(pane, false, true);
        else {
          bindStartSlidingEvents(pane, false);
          $R	.css("cursor", "default")
            .attr("title", "");
          removeHover(null, $R[0]); // in case currently hovered
        }
      }


      /**
       * @param {(string|Object)}	evt_or_pane
       */
      ,	enableResizable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$R	= $Rs[pane]
          ,	o	= options[pane]
        ;
        if (!$R || !$R.data('draggable')) return;
        o.resizable = true;
        $R.draggable("enable");
        if (!state[pane].isClosed)
          $R	.css("cursor", o.resizerCursor)
            .attr("title", o.tips.Resize);
      }
      /**
       * @param {(string|Object)}	evt_or_pane
       */
      ,	disableResizable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var	pane = evtPane.call(this, evt_or_pane)
          ,	$R	= $Rs[pane]
        ;
        if (!$R || !$R.data('draggable')) return;
        options[pane].resizable = false;
        $R	.draggable("disable")
          .css("cursor", "default")
          .attr("title", "");
        removeHover(null, $R[0]); // in case currently hovered
      }


      /**
       * Move a pane from source-side (eg, west) to target-side (eg, east)
       * If pane exists on target-side, move that to source-side, ie, 'swap' the panes
       *
       * @param {(string|Object)}	evt_or_pane1	The pane/edge being swapped
       * @param {string}			pane2			ditto
       */
      ,	swapPanes = function (evt_or_pane1, pane2) {
        if (!isInitialized()) return;
        var pane1 = evtPane.call(this, evt_or_pane1);
        // change state.edge NOW so callbacks can know where pane is headed...
        state[pane1].edge = pane2;
        state[pane2].edge = pane1;
        // run these even if NOT state.initialized
        if (false === _runCallbacks("onswap_start", pane1)
          ||	false === _runCallbacks("onswap_start", pane2)
        ) {
          state[pane1].edge = pane1; // reset
          state[pane2].edge = pane2;
          return;
        }

        var
          oPane1	= copy( pane1 )
          ,	oPane2	= copy( pane2 )
          ,	sizes	= {}
        ;
        sizes[pane1] = oPane1 ? oPane1.state.size : 0;
        sizes[pane2] = oPane2 ? oPane2.state.size : 0;

        // clear pointers & state
        $Ps[pane1] = false;
        $Ps[pane2] = false;
        state[pane1] = {};
        state[pane2] = {};

        // ALWAYS remove the resizer & toggler elements
        if ($Ts[pane1]) $Ts[pane1].remove();
        if ($Ts[pane2]) $Ts[pane2].remove();
        if ($Rs[pane1]) $Rs[pane1].remove();
        if ($Rs[pane2]) $Rs[pane2].remove();
        $Rs[pane1] = $Rs[pane2] = $Ts[pane1] = $Ts[pane2] = false;

        // transfer element pointers and data to NEW Layout keys
        move( oPane1, pane2 );
        move( oPane2, pane1 );

        // cleanup objects
        oPane1 = oPane2 = sizes = null;

        // make panes 'visible' again
        if ($Ps[pane1]) $Ps[pane1].css(_c.visible);
        if ($Ps[pane2]) $Ps[pane2].css(_c.visible);

        // fix any size discrepancies caused by swap
        resizeAll();

        // run these even if NOT state.initialized
        _runCallbacks("onswap_end", pane1);
        _runCallbacks("onswap_end", pane2);

        return;

        function copy (n) { // n = pane
          var
            $P	= $Ps[n]
            ,	$C	= $Cs[n]
          ;
          return !$P ? false : {
            pane:		n
            ,	P:			$P ? $P[0] : false
            ,	C:			$C ? $C[0] : false
            ,	state:		$.extend(true, {}, state[n])
            ,	options:	$.extend(true, {}, options[n])
          }
        };

        function move (oPane, pane) {
          if (!oPane) return;
          var
            P		= oPane.P
            ,	C		= oPane.C
            ,	oldPane = oPane.pane
            ,	c		= _c[pane]
            //	save pane-options that should be retained
            ,	s		= $.extend(true, {}, state[pane])
            ,	o		= options[pane]
            //	RETAIN side-specific FX Settings - more below
            ,	fx		= { resizerCursor: o.resizerCursor }
            ,	re, size, pos
          ;
          $.each("fxName,fxSpeed,fxSettings".split(","), function (i, k) {
            fx[k +"_open"]  = o[k +"_open"];
            fx[k +"_close"] = o[k +"_close"];
            fx[k +"_size"]  = o[k +"_size"];
          });

          // update object pointers and attributes
          $Ps[pane] = $(P)
            .data({
              layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
              ,	layoutEdge:		pane
            })
            .css(_c.hidden)
            .css(c.cssReq)
          ;
          $Cs[pane] = C ? $(C) : false;

          // set options and state
          options[pane]	= $.extend(true, {}, oPane.options, fx);
          state[pane]		= $.extend(true, {}, oPane.state);

          // change classNames on the pane, eg: ui-layout-pane-east ==> ui-layout-pane-west
          re = new RegExp(o.paneClass +"-"+ oldPane, "g");
          P.className = P.className.replace(re, o.paneClass +"-"+ pane);

          // ALWAYS regenerate the resizer & toggler elements
          initHandles(pane); // create the required resizer & toggler

          // if moving to different orientation, then keep 'target' pane size
          if (c.dir != _c[oldPane].dir) {
            size = sizes[pane] || 0;
            setSizeLimits(pane); // update pane-state
            size = max(size, state[pane].minSize);
            // use manualSizePane to disable autoResize - not useful after panes are swapped
            manualSizePane(pane, size, true, true); // true/true = skipCallback/noAnimation
          }
          else // move the resizer here
            $Rs[pane].css(c.side, sC.inset[c.side] + (state[pane].isVisible ? getPaneSize(pane) : 0));


          // ADD CLASSNAMES & SLIDE-BINDINGS
          if (oPane.state.isVisible && !s.isVisible)
            setAsOpen(pane, true); // true = skipCallback
          else {
            setAsClosed(pane);
            bindStartSlidingEvents(pane, true); // will enable events IF option is set
          }

          // DESTROY the object
          oPane = null;
        };
      }


      /**
       * INTERNAL method to sync pin-buttons when pane is opened or closed
       * Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
       *
       * @see  open(), setAsOpen(), setAsClosed()
       * @param {string}	pane   These are the params returned to callbacks by layout()
       * @param {boolean}	doPin  True means set the pin 'down', False means 'up'
       */
      ,	syncPinBtns = function (pane, doPin) {
        if ($.layout.plugins.buttons)
          $.each(state[pane].pins, function (i, selector) {
            $.layout.buttons.setPinState(Instance, $(selector), pane, doPin);
          });
      }

    ;	// END var DECLARATIONS

    /**
     * Capture keys when enableCursorHotkey - toggle pane if hotkey pressed
     *
     * @see  document.keydown()
     */
    function keyDown (evt) {
      if (!evt) return true;
      var code = evt.keyCode;
      if (code < 33) return true; // ignore special keys: ENTER, TAB, etc

      var
        PANE = {
          38: "north" // Up Cursor	- $.ui.keyCode.UP
          ,	40: "south" // Down Cursor	- $.ui.keyCode.DOWN
          ,	37: "west"  // Left Cursor	- $.ui.keyCode.LEFT
          ,	39: "east"  // Right Cursor	- $.ui.keyCode.RIGHT
        }
        ,	ALT		= evt.altKey // no worky!
        ,	SHIFT	= evt.shiftKey
        ,	CTRL	= evt.ctrlKey
        ,	CURSOR	= (CTRL && code >= 37 && code <= 40)
        ,	o, k, m, pane
      ;

      if (CURSOR && options[PANE[code]].enableCursorHotkey) // valid cursor-hotkey
        pane = PANE[code];
      else if (CTRL || SHIFT) // check to see if this matches a custom-hotkey
        $.each(_c.borderPanes, function (i, p) { // loop each pane to check its hotkey
          o = options[p];
          k = o.customHotkey;
          m = o.customHotkeyModifier; // if missing or invalid, treated as "CTRL+SHIFT"
          if ((SHIFT && m=="SHIFT") || (CTRL && m=="CTRL") || (CTRL && SHIFT)) { // Modifier matches
            if (k && code === (isNaN(k) || k <= 9 ? k.toUpperCase().charCodeAt(0) : k)) { // Key matches
              pane = p;
              return false; // BREAK
            }
          }
        });

      // validate pane
      if (!pane || !$Ps[pane] || !options[pane].closable || state[pane].isHidden)
        return true;

      toggle(pane);

      evt.stopPropagation();
      evt.returnValue = false; // CANCEL key
      return false;
    };


    /*
     * ######################################
     *	UTILITY METHODS
     *	called externally or by initButtons
     * ######################################
     */

    /**
     * Change/reset a pane overflow setting & zIndex to allow popups/drop-downs to work
     *
     * @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
     */
    function allowOverflow (el) {
      if (!isInitialized()) return;
      if (this && this.tagName) el = this; // BOUND to element
      var $P;
      if (isStr(el))
        $P = $Ps[el];
      else if ($(el).data("layoutRole"))
        $P = $(el);
      else
        $(el).parents().each(function(){
          if ($(this).data("layoutRole")) {
            $P = $(this);
            return false; // BREAK
          }
        });
      if (!$P || !$P.length) return; // INVALID

      var
        pane	= $P.data("layoutEdge")
        ,	s		= state[pane]
      ;

      // if pane is already raised, then reset it before doing it again!
      // this would happen if allowOverflow is attached to BOTH the pane and an element
      if (s.cssSaved)
        resetOverflow(pane); // reset previous CSS before continuing

      // if pane is raised by sliding or resizing, or its closed, then abort
      if (s.isSliding || s.isResizing || s.isClosed) {
        s.cssSaved = false;
        return;
      }

      var
        newCSS	= { zIndex: (options.zIndexes.resizer_normal + 1) }
        ,	curCSS	= {}
        ,	of		= $P.css("overflow")
        ,	ofX		= $P.css("overflowX")
        ,	ofY		= $P.css("overflowY")
      ;
      // determine which, if any, overflow settings need to be changed
      if (of != "visible") {
        curCSS.overflow = of;
        newCSS.overflow = "visible";
      }
      if (ofX && !ofX.match(/(visible|auto)/)) {
        curCSS.overflowX = ofX;
        newCSS.overflowX = "visible";
      }
      if (ofY && !ofY.match(/(visible|auto)/)) {
        curCSS.overflowY = ofX;
        newCSS.overflowY = "visible";
      }

      // save the current overflow settings - even if blank!
      s.cssSaved = curCSS;

      // apply new CSS to raise zIndex and, if necessary, make overflow 'visible'
      $P.css( newCSS );

      // make sure the zIndex of all other panes is normal
      $.each(_c.allPanes, function(i, p) {
        if (p != pane) resetOverflow(p);
      });

    };
    /**
     * @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
     */
    function resetOverflow (el) {
      if (!isInitialized()) return;
      if (this && this.tagName) el = this; // BOUND to element
      var $P;
      if (isStr(el))
        $P = $Ps[el];
      else if ($(el).data("layoutRole"))
        $P = $(el);
      else
        $(el).parents().each(function(){
          if ($(this).data("layoutRole")) {
            $P = $(this);
            return false; // BREAK
          }
        });
      if (!$P || !$P.length) return; // INVALID

      var
        pane	= $P.data("layoutEdge")
        ,	s		= state[pane]
        ,	CSS		= s.cssSaved || {}
      ;
      // reset the zIndex
      if (!s.isSliding && !s.isResizing)
        $P.css("zIndex", options.zIndexes.pane_normal);

      // reset Overflow - if necessary
      $P.css( CSS );

      // clear var
      s.cssSaved = false;
    };

    /*
     * #####################
     * CREATE/RETURN LAYOUT
     * #####################
     */

    // validate that container exists
    var $N = $(this).eq(0); // FIRST matching Container element
    if (!$N.length) {
      return _log( options.errors.containerMissing );
    };

    // Users retrieve Instance of a layout with: $N.layout() OR $N.data("layout")
    // return the Instance-pointer if layout has already been initialized
    if ($N.data("layoutContainer") && $N.data("layout"))
      return $N.data("layout"); // cached pointer

    // init global vars
    var
      $Ps	= {}	// Panes x5		- set in initPanes()
      ,	$Cs	= {}	// Content x5	- set in initPanes()
      ,	$Rs	= {}	// Resizers x4	- set in initHandles()
      ,	$Ts	= {}	// Togglers x4	- set in initHandles()
      ,	$Ms	= $([])	// Masks - up to 2 masks per pane (IFRAME + DIV)
      //	aliases for code brevity
      ,	sC	= state.container // alias for easy access to 'container dimensions'
      ,	sID	= state.id // alias for unique layout ID/namespace - eg: "layout435"
    ;

    // create Instance object to expose data & option Properties, and primary action Methods
    var Instance = {
      //	layout data
      options:			options			// property - options hash
      ,	state:				state			// property - dimensions hash
      //	object pointers
      ,	container:			$N				// property - object pointers for layout container
      ,	panes:				$Ps				// property - object pointers for ALL Panes: panes.north, panes.center
      ,	contents:			$Cs				// property - object pointers for ALL Content: contents.north, contents.center
      ,	resizers:			$Rs				// property - object pointers for ALL Resizers, eg: resizers.north
      ,	togglers:			$Ts				// property - object pointers for ALL Togglers, eg: togglers.north
      //	border-pane open/close
      ,	hide:				hide			// method - ditto
      ,	show:				show			// method - ditto
      ,	toggle:				toggle			// method - pass a 'pane' ("north", "west", etc)
      ,	open:				open			// method - ditto
      ,	close:				close			// method - ditto
      ,	slideOpen:			slideOpen		// method - ditto
      ,	slideClose:			slideClose		// method - ditto
      ,	slideToggle:		slideToggle		// method - ditto
      //	pane actions
      ,	setSizeLimits:		setSizeLimits	// method - pass a 'pane' - update state min/max data
      ,	_sizePane:			sizePane		// method -intended for user by plugins only!
      ,	sizePane:			manualSizePane	// method - pass a 'pane' AND an 'outer-size' in pixels or percent, or 'auto'
      ,	sizeContent:		sizeContent		// method - pass a 'pane'
      ,	swapPanes:			swapPanes		// method - pass TWO 'panes' - will swap them
      ,	showMasks:			showMasks		// method - pass a 'pane' OR list of panes - default = all panes with mask option set
      ,	hideMasks:			hideMasks		// method - ditto'
      //	pane element methods
      ,	initContent:		initContent		// method - ditto
      ,	addPane:			addPane			// method - pass a 'pane'
      ,	removePane:			removePane		// method - pass a 'pane' to remove from layout, add 'true' to delete the pane-elem
      ,	createChildren:		createChildren	// method - pass a 'pane' and (optional) layout-options (OVERRIDES options[pane].children
      ,	refreshChildren:	refreshChildren	// method - pass a 'pane' and a layout-instance
      //	special pane option setting
      ,	enableClosable:		enableClosable	// method - pass a 'pane'
      ,	disableClosable:	disableClosable	// method - ditto
      ,	enableSlidable:		enableSlidable	// method - ditto
      ,	disableSlidable:	disableSlidable	// method - ditto
      ,	enableResizable:	enableResizable	// method - ditto
      ,	disableResizable:	disableResizable// method - ditto
      //	utility methods for panes
      ,	allowOverflow:		allowOverflow	// utility - pass calling element (this)
      ,	resetOverflow:		resetOverflow	// utility - ditto
      //	layout control
      ,	destroy:			destroy			// method - no parameters
      ,	initPanes:			isInitialized	// method - no parameters
      ,	resizeAll:			resizeAll		// method - no parameters
      //	callback triggering
      ,	runCallbacks:		_runCallbacks	// method - pass evtName & pane (if a pane-event), eg: trigger("onopen", "west")
      //	alias collections of options, state and children - created in addPane and extended elsewhere
      ,	hasParentLayout:	false			// set by initContainer()
      ,	children:			children		// pointers to child-layouts, eg: Instance.children.west.layoutName
      ,	north:				false			// alias group: { name: pane, pane: $Ps[pane], options: options[pane], state: state[pane], children: children[pane] }
      ,	south:				false			// ditto
      ,	west:				false			// ditto
      ,	east:				false			// ditto
      ,	center:				false			// ditto
    };

    // create the border layout NOW
    if (_create() === 'cancel') // onload_start callback returned false to CANCEL layout creation
      return null;
    else // true OR false -- if layout-elements did NOT init (hidden or do not exist), can auto-init later
      return Instance; // return the Instance object

  }


})( jQuery );




/**
 * jquery.layout.state 1.2
 * $Date: 2014-08-30 08:00:00 (Sat, 30 Aug 2014) $
 *
 * Copyright (c) 2014
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @requires: UI Layout 1.4.0 or higher
 * @requires: $.ui.cookie (above)
 *
 * @see: http://groups.google.com/group/jquery-ui-layout
 */
;(function ($) {

  if (!$.layout) return;


  /**
   *	UI COOKIE UTILITY
   *
   *	A $.cookie OR $.ui.cookie namespace *should be standard*, but until then...
   *	This creates $.ui.cookie so Layout does not need the cookie.jquery.js plugin
   *	NOTE: This utility is REQUIRED by the layout.state plugin
   *
   *	Cookie methods in Layout are created as part of State Management
   */
  if (!$.ui) $.ui = {};
  $.ui.cookie = {

    // cookieEnabled is not in DOM specs, but DOES works in all browsers,including IE6
    acceptsCookies: !!navigator.cookieEnabled

    ,	read: function (name) {
      var
        c	= document.cookie
        ,	cs	= c ? c.split(';') : []
        ,	pair, data, i
      ;
      for (i=0; pair=cs[i]; i++) {
        data = $.trim(pair).split('='); // name=value => [ name, value ]
        if (data[0] == name) // found the layout cookie
          return decodeURIComponent(data[1]);
      }
      return null;
    }

    ,	write: function (name, val, cookieOpts) {
      var	params	= ""
        ,	date	= ""
        ,	clear	= false
        ,	o		= cookieOpts || {}
        ,	x		= o.expires  || null
        ,	t		= $.type(x)
      ;
      if (t === "date")
        date = x;
      else if (t === "string" && x > 0) {
        x = parseInt(x,10);
        t = "number";
      }
      if (t === "number") {
        date = new Date();
        if (x > 0)
          date.setDate(date.getDate() + x);
        else {
          date.setFullYear(1970);
          clear = true;
        }
      }
      if (date)		params += ";expires="+ date.toUTCString();
      if (o.path)		params += ";path="+ o.path;
      if (o.domain)	params += ";domain="+ o.domain;
      if (o.secure)	params += ";secure";
      document.cookie = name +"="+ (clear ? "" : encodeURIComponent( val )) + params; // write or clear cookie
    }

    ,	clear: function (name) {
      $.ui.cookie.write(name, "", {expires: -1});
    }

  };
// if cookie.jquery.js is not loaded, create an alias to replicate it
// this may be useful to other plugins or code dependent on that plugin
  if (!$.cookie) $.cookie = function (k, v, o) {
    var C = $.ui.cookie;
    if (v === null)
      C.clear(k);
    else if (v === undefined)
      return C.read(k);
    else
      C.write(k, v, o);
  };



  /**
   *	State-management options stored in options.stateManagement, which includes a .cookie hash
   *	Default options saves ALL KEYS for ALL PANES, ie: pane.size, pane.isClosed, pane.isHidden
   *
   *	// STATE/COOKIE OPTIONS
   *	@example $(el).layout({
				stateManagement: {
					enabled:	true
				,	stateKeys:	"east.size,west.size,east.isClosed,west.isClosed"
				,	cookie:		{ name: "appLayout", path: "/" }
				}
			})
   *	@example $(el).layout({ stateManagement__enabled: true }) // enable auto-state-management using cookies
   *	@example $(el).layout({ stateManagement__cookie: { name: "appLayout", path: "/" } })
   *	@example $(el).layout({ stateManagement__cookie__name: "appLayout", stateManagement__cookie__path: "/" })
   *
   *	// STATE/COOKIE METHODS
   *	@example myLayout.saveCookie( "west.isClosed,north.size,south.isHidden", {expires: 7} );
   *	@example myLayout.loadCookie();
   *	@example myLayout.deleteCookie();
   *	@example var JSON = myLayout.readState();	// CURRENT Layout State
   *	@example var JSON = myLayout.readCookie();	// SAVED Layout State (from cookie)
   *	@example var JSON = myLayout.state.stateData;	// LAST LOADED Layout State (cookie saved in layout.state hash)
   *
   *	CUSTOM STATE-MANAGEMENT (eg, saved in a database)
   *	@example var JSON = myLayout.readState( "west.isClosed,north.size,south.isHidden" );
   *	@example myLayout.loadState( JSON );
   */

// tell Layout that the state plugin is available
  $.layout.plugins.stateManagement = true;

//	Add State-Management options to layout.defaults
  $.layout.defaults.stateManagement = {
    enabled:		false	// true = enable state-management, even if not using cookies
    ,	autoSave:		true	// Save a state-cookie when page exits?
    ,	autoLoad:		true	// Load the state-cookie when Layout inits?
    ,	animateLoad:	true	// animate panes when loading state into an active layout
    ,	includeChildren: true	// recurse into child layouts to include their state as well
    // List state-data to save - must be pane-specific
    ,	stateKeys:	"north.size,south.size,east.size,west.size,"+
    "north.isClosed,south.isClosed,east.isClosed,west.isClosed,"+
    "north.isHidden,south.isHidden,east.isHidden,west.isHidden"
    ,	cookie: {
      name:	""	// If not specified, will use Layout.name, else just "Layout"
      ,	domain:	""	// blank = current domain
      ,	path:	""	// blank = current page, "/" = entire website
      ,	expires: ""	// 'days' to keep cookie - leave blank for 'session cookie'
      ,	secure:	false
    }
  };

// Set stateManagement as a 'layout-option', NOT a 'pane-option'
  $.layout.optionsMap.layout.push("stateManagement");
// Update config so layout does not move options into the pane-default branch (panes)
  $.layout.config.optionRootKeys.push("stateManagement");

  /*
   *	State Management methods
   */
  $.layout.state = {

    /**
     * Get the current layout state and save it to a cookie
     *
     * myLayout.saveCookie( keys, cookieOpts )
     *
     * @param {Object}			inst
     * @param {(string|Array)=}	keys
     * @param {Object=}			cookieOpts
     */
    saveCookie: function (inst, keys, cookieOpts) {
      var o	= inst.options
        ,	sm	= o.stateManagement
        ,	oC	= $.extend(true, {}, sm.cookie, cookieOpts || null)
        ,	data = inst.state.stateData = inst.readState( keys || sm.stateKeys ) // read current panes-state
      ;
      $.ui.cookie.write( oC.name || o.name || "Layout", $.layout.state.encodeJSON(data), oC );
      return $.extend(true, {}, data); // return COPY of state.stateData data
    }

    /**
     * Remove the state cookie
     *
     * @param {Object}	inst
     */
    ,	deleteCookie: function (inst) {
      var o = inst.options;
      $.ui.cookie.clear( o.stateManagement.cookie.name || o.name || "Layout" );
    }

    /**
     * Read & return data from the cookie - as JSON
     *
     * @param {Object}	inst
     */
    ,	readCookie: function (inst) {
      var o = inst.options;
      var c = $.ui.cookie.read( o.stateManagement.cookie.name || o.name || "Layout" );
      // convert cookie string back to a hash and return it
      return c ? $.layout.state.decodeJSON(c) : {};
    }

    /**
     * Get data from the cookie and USE IT to loadState
     *
     * @param {Object}	inst
     */
    ,	loadCookie: function (inst) {
      var c = $.layout.state.readCookie(inst); // READ the cookie
      if (c && !$.isEmptyObject( c )) {
        inst.state.stateData = $.extend(true, {}, c); // SET state.stateData
        inst.loadState(c); // LOAD the retrieved state
      }
      return c;
    }

    /**
     * Update layout options from the cookie, if one exists
     *
     * @param {Object}		inst
     * @param {Object=}		stateData
     * @param {boolean=}	animate
     */
    ,	loadState: function (inst, data, opts) {
      if (!$.isPlainObject( data ) || $.isEmptyObject( data )) return;

      // normalize data & cache in the state object
      data = inst.state.stateData = $.layout.transformData( data ); // panes = default subkey

      // add missing/default state-restore options
      var smo = inst.options.stateManagement;
      opts = $.extend({
        animateLoad:		false //smo.animateLoad
        ,	includeChildren:	smo.includeChildren
      }, opts );

      if (!inst.state.initialized) {
        /*
         *	layout NOT initialized, so just update its options
         */
        // MUST remove pane.children keys before applying to options
        // use a copy so we don't remove keys from original data
        var o = $.extend(true, {}, data);
        //delete o.center; // center has no state-data - only children
        $.each($.layout.config.allPanes, function (idx, pane) {
          if (o[pane]) delete o[pane].children;
        });
        // update CURRENT layout-options with saved state data
        $.extend(true, inst.options, o);
      }
      else {
        /*
         *	layout already initialized, so modify layout's configuration
         */
        var noAnimate = !opts.animateLoad
          ,	o, c, h, state, open
        ;
        $.each($.layout.config.borderPanes, function (idx, pane) {
          o = data[ pane ];
          if (!$.isPlainObject( o )) return; // no key, skip pane

          s	= o.size;
          c	= o.initClosed;
          h	= o.initHidden;
          ar	= o.autoResize
          state	= inst.state[pane];
          open	= state.isVisible;

          // reset autoResize
          if (ar)
            state.autoResize = ar;
          // resize BEFORE opening
          if (!open)
            inst._sizePane(pane, s, false, false, false); // false=skipCallback/noAnimation/forceResize
          // open/close as necessary - DO NOT CHANGE THIS ORDER!
          if (h === true)			inst.hide(pane, noAnimate);
          else if (c === true)	inst.close(pane, false, noAnimate);
          else if (c === false)	inst.open (pane, false, noAnimate);
          else if (h === false)	inst.show (pane, false, noAnimate);
          // resize AFTER any other actions
          if (open)
            inst._sizePane(pane, s, false, false, noAnimate); // animate resize if option passed
        });

        /*
         *	RECURSE INTO CHILD-LAYOUTS
         */
        if (opts.includeChildren) {
          var paneStateChildren, childState;
          $.each(inst.children, function (pane, paneChildren) {
            paneStateChildren = data[pane] ? data[pane].children : 0;
            if (paneStateChildren && paneChildren) {
              $.each(paneChildren, function (stateKey, child) {
                childState = paneStateChildren[stateKey];
                if (child && childState)
                  child.loadState( childState );
              });
            }
          });
        }
      }
    }

    /**
     * Get the *current layout state* and return it as a hash
     *
     * @param {Object=}		inst	// Layout instance to get state for
     * @param {object=}		[opts]	// State-Managements override options
     */
    ,	readState: function (inst, opts) {
      // backward compatility
      if ($.type(opts) === 'string') opts = { keys: opts };
      if (!opts) opts = {};
      var	sm		= inst.options.stateManagement
        ,	ic		= opts.includeChildren
        ,	recurse	= ic !== undefined ? ic : sm.includeChildren
        ,	keys	= opts.stateKeys || sm.stateKeys
        ,	alt		= { isClosed: 'initClosed', isHidden: 'initHidden' }
        ,	state	= inst.state
        ,	panes	= $.layout.config.allPanes
        ,	data	= {}
        ,	pair, pane, key, val
        ,	ps, pC, child, array, count, branch
      ;
      if ($.isArray(keys)) keys = keys.join(",");
      // convert keys to an array and change delimiters from '__' to '.'
      keys = keys.replace(/__/g, ".").split(',');
      // loop keys and create a data hash
      for (var i=0, n=keys.length; i < n; i++) {
        pair = keys[i].split(".");
        pane = pair[0];
        key  = pair[1];
        if ($.inArray(pane, panes) < 0) continue; // bad pane!
        val = state[ pane ][ key ];
        if (val == undefined) continue;
        if (key=="isClosed" && state[pane]["isSliding"])
          val = true; // if sliding, then *really* isClosed
        ( data[pane] || (data[pane]={}) )[ alt[key] ? alt[key] : key ] = val;
      }

      // recurse into the child-layouts for each pane
      if (recurse) {
        $.each(panes, function (idx, pane) {
          pC = inst.children[pane];
          ps = state.stateData[pane];
          if ($.isPlainObject( pC ) && !$.isEmptyObject( pC )) {
            // ensure a key exists for this 'pane', eg: branch = data.center
            branch = data[pane] || (data[pane] = {});
            if (!branch.children) branch.children = {};
            $.each( pC, function (key, child) {
              // ONLY read state from an initialize layout
              if ( child.state.initialized )
                branch.children[ key ] = $.layout.state.readState( child );
              // if we have PREVIOUS (onLoad) state for this child-layout, KEEP IT!
              else if ( ps && ps.children && ps.children[ key ] ) {
                branch.children[ key ] = $.extend(true, {}, ps.children[ key ] );
              }
            });
          }
        });
      }

      return data;
    }

    /**
     *	Stringify a JSON hash so can save in a cookie or db-field
     */
    ,	encodeJSON: function (json) {
      var local = window.JSON || {};
      return (local.stringify || stringify)(json);

      function stringify (h) {
        var D=[], i=0, k, v, t // k = key, v = value
          ,	a = $.isArray(h)
        ;
        for (k in h) {
          v = h[k];
          t = typeof v;
          if (t == 'string')		// STRING - add quotes
            v = '"'+ v +'"';
          else if (t == 'object')	// SUB-KEY - recurse into it
            v = parse(v);
          D[i++] = (!a ? '"'+ k +'":' : '') + v;
        }
        return (a ? '[' : '{') + D.join(',') + (a ? ']' : '}');
      };
    }

    /**
     *	Convert stringified JSON back to a hash object
     *	@see		$.parseJSON(), adding in jQuery 1.4.1
     */
    ,	decodeJSON: function (str) {
      try { return $.parseJSON ? $.parseJSON(str) : window["eval"]("("+ str +")") || {}; }
      catch (e) { return {}; }
    }


    ,	_create: function (inst) {
      var s	= $.layout.state
        ,	o	= inst.options
        ,	sm	= o.stateManagement
      ;
      //	ADD State-Management plugin methods to inst
      $.extend( inst, {
        //	readCookie - update options from cookie - returns hash of cookie data
        readCookie:		function () { return s.readCookie(inst); }
        //	deleteCookie
        ,	deleteCookie:	function () { s.deleteCookie(inst); }
        //	saveCookie - optionally pass keys-list and cookie-options (hash)
        ,	saveCookie:		function (keys, cookieOpts) { return s.saveCookie(inst, keys, cookieOpts); }
        //	loadCookie - readCookie and use to loadState() - returns hash of cookie data
        ,	loadCookie:		function () { return s.loadCookie(inst); }
        //	loadState - pass a hash of state to use to update options
        ,	loadState:		function (stateData, opts) { s.loadState(inst, stateData, opts); }
        //	readState - returns hash of current layout-state
        ,	readState:		function (keys) { return s.readState(inst, keys); }
        //	add JSON utility methods too...
        ,	encodeJSON:		s.encodeJSON
        ,	decodeJSON:		s.decodeJSON
      });

      // init state.stateData key, even if plugin is initially disabled
      inst.state.stateData = {};

      // autoLoad MUST BE one of: data-array, data-hash, callback-function, or TRUE
      if ( !sm.autoLoad ) return;

      //	When state-data exists in the autoLoad key USE IT,
      //	even if stateManagement.enabled == false
      if ($.isPlainObject( sm.autoLoad )) {
        if (!$.isEmptyObject( sm.autoLoad )) {
          inst.loadState( sm.autoLoad );
        }
      }
      else if ( sm.enabled ) {
        // update the options from cookie or callback
        // if options is a function, call it to get stateData
        if ($.isFunction( sm.autoLoad )) {
          var d = {};
          try {
            d = sm.autoLoad( inst, inst.state, inst.options, inst.options.name || '' ); // try to get data from fn
          } catch (e) {}
          if (d && $.isPlainObject( d ) && !$.isEmptyObject( d ))
            inst.loadState(d);
        }
        else // any other truthy value will trigger loadCookie
          inst.loadCookie();
      }
    }

    ,	_unload: function (inst) {
      var sm = inst.options.stateManagement;
      if (sm.enabled && sm.autoSave) {
        // if options is a function, call it to save the stateData
        if ($.isFunction( sm.autoSave )) {
          try {
            sm.autoSave( inst, inst.state, inst.options, inst.options.name || '' ); // try to get data from fn
          } catch (e) {}
        }
        else // any truthy value will trigger saveCookie
          inst.saveCookie();
      }
    }

  };

// add state initialization method to Layout's onCreate array of functions
  $.layout.onCreate.push( $.layout.state._create );
  $.layout.onUnload.push( $.layout.state._unload );

})( jQuery );



/**
 * @preserve jquery.layout.buttons 1.0
 * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
 *
 * Copyright (c) 2011
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @dependancies: UI Layout 1.3.0.rc30.1 or higher
 *
 * @support: http://groups.google.com/group/jquery-ui-layout
 *
 * Docs: [ to come ]
 * Tips: [ to come ]
 */
;(function ($) {

  if (!$.layout) return;


// tell Layout that the state plugin is available
  $.layout.plugins.buttons = true;

//	Add State-Management options to layout.defaults
  $.layout.defaults.autoBindCustomButtons = false;
// Set stateManagement as a layout-option, NOT a pane-option
  $.layout.optionsMap.layout.push("autoBindCustomButtons");

  /*
   *	Button methods
   */
  $.layout.buttons = {
    // set data used by multiple methods below
    config: {
      borderPanes:	"north,south,west,east"
    }

    /**
     * Searches for .ui-layout-button-xxx elements and auto-binds them as layout-buttons
     *
     * @see  _create()
     */
    ,	init: function (inst) {
      var pre		= "ui-layout-button-"
        ,	layout	= inst.options.name || ""
        ,	name;
      $.each("toggle,open,close,pin,toggle-slide,open-slide".split(","), function (i, action) {
        $.each($.layout.buttons.config.borderPanes.split(","), function (ii, pane) {
          $("."+pre+action+"-"+pane).each(function(){
            // if button was previously 'bound', data.layoutName was set, but is blank if layout has no 'name'
            name = $(this).data("layoutName") || $(this).attr("layoutName");
            if (name == undefined || name === layout)
              inst.bindButton(this, action, pane);
          });
        });
      });
    }

    /**
     * Helper function to validate params received by addButton utilities
     *
     * Two classes are added to the element, based on the buttonClass...
     * The type of button is appended to create the 2nd className:
     *  - ui-layout-button-pin
     *  - ui-layout-pane-button-toggle
     *  - ui-layout-pane-button-open
     *  - ui-layout-pane-button-close
     *
     * @param  {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
     * @param  {string}   			pane 		Name of the pane the button is for: 'north', 'south', etc.
     * @return {Array.<Object>}		If both params valid, the element matching 'selector' in a jQuery wrapper - otherwise returns null
     */
    ,	get: function (inst, selector, pane, action) {
      var $E	= $(selector)
        ,	o	= inst.options
        //,	err	= o.showErrorMessages
      ;
      if ($E.length && $.layout.buttons.config.borderPanes.indexOf(pane) >= 0) {
        var btn = o[pane].buttonClass +"-"+ action;
        $E	.addClass( btn +" "+ btn +"-"+ pane )
          .data("layoutName", o.name); // add layout identifier - even if blank!
      }
      return $E;
    }


    /**
     * NEW syntax for binding layout-buttons - will eventually replace addToggle, addOpen, etc.
     *
     * @param {(string|!Object)}	sel		jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
     * @param {string}			action
     * @param {string}			pane
     */
    ,	bind: function (inst, sel, action, pane) {
      var _ = $.layout.buttons;
      switch (action.toLowerCase()) {
        case "toggle":			_.addToggle	(inst, sel, pane); break;
        case "open":			_.addOpen	(inst, sel, pane); break;
        case "close":			_.addClose	(inst, sel, pane); break;
        case "pin":				_.addPin	(inst, sel, pane); break;
        case "toggle-slide":	_.addToggle	(inst, sel, pane, true); break;
        case "open-slide":		_.addOpen	(inst, sel, pane, true); break;
      }
      return inst;
    }

    /**
     * Add a custom Toggler button for a pane
     *
     * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
     * @param {string}  			pane 		Name of the pane the button is for: 'north', 'south', etc.
     * @param {boolean=}			slide 		true = slide-open, false = pin-open
     */
    ,	addToggle: function (inst, selector, pane, slide) {
      $.layout.buttons.get(inst, selector, pane, "toggle")
        .click(function(evt){
          inst.toggle(pane, !!slide);
          evt.stopPropagation();
        });
      return inst;
    }

    /**
     * Add a custom Open button for a pane
     *
     * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
     * @param {string}			pane 		Name of the pane the button is for: 'north', 'south', etc.
     * @param {boolean=}			slide 		true = slide-open, false = pin-open
     */
    ,	addOpen: function (inst, selector, pane, slide) {
      $.layout.buttons.get(inst, selector, pane, "open")
        .attr("title", inst.options[pane].tips.Open)
        .click(function (evt) {
          inst.open(pane, !!slide);
          evt.stopPropagation();
        });
      return inst;
    }

    /**
     * Add a custom Close button for a pane
     *
     * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
     * @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
     */
    ,	addClose: function (inst, selector, pane) {
      $.layout.buttons.get(inst, selector, pane, "close")
        .attr("title", inst.options[pane].tips.Close)
        .click(function (evt) {
          inst.close(pane);
          evt.stopPropagation();
        });
      return inst;
    }

    /**
     * Add a custom Pin button for a pane
     *
     * Four classes are added to the element, based on the paneClass for the associated pane...
     * Assuming the default paneClass and the pin is 'up', these classes are added for a west-pane pin:
     *  - ui-layout-pane-pin
     *  - ui-layout-pane-west-pin
     *  - ui-layout-pane-pin-up
     *  - ui-layout-pane-west-pin-up
     *
     * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
     * @param {string}   		pane 		Name of the pane the pin is for: 'north', 'south', etc.
     */
    ,	addPin: function (inst, selector, pane) {
      var $E = $.layout.buttons.get(inst, selector, pane, "pin");
      if ($E.length) {
        var s = inst.state[pane];
        $E.click(function (evt) {
          $.layout.buttons.setPinState(inst, $(this), pane, (s.isSliding || s.isClosed));
          if (s.isSliding || s.isClosed) inst.open( pane ); // change from sliding to open
          else inst.close( pane ); // slide-closed
          evt.stopPropagation();
        });
        // add up/down pin attributes and classes
        $.layout.buttons.setPinState(inst, $E, pane, (!s.isClosed && !s.isSliding));
        // add this pin to the pane data so we can 'sync it' automatically
        // PANE.pins key is an array so we can store multiple pins for each pane
        s.pins.push( selector ); // just save the selector string
      }
      return inst;
    }

    /**
     * Change the class of the pin button to make it look 'up' or 'down'
     *
     * @see  addPin(), syncPins()
     * @param {Array.<Object>}	$Pin	The pin-span element in a jQuery wrapper
     * @param {string}	pane	These are the params returned to callbacks by layout()
     * @param {boolean}	doPin	true = set the pin 'down', false = set it 'up'
     */
    ,	setPinState: function (inst, $Pin, pane, doPin) {
      var updown = $Pin.attr("pin");
      if (updown && doPin === (updown=="down")) return; // already in correct state
      var
        po		= inst.options[pane]
        ,	lang	= po.tips
        ,	pin		= po.buttonClass +"-pin"
        ,	side	= pin +"-"+ pane
        ,	UP		= pin +"-up "+	side +"-up"
        ,	DN		= pin +"-down "+side +"-down"
      ;
      $Pin
        .attr("pin", doPin ? "down" : "up") // logic
        .attr("title", doPin ? lang.Unpin : lang.Pin)
        .removeClass( doPin ? UP : DN )
        .addClass( doPin ? DN : UP )
      ;
    }

    /**
     * INTERNAL function to sync 'pin buttons' when pane is opened or closed
     * Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
     *
     * @see  open(), close()
     * @param {string}	pane   These are the params returned to callbacks by layout()
     * @param {boolean}	doPin  True means set the pin 'down', False means 'up'
     */
    ,	syncPinBtns: function (inst, pane, doPin) {
      // REAL METHOD IS _INSIDE_ LAYOUT - THIS IS HERE JUST FOR REFERENCE
      $.each(state[pane].pins, function (i, selector) {
        $.layout.buttons.setPinState(inst, $(selector), pane, doPin);
      });
    }


    ,	_load: function (inst) {
      //	ADD Button methods to Layout Instance
      $.extend( inst, {
        bindButton:		function (selector, action, pane) { return $.layout.buttons.bind(inst, selector, action, pane); }
        //	DEPRECATED METHODS...
        ,	addToggleBtn:	function (selector, pane, slide) { return $.layout.buttons.addToggle(inst, selector, pane, slide); }
        ,	addOpenBtn:		function (selector, pane, slide) { return $.layout.buttons.addOpen(inst, selector, pane, slide); }
        ,	addCloseBtn:	function (selector, pane) { return $.layout.buttons.addClose(inst, selector, pane); }
        ,	addPinBtn:		function (selector, pane) { return $.layout.buttons.addPin(inst, selector, pane); }
      });

      // init state array to hold pin-buttons
      for (var i=0; i<4; i++) {
        var pane = $.layout.buttons.config.borderPanes[i];
        inst.state[pane].pins = [];
      }

      // auto-init buttons onLoad if option is enabled
      if ( inst.options.autoBindCustomButtons )
        $.layout.buttons.init(inst);
    }

    ,	_unload: function (inst) {
      // TODO: unbind all buttons???
    }

  };

// add initialization method to Layout's onLoad array of functions
  $.layout.onLoad.push(  $.layout.buttons._load );
//$.layout.onUnload.push( $.layout.buttons._unload );

})( jQuery );




/**
 * jquery.layout.browserZoom 1.0
 * $Date: 2011-12-29 08:00:00 (Thu, 29 Dec 2011) $
 *
 * Copyright (c) 2012
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @requires: UI Layout 1.3.0.rc30.1 or higher
 *
 * @see: http://groups.google.com/group/jquery-ui-layout
 *
 * TODO: Extend logic to handle other problematic zooming in browsers
 * TODO: Add hotkey/mousewheel bindings to _instantly_ respond to these zoom event
 */
(function ($) {

// tell Layout that the plugin is available
  $.layout.plugins.browserZoom = true;

  $.layout.defaults.browserZoomCheckInterval = 1000;
  $.layout.optionsMap.layout.push("browserZoomCheckInterval");

  /*
   *	browserZoom methods
   */
  $.layout.browserZoom = {

    _init: function (inst) {
      // abort if browser does not need this check
      if ($.layout.browserZoom.ratio() !== false)
        $.layout.browserZoom._setTimer(inst);
    }

    ,	_setTimer: function (inst) {
      // abort if layout destroyed or browser does not need this check
      if (inst.destroyed) return;
      var o	= inst.options
        ,	s	= inst.state
        //	don't need check if inst has parentLayout, but check occassionally in case parent destroyed!
        //	MINIMUM 100ms interval, for performance
        ,	ms	= inst.hasParentLayout ?  5000 : Math.max( o.browserZoomCheckInterval, 100 )
      ;
      // set the timer
      setTimeout(function(){
          if (inst.destroyed || !o.resizeWithWindow) return;
          var d = $.layout.browserZoom.ratio();
          if (d !== s.browserZoom) {
            s.browserZoom = d;
            inst.resizeAll();
          }
          // set a NEW timeout
          $.layout.browserZoom._setTimer(inst);
        }
        ,	ms );
    }

    ,	ratio: function () {
      var w	= window
        ,	s	= screen
        ,	d	= document
        ,	dE	= d.documentElement || d.body
        ,	b	= $.layout.browser
        ,	v	= b.version
        ,	r, sW, cW
      ;
      // we can ignore all browsers that fire window.resize event onZoom
      if (!b.msie || v > 8)
        return false; // don't need to track zoom
      if (s.deviceXDPI && s.systemXDPI) // syntax compiler hack
        return calc(s.deviceXDPI, s.systemXDPI);
      // everything below is just for future reference!
      if (b.webkit && (r = d.body.getBoundingClientRect))
        return calc((r.left - r.right), d.body.offsetWidth);
      if (b.webkit && (sW = w.outerWidth))
        return calc(sW, w.innerWidth);
      if ((sW = s.width) && (cW = dE.clientWidth))
        return calc(sW, cW);
      return false; // no match, so cannot - or don't need to - track zoom

      function calc (x,y) { return (parseInt(x,10) / parseInt(y,10) * 100).toFixed(); }
    }

  };
// add initialization method to Layout's onLoad array of functions
  $.layout.onReady.push( $.layout.browserZoom._init );


})( jQuery );




/**
 *	UI Layout Plugin: Slide-Offscreen Animation
 *
 *	Prevent panes from being 'hidden' so that an iframes/objects
 *	does not reload/refresh when pane 'opens' again.
 *	This plug-in adds a new animation called "slideOffscreen".
 *	It is identical to the normal "slide" effect, but avoids hiding the element
 *
 *	Requires Layout 1.3.0.RC30.1 or later for Close offscreen
 *	Requires Layout 1.3.0.RC30.5 or later for Hide, initClosed & initHidden offscreen
 *
 *	Version:	1.1 - 2012-11-18
 *	Author:		Kevin Dalman (kevin@jquery-dev.com)
 *	@preserve	jquery.layout.slideOffscreen-1.1.js
 */
;(function ($) {

// Add a new "slideOffscreen" effect
  if ($.effects) {

    // add an option so initClosed and initHidden will work
    $.layout.defaults.panes.useOffscreenClose = false; // user must enable when needed
    /* set the new animation as the default for all panes
     $.layout.defaults.panes.fxName = "slideOffscreen";
     */

    if ($.layout.plugins)
      $.layout.plugins.effects.slideOffscreen = true;

    // dupe 'slide' effect defaults as new effect defaults
    $.layout.effects.slideOffscreen = $.extend(true, {}, $.layout.effects.slide);

    // add new effect to jQuery UI
    $.effects.slideOffscreen = function(o) {
      return this.queue(function(){

        var fx		= $.effects
          ,	opt		= o.options
          ,	$el		= $(this)
          ,	pane	= $el.data('layoutEdge')
          ,	state	= $el.data('parentLayout').state
          ,	dist	= state[pane].size
          ,	s		= this.style
          ,	props	= ['top','bottom','left','right']
          // Set options
          ,	mode	= fx.setMode($el, opt.mode || 'show') // Set Mode
          ,	show	= (mode == 'show')
          ,	dir		= opt.direction || 'left' // Default Direction
          ,	ref	 	= (dir == 'up' || dir == 'down') ? 'top' : 'left'
          ,	pos		= (dir == 'up' || dir == 'left')
          ,	offscrn	= $.layout.config.offscreenCSS || {}
          ,	keyLR	= $.layout.config.offscreenReset
          ,	keyTB	= 'offscreenResetTop' // only used internally
          ,	animation = {}
        ;
        // Animation settings
        animation[ref]	= (show ? (pos ? '+=' : '-=') : (pos ? '-=' : '+=')) + dist;

        if (show) { // show() animation, so save top/bottom but retain left/right set when 'hidden'
          $el.data(keyTB, { top: s.top, bottom: s.bottom });

          // set the top or left offset in preparation for animation
          // Note: ALL animations work by shifting the top or left edges
          if (pos) { // top (north) or left (west)
            $el.css(ref, isNaN(dist) ? "-" + dist : -dist); // Shift outside the left/top edge
          }
          else { // bottom (south) or right (east) - shift all the way across container
            if (dir === 'right')
              $el.css({ left: state.container.layoutWidth, right: 'auto' });
            else // dir === bottom
              $el.css({ top: state.container.layoutHeight, bottom: 'auto' });
          }
          // restore the left/right setting if is a top/bottom animation
          if (ref === 'top')
            $el.css( $el.data( keyLR ) || {} );
        }
        else { // hide() animation, so save ALL CSS
          $el.data(keyTB, { top: s.top, bottom: s.bottom });
          $el.data(keyLR, { left: s.left, right: s.right });
        }

        // Animate
        $el.show().animate(animation, { queue: false, duration: o.duration, easing: opt.easing, complete: function(){
          // Restore top/bottom
          if ($el.data( keyTB ))
            $el.css($el.data( keyTB )).removeData( keyTB );
          if (show) // Restore left/right too
            $el.css($el.data( keyLR ) || {}).removeData( keyLR );
          else // Move the pane off-screen (left: -99999, right: 'auto')
            $el.css( offscrn );

          if (o.callback) o.callback.apply(this, arguments); // Callback
          $el.dequeue();
        }});

      });
    };

  }

})( jQuery );
},{}],8:[function(require,module,exports){
/**
 * pubsub.js
 *
 * A tiny, optimized, tested, standalone and robust
 * pubsub implementation supporting different javascript environments
 *
 * @author Federico "Lox" Lucignano <http://plus.ly/federico.lox>
 *
 * @see https://github.com/federico-lox/pubsub.js
 */

/*global define, module*/
(function (context) {

  /**
   * @private
   */
  function init() {
    //the channel subscription hash
    var channels = {},
    //help minification
      funcType = Function;

    return {
      /*
       * @public
       *
       * Publish some data on a channel
       *
       * @param String channel The channel to publish on
       * @param Mixed argument The data to publish, the function supports
       * as many data parameters as needed
       *
       * @example Publish stuff on '/some/channel'.
       * Anything subscribed will be called with a function
       * signature like: function(a,b,c){ ... }
       *
       * PubSub.publish(
       *		"/some/channel", "a", "b",
       *		{total: 10, min: 1, max: 3}
       * );
       */
      publish: function () {
        //help minification
        var args = arguments,
        // args[0] is the channel
          subs = channels[args[0]],
          len,
          params,
          x;

        if (subs) {
          len = subs.length;
          params = (args.length > 1) ?
            Array.prototype.splice.call(args, 1) : [];

          //run the callbacks asynchronously,
          //do not block the main execution process
          setTimeout(
            function () {
              //executes callbacks in the order
              //in which they were registered
              for (x = 0; x < len; x += 1) {
                subs[x].apply(context, params);
              }

              //clear references to allow garbage collection
              subs = context = params = null;
            },
            0
          );
        }
      },

      /*
       * @public
       *
       * Register a callback on a channel
       *
       * @param String channel The channel to subscribe to
       * @param Function callback The event handler, any time something is
       * published on a subscribed channel, the callback will be called
       * with the published array as ordered arguments
       *
       * @return Array A handle which can be used to unsubscribe this
       * particular subscription
       *
       * @example PubSub.subscribe(
       *				"/some/channel",
       *				function(a, b, c){ ... }
       *			);
       */
      subscribe: function (channel, callback) {
        if (typeof channel !== 'string') {
          throw "invalid or missing channel";
        }

        if (!(callback instanceof funcType)) {
          throw "invalid or missing callback";
        }

        if (!channels[channel]) {
          channels[channel] = [];
        }

        channels[channel].push(callback);

        return {channel: channel, callback: callback};
      },

      /*
       * @public
       *
       * Disconnect a subscribed function f.
       *
       * @param Mixed handle The return value from a subscribe call or the
       * name of a channel as a String
       * @param Function callback [OPTIONAL] The event handler originaally
       * registered, not needed if handle contains the return value
       * of subscribe
       *
       * @example
       * var handle = PubSub.subscribe("/some/channel", function(){});
       * PubSub.unsubscribe(handle);
       *
       * or
       *
       * PubSub.unsubscribe("/some/channel", callback);
       */
      unsubscribe: function (handle, callback) {
        if (handle.channel && handle.callback) {
          callback = handle.callback;
          handle = handle.channel;
        }

        if (typeof handle !== 'string') {
          throw "invalid or missing channel";
        }

        if (!(callback instanceof funcType)) {
          throw "invalid or missing callback";
        }

        var subs = channels[handle],
          x,
          y = (subs instanceof Array) ? subs.length : 0;

        for (x = 0; x < y; x += 1) {
          if (subs[x] === callback) {
            subs.splice(x, 1);
            break;
          }
        }
      }
    };
  }

  //UMD
  if (typeof define === 'function' && define.amd) {
    //AMD module
    define('pubsub', init);
  } else if (typeof module === 'object' && module.exports) {
    //CommonJS module
    module.exports = init();
  } else {
    //traditional namespace
    context.PubSub = init();
  }
}(this));
},{}],9:[function(require,module,exports){
// Spectrum Colorpicker v1.8.0
// https://github.com/bgrins/spectrum
// Author: Brian Grinstead
// License: MIT

!function($, undefined) {

  var defaultOpts = {

      // Callbacks
      beforeShow: noop,
      move: noop,
      change: noop,
      show: noop,
      hide: noop,

      // Options
      color: false,
      flat: false,
      showInput: false,
      allowEmpty: false,
      showButtons: true,
      clickoutFiresChange: true,
      showInitial: false,
      showPalette: false,
      showPaletteOnly: false,
      hideAfterPaletteSelect: false,
      togglePaletteOnly: false,
      showSelectionPalette: true,
      localStorageKey: false,
      appendTo: "body",
      maxSelectionSize: 7,
      cancelText: "cancel",
      chooseText: "choose",
      togglePaletteMoreText: "more",
      togglePaletteLessText: "less",
      clearText: "Clear Color Selection",
      noColorSelectedText: "No Color Selected",
      preferredFormat: false,
      className: "", // Deprecated - use containerClassName and replacerClassName instead.
      containerClassName: "",
      replacerClassName: "",
      showAlpha: false,
      theme: "sp-light",
      palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]],
      selectionPalette: [],
      disabled: false,
      offset: null
    },
    spectrums = [],
    IE = !!/msie/i.exec( window.navigator.userAgent ),
    rgbaSupport = (function() {
      function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
      }

      var elem = document.createElement('div');
      var style = elem.style;
      style.cssText = 'background-color:rgba(0,0,0,.5)';
      return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
    })(),
    replaceInput = [
      "<div class='sp-replacer'>",
      "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
      "<div class='sp-dd'>&#9660;</div>",
      "</div>"
    ].join(''),
    markup = (function () {

      // IE does not support gradients with multiple stops, so we need to simulate
      //  that for the rainbow slider with 8 divs that each have a single gradient
      var gradientFix = "";
      if (IE) {
        for (var i = 1; i <= 6; i++) {
          gradientFix += "<div class='sp-" + i + "'></div>";
        }
      }

      return [
        "<div class='sp-container sp-hidden'>",
        "<div class='sp-palette-container'>",
        "<div class='sp-palette sp-thumb sp-cf'></div>",
        "<div class='sp-palette-button-container sp-cf'>",
        "<button type='button' class='sp-palette-toggle'></button>",
        "</div>",
        "</div>",
        "<div class='sp-picker-container'>",
        "<div class='sp-top sp-cf'>",
        "<div class='sp-fill'></div>",
        "<div class='sp-top-inner'>",
        "<div class='sp-color'>",
        "<div class='sp-sat'>",
        "<div class='sp-val'>",
        "<div class='sp-dragger'></div>",
        "</div>",
        "</div>",
        "</div>",
        "<div class='sp-clear sp-clear-display'>",
        "</div>",
        "<div class='sp-hue'>",
        "<div class='sp-slider'></div>",
        gradientFix,
        "</div>",
        "</div>",
        "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
        "</div>",
        "<div class='sp-input-container sp-cf'>",
        "<input class='sp-input' type='text' spellcheck='false'  />",
        "</div>",
        "<div class='sp-initial sp-thumb sp-cf'></div>",
        "<div class='sp-button-container sp-cf'>",
        "<a class='sp-cancel' href='#'></a>",
        "<button type='button' class='sp-choose'></button>",
        "</div>",
        "</div>",
        "</div>"
      ].join("");
    })();

  function paletteTemplate (p, color, className, opts) {
    var html = [];
    for (var i = 0; i < p.length; i++) {
      var current = p[i];
      if(current) {
        var tiny = tinycolor(current);
        var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
        c += (tinycolor.equals(color, current)) ? " sp-thumb-active" : "";
        var formattedString = tiny.toString(opts.preferredFormat || "rgb");
        var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
        html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
      } else {
        var cls = 'sp-clear-display';
        html.push($('<div />')
          .append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>')
            .attr('title', opts.noColorSelectedText)
          )
          .html()
        );
      }
    }
    return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
  }

  function hideAll() {
    for (var i = 0; i < spectrums.length; i++) {
      if (spectrums[i]) {
        spectrums[i].hide();
      }
    }
  }

  function instanceOptions(o, callbackContext) {
    var opts = $.extend({}, defaultOpts, o);
    opts.callbacks = {
      'move': bind(opts.move, callbackContext),
      'change': bind(opts.change, callbackContext),
      'show': bind(opts.show, callbackContext),
      'hide': bind(opts.hide, callbackContext),
      'beforeShow': bind(opts.beforeShow, callbackContext)
    };

    return opts;
  }

  function spectrum(element, o) {

    var opts = instanceOptions(o, element),
      flat = opts.flat,
      showSelectionPalette = opts.showSelectionPalette,
      localStorageKey = opts.localStorageKey,
      theme = opts.theme,
      callbacks = opts.callbacks,
      resize = throttle(reflow, 10),
      visible = false,
      isDragging = false,
      dragWidth = 0,
      dragHeight = 0,
      dragHelperHeight = 0,
      slideHeight = 0,
      slideWidth = 0,
      alphaWidth = 0,
      alphaSlideHelperWidth = 0,
      slideHelperHeight = 0,
      currentHue = 0,
      currentSaturation = 0,
      currentValue = 0,
      currentAlpha = 1,
      palette = [],
      paletteArray = [],
      paletteLookup = {},
      selectionPalette = opts.selectionPalette.slice(0),
      maxSelectionSize = opts.maxSelectionSize,
      draggingClass = "sp-dragging",
      shiftMovementDirection = null;

    var doc = element.ownerDocument,
      body = doc.body,
      boundElement = $(element),
      disabled = false,
      container = $(markup, doc).addClass(theme),
      pickerContainer = container.find(".sp-picker-container"),
      dragger = container.find(".sp-color"),
      dragHelper = container.find(".sp-dragger"),
      slider = container.find(".sp-hue"),
      slideHelper = container.find(".sp-slider"),
      alphaSliderInner = container.find(".sp-alpha-inner"),
      alphaSlider = container.find(".sp-alpha"),
      alphaSlideHelper = container.find(".sp-alpha-handle"),
      textInput = container.find(".sp-input"),
      paletteContainer = container.find(".sp-palette"),
      initialColorContainer = container.find(".sp-initial"),
      cancelButton = container.find(".sp-cancel"),
      clearButton = container.find(".sp-clear"),
      chooseButton = container.find(".sp-choose"),
      toggleButton = container.find(".sp-palette-toggle"),
      isInput = boundElement.is("input"),
      isInputTypeColor = isInput && boundElement.attr("type") === "color" && inputTypeColorSupport(),
      shouldReplace = isInput && !flat,
      replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]),
      offsetElement = (shouldReplace) ? replacer : boundElement,
      previewElement = replacer.find(".sp-preview-inner"),
      initialColor = opts.color || (isInput && boundElement.val()),
      colorOnShow = false,
      currentPreferredFormat = opts.preferredFormat,
      clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,
      isEmpty = !initialColor,
      allowEmpty = opts.allowEmpty && !isInputTypeColor;

    function applyOptions() {

      if (opts.showPaletteOnly) {
        opts.showPalette = true;
      }

      toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);

      if (opts.palette) {
        palette = opts.palette.slice(0);
        paletteArray = $.isArray(palette[0]) ? palette : [palette];
        paletteLookup = {};
        for (var i = 0; i < paletteArray.length; i++) {
          for (var j = 0; j < paletteArray[i].length; j++) {
            var rgb = tinycolor(paletteArray[i][j]).toRgbString();
            paletteLookup[rgb] = true;
          }
        }
      }

      container.toggleClass("sp-flat", flat);
      container.toggleClass("sp-input-disabled", !opts.showInput);
      container.toggleClass("sp-alpha-enabled", opts.showAlpha);
      container.toggleClass("sp-clear-enabled", allowEmpty);
      container.toggleClass("sp-buttons-disabled", !opts.showButtons);
      container.toggleClass("sp-palette-buttons-disabled", !opts.togglePaletteOnly);
      container.toggleClass("sp-palette-disabled", !opts.showPalette);
      container.toggleClass("sp-palette-only", opts.showPaletteOnly);
      container.toggleClass("sp-initial-disabled", !opts.showInitial);
      container.addClass(opts.className).addClass(opts.containerClassName);

      reflow();
    }

    function initialize() {

      if (IE) {
        container.find("*:not(input)").attr("unselectable", "on");
      }

      applyOptions();

      if (shouldReplace) {
        boundElement.after(replacer).hide();
      }

      if (!allowEmpty) {
        clearButton.hide();
      }

      if (flat) {
        boundElement.after(container).hide();
      }
      else {

        var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
        if (appendTo.length !== 1) {
          appendTo = $("body");
        }

        appendTo.append(container);
      }

      updateSelectionPaletteFromStorage();

      offsetElement.bind("click.spectrum touchstart.spectrum", function (e) {
        if (!disabled) {
          toggle();
        }

        e.stopPropagation();

        if (!$(e.target).is("input")) {
          e.preventDefault();
        }
      });

      if(boundElement.is(":disabled") || (opts.disabled === true)) {
        disable();
      }

      // Prevent clicks from bubbling up to document.  This would cause it to be hidden.
      container.click(stopPropagation);

      // Handle user typed input
      textInput.change(setFromTextInput);
      textInput.bind("paste", function () {
        setTimeout(setFromTextInput, 1);
      });
      textInput.keydown(function (e) { if (e.keyCode == 13) { setFromTextInput(); } });

      cancelButton.text(opts.cancelText);
      cancelButton.bind("click.spectrum", function (e) {
        e.stopPropagation();
        e.preventDefault();
        revert();
        hide();
      });

      clearButton.attr("title", opts.clearText);
      clearButton.bind("click.spectrum", function (e) {
        e.stopPropagation();
        e.preventDefault();
        isEmpty = true;
        move();

        if(flat) {
          //for the flat style, this is a change event
          updateOriginalInput(true);
        }
      });

      chooseButton.text(opts.chooseText);
      chooseButton.bind("click.spectrum", function (e) {
        e.stopPropagation();
        e.preventDefault();

        if (IE && textInput.is(":focus")) {
          textInput.trigger('change');
        }

        if (isValid()) {
          updateOriginalInput(true);
          hide();
        }
      });

      toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
      toggleButton.bind("click.spectrum", function (e) {
        e.stopPropagation();
        e.preventDefault();

        opts.showPaletteOnly = !opts.showPaletteOnly;

        // To make sure the Picker area is drawn on the right, next to the
        // Palette area (and not below the palette), first move the Palette
        // to the left to make space for the picker, plus 5px extra.
        // The 'applyOptions' function puts the whole container back into place
        // and takes care of the button-text and the sp-palette-only CSS class.
        if (!opts.showPaletteOnly && !flat) {
          container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
        }
        applyOptions();
      });

      draggable(alphaSlider, function (dragX, dragY, e) {
        currentAlpha = (dragX / alphaWidth);
        isEmpty = false;
        if (e.shiftKey) {
          currentAlpha = Math.round(currentAlpha * 10) / 10;
        }

        move();
      }, dragStart, dragStop);

      draggable(slider, function (dragX, dragY) {
        currentHue = parseFloat(dragY / slideHeight);
        isEmpty = false;
        if (!opts.showAlpha) {
          currentAlpha = 1;
        }
        move();
      }, dragStart, dragStop);

      draggable(dragger, function (dragX, dragY, e) {

        // shift+drag should snap the movement to either the x or y axis.
        if (!e.shiftKey) {
          shiftMovementDirection = null;
        }
        else if (!shiftMovementDirection) {
          var oldDragX = currentSaturation * dragWidth;
          var oldDragY = dragHeight - (currentValue * dragHeight);
          var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);

          shiftMovementDirection = furtherFromX ? "x" : "y";
        }

        var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
        var setValue = !shiftMovementDirection || shiftMovementDirection === "y";

        if (setSaturation) {
          currentSaturation = parseFloat(dragX / dragWidth);
        }
        if (setValue) {
          currentValue = parseFloat((dragHeight - dragY) / dragHeight);
        }

        isEmpty = false;
        if (!opts.showAlpha) {
          currentAlpha = 1;
        }

        move();

      }, dragStart, dragStop);

      if (!!initialColor) {
        set(initialColor);

        // In case color was black - update the preview UI and set the format
        // since the set function will not run (default color is black).
        updateUI();
        currentPreferredFormat = opts.preferredFormat || tinycolor(initialColor).format;

        addColorToSelectionPalette(initialColor);
      }
      else {
        updateUI();
      }

      if (flat) {
        show();
      }

      function paletteElementClick(e) {
        if (e.data && e.data.ignore) {
          set($(e.target).closest(".sp-thumb-el").data("color"));
          move();
        }
        else {
          set($(e.target).closest(".sp-thumb-el").data("color"));
          move();
          updateOriginalInput(true);
          if (opts.hideAfterPaletteSelect) {
            hide();
          }
        }

        return false;
      }

      var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
      paletteContainer.delegate(".sp-thumb-el", paletteEvent, paletteElementClick);
      initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, { ignore: true }, paletteElementClick);
    }

    function updateSelectionPaletteFromStorage() {

      if (localStorageKey && window.localStorage) {

        // Migrate old palettes over to new format.  May want to remove this eventually.
        try {
          var oldPalette = window.localStorage[localStorageKey].split(",#");
          if (oldPalette.length > 1) {
            delete window.localStorage[localStorageKey];
            $.each(oldPalette, function(i, c) {
              addColorToSelectionPalette(c);
            });
          }
        }
        catch(e) { }

        try {
          selectionPalette = window.localStorage[localStorageKey].split(";");
        }
        catch (e) { }
      }
    }

    function addColorToSelectionPalette(color) {
      if (showSelectionPalette) {
        var rgb = tinycolor(color).toRgbString();
        if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
          selectionPalette.push(rgb);
          while(selectionPalette.length > maxSelectionSize) {
            selectionPalette.shift();
          }
        }

        if (localStorageKey && window.localStorage) {
          try {
            window.localStorage[localStorageKey] = selectionPalette.join(";");
          }
          catch(e) { }
        }
      }
    }

    function getUniqueSelectionPalette() {
      var unique = [];
      if (opts.showPalette) {
        for (var i = 0; i < selectionPalette.length; i++) {
          var rgb = tinycolor(selectionPalette[i]).toRgbString();

          if (!paletteLookup[rgb]) {
            unique.push(selectionPalette[i]);
          }
        }
      }

      return unique.reverse().slice(0, opts.maxSelectionSize);
    }

    function drawPalette() {

      var currentColor = get();

      var html = $.map(paletteArray, function (palette, i) {
        return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts);
      });

      updateSelectionPaletteFromStorage();

      if (selectionPalette) {
        html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
      }

      paletteContainer.html(html.join(""));
    }

    function drawInitial() {
      if (opts.showInitial) {
        var initial = colorOnShow;
        var current = get();
        initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial", opts));
      }
    }

    function dragStart() {
      if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
        reflow();
      }
      isDragging = true;
      container.addClass(draggingClass);
      shiftMovementDirection = null;
      boundElement.trigger('dragstart.spectrum', [ get() ]);
    }

    function dragStop() {
      isDragging = false;
      container.removeClass(draggingClass);
      boundElement.trigger('dragstop.spectrum', [ get() ]);
    }

    function setFromTextInput() {

      var value = textInput.val();

      if ((value === null || value === "") && allowEmpty) {
        set(null);
        updateOriginalInput(true);
      }
      else {
        var tiny = tinycolor(value);
        if (tiny.isValid()) {
          set(tiny);
          updateOriginalInput(true);
        }
        else {
          textInput.addClass("sp-validation-error");
        }
      }
    }

    function toggle() {
      if (visible) {
        hide();
      }
      else {
        show();
      }
    }

    function show() {
      var event = $.Event('beforeShow.spectrum');

      if (visible) {
        reflow();
        return;
      }

      boundElement.trigger(event, [ get() ]);

      if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
        return;
      }

      hideAll();
      visible = true;

      $(doc).bind("keydown.spectrum", onkeydown);
      $(doc).bind("click.spectrum", clickout);
      $(window).bind("resize.spectrum", resize);
      replacer.addClass("sp-active");
      container.removeClass("sp-hidden");

      reflow();
      updateUI();

      colorOnShow = get();

      drawInitial();
      callbacks.show(colorOnShow);
      boundElement.trigger('show.spectrum', [ colorOnShow ]);
    }

    function onkeydown(e) {
      // Close on ESC
      if (e.keyCode === 27) {
        hide();
      }
    }

    function clickout(e) {
      // Return on right click.
      if (e.button == 2) { return; }

      // If a drag event was happening during the mouseup, don't hide
      // on click.
      if (isDragging) { return; }

      if (clickoutFiresChange) {
        updateOriginalInput(true);
      }
      else {
        revert();
      }
      hide();
    }

    function hide() {
      // Return if hiding is unnecessary
      if (!visible || flat) { return; }
      visible = false;

      $(doc).unbind("keydown.spectrum", onkeydown);
      $(doc).unbind("click.spectrum", clickout);
      $(window).unbind("resize.spectrum", resize);

      replacer.removeClass("sp-active");
      container.addClass("sp-hidden");

      callbacks.hide(get());
      boundElement.trigger('hide.spectrum', [ get() ]);
    }

    function revert() {
      set(colorOnShow, true);
    }

    function set(color, ignoreFormatChange) {
      if (tinycolor.equals(color, get())) {
        // Update UI just in case a validation error needs
        // to be cleared.
        updateUI();
        return;
      }

      var newColor, newHsv;
      if (!color && allowEmpty) {
        isEmpty = true;
      } else {
        isEmpty = false;
        newColor = tinycolor(color);
        newHsv = newColor.toHsv();

        currentHue = (newHsv.h % 360) / 360;
        currentSaturation = newHsv.s;
        currentValue = newHsv.v;
        currentAlpha = newHsv.a;
      }
      updateUI();

      if (newColor && newColor.isValid() && !ignoreFormatChange) {
        currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
      }
    }

    function get(opts) {
      opts = opts || { };

      if (allowEmpty && isEmpty) {
        return null;
      }

      return tinycolor.fromRatio({
        h: currentHue,
        s: currentSaturation,
        v: currentValue,
        a: Math.round(currentAlpha * 100) / 100
      }, { format: opts.format || currentPreferredFormat });
    }

    function isValid() {
      return !textInput.hasClass("sp-validation-error");
    }

    function move() {
      updateUI();

      callbacks.move(get());
      boundElement.trigger('move.spectrum', [ get() ]);
    }

    function updateUI() {

      textInput.removeClass("sp-validation-error");

      updateHelperLocations();

      // Update dragger background color (gradients take care of saturation and value).
      var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
      dragger.css("background-color", flatColor.toHexString());

      // Get a format that alpha will be included in (hex and names ignore alpha)
      var format = currentPreferredFormat;
      if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
        if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
          format = "rgb";
        }
      }

      var realColor = get({ format: format }),
        displayColor = '';

      //reset background info for preview element
      previewElement.removeClass("sp-clear-display");
      previewElement.css('background-color', 'transparent');

      if (!realColor && allowEmpty) {
        // Update the replaced elements background with icon indicating no color selection
        previewElement.addClass("sp-clear-display");
      }
      else {
        var realHex = realColor.toHexString(),
          realRgb = realColor.toRgbString();

        // Update the replaced elements background color (with actual selected color)
        if (rgbaSupport || realColor.alpha === 1) {
          previewElement.css("background-color", realRgb);
        }
        else {
          previewElement.css("background-color", "transparent");
          previewElement.css("filter", realColor.toFilter());
        }

        if (opts.showAlpha) {
          var rgb = realColor.toRgb();
          rgb.a = 0;
          var realAlpha = tinycolor(rgb).toRgbString();
          var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";

          if (IE) {
            alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
          }
          else {
            alphaSliderInner.css("background", "-webkit-" + gradient);
            alphaSliderInner.css("background", "-moz-" + gradient);
            alphaSliderInner.css("background", "-ms-" + gradient);
            // Use current syntax gradient on unprefixed property.
            alphaSliderInner.css("background",
              "linear-gradient(to right, " + realAlpha + ", " + realHex + ")");
          }
        }

        displayColor = realColor.toString(format);
      }

      // Update the text entry input as it changes happen
      if (opts.showInput) {
        textInput.val(displayColor);
      }

      if (opts.showPalette) {
        drawPalette();
      }

      drawInitial();
    }

    function updateHelperLocations() {
      var s = currentSaturation;
      var v = currentValue;

      if(allowEmpty && isEmpty) {
        //if selected color is empty, hide the helpers
        alphaSlideHelper.hide();
        slideHelper.hide();
        dragHelper.hide();
      }
      else {
        //make sure helpers are visible
        alphaSlideHelper.show();
        slideHelper.show();
        dragHelper.show();

        // Where to show the little circle in that displays your current selected color
        var dragX = s * dragWidth;
        var dragY = dragHeight - (v * dragHeight);
        dragX = Math.max(
          -dragHelperHeight,
          Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
        );
        dragY = Math.max(
          -dragHelperHeight,
          Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
        );
        dragHelper.css({
          "top": dragY + "px",
          "left": dragX + "px"
        });

        var alphaX = currentAlpha * alphaWidth;
        alphaSlideHelper.css({
          "left": (alphaX - (alphaSlideHelperWidth / 2)) + "px"
        });

        // Where to show the bar that displays your current selected hue
        var slideY = (currentHue) * slideHeight;
        slideHelper.css({
          "top": (slideY - slideHelperHeight) + "px"
        });
      }
    }

    function updateOriginalInput(fireCallback) {
      var color = get(),
        displayColor = '',
        hasChanged = !tinycolor.equals(color, colorOnShow);

      if (color) {
        displayColor = color.toString(currentPreferredFormat);
        // Update the selection palette with the current color
        addColorToSelectionPalette(color);
      }

      if (isInput) {
        boundElement.val(displayColor);
      }

      if (fireCallback && hasChanged) {
        callbacks.change(color);
        boundElement.trigger('change', [ color ]);
      }
    }

    function reflow() {
      if (!visible) {
        return; // Calculations would be useless and wouldn't be reliable anyways
      }
      dragWidth = dragger.width();
      dragHeight = dragger.height();
      dragHelperHeight = dragHelper.height();
      slideWidth = slider.width();
      slideHeight = slider.height();
      slideHelperHeight = slideHelper.height();
      alphaWidth = alphaSlider.width();
      alphaSlideHelperWidth = alphaSlideHelper.width();

      if (!flat) {
        container.css("position", "absolute");
        if (opts.offset) {
          container.offset(opts.offset);
        } else {
          container.offset(getOffset(container, offsetElement));
        }
      }

      updateHelperLocations();

      if (opts.showPalette) {
        drawPalette();
      }

      boundElement.trigger('reflow.spectrum');
    }

    function destroy() {
      boundElement.show();
      offsetElement.unbind("click.spectrum touchstart.spectrum");
      container.remove();
      replacer.remove();
      spectrums[spect.id] = null;
    }

    function option(optionName, optionValue) {
      if (optionName === undefined) {
        return $.extend({}, opts);
      }
      if (optionValue === undefined) {
        return opts[optionName];
      }

      opts[optionName] = optionValue;

      if (optionName === "preferredFormat") {
        currentPreferredFormat = opts.preferredFormat;
      }
      applyOptions();
    }

    function enable() {
      disabled = false;
      boundElement.attr("disabled", false);
      offsetElement.removeClass("sp-disabled");
    }

    function disable() {
      hide();
      disabled = true;
      boundElement.attr("disabled", true);
      offsetElement.addClass("sp-disabled");
    }

    function setOffset(coord) {
      opts.offset = coord;
      reflow();
    }

    initialize();

    var spect = {
      show: show,
      hide: hide,
      toggle: toggle,
      reflow: reflow,
      option: option,
      enable: enable,
      disable: disable,
      offset: setOffset,
      set: function (c) {
        set(c);
        updateOriginalInput();
      },
      get: get,
      destroy: destroy,
      container: container
    };

    spect.id = spectrums.push(spect) - 1;

    return spect;
  }

  /**
   * checkOffset - get the offset below/above and left/right element depending on screen position
   * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
   */
  function getOffset(picker, input) {
    var extraY = 0;
    var dpWidth = picker.outerWidth();
    var dpHeight = picker.outerHeight();
    var inputHeight = input.outerHeight();
    var doc = picker[0].ownerDocument;
    var docElem = doc.documentElement;
    var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
    var viewHeight = docElem.clientHeight + $(doc).scrollTop();
    var offset = input.offset();
    offset.top += inputHeight;

    offset.left -=
      Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
        Math.abs(offset.left + dpWidth - viewWidth) : 0);

    offset.top -=
      Math.min(offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
        Math.abs(dpHeight + inputHeight - extraY) : extraY));

    return offset;
  }

  /**
   * noop - do nothing
   */
  function noop() {

  }

  /**
   * stopPropagation - makes the code only doing this a little easier to read in line
   */
  function stopPropagation(e) {
    e.stopPropagation();
  }

  /**
   * Create a function bound to a given object
   * Thanks to underscore.js
   */
  function bind(func, obj) {
    var slice = Array.prototype.slice;
    var args = slice.call(arguments, 2);
    return function () {
      return func.apply(obj, args.concat(slice.call(arguments)));
    };
  }

  /**
   * Lightweight drag helper.  Handles containment within the element, so that
   * when dragging, the x is within [0,element.width] and y is within [0,element.height]
   */
  function draggable(element, onmove, onstart, onstop) {
    onmove = onmove || function () { };
    onstart = onstart || function () { };
    onstop = onstop || function () { };
    var doc = document;
    var dragging = false;
    var offset = {};
    var maxHeight = 0;
    var maxWidth = 0;
    var hasTouch = ('ontouchstart' in window);

    var duringDragEvents = {};
    duringDragEvents["selectstart"] = prevent;
    duringDragEvents["dragstart"] = prevent;
    duringDragEvents["touchmove mousemove"] = move;
    duringDragEvents["touchend mouseup"] = stop;

    function prevent(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.returnValue = false;
    }

    function move(e) {
      if (dragging) {
        // Mouseup happened outside of window
        if (IE && doc.documentMode < 9 && !e.button) {
          return stop();
        }

        var t0 = e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0];
        var pageX = t0 && t0.pageX || e.pageX;
        var pageY = t0 && t0.pageY || e.pageY;

        var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
        var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

        if (hasTouch) {
          // Stop scrolling in iOS
          prevent(e);
        }

        onmove.apply(element, [dragX, dragY, e]);
      }
    }

    function start(e) {
      var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

      if (!rightclick && !dragging) {
        if (onstart.apply(element, arguments) !== false) {
          dragging = true;
          maxHeight = $(element).height();
          maxWidth = $(element).width();
          offset = $(element).offset();

          $(doc).bind(duringDragEvents);
          $(doc.body).addClass("sp-dragging");

          move(e);

          prevent(e);
        }
      }
    }

    function stop() {
      if (dragging) {
        $(doc).unbind(duringDragEvents);
        $(doc.body).removeClass("sp-dragging");

        // Wait a tick before notifying observers to allow the click event
        // to fire in Chrome.
        setTimeout(function() {
          onstop.apply(element, arguments);
        }, 0);
      }
      dragging = false;
    }

    $(element).bind("touchstart mousedown", start);
  }

  function throttle(func, wait, debounce) {
    var timeout;
    return function () {
      var context = this, args = arguments;
      var throttler = function () {
        timeout = null;
        func.apply(context, args);
      };
      if (debounce) clearTimeout(timeout);
      if (debounce || !timeout) timeout = setTimeout(throttler, wait);
    };
  }

  function inputTypeColorSupport() {
    return $.fn.spectrum.inputTypeColorSupport();
  }

  /**
   * Define a jQuery plugin
   */
  var dataID = "spectrum.id";
  $.fn.spectrum = function (opts, extra) {

    if (typeof opts == "string") {

      var returnValue = this;
      var args = Array.prototype.slice.call( arguments, 1 );

      this.each(function () {
        var spect = spectrums[$(this).data(dataID)];
        if (spect) {
          var method = spect[opts];
          if (!method) {
            throw new Error( "Spectrum: no such method: '" + opts + "'" );
          }

          if (opts == "get") {
            returnValue = spect.get();
          }
          else if (opts == "container") {
            returnValue = spect.container;
          }
          else if (opts == "option") {
            returnValue = spect.option.apply(spect, args);
          }
          else if (opts == "destroy") {
            spect.destroy();
            $(this).removeData(dataID);
          }
          else {
            method.apply(spect, args);
          }
        }
      });

      return returnValue;
    }

    // Initializing a new instance of spectrum
    return this.spectrum("destroy").each(function () {
      var options = $.extend({}, opts, $(this).data());
      var spect = spectrum(this, options);
      $(this).data(dataID, spect.id);
    });
  };

  $.fn.spectrum.load = true;
  $.fn.spectrum.loadOpts = {};
  $.fn.spectrum.draggable = draggable;
  $.fn.spectrum.defaults = defaultOpts;
  $.fn.spectrum.inputTypeColorSupport = function inputTypeColorSupport() {
    if (typeof inputTypeColorSupport._cachedResult === "undefined") {
      var colorInput = $("<input type='color'/>")[0]; // if color element is supported, value will default to not null
      inputTypeColorSupport._cachedResult = colorInput.type === "color" && colorInput.value !== "";
    }
    return inputTypeColorSupport._cachedResult;
  };

  $.spectrum = { };
  $.spectrum.localization = { };
  $.spectrum.palettes = { };

  $.fn.spectrum.processNativeColorInputs = function () {
    var colorInputs = $("input[type=color]");
    if (colorInputs.length && !inputTypeColorSupport()) {
      colorInputs.spectrum({
        preferredFormat: "hex6"
      });
    }
  };

  // TinyColor v1.1.2
  // https://github.com/bgrins/TinyColor
  // Brian Grinstead, MIT License

  (function() {

    var trimLeft = /^[\s,#]+/,
      trimRight = /\s+$/,
      tinyCounter = 0,
      math = Math,
      mathRound = math.round,
      mathMin = math.min,
      mathMax = math.max,
      mathRandom = math.random;

    var tinycolor = function(color, opts) {

      color = (color) ? color : '';
      opts = opts || { };

      // If input is already a tinycolor, return itself
      if (color instanceof tinycolor) {
        return color;
      }
      // If we are called as a function, call using new instead
      if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
      }

      var rgb = inputToRGB(color);
      this._originalInput = color,
        this._r = rgb.r,
        this._g = rgb.g,
        this._b = rgb.b,
        this._a = rgb.a,
        this._roundA = mathRound(100*this._a) / 100,
        this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;

      // Don't let the range of [0,255] come back in [0,1].
      // Potentially lose a little bit of precision here, but will fix issues where
      // .5 gets interpreted as half of the total, instead of half of 1
      // If it was supposed to be 128, this was already taken care of by `inputToRgb`
      if (this._r < 1) { this._r = mathRound(this._r); }
      if (this._g < 1) { this._g = mathRound(this._g); }
      if (this._b < 1) { this._b = mathRound(this._b); }

      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
    };

    tinycolor.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
      },
      setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
      },
      toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
      },
      toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
      },
      toHex8: function() {
        return rgbaToHex(this._r, this._g, this._b, this._a);
      },
      toHex8String: function() {
        return '#' + this.toHex8();
      },
      toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }

        if (this._a < 1) {
          return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
          var s = tinycolor(secondColor);
          secondHex8String = s.toHex8String();
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
      },
      toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

        if (needsAlphaFormat) {
          // Special case for "transparent", all other non-alpha formats
          // will return rgba when there is transparency.
          if (format === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
          formattedString = this.toHexString();
        }
        if (format === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format === "name") {
          formattedString = this.toName();
        }
        if (format === "hsl") {
          formattedString = this.toHslString();
        }
        if (format === "hsv") {
          formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
      },

      _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin, arguments);
      },

      _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function(color, opts) {
      if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
          if (color.hasOwnProperty(i)) {
            if (i === "a") {
              newColor[i] = color[i];
            }
            else {
              newColor[i] = convertToPercentage(color[i]);
            }
          }
        }
        color = newColor;
      }

      return tinycolor(color, opts);
    };

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var ok = false;
      var format = false;

      if (typeof color == "string") {
        color = stringInputToObject(color);
      }

      if (typeof color == "object") {
        if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
          color.s = convertToPercentage(color.s);
          color.v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, color.s, color.v);
          ok = true;
          format = "hsv";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
          color.s = convertToPercentage(color.s);
          color.l = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, color.s, color.l);
          ok = true;
          format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
          a = color.a;
        }
      }

      a = boundAlpha(a);

      return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
      };
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);

      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, l = (max + min) / 2;

      if(max == min) {
        h = s = 0; // achromatic
      }
      else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
      }

      return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
      var r, g, b;

      h = bound01(h, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);

      function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }

      if(s === 0) {
        r = g = b = l; // achromatic
      }
      else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);

      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, v = max;

      var d = max - min;
      s = max === 0 ? 0 : d / max;

      if(max == min) {
        h = 0; // achromatic
      }
      else {
        switch(max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hsvToRgb(h, s, v) {

      h = bound01(h, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);

      var i = math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

      return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

      var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
      ];

      // Return a 3 character hex if possible
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }

      return hex.join("");
    }
    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b and a are contained in the set [0, 255]
    // Returns an 8 character hex
    function rgbaToHex(r, g, b, a) {

      var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
      ];

      return hex.join("");
    }

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
      if (!color1 || !color2) { return false; }
      return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function() {
      return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };


    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }

    function saturate(color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }

    function greyscale(color) {
      return tinycolor(color).desaturate(100);
    }

    function lighten (color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }

    function brighten(color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var rgb = tinycolor(color).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
      return tinycolor(rgb);
    }

    function darken (color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
      var hsl = tinycolor(color).toHsl();
      var hue = (mathRound(hsl.h) + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
      var hsl = tinycolor(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor(hsl);
    }

    function triad(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
      ];
    }

    function tetrad(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
      ];
    }

    function splitcomplement(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
      ];
    }

    function analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;

      var hsl = tinycolor(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor(color)];

      for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
      }
      return ret;
    }

    function monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor(color).toHsv();
      var h = hsv.h, s = hsv.s, v = hsv.v;
      var ret = [];
      var modification = 1 / results;

      while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
      }

      return ret;
    }

    // Utility Functions
    // ---------------------

    tinycolor.mix = function(color1, color2, amount) {
      amount = (amount === 0) ? 0 : (amount || 50);

      var rgb1 = tinycolor(color1).toRgb();
      var rgb2 = tinycolor(color2).toRgb();

      var p = amount / 100;
      var w = p * 2 - 1;
      var a = rgb2.a - rgb1.a;

      var w1;

      if (w * a == -1) {
        w1 = w;
      } else {
        w1 = (w + a) / (1 + w * a);
      }

      w1 = (w1 + 1) / 2;

      var w2 = 1 - w1;

      var rgba = {
        r: rgb2.r * w1 + rgb1.r * w2,
        g: rgb2.g * w1 + rgb1.g * w2,
        b: rgb2.b * w1 + rgb1.b * w2,
        a: rgb2.a * p  + rgb1.a * (1 - p)
      };

      return tinycolor(rgba);
    };


    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/AERT#color-contrast>

    // `readability`
    // Analyze the 2 colors and returns an object with the following properties:
    //    `brightness`: difference in brightness between the two colors
    //    `color`: difference in color/hue between the two colors
    tinycolor.readability = function(color1, color2) {
      var c1 = tinycolor(color1);
      var c2 = tinycolor(color2);
      var rgb1 = c1.toRgb();
      var rgb2 = c2.toRgb();
      var brightnessA = c1.getBrightness();
      var brightnessB = c2.getBrightness();
      var colorDiff = (
        Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) +
        Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) +
        Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b)
      );

      return {
        brightness: Math.abs(brightnessA - brightnessB),
        color: colorDiff
      };
    };

    // `readable`
    // http://www.w3.org/TR/AERT#color-contrast
    // Ensure that foreground and background color combinations provide sufficient contrast.
    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    tinycolor.isReadable = function(color1, color2) {
      var readability = tinycolor.readability(color1, color2);
      return readability.brightness > 125 && readability.color > 500;
    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // *Example*
    //    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
    tinycolor.mostReadable = function(baseColor, colorList) {
      var bestColor = null;
      var bestScore = 0;
      var bestIsReadable = false;
      for (var i=0; i < colorList.length; i++) {

        // We normalize both around the "acceptable" breaking point,
        // but rank brightness constrast higher than hue.

        var readability = tinycolor.readability(baseColor, colorList[i]);
        var readable = readability.brightness > 125 && readability.color > 500;
        var score = 3 * (readability.brightness / 125) + (readability.color / 500);

        if ((readable && ! bestIsReadable) ||
          (readable && bestIsReadable && score > bestScore) ||
          ((! readable) && (! bestIsReadable) && score > bestScore)) {
          bestIsReadable = readable;
          bestScore = score;
          bestColor = tinycolor(colorList[i]);
        }
      }
      return bestColor;
    };


    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = tinycolor.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = tinycolor.hexNames = flip(names);


    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
      var flipped = { };
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          flipped[o[i]] = i;
        }
      }
      return flipped;
    }

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
      a = parseFloat(a);

      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }

      return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
      if (isOnePointZero(n)) { n = "100%"; }

      var processPercent = isPercentage(n);
      n = mathMin(max, mathMax(0, parseFloat(n)));

      // Automatically convert percentage into number
      if (processPercent) {
        n = parseInt(n * max, 10) / 100;
      }

      // Handle floating point rounding errors
      if ((math.abs(n - max) < 0.000001)) {
        return 1;
      }

      // Convert into [0, 1] range if it isn't already
      return (n % max) / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
      return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
      return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
      return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
      if (n <= 1) {
        n = (n * 100) + "%";
      }

      return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
      return (parseIntFromHex(h) / 255);
    }

    var matchers = (function() {

      // <http://www.w3.org/TR/css3-values/#integers>
      var CSS_INTEGER = "[-\\+]?\\d+%?";

      // <http://www.w3.org/TR/css3-values/#number-value>
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

      // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

      // Actual matching.
      // Parentheses and commas are optional, but not required.
      // Whitespace can take the place of commas or opening paren
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

      return {
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    })();

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

      color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      }
      else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }

      // Try to match string input using regular expressions.
      // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
      // Just return an object and let the conversion functions handle that.
      // This way the result will be the same whether the tinycolor is initialized with string or object.
      var match;
      if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      if ((match = matchers.hex8.exec(color))) {
        return {
          a: convertHexToDecimal(match[1]),
          r: parseIntFromHex(match[2]),
          g: parseIntFromHex(match[3]),
          b: parseIntFromHex(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if ((match = matchers.hex6.exec(color))) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if ((match = matchers.hex3.exec(color))) {
        return {
          r: parseIntFromHex(match[1] + '' + match[1]),
          g: parseIntFromHex(match[2] + '' + match[2]),
          b: parseIntFromHex(match[3] + '' + match[3]),
          format: named ? "name" : "hex"
        };
      }

      return false;
    }

    window.tinycolor = tinycolor;
  })();

  $(function () {
    if ($.fn.spectrum.load) {
      $.fn.spectrum.processNativeColorInputs();
    }
  });

}(window.jQuery);
},{}],10:[function(require,module,exports){
/*
 * jQuery UIx Multiselect 2.0
 *
 * Authors:
 *  Yanick Rochon (yanick.rochon[at]gmail[dot]com)
 *
 * Licensed under the MIT (MIT-LICENSE.txt) license.
 *
 * http://mind2soft.com/labs/jquery/multiselect/
 *
 *
 * Depends:
 * jQuery UI 1.8+
 *
 */

(function($, window, undefined) {
  // ECMAScript 5 Strict Mode: [John Resig Blog Post](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)


  // Each instance must have their own drag and drop scope. We use a global page scope counter
  // so we do not create two instances with mistankenly the same scope! We do not support
  // cross instance drag and drop; this would require also copying the OPTION element and it
  // would slow the component down. This is not the widget's contract anyhow.
  var globalScope = 0;

  var DEF_OPTGROUP = '';
  var PRE_OPTGROUP = 'group-';

  // these events will trigger on the original element
  //var NATIVE_EVENTS = ["change"];   // for version 2.1

  // a list of predefined events
  //var EVENT_CHANGE = 'change';    // for version 2.1
  var EVENT_CHANGE = 'multiselectChange';
  //var EVENT_SEARCH = 'beforesearch';   // for version 2.1
  var EVENT_SEARCH = 'multiselectSearch';
  var EVENT_REORDERED = 'multiselectReordered';

  // The jQuery.uix namespace will automatically be created if it doesn't exist
  $.widget("uix.multiselect", {
    options: {
      availableListPosition: 'right',// 'top', 'right', 'bottom', 'left'; the position of the available list (default: 'right')
      // beforesearch: null,            // a funciton called before searching. If the default is prevented, search will not happen (for version 2.1)
      collapsableGroups: true,       // tells whether the option groups can be collapsed or not (default: true)
      created: null,                 // a function called when the widget is done loading (default: null)
      defaultGroupName: '',          // the name of the default option group (default: '')
      filterSelected: false,         // when searching, filter selected options also? (default: false)
      locale: 'auto',                // any valid locale, 'auto', or '' for default built-in strings (default: 'auto')
      moveEffect: null,              // 'blind','bounce','clip','drop','explode','fold','highlight','puff','pulsate','shake','slide' (default: null)
      moveEffectOptions: {},         // effect options (see jQuery UI documentation) (default: {})
      moveEffectSpeed: null,         // string ('slow','fast') or number in millisecond (ignored if moveEffect is 'show') (default: null)
      optionRenderer: false,         // a function that will return the item element to be rendered in the list (default: false)
      optionGroupRenderer: false,    // a function that will return the group item element to be rendered (default: false)
      searchDelay: 500,              // the search delay in ms (default: 500)
      searchField: 'toggle',         // false, true, 'toggle'; set the search field behaviour (default: 'toggle')
      searchPreFilter: null,         // prepare the search term before filtering.
      searchFilter: null,            // a search filter. Will receive the term and OPTION element and should return a boolean value.
      searchHeader: 'available',     // 'available', 'selected'; set the list header that will host the search field (default: 'available')
      selectionMode: 'click,d&d',    // how options can be selected separated by commas: 'click', "dblclick" and 'd&d' (default: 'click,d&d')
      showDefaultGroupHeader: false, // show the default option group header (default: false)
      showEmptyGroups: false,        // always display option groups even if empty (default: false)
      splitRatio: 0.55,              // % of the left list's width of the widget total width (default 0.55)
      sortable: false,               // if the selected list should be user sortable or not
      sortMethod: null,              // null, 'standard', 'natural'; a sort function name (see ItemComparators), or a custom function (default: null)
      selectAll: 'both'              // 'available', 'selected', 'both', 'none' - Whether or not to display a select or deselect all icon (default: 'both')
    },

    _create: function() {
      var that = this;
      var selListHeader, selListContent, avListHeader, avListContent;
      var btnSelectAll, btnDeselectAll;

      this.scope = 'multiselect' + (globalScope++);
      this.optionGroupIndex = 1;
      this._setLocale(this.options.locale);

      this.element.addClass('uix-multiselect-original');
      this._elementWrapper = $('<div></div>').addClass('uix-multiselect ui-widget')
        .css({
          width: this.element.css('width'),
          height: this.element.css('height')
        })
        .append(
          $('<div></div>').addClass('multiselect-selected-list')
            .append( $('<div></div>').addClass('ui-widget-header')
              .append( btnDeselectAll = $('<button></button>', { type:"button" }).addClass('uix-control-right')
                .attr('data-localekey', 'deselectAll')
                .attr('title', this._t('deselectAll'))
                .button({icon: 'ui-icon-arrowthickstop-1-e', text:false})
                .click(function(e) { e.preventDefault(); e.stopPropagation(); that.optionCache.setSelectedAll(false); return false; })
                ['both,selected'.indexOf(this.options.selectAll)>=0 ? 'show' : 'hide']()
              )
              .append( selListHeader = $('<div></div>').addClass('header-text') )
            )
            .append( selListContent = $('<div></div>').addClass('uix-list-container ui-widget-content') )
        )
        ['right,top'.indexOf(this.options.availableListPosition)>=0?'prepend':'append'](
        $('<div></div>').addClass('multiselect-available-list')
          .append( $('<div></div>').addClass('ui-widget-header')
            .append( btnSelectAll = $('<button></button>', { type:"button" }).addClass('uix-control-right')
              .attr('data-localekey', 'selectAll')
              .attr('title', this._t('selectAll'))
              .button({icon:'ui-icon-arrowthickstop-1-w', text:false})
              .click(function(e) { e.preventDefault(); e.stopPropagation(); that.optionCache.setSelectedAll(true); return false; })
              ['both,available'.indexOf(this.options.selectAll)>=0 ? 'show' : 'hide']()
            )
            .append( avListHeader = $('<div></div>').addClass('header-text') )

          )
          .append( avListContent  = $('<div></div>').addClass('uix-list-container ui-widget-content') )
      )
        .insertAfter(this.element)
      ;

      this._buttons = {
        'selectAll': btnSelectAll,
        'deselectAll': btnDeselectAll
      };
      this._headers = {
        'selected': selListHeader,
        'available': avListHeader
      };
      this._lists = {
        'selected': selListContent.attr('id', this.scope+'_selListContent'),
        'available': avListContent.attr('id', this.scope+'_avListContent')
      };

      this.optionCache = new OptionCache(this);
      this._searchDelayed = new SearchDelayed(this);

      this._initSearchable();

      this._applyListDroppable();

      this.refresh(this.options.created);
    },

    /**
     * ***************************************
     *   PUBLIC
     * ***************************************
     */

    /**
     * Refresh all the lists from the underlaying element. This method is executed
     * asynchronously from the call, therefore it returns immediately. However, the
     * method accepts a callback parameter which will be executed when the refresh is
     * complete.
     *
     * @param callback   function    a callback function called when the refresh is complete
     */
    refresh: function(callback) {
      this._resize();  // just make sure we display the widget right without delay
      asyncFunction(function() {
        this.optionCache.cleanup();

        var opt, options = this.element[0].childNodes;

        for (var i=0, l1=options.length; i<l1; i++) {
          opt = options[i];
          if (opt.nodeType === 1) {
            if (opt.tagName.toUpperCase() === 'OPTGROUP') {
              var optGroup = $(opt).data('option-group') || (PRE_OPTGROUP + (this.optionGroupIndex++));
              var grpOptions = opt.childNodes;

              this.optionCache.prepareGroup($(opt), optGroup);

              for (var j=0, l2=grpOptions.length; j<l2; j++) {
                opt = grpOptions[j];
                if (opt.nodeType === 1) {
                  this.optionCache.prepareOption($(opt), optGroup);
                }
              }
            } else {
              this.optionCache.prepareOption($(opt));  // add to default group
            }
          }
        }

        this.optionCache.reIndex();

        if (this._searchField && this._searchField.is(':visible')) {
          this._search(null, true);
        }

        if (callback) callback();
      }, 10, this);

    },

    /**
     * Search the list of available items and filter them. If the parameter 'text' is
     * undefined, the actual value from the search field is used. If 'text' is specified,
     * the search field is updated.
     *
     * @param options string|object    (optional) the search options
     */
    search: function(options) {
      if (typeof options != 'object') {
        options = {showInput: true, text: options};
      }

      if ((options.toggleInput != false) && !this._searchField.is(':visible')) {
        this._buttons.search.trigger('click');
      }

      this._search(options.text, !!options.silent);
    },

    /**
     * Dynamically change the locale for the widget. If the specified locale is not
     * found, the default locale will be used. If locale is undefined, the current locale
     * will be returned
     */
    locale: function(locale) {

      if (locale === undefined) {
        return this.options.locale;
      } else {
        this._setLocale(locale);

        this._updateControls();
        this._updateHeaders();
      }
    },

    _destroy: function() {
      this.optionCache.reset(true);
      this._lists['selected'].empty().remove();
      this._lists['available'].empty().remove();
      this._elementWrapper.empty().remove();

      delete this.optionCache;
      delete this._searchDelayed;
      delete this._lists;
      delete this._elementWrapper;

      this.element.removeClass('uix-multiselect-original');
    },

    /**
     * ***************************************
     *   PRIVATE
     * ***************************************
     */

    _initSearchable: function() {
      var isToggle = ('toggle' === this.options.searchField);
      var searchHeader = this.options.searchHeader;

      if (isToggle) {
        var that = this;
        this._buttons['search'] = $('<button></button', { type:"button" }).addClass('uix-control-right')
          .attr('data-localekey', 'search')
          .attr('title', this._t('search'))
          .button({icon:'ui-icon-search', text:false})
          .click(function(e) {
            e.preventDefault(); e.stopPropagation();
            if (that._searchField.is(':visible')) {
              var b = $(this);
              that._headers[searchHeader].css('visibility', 'visible').fadeTo('fast', 1.0);
              that._searchField.hide('slide', {direction: 'right'}, 200, function() { b.removeClass('ui-corner-right ui-state-active').addClass('ui-corner-all'); });
              that._searchDelayed.cancelLastRequest();
              that.optionCache.filter('');
            } else {
              that._headers[searchHeader].fadeTo('fast', 0.1, function() { $(this).css('visibility', 'hidden'); });
              $(this).removeClass('ui-corner-all').addClass('ui-corner-right ui-state-active');
              that._searchField.show('slide', {direction: 'right'}, 200, function() { $(this).focus(); });
              that._search();
            }
            return false;
          })
          .insertBefore( this._headers[searchHeader] );
      }
      if (this.options.searchField) {
        if (!isToggle) {
          this._headers[searchHeader].hide();
        }
        this._searchField = $('<input type="text" />').addClass('uix-search ui-widget-content ui-corner-' + (isToggle ? 'left' : 'all'))[isToggle ? 'hide' : 'show']()
          .insertBefore( this._headers[searchHeader] )
          .focus(function() { $(this).select(); })
          .on("keydown keypress", function(e) { if (e.keyCode == 13) { e.preventDefault(); e.stopPropagation(); return false; } })
          .keyup($.proxy(this._searchDelayed.request, this._searchDelayed));
      }
    },

    _applyListDroppable: function() {
      if (this.options.selectionMode.indexOf('d&d') == -1) return;

      var _optionCache = this.optionCache;
      var currentScope = this.scope;

      var getElementData = function(d) {
        return _optionCache._elements[d.data('element-index')];
      };

      var initDroppable = function(e, s) {
        e.droppable({
          accept: function(draggable) {
            var eData = getElementData(draggable);
            return eData && (eData.selected != s);  // from different seleciton only
          },
          activeClass: 'ui-state-highlight',
          scope: currentScope,
          drop: function(evt, ui) {
            ui.draggable.removeClass('ui-state-disabled');
            ui.helper.remove();
            _optionCache.setSelected(getElementData(ui.draggable), s);
          }
        });
      }

      initDroppable(this._lists['selected'], true);
      initDroppable(this._lists['available'], false);

      if (this.options.sortable) {
        var that = this;
        this._lists['selected'].sortable({
          appendTo: 'parent',
          axis: "y",
          containment: $('.multiselect-selected-list', this._elementWrapper), //"parent",
          items: '.multiselect-element-wrapper',
          handle: '.group-element',
          revert: true,
          stop: $.proxy(function(evt, ui) {
            var prevGroup;
            $('.multiselect-element-wrapper', that._lists['selected']).each(function() {
              var currGroup = that.optionCache._groups.get($(this).data('option-group'));
              if (!prevGroup) {
                that.element.append(currGroup.groupElement);
              } else {
                currGroup.groupElement.insertAfter(prevGroup.groupElement);
              }
              prevGroup = currGroup;
            });
          }, this)
        });
      }
    },

    _search: function(term, silent) {
      if (this._searchField.is(':visible')) {
        if (typeof term === "string") {   // issue #36
          this._searchField.val(term);
        } else {
          term = this._searchField.val();
        }
      }

      this.optionCache.filter(term, silent);
    },

    _setLocale: function(locale) {
      if (locale == 'auto') {
        locale = navigator.userLanguage ||
          navigator.language ||
          navigator.browserLanguage ||
          navigator.systemLanguage ||
          '';
      }
      if (!$.uix.multiselect.i18n[locale]) {
        locale = '';   // revert to default is not supported auto locale
      }
      this.options.locale = locale;
    },

    _t: function(key, plural, data) {
      return _({locale:this.options.locale, key:key, plural:plural, data:data});
    },

    _updateControls: function() {
      var that = this;
      $('.uix-control-left,.uix-control-right', this._elementWrapper).each(function() {
        $(this).attr('title', that._t( $(this).attr('data-localekey') ));
      });
    },

    _updateHeaders: function() {
      var t, info = this.optionCache.getSelectionInfo();

      this._headers['selected']
        .text( t = this._t('itemsSelected', info.selected.total, {count:info.selected.total}) )
        .parent().attr('title',
        this.options.filterSelected
          ? this._t('itemsSelected', info.selected.count, {count:info.selected.count}) + ", " +
          this._t('itemsFiltered', info.selected.filtered, {count:info.selected.filtered})
          : t
      );
      this._headers['available']
        .text( this._t('itemsAvailable', info.available.total, {count:info.available.total}) )
        .parent().attr('title',
        this._t('itemsAvailable', info.available.count, {count:info.available.count}) + ", " +
        this._t('itemsFiltered', info.available.filtered, {count:info.available.filtered}) );
    },

    // call this method whenever the widget resizes
    // NOTE : the widget MUST be visible and have a width and height when calling this
    _resize: function() {
      var pos = this.options.availableListPosition.toLowerCase();         // shortcut
      var sSize = ('left,right'.indexOf(pos) >= 0) ? 'Width' : 'Height';  // split size fn
      var tSize = ('left,right'.indexOf(pos) >= 0) ? 'Height' : 'Width';  // total size fn
      var cSl = this.element['outer'+sSize]() * this.options.splitRatio;  // list container size selected
      var cAv = this.element['outer'+sSize]() - cSl;                      // ... available
      var hSl = (tSize === 'Width') ? cSl : this.element.outerHeight();   // scrollable area size selected
      var hAv = (tSize === 'Width') ? cAv : this.element.outerHeight();   // ... available
      var styleRule = ('left,right'.indexOf(pos) >= 0) ? 'left' : 'top';  // CSS rule for offsetting
      var swap = ('left,top'.indexOf(pos) >= 0);                          // true if we swap left-right or top-bottom
      var isToggle = ('toggle' === this.options.searchField);             // true if search field is toggle-able
      var headerBordersBoth = 'ui-corner-tl ui-corner-tr ui-corner-bl ui-corner-br ui-corner-top';
      var hSlCls = (tSize === 'Width') ? (swap ? '' : 'ui-corner-top') : (swap ? 'ui-corner-tr' : 'ui-corner-tl');
      var hAvCls = (tSize === 'Width') ? (swap ? 'ui-corner-top' : '') : (swap ? 'ui-corner-tl' : 'ui-corner-tr');

      // calculate outer lists dimensions
      this._elementWrapper.find('.multiselect-available-list')
        [sSize.toLowerCase()](cAv).css(styleRule, swap ? 0 : cSl)
        [tSize.toLowerCase()](this.element['outer'+tSize]() + 1);  // account for borders
      this._elementWrapper.find('.multiselect-selected-list')
        [sSize.toLowerCase()](cSl).css(styleRule, swap ? cAv : 0)
        [tSize.toLowerCase()](this.element['outer'+tSize]() + 1); // account for borders

      // selection all button
      this._buttons['selectAll'].button('option', 'icons', {primary: transferIcon(pos, 'ui-icon-arrowthickstop-1-', false) });
      this._buttons['deselectAll'].button('option', 'icons', {primary: transferIcon(pos, 'ui-icon-arrowthickstop-1-', true) });

      // header borders
      this._headers['available'].parent().removeClass(headerBordersBoth).addClass(hAvCls);
      this._headers['selected'].parent().removeClass(headerBordersBoth).addClass(hSlCls);

      // make both headers equal!
      if (!isToggle) {
        var h = Math.max(this._headers['selected'].parent().height(), this._headers['available'].parent().height());
        this._headers['available'].parent().height(h);
        this._headers['selected'].parent().height(h);
      }
      // adjust search field width
      if (this._searchField) {
        this._searchField.width( (sSize === 'Width' ? cAv : this.element.width()) - (isToggle ? 52 : 26) );  // issue #50
      }

      // calculate inner lists height
      this._lists['available'].height(hAv - this._headers['available'].parent().outerHeight() - 2);  // account for borders
      this._lists['selected'].height(hSl - this._headers['selected'].parent().outerHeight() - 2);    // account for borders
    },

    /**
     * return false if the event was prevented by an handler, true otherwise
     */
    _triggerUIEvent: function(event, ui) {
      var eventType;

      if (typeof event === 'string') {
        eventType = event;
        event = $.Event(event);
      } else {
        eventType = event.type;
      }

      //console.log($.inArray(event.type, NATIVE_EVENTS));

      //if ($.inArray(event.type, NATIVE_EVENTS) > -1) {
      this.element.trigger(event, ui);
      //} else {
      //    this._trigger(eventType, event, ui);
      //}

      return !event.isDefaultPrevented();
    },

    _setOption: function(key, value) {
      // Use the _setOption method to respond to changes to options
      switch(key) {
        // TODO
      }
      if (typeof(this._superApply) == 'function'){
        this._superApply(arguments);
      }else{
        $.Widget.prototype._setOption.apply(this, arguments);
      }
    }
  });



  /**
   * Comparator registry.
   *
   * function(a, b, g)   where a is compared to b and g is true if they are groups
   */
  var ItemComparators = {
    /**
     * Naive general implementation
     */
    standard: function(a, b) {
      if (a > b) return 1;
      if (a < b) return -1;
      return 0;
    },
    /*
     * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
     * Author: Jim Palmer (based on chunking idea from Dave Koelle)
     */
    natural: function naturalSort(a, b) {
      var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
        sre = /(^[ ]*|[ ]*$)/g,
        dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
        hre = /^0x[0-9a-f]+$/i,
        ore = /^0/,
        i = function(s) { return naturalSort.insensitive && (''+s).toLowerCase() || ''+s },
        // convert all to strings strip whitespace
        x = i(a).replace(sre, '') || '',
        y = i(b).replace(sre, '') || '',
        // chunk/tokenize
        xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
        yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
        // numeric, hex or date detection
        xD = parseInt(x.match(hre)) || (xN.length != 1 && x.match(dre) && Date.parse(x)),
        yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null,
        oFxNcL, oFyNcL;
      // first try and sort Hex codes or Dates
      if (yD)
        if ( xD < yD ) return -1;
        else if ( xD > yD ) return 1;
      // natural sorting through split numeric strings and default strings
      for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
        // find floats not starting with '0', string or 0 if not defined (Clint Priest)
        oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
        oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
        // handle numeric vs string comparison - number < string - (Kyle Adams)
        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
        // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
        else if (typeof oFxNcL !== typeof oFyNcL) {
          oFxNcL += '';
          oFyNcL += '';
        }
        if (oFxNcL < oFyNcL) return -1;
        if (oFxNcL > oFyNcL) return 1;
      }
      return 0;
    }
  };


  var transferDirection = ['n','e','s','w'];                          // button icon direction
  var transferOrientation = ['bottom','left','top','right'];    // list of matching directions with icons
  var transferIcon = function(pos, prefix, selected) {
    return prefix + transferDirection[($.inArray(pos.toLowerCase(), transferOrientation) + (selected ? 2 : 0)) % 4];
  };

  /**
   * setTimeout on steroids!
   */
  var asyncFunction = function(callback, timeout, self) {
    var args = Array.prototype.slice.call(arguments, 3);
    return setTimeout(function() {
      callback.apply(self || window, args);
    }, timeout);
  };


  var SearchDelayed = function(widget, options) {
    this._widget = widget;
    this._options = options;
    this._lastSearchValue = null;
  };

  SearchDelayed.prototype = {
    request: function() {
      if (this._widget._searchField.val() == this._lastSearchValue) return;  // prevent searching twice same term

      this.cancelLastRequest();

      this._timeout = asyncFunction(function() {
        this._timeout = null;
        this._lastSearchValue = this._widget._searchField.val();

        this._widget._search();
      }, this._widget.options.searchDelay, this);
    },
    cancelLastRequest: function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
    }
  };

  /**
   * Map of all option groups
   */
  var GroupCache = function(comp) {
    // private members

    var keys = [];
    var items = {};
    var comparator = comp;

    // public methods

    this.setComparator = function(comp) {
      comparator = comp;
      return this;
    };

    this.clear = function() {
      keys = [];
      items = {};
      return this;
    };

    this.containsKey = function(key) {
      return !!items[key];
    };

    this.get = function(key) {
      return items[key];
    };

    this.put = function(key, val) {
      if (!items[key]) {
        if (comparator) {
          keys.splice((function() {
            var low = 0, high = keys.length;
            var mid = -1, c = 0;
            while (low < high) {
              mid = parseInt((low + high)/2);
              var a = items[keys[mid]].groupElement;
              var b = val.groupElement;
              c = comparator(a ? a.attr('label') : DEF_OPTGROUP, b ? b.attr('label') : DEF_OPTGROUP);
              if (c < 0)   {
                low = mid + 1;
              } else if (c > 0) {
                high = mid;
              } else {
                return mid;
              }
            }
            return low;
          })(), 0, key);
        } else {
          keys.push(key);
        }
      }

      items[key] = val;
      return this;
    };

    this.remove = function(key) {
      delete items[key];
      return keys.splice(keys.indexOf(key), 1);
    };

    this.each = function(callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      args.splice(0, 0, null, null);
      for (var i=0, len=keys.length; i<len; i++) {
        args[0] = keys[i];
        args[1] = items[keys[i]];
        callback.apply(args[1], args);
      }
      return this;
    };

  };

  var OptionCache = function(widget) {
    this._widget = widget;
    this._listContainers = {
      'selected': $('<div></div>').appendTo(this._widget._lists['selected']),
      'available': $('<div></div>').appendTo(this._widget._lists['available'])
    };

    this._elements = [];
    this._groups = new GroupCache();

    this._moveEffect = {
      fn: widget.options.moveEffect,
      options: widget.options.moveEffectOptions,
      speed: widget.options.moveEffectSpeed
    };

    this._selectionMode = this._widget.options.selectionMode.indexOf('dblclick') > -1 ? 'dblclick'
      : this._widget.options.selectionMode.indexOf('click') > -1 ? 'click' : false;

    this.reset();
  };

  OptionCache.Options = {
    batchCount: 200,
    batchDelay: 50
  };

  OptionCache.prototype = {
    _createGroupElement: function(grpElement, optGroup, selected) {
      var that = this;
      var gData;

      var getLocalData = function() {
        if (!gData) gData = that._groups.get(optGroup);
        return gData;
      };

      var getGroupName = function() {
        return grpElement ? grpElement.attr('label') : that._widget.options.defaultGroupName;
      };

      var labelCount = $('<span></span>').addClass('label')
        .text(getGroupName() + ' (0)')
        .attr('title', getGroupName() + ' (0)');

      var fnUpdateCount = function() {
        var gDataDst = getLocalData()[selected?'selected':'available'];

        gDataDst.listElement[(!selected && (gDataDst.count || that._widget.options.showEmptyGroups)) || (gDataDst.count && ((gData.optionGroup != DEF_OPTGROUP) || that._widget.options.showDefaultGroupHeader)) ? 'show' : 'hide']();

        var t = getGroupName() + ' (' + gDataDst.count + ')';
        labelCount.text(t).attr('title', t);
      };

      var e = $('<div></div>')
        .addClass('ui-widget-header ui-priority-secondary group-element')
        .append( $('<button></button>', { type:"button" }).addClass('uix-control-right')
          .attr('data-localekey', (selected?'de':'')+'selectAllGroup')
          .attr('title', this._widget._t((selected?'de':'')+'selectAllGroup'))
          .button({icons:{primary:transferIcon(this._widget.options.availableListPosition, 'ui-icon-arrowstop-1-', selected)}, text:false})
          .click(function(e) {
            e.preventDefault(); e.stopPropagation();

            var gDataDst = getLocalData()[selected?'selected':'available'];

            if (gData.count > 0) {
              var _transferedOptions = [];

              that._bufferedMode(true);
              for (var i=gData.startIndex, len=gData.startIndex+gData.count, eData; i<len; i++) {
                eData = that._elements[i];
                if (!eData.filtered && !eData.selected != selected) {
                  that.setSelected(eData, !selected, true);
                  _transferedOptions.push(eData.optionElement[0]);
                }
              }

              that._updateGroupElements(gData);
              that._widget._updateHeaders();

              that._bufferedMode(false);

              that._widget._triggerUIEvent(EVENT_CHANGE, { optionElements:_transferedOptions, selected:!selected} );
            }

            return false;
          })
        )
        .append(labelCount)
      ;

      var fnToggle,
        groupIcon = (grpElement) ? grpElement.attr('data-group-icon') : null;
      if (this._widget.options.collapsableGroups) {
        var collapseIconAttr = (grpElement) ? grpElement.attr('data-collapse-icon') : null,
          grpCollapseIcon = (collapseIconAttr) ? 'ui-icon ' + collapseIconAttr : 'ui-icon ui-icon-triangle-1-s';
        var h = $('<span></span>').addClass('ui-icon collapse-handle')
          .attr('data-localekey', 'collapseGroup')
          .attr('title', this._widget._t('collapseGroup'))
          .addClass(grpCollapseIcon)
          .mousedown(function(e) { e.stopPropagation(); })
          .click(function(e) { e.preventDefault(); e.stopPropagation(); fnToggle(grpElement); return false; })
          .prependTo(e.addClass('group-element-collapsable'))
        ;

        fnToggle = function(grpElement) {
          var gDataDst = getLocalData()[selected?'selected':'available'],
            collapseIconAttr = (grpElement) ? grpElement.attr('data-collapse-icon') : null,
            expandIconAttr = (grpElement) ? grpElement.attr('data-expand-icon') : null,
            collapseIcon = (collapseIconAttr) ? 'ui-icon ' + collapseIconAttr : 'ui-icon ui-icon-triangle-1-s',
            expandIcon = (expandIconAttr) ? 'ui-icon ' + expandIconAttr : 'ui-icon ui-icon-triangle-1-e';
          gDataDst.collapsed = !gDataDst.collapsed;
          gDataDst.listContainer.slideToggle();  // animate options?
          h.removeClass(gDataDst.collapsed ? collapseIcon : expandIcon)
            .addClass(gDataDst.collapsed ? expandIcon : collapseIcon);
        };
      }else{
        if (groupIcon) {
          $('<span></span>').addClass('collapse-handle '+groupIcon)
            .css('cursor','default')
            .prependTo(e.addClass('group-element-collapsable'));
        }
      }
      return $('<div></div>')
      // create an utility function to update group element count
        .data('fnUpdateCount', fnUpdateCount)
        .data('fnToggle', fnToggle || $.noop)
        .append(e)
        ;
    },

    _createGroupContainerElement: function(grpElement, optGroup, selected) {
      var that = this;
      var e = $('<div></div>');
      var _received_index;

      if (this._widget.options.sortable && selected) {
        e.sortable({
          tolerance: "pointer",
          appendTo: this._widget._elementWrapper,
          connectWith: this._widget._lists['available'].attr('id'),
          scope: this._widget.scope,
          helper: 'clone',
          receive: function(evt, ui) {
            var e = that._elements[_received_index = ui.item.data('element-index')];

            e.selected = true;
            e.optionElement.prop('selected', true);
            e.listElement.removeClass('ui-state-active');
          },
          stop: function(evt, ui) {
            var e;
            if (_received_index != undefined) {
              e = that._elements[_received_index];
              _received_index = undefined;
              ui.item.replaceWith(e.listElement.addClass('ui-state-highlight option-selected'));
              that._widget._updateHeaders();
              that._widget._triggerUIEvent(EVENT_CHANGE, { optionElements:[e.optionElement[0]], selected:true } );
            } else {
              e = that._elements[ui.item.data('element-index')];
              if (e && !e.selected) {
                that._bufferedMode(true);
                that._appendToList(e);
                that._bufferedMode(false);
              }
              else {
                that._widget._triggerUIEvent(EVENT_REORDERED, { } );
              }
            }
            if (e) that._reorderSelected(e.optionGroup);
          },
          revert: true
        });
      }

      if (this._selectionMode) {
        $(e).on(this._selectionMode, 'div.option-element', function() {
          var eData = that._elements[$(this).data('element-index')];
          eData.listElement.removeClass('ui-state-hover');
          that.setSelected(eData, !selected);
        });
      }

      return e;
    },

    _createElement: function(optElement, optGroup) {
      var o = this._widget.options.optionRenderer
        ? this._widget.options.optionRenderer(optElement, optGroup)
        : $('<div></div>').text(optElement.text());
      var optIcon = optElement.attr("data-option-icon");
      var e = $('<div></div>').append(o).addClass('ui-state-default option-element')
        .attr("unselectable", "on")  // disable text selection on this element (IE, Opera)
        .data('element-index', -1)
        .hover(
          function() {
            if (optElement.prop('selected')) $(this).removeClass('ui-state-highlight');
            $(this).addClass('ui-state-hover');
          },
          function() {
            $(this).removeClass('ui-state-hover');
            if (optElement.prop('selected')) $(this).addClass('ui-state-highlight');
          }
        );
      if (this._widget.options.selectionMode.indexOf('d&d') > -1) {
        var that = this;
        e.draggable({
          addClasses: false,
          cancel: (this._widget.options.sortable ? '.option-selected, ' : '') + '.ui-state-disabled',
          appendTo: this._widget._elementWrapper,
          scope: this._widget.scope,
          start: function(evt, ui) {
            $(this).addClass('ui-state-disabled ui-state-active');
            ui.helper.width($(this).width()).height($(this).height());
          },
          stop: function(evt, ui) {
            $(this).removeClass('ui-state-disabled ui-state-active');
          },
          helper: 'clone',
          revert: 'invalid',
          zIndex: 99999,
          disabled: optElement.prop('disabled')
        });
        if (optElement.prop('disabled')) {
          e.addClass('ui-state-disabled');
        }
        if (this._widget.options.sortable) {
          e.draggable('option', 'connectToSortable', this._groups.get(optGroup)['selected'].listContainer);
        }
      } else if (optElement.prop('disabled')) {
        e[(optElement.prop('disabled') ? "add" : "remove") + "Class"]('ui-state-disabled');
      }
      if (optIcon) {
        e.addClass('grouped-option').prepend($('<span></span>').addClass('ui-icon ' + optIcon));
      }
      return e;
    },

    _isOptionCollapsed: function(eData) {
      return this._groups.get(eData.optionGroup)[eData.selected?'selected':'available'].collapsed;
    },

    _updateGroupElements: function(gData) {
      if (gData) {
        gData['selected'].count = 0;
        gData['available'].count = 0;
        for (var i=gData.startIndex, len=gData.startIndex+gData.count; i<len; i++) {
          gData[this._elements[i].selected?'selected':'available'].count++;
        }
        gData['selected'].listElement.data('fnUpdateCount')();
        gData['available'].listElement.data('fnUpdateCount')();
      } else {
        this._groups.each(function(k,gData,that) {
          that._updateGroupElements(gData);
        }, this);
      }
    },

    _appendToList: function(eData) {
      var that = this;
      var gData = this._groups.get(eData.optionGroup);

      var gDataDst = gData[eData.selected?'selected':'available'];

      if ((eData.optionGroup != this._widget.options.defaultGroupName) || this._widget.options.showDefaultGroupHeader) {
        gDataDst.listElement.show();
      }
      if (gDataDst.collapsed) {
        gDataDst.listElement.data('fnToggle')(); // animate show?
      } else {
        gDataDst.listContainer.show();
      }

      var insertIndex = eData.index - 1;
      while ((insertIndex >= gData.startIndex) &&
      (this._elements[insertIndex].selected != eData.selected)) {
        insertIndex--;
      }

      if (insertIndex < gData.startIndex) {
        gDataDst.listContainer.prepend(eData.listElement);
      } else {
        var prev = this._elements[insertIndex].listElement;
        // FIX : if previous element is animated, get it's animated parent as reference
        if (prev.parent().hasClass('ui-effects-wrapper')) {
          prev = prev.parent();
        }
        eData.listElement.insertAfter(prev);
      }
      eData.listElement[(eData.selected?'add':'remove')+'Class']('ui-state-highlight option-selected');

      if ((eData.selected || !eData.filtered) && !this._isOptionCollapsed(eData) && this._moveEffect && this._moveEffect.fn) {
        eData.listElement.hide().show(this._moveEffect.fn, this._moveEffect.options, this._moveEffect.speed);
      } else if (eData.filtered) {
        eData.listElement.hide();
      }
    },

    _reorderSelected: function(optGroup) {
      var e = this._elements;
      var g = this._groups.get(optGroup);
      var container = g.groupElement ? g.groupElement : this._widget.element;
      var prevElement;
      $('.option-element', g['selected'].listContainer).each(function() {
        var currElement = e[$(this).data('element-index')].optionElement;
        if (!prevElement) {
          container.prepend(currElement);
        } else {
          currElement.insertAfter(prevElement);
        }
        prevElement = currElement;
      });
      this._widget._triggerUIEvent(EVENT_REORDERED, { selectElement:container.context } );
    },

    _bufferedMode: function(enabled) {
      if (enabled) {
        this._oldMoveEffect = this._moveEffect; this._moveEffect = null;

        // backup lists' scroll position before going into buffered mode
        this._widget._lists['selected'].data('scrollTop', this._widget._lists['selected'].scrollTop());
        this._widget._lists['available'].data('scrollTop', this._widget._lists['available'].scrollTop());

        this._listContainers['selected'].detach();
        this._listContainers['available'].detach();
      } else {
        // restore scroll position (if available)
        this._widget._lists['selected'].append(this._listContainers['selected'])
          .scrollTop( this._widget._lists['selected'].data('scrollTop') || 0 );
        this._widget._lists['available'].append(this._listContainers['available'])
          .scrollTop( this._widget._lists['available'].data('scrollTop') || 0 );

        this._moveEffect = this._oldMoveEffect;

        delete this._oldMoveEffect;
      }

    },

    reset: function(destroy) {
      this._groups.clear();
      this._listContainers['selected'].empty();
      this._listContainers['available'].empty();

      if (destroy) {
        for (var i=0, e=this._elements, len=e.length; i<len; i++) {
          e[i].optionElement.removeData('element-index');
        }
        delete this._elements;
        delete this._groups;
        delete this._listContainers;
      } else {
        this._elements = [];
        this.prepareGroup();  // reset default group
        this._groups.setComparator(this.getComparator());
      }
    },

    // should call _reIndex after this
    cleanup: function() {
      var p = this._widget.element[0];
      var _groupsRemoved = [];
      this._groups.each(function(g,v) {
        if (v.groupElement && !$.contains(p, v.groupElement[0])) {
          _groupsRemoved.push(g);
        }
      });
      for (var i=0, eData; i<this._elements.length; i++) {
        eData = this._elements[i];
        if (!$.contains(p, eData.optionElement[0]) || ($.inArray(eData.optionGroup, _groupsRemoved) > -1)) {
          this._elements.splice(i--, 1)[0].listElement.remove();
        }
      }
      for (var i=0, len=_groupsRemoved.length; i<len; i++) {
        this._groups.remove(_groupsRemoved[i]);
      }

      this.prepareGroup();  // make sure we have the default group still!
    },

    getComparator: function() {
      return this._widget.options.sortMethod
        ? typeof this._widget.options.sortMethod == 'function'
          ? this._widget.options.sortMethod
          : ItemComparators[this._widget.options.sortMethod]
        : null;
    },

    // prepare option group to be rendered (should call reIndex after this!)
    prepareGroup: function(grpElement, optGroup) {
      optGroup = optGroup || DEF_OPTGROUP;
      if (!this._groups.containsKey(optGroup)) {
        this._groups.put(optGroup, {
          startIndex: -1,
          count: 0,
          'selected': {
            collapsed: false,
            count: 0,
            listElement: this._createGroupElement(grpElement, optGroup, true),
            listContainer: this._createGroupContainerElement(grpElement, optGroup, true)
          },
          'available': {
            collapsed: false,
            count: 0,
            listElement: this._createGroupElement(grpElement, optGroup, false),
            listContainer: this._createGroupContainerElement(grpElement, optGroup, false)
          },
          groupElement: grpElement,
          optionGroup: optGroup     // for back ref
        });
      }
    },

    // prepare option element to be rendered (must call reIndex after this!)
    // If optGroup is defined, prepareGroup(optGroup) should have been called already
    prepareOption: function(optElement, optGroup) {
      var e;
      if (optElement.data('element-index') === undefined) {
        optGroup = optGroup || DEF_OPTGROUP;
        this._elements.push(e = {
          index: -1,
          selected: false,
          filtered: false,
          listElement: this._createElement(optElement, optGroup),
          optionElement: optElement,
          optionGroup: optGroup
        });
      } else {
        this._elements[optElement.data('element-index')]
          .listElement[(optElement.prop('disabled') ? "add" : "remove") + "Class"]('ui-state-disabled')
        ;
      }

    },

    reIndex: function() {
      // note : even if not sorted, options are added as they appear,
      //        so they should be grouped just fine anyway!
      var comparator = this.getComparator();
      if (comparator) {
        var _groups = this._groups;
        this._elements.sort(function(a, b) {
          // sort groups
          var ga = _groups.get(a.optionGroup).groupElement;
          var gb = _groups.get(b.optionGroup).groupElement;
          var g = comparator(ga ? ga.attr('label') : DEF_OPTGROUP, gb ? gb.attr('label') : DEF_OPTGROUP);
          if (g != 0) return g;
          else        return comparator(a.optionElement.text(), b.optionElement.text());
        });
      }

      this._bufferedMode(true);

      this._groups.each(function(g, v, l, showDefGroupName) {
        if (!v['available'].listContainer.parents('.multiselect-element-wrapper').length) {  // if no parent, then it was never attached yet.
          if (v.groupElement) {
            v.groupElement.data('option-group', g);  // for back ref
          }

          var wrapper_selected = $('<div></div>').addClass('multiselect-element-wrapper').data('option-group', g);
          var wrapper_available = $('<div></div>').addClass('multiselect-element-wrapper').data('option-group', g);
          wrapper_selected.append(v.selected.listElement.hide());
          if (g != DEF_OPTGROUP || (g == DEF_OPTGROUP && showDefGroupName)) {
            wrapper_available.append(v['available'].listElement.show());
          }
          wrapper_selected.append(v['selected'].listContainer);
          wrapper_available.append(v['available'].listContainer);

          l['selected'].append(wrapper_selected);
          l['available'].append(wrapper_available);
        }
        v.count = 0;
      }, this._listContainers, this._widget.options.showDefaultGroupHeader);

      for (var i=0, eData, gData, len=this._elements.length; i<len; i++) {
        eData = this._elements[i];
        gData = this._groups.get(eData.optionGroup);

        // update group index and count info
        if (gData.startIndex == -1 || gData.startIndex >= i) {
          gData.startIndex = i;
          gData.count = 1;
        } else {
          gData.count++;
        }

        // save element index for back ref
        eData.listElement.data('element-index', eData.index = i);

        if (eData.optionElement.data('element-index') == undefined || eData.selected != eData.optionElement.prop('selected')) {
          eData.selected = eData.optionElement.prop('selected');
          eData.optionElement.data('element-index', i);  // also save for back ref here

          this._appendToList(eData);
        }
      }

      this._updateGroupElements();
      this._widget._updateHeaders();
      this._groups.each(function(g,v,t) { t._reorderSelected(g); }, this);

      this._bufferedMode(false);

    },

    filter: function(term, silent) {

      if (term && !silent) {
        var ui = { term:term };
        if (this._widget._triggerUIEvent(EVENT_SEARCH, ui )) {
          term = ui.term;  // update term
        } else {
          return;
        }
      }

      this._bufferedMode(true);

      var filterSelected = this._widget.options.filterSelected;
      var filterFn = this._widget.options.searchFilter || function(term, opt) {
          return opt.innerHTML.toLocaleLowerCase().indexOf(term) > -1;
        };
      term = (this._widget.options.searchPreFilter || function(term) {
        return term ? (term+"").toLocaleLowerCase() : false;
      })(term);

      for (var i=0, eData, len=this._elements.length, filtered; i<len; i++) {
        eData = this._elements[i];
        filtered = !(!term || filterFn(term, eData.optionElement[0]));

        if ((!eData.selected || filterSelected) && (eData.filtered != filtered)) {
          eData.listElement[filtered ? 'hide' : 'show']();
          eData.filtered = filtered;
        } else if (eData.selected) {
          eData.filtered = filtered;
        }
      }

      this._widget._updateHeaders();
      this._bufferedMode(false);
    },

    getSelectionInfo: function() {
      var info = {'selected': {'total': 0, 'count': 0, 'filtered': 0}, 'available': {'total': 0, 'count': 0, 'filtered': 0} };

      for (var i=0, len=this._elements.length; i<len; i++) {
        var eData = this._elements[i];
        info[eData.selected?'selected':'available'][eData.filtered?'filtered':'count']++;
        info[eData.selected?'selected':'available'].total++;
      }

      return info;
    },

    setSelected: function(eData, selected, silent) {
      if (eData.optionElement.attr('disabled') && selected) {
        return;
      }

      eData.optionElement.prop('selected', eData.selected = selected);

      this._appendToList(eData);

      if (!silent) {
        if (this._widget.options.sortable && selected) {
          this._reorderSelected(eData.optionGroup);
        }
        this._updateGroupElements(this._groups.get(eData.optionGroup));
        this._widget._updateHeaders();
        this._widget._triggerUIEvent(EVENT_CHANGE, { optionElements:[eData.optionElement[0]], selected:selected } );
      }
    },

    // utility function to select all options
    setSelectedAll: function(selected) {
      var _transferedOptions = [];
      var _modifiedGroups = {};

      this._bufferedMode(true);

      for (var i=0, eData, len=this._elements.length; i<len; i++) {
        eData = this._elements[i];
        if (!((eData.selected == selected) || (eData.optionElement.attr('disabled') || (selected && (eData.filtered || eData.selected))))) {
          this.setSelected(eData, selected, true);
          _transferedOptions.push(eData.optionElement[0]);
          _modifiedGroups[eData.optionGroup] = true;
        }
      }

      if (this._widget.options.sortable && selected) {
        var that = this;
        $.each(_modifiedGroups, function(g) {  that._reorderSelected(g); });
      }

      this._updateGroupElements();
      this._widget._updateHeaders();
      this._bufferedMode(false);

      this._widget._triggerUIEvent(EVENT_CHANGE, { optionElements:_transferedOptions, selected:selected } );
    }

  };

  /**
   * Expects paramter p to be
   *
   *   locale        (string) the locale to use (default = '')
   *   key           (string) the locale string key
   *   plural        (int)    the plural value to use
   *   data          (object) the data object to use as variables
   *
   */
  function _(p) {
    var locale = $.uix.multiselect.i18n[p.locale] ? p.locale : '';
    var i18n = $.uix.multiselect.i18n[locale];
    var plural = p.plural || 0;
    var data = p.data || {};
    var t;

    if (plural === 2 && i18n[p.key+'_plural_two']) {
      t = i18n[p.key+'_plural_two'];
    } else if ((plural === 2 || plural === 3) && i18n[p.key+'_plural_few']) {
      t = i18n[p.key+'_plural_few']
    } else if (plural > 1 && i18n[p.key+'_plural']) {
      t = i18n[p.key+'_plural'];
    } else if (plural === 0 && i18n[p.key+'_nil']) {
      t = i18n[p.key+'_nil'];
    } else {
      t = i18n[p.key] || '';
    }

    return t.replace(/\{([^\}]+)\}/g, function(m, n) { return data[n]; });
  };

  /**
   * Default translation
   */
  $.uix.multiselect.i18n = {
    '': {
      itemsSelected_nil: 'No items',          // 0
      itemsSelected: '{count} items',          // 0, 1
      itemsSelected_plural: '{count} items',  // n
      //itemsSelected_plural_two: ...                    // 2
      //itemsSelected_plural_few: ...                    // 3, 4
      itemsAvailable_nil: 'No items',
      itemsAvailable: '{count} item',
      itemsAvailable_plural: '{count} items',
      //itemsAvailable_plural_two: ...
      //itemsAvailable_plural_few: ...
      itemsFiltered_nil: 'None found',
      itemsFiltered: '{count} item',
      itemsFiltered_plural: '{count} items',
      //itemsFiltered_plural_two: ...
      //itemsFiltered_plural_few: ...
      selectAll: 'Select All',
      deselectAll: 'Deselect All',
      search: 'Search Options',
      collapseGroup: 'Collapse Group',
      expandGroup: 'Expand Group',
      selectAllGroup: 'Select All Group',
      deselectAllGroup: 'Deselect All Group'
    }
  };

})(jQuery, window);
},{}],11:[function(require,module,exports){
'use strict';
// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.

var styleElementsInsertedAtTop = [];

var insertStyleElement = function(styleElement, options) {
    var head = document.head || document.getElementsByTagName('head')[0];
    var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];

    options = options || {};
    options.insertAt = options.insertAt || 'bottom';

    if (options.insertAt === 'top') {
        if (!lastStyleElementInsertedAtTop) {
            head.insertBefore(styleElement, head.firstChild);
        } else if (lastStyleElementInsertedAtTop.nextSibling) {
            head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
        } else {
            head.appendChild(styleElement);
        }
        styleElementsInsertedAtTop.push(styleElement);
    } else if (options.insertAt === 'bottom') {
        head.appendChild(styleElement);
    } else {
        throw new Error('Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.');
    }
};

module.exports = {
    // Create a <link> tag with optional data attributes
    createLink: function(href, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0];
        var link = document.createElement('link');

        link.href = href;
        link.rel = 'stylesheet';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            link.setAttribute('data-' + key, value);
        }

        head.appendChild(link);
    },
    // Create a <style> tag with optional data attributes
    createStyle: function(cssText, attributes, extraOptions) {
        extraOptions = extraOptions || {};

        var style = document.createElement('style');
        style.type = 'text/css';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            style.setAttribute('data-' + key, value);
        }

        if (style.sheet) { // for jsdom and IE9+
            style.innerHTML = cssText;
            style.sheet.cssText = cssText;
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
        } else if (style.styleSheet) { // for IE8 and below
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
            style.styleSheet.cssText = cssText;
        } else { // for Chrome, Firefox, and Safari
            style.appendChild(document.createTextNode(cssText));
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
        }
    }
};

},{}],12:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.2.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ name ] );

	// Fall back to offsetWidth/Height when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === "auto" ) {
		val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var doc, docElem, rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;

		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],13:[function(require,module,exports){
/**
 *
 * This module provides routines for dealing with arrays.
 *
 * @module dex/array
 *
 */

module.exports = function array(dex) {

  return {
    'unique': function (array) {
      return _.uniq(array);
    },
    'orderedUnique': function (array) {
      var map = {};
      var uniqueArray = [];
      if (Array.isArray(array)) {
        array.forEach(function (elt) {
          if ((typeof map[elt]) == "undefined") {
            uniqueArray.push(elt);
            map[elt] = 1;
          }
        });
      }
      return uniqueArray;
    },
    /**
     *
     * Take a slice of an array without modifying the original array.
     *
     * dex.array.slice(array) - Return a copy of the array.
     * dex.array.slice(array, rowRange) - Copy the array, then return a slice
     * within the specified range.
     * dex.array.slice(array, rowRange, maxRows) - Copy the array, then return a slice
     * within the specified range up to, but not exceeding, maxRows rows.
     *
     * @param (array) array - The array to slice.
     * @param (array|number) rowRange - If supplied an array, the range defined by the of rows to slice.
     * @param {number} maxRows - The maximum number of rows to return.
     *
     * @example {@lang javascript}
     * var myArray = [ 1, 2, 3, 4, 5 ];
     *
     * // Returns: [ 3, 4, 5]
     * slice(myArray, 2);
     *
     * // Returns: [ 1, 3, 5 ]
     * slice(myArray, [0, 2, 4]);
     *
     * // I am not sure why you would do this, but in the interest of supporting
     * // the Principle of Least Surprise, this returns the array unchanged.
     * // Returns: [ 1, 2, 3, 4, 5 ]
     * slice(myArray)
     *
     */
    'slice': function (array, rowRange, maxRows) {
      var arraySlice = [];
      var range;
      var i;

      var arrayCopy = dex.array.copy(array);

      // Numeric.
      // Array.
      // Object.  Numeric with start and end.
      if (arguments.length === 2) {
        if (Array.isArray(rowRange)) {
          range = rowRange;
        }
        else {
          range = dex.range(rowRange, arrayCopy.length - rowRange);
        }
      }
      else if (arguments.length < 2) {
        return arrayCopy;
      }
      else {
        if (Array.isArray(rowRange)) {
          range = rowRange;
        }
        else {
          range = dex.range(rowRange, maxRows);
        }
      }

      //dex.console.log("BEFORE: array.slice(range=" + range + "): arraySlice=" + arraySlice);
      for (i = 0; i < range.length; i++) {
        arraySlice.push(arrayCopy[range[i]]);
      }
      //dex.console.log("AFTER: array.slice(range=" + range + "): arraySlice=" + arraySlice);
      return arraySlice;
    },

    'getPermutations': function (list, maxLen) {
      // Copy initial values as arrays
      var perm = list.map(function (val) {
        return [val];
      });
      // Our permutation generator
      var generate = function (perm, maxLen, currLen) {
        // Reached desired length
        if (currLen === maxLen) {
          return perm;
        }
        // For each existing permutation
        for (var i = 0, len = perm.length; i < len; i++) {
          var currPerm = perm.shift();
          // Create new permutation
          for (var k = 0; k < list.length; k++) {
            perm.push(currPerm.concat(list[k]));
          }
        }
        // Recurse
        return generate(perm, maxLen, currLen + 1);
      };
      // Start with size 1 because of initial values
      return generate(perm, maxLen, 1);
    },

    'getCombinations': function (list, comboLength) {
      var i, j, combs, head, tailcombs;

      // There is no way to take e.g. sets of 5 elements from
      // a set of 4.
      if (comboLength > list.length || comboLength <= 0) {
        return [];
      }

      // K-sized set has only one K-sized subset.
      if (comboLength == list.length) {
        return [list];
      }

      // There is N 1-sized subsets in a N-sized set.
      if (comboLength == 1) {
        combs = [];
        for (i = 0; i < list.length; i++) {
          combs.push([list[i]]);
        }
        return combs;
      }

      // Assert {1 < k < set.length}

      // Algorithm description:
      // To get k-combinations of a set, we want to join each element
      // with all (k-1)-combinations of the other elements. The set of
      // these k-sized sets would be the desired result. However, as we
      // represent sets with lists, we need to take duplicates into
      // account. To avoid producing duplicates and also unnecessary
      // computing, we use the following approach: each element i
      // divides the list into three: the preceding elements, the
      // current element i, and the subsequent elements. For the first
      // element, the list of preceding elements is empty. For element i,
      // we compute the (k-1)-computations of the subsequent elements,
      // join each with the element i, and store the joined to the set of
      // computed k-combinations. We do not need to take the preceding
      // elements into account, because they have already been the i:th
      // element so they are already computed and stored. When the length
      // of the subsequent list drops below (k-1), we cannot find any
      // (k-1)-combs, hence the upper limit for the iteration:
      combs = [];
      for (i = 0; i < list.length - comboLength + 1; i++) {
        // head is a list that includes only our current element.
        head = list.slice(i, i + 1);
        // We take smaller combinations from the subsequent elements
        tailcombs = dex.array.getCombinations(list.slice(i + 1), comboLength - 1);
        // For each (k-1)-combination we join it with the current
        // and store it to the set of k-combinations.
        for (j = 0; j < tailcombs.length; j++) {
          combs.push(head.concat(tailcombs[j]));
        }
      }
      return combs;
    },

    /**
     *
     * Returns an array of the mathematically smallest and largest
     * elements within the array.
     *
     * @param matrix The array to evaluate.
     * @param indices The array indices to be considered in the evaluation.
     *
     * @returns {Array} - An array consisting of [ min, max ] of the array.
     *
     */
    'extent': function (matrix, indices) {
      if (!matrix || matrix.length <= 0 || !indices || indices.length <= 0) {
        return [0, 0];
      }

      var min = matrix[0][indices[0]];
      var max = min;

      indices.forEach(function (ci) {
        matrix.forEach(function (row) {
          if (min > row[ci]) {
            min = row[ci];
          }
          if (max < row[ci]) {
            max = row[ci];
          }
        });
      });
      return [min, max];
    },

    /**
     *
     * Return a distinct copy of an array.
     *
     * @param {Array} array The array to copy.
     * @returns {Array} The copy of the array.
     *
     */
    'copy': function (array) {
      // Shallow copy
      return _.clone(array);
      // Deep copy:
      //return $.extend(true, {}, array);
    },
    'combine': function(array1, array2) {
      var a1 = dex.array.copy(array1);
      var a2 = dex.array.copy(array2);
      return a1.concat(a2);
    },
    'isNumeric': function (array) {
      return array.every(dex.object.isNumeric);
    }
  };
};
},{}],14:[function(require,module,exports){
/**
 *
 * This module provides a C3 Area Chart.
 *
 * @name dex/charts/c3/AreaChart
 *
 * @param userConfig
 * @returns AreaChart
 */
var areachart = function (userConfig) {
  var defaults = {
    'parent': '#C3AreaChartParent',
    'id': 'C3AreaChartId',
    'class': 'C3AreaChartClass',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "options": {
      "data.type" : "area-spline"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  dex.console.log("COMBINED_CONFIG", combinedConfig);
  return dex.charts.c3.C3Chart(combinedConfig);
};

module.exports = areachart;
},{}],15:[function(require,module,exports){
/**
 *
 * This module provides a C3 Bar Chart.
 *
 * @name dex/charts/c3/BarChart
 *
 * @param userConfig
 * @returns BarChart
 */
var barchart = function (userConfig) {
  var defaults = {
    'parent': '#C3_BarChart',
    'id': 'C3_BarChart',
    'class': 'C3_BarChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "options": {
      "data.type": "bar"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  return dex.charts.c3.C3Chart(combinedConfig);
};

module.exports = barchart;
},{}],16:[function(require,module,exports){
var c3chart = function (userConfig) {
  var chart;
  var internalChart;

  var defaults = {
    // The parent container of this chart.
    'parent': '#C3ChartParent',
    'id': 'C3ChartId',
    'class': 'C3ChartClass',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'margin': {
      'left': 50,
      'right': 50,
      'top': 20,
      'bottom': 20
    },
    "colorScheme": "category10",
    "draggable": false,
    'csv': {
      'header': [],
      'data': []
    },
    'options': {
      "tooltip.show": true,
      "subchart.show": true,
      "zoom.enabled": true,
      "point.show": true,
      "legend.position": "right"
    }
  };

  chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "C3 Settings",
      "contents": [
        dex.config.gui.general(),
        dex.config.gui.dimensions(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Show Tooltips",
              "description": "If true, show tooltips.",
              "type": "boolean",
              "initialValue": true,
              "target": "options.tooltip.show"
            },
            {
              "name": "Group Tooltips",
              "description": "If true, group tooltips.",
              "type": "boolean",
              "initialValue": true,
              "target": "options.tooltip.grouped"
            },
            {
              "name": "Show Subchart",
              "description": "If true, show subchart.",
              "type": "boolean",
              "initialValue": false,
              "target": "options.subchart.show"
            },
            {
              "name": "Enable Zoom",
              "description": "If true, enable zoom.",
              "type": "boolean",
              "initialValue": true,
              "target": "options.zoom.enabled"
            },
            {
              "name": "Show Points",
              "description": "If true, show points.",
              "type": "boolean",
              "initialValue": true,
              "target": "options.point.show"
            },
            {
              "name": "Show Legend",
              "description": "Location of legend.",
              "type": "boolean",
              "initialValue": true,
              "target": "options.legend.show"
            },
            {
              "name": "Legend Position",
              "description": "Location of legend.",
              "type": "choice",
              "choices": ["right", "bottom", "inset"],
              "initialValue": "right",
              "target": "options.legend.position"
            },
            {
              "name": "Color Scheme",
              "description": "Color Scheme",
              "type": "choice",
              "choices": dex.color.colormaps(),
              "target": "colorScheme"
            },
            {
              "name": "Type",
              "description": "Type of chart",
              "type": "choice",
              "choices": ["line", "spline", "area",
                "area-spline", "bar", "scatter", "step", "donut", "pie"],
              "target": "options.data.type"
            },
            {
              "name": "Stack",
              "description": "Stack items",
              "type": "boolean",
              "initialValue": false,
              "target": "stack"
            },
          ]
        }
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var csv = config.csv;
    d3 = dex.charts.d3.d3v3;
    d3.selectAll(config.parent).selectAll("*").remove();

    config.options.padding = {
      left: +config.margin.left,
      right: +config.margin.right,
      top: +config.margin.top,
      bottom: +config.margin.bottom
    };

    config.options.bindto = config.parent;
    var dataOptions = getDataOptions(csv);
    dex.console.log("PRE-OPTS", config.options);
    config.options =
      dex.config.expandAndOverlay(dataOptions, config.options);
    dex.console.log("C3OPTIONS", JSON.stringify(config.options));
    internalChart = c3.generate(config.options);
    chart.resize();
    dex.config.apply(chart);
    return chart;
  };

  function getDataOptions(csv) {
    var options = {};
    var gtypes = dex.csv.guessTypes(csv);
    var ncsv = dex.csv.numericSubset(csv);
    var columns = dex.csv.transpose(csv);

    ncsv.data.unshift(ncsv.header);
    // Categorical axis
    if (gtypes[0] == "string") {
      // Donut an pie charts are a special case
      if (chart.config && chart.config.options &&
        chart.config.options.data && (
          chart.config.options.data.type == "pie" ||
          chart.config.options.data.type == "donut"
        )) {
        var summary = dex.csv.summary(csv, [0]);

        return {
          data: {
            "columns": summary.data,
            "color": dex.color.getColormap(chart.config.colorScheme)
          }
        }
      }
      else {
        options = {
          data: {
            "rows": ncsv.data,
            "color": dex.color.getColormap(chart.config.colorScheme)
          },
          axis: {
            x: {
              type: "category",
              categories: columns.data[0]
            }
          }
        };
        if (chart.config.stack) {
          options.data.groups = [ncsv.header];
        }
        return options;
      }
    }
    else if (gtypes[0] == "date") {
      var numericIndices = dex.csv.getNumericIndices(csv);
      numericIndices.unshift(0);
      var tcsv = dex.csv.columnSlice(csv, numericIndices);
      tcsv.data.unshift(tcsv.header);
      options = {
        data: {
          "x": tcsv.header[0],
          "rows": tcsv.data,
          "color": dex.color.getColormap(chart.config.colorScheme)
        },
        axis: {
          x: {
            type: "timeseries",
            tick: {
              format: '%Y-%m-%d'
            }
          }
        }
      };

      if (chart.config.stack) {
        options.data.groups = [ncsv.header];
      }
      return options;
    }
    else {
      options = {
        data: {
          "x": ncsv.header[0],
          "rows": ncsv.data,
          "color": dex.color.getColormap(chart.config.colorScheme)
        }
      };

      if (chart.config.stack) {
        options.data.groups = [dex.array.copy(ncsv.header)];
        options.data.groups[0].shift();
      }
      return options;
    }
  }

  chart.update = function () {
    dex.console.log("C3 Chart Update...");
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var csv = config.csv;
    var dataOptions = getDataOptions(csv);
    config.options =
      dex.config.expandAndOverlay(
        dataOptions, config.options);
    dex.console.log("DATA-OPTIONS", dataOptions, "C3OPTIONS", JSON.stringify(config.options));
    internalChart.load(config.options);
    dex.config.apply(chart);
    return chart;
  };

  chart.clone = function clone(override) {
    return c3chart(dex.config.expandAndOverlay(override, userConfig));
  };

  $(document).ready(function () {
    if (chart.config.draggable) {
      $("#" + chart.config.id).draggable();
    }
  });

  return chart;
};

module.exports = c3chart;
},{}],17:[function(require,module,exports){
/**
 *
 * This module provides a C3 Donut Chart.
 *
 * @name dex/charts/c3/DonutChart
 *
 * @param userConfig
 * @returns DonutChart
 */
var donutchart = function (userConfig) {
  var defaults = {
    'parent': '#C3_DonutChart',
    'id': 'C3_DonutChart',
    'class': 'C3_DonutChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "options": {
      "data.type": "donut"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  return dex.charts.c3.C3Chart(combinedConfig);
};

module.exports = donutchart;
},{}],18:[function(require,module,exports){
/**
 *
 * This module provides a C3 Line Chart.
 *
 * @name dex/charts/c3/LineChart
 *
 * @param userConfig
 * @returns LineChart
 */
var linechart = function (userConfig) {
  var defaults = {
    'parent': '#C3_LineChart',
    'id': 'C3_LineChart',
    'class': 'C3_LineChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "options": {
      "data.type": "line"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  return dex.charts.c3.C3Chart(combinedConfig);
};

module.exports = linechart;
},{}],19:[function(require,module,exports){
/**
 *
 * This module provides a C3 Pie Chart.
 *
 * @name dex/charts/c3/PieChart
 *
 * @param userConfig
 * @returns PieChart
 */
var piechart = function (userConfig) {
  var defaults = {
    'parent': '#C3_PieChart',
    'id': 'C3_PieChart',
    'class': 'C3_PieChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "options": {
      "data.type": "pie"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  return dex.charts.c3.C3Chart(combinedConfig);
};

module.exports = piechart;
},{}],20:[function(require,module,exports){
/**
 *
 * This module provides a C3 ScatterPlot
 *
 * @name dex/charts/c3/ScatterPlot
 *
 * @param userConfig
 * @returns ScatterPlot
 */
var scatterplot = function (userConfig) {
  var defaults = {
    'parent': '#C3_ScatterPlot',
    'id': 'C3_ScatterPlot',
    'class': 'C3_ScatterPlot',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "options": {
      "data.type": "scatter"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  return dex.charts.c3.C3Chart(combinedConfig);
};

module.exports = scatterplot;
},{}],21:[function(require,module,exports){
/**
 *
 * This module provides a C3 StackedArea Chart.
 *
 * @name dex/charts/c3/StackedAreaChart
 *
 * @param userConfig
 * @returns StackedAreaChart
 */
var stackedareachart = function (userConfig) {
  var defaults = {
    'parent': '#C3_StackedAreaChart',
    'id': 'C3_StackedAreaChart',
    'class': 'C3_StackedAreaChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "stack" : true,
    "options": {
      "data.type": "area"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  return dex.charts.c3.C3Chart(combinedConfig);
};

module.exports = stackedareachart;
},{}],22:[function(require,module,exports){
/**
 *
 * This module provides a C3 StackedBar Chart.
 *
 * @name dex/charts/c3/StackedBarChart
 *
 * @param userConfig
 * @returns StackedBarChart
 */
var stackedbarchart = function (userConfig) {
  var chart;

  var defaults = {
    'parent': '#C3_StackedBarChart',
    'id': 'C3_StackedBarChart',
    'class': 'C3_StackedBarChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    "stack" : true,
    "options": {
      "data.type": "bar"
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.c3.C3Chart(combinedConfig);

  return chart;
};

module.exports = stackedbarchart;
},{}],23:[function(require,module,exports){
/**
 * @module dex/charts/c3
 */
var c3 = {};

c3.C3Chart = require("./C3Chart");
c3.PieChart = require("./PieChart");
c3.DonutChart = require("./DonutChart");
c3.AreaChart = require("./AreaChart");
c3.BarChart = require("./BarChart");
c3.LineChart = require("./LineChart");
c3.ScatterPlot = require("./ScatterPlot");
c3.StackedAreaChart = require("./StackedAreaChart");
c3.StackedBarChart = require("./StackedBarChart");

module.exports = c3;
},{"./AreaChart":14,"./BarChart":15,"./C3Chart":16,"./DonutChart":17,"./LineChart":18,"./PieChart":19,"./ScatterPlot":20,"./StackedAreaChart":21,"./StackedBarChart":22}],24:[function(require,module,exports){
/**
 *
 * This module provides visualization components for charting
 * out of a diverse set of base implementations ranging from
 * D3 to three.js and WebGL.
 *
 * @module dex/charts
 * @property {module:dex/charts/c3} c3           - The C3 charting module.
 * @property {module:dex/charts/d3} d3           - The D3 charting module.
 * @property {module:dex/charts/d3plus} d3plus   - The D3Plus charting module.
 * @property {module:dex/charts/echarts} echarts - The ECharts charting module.
 * @property {module:dex/charts/elegans} elegans - Elegans 3D/WebGL charting module.
 * @property {module:dex/charts/nvd3} nvd3       - The NVD3 charting module.
 * @property {module:dex/charts/threejs} threejs - The WebGL/ThreeJS charting module.
 * @property {module:dex/charts/vis} vis         - The Vis.js charting module.
 *
 */
module.exports = function charts() {
  return {
    'c3'       : require("./c3/c3"),
    'd3'       : require("./d3/d3"),
    'd3plus'   : require("./d3plus/d3plus"),
    'echarts'  : require("./echarts/echarts"),
    'elegans'  : require("./elegans/elegans"),
    'multiples': require("./multiples/multiples"),
    'nvd3'     : require("./nvd3/nvd3"),
    'taucharts': require("./taucharts/taucharts"),
    'threejs'  : require("./threejs/threejs"),
    'vis'      : require("./vis/vis")
  };
};
},{"./c3/c3":23,"./d3/d3":42,"./d3plus/d3plus":44,"./echarts/echarts":54,"./elegans/elegans":56,"./multiples/multiples":58,"./nvd3/nvd3":61,"./taucharts/taucharts":70,"./threejs/threejs":72,"./vis/vis":74}],25:[function(require,module,exports){
var bumpchart = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults = {
    'parent': '#BumpChartParent',
    'id': 'BumpChartId',
    'class': 'BumpChartClass',
    'resizable': true,
    // Sample data...
    'csv': {
      'header': ["category", "sequence", "rank"],
      'data': [
        ["Team 1", 1, 1],
        ["Team 1", 2, 2],
        ["Team 1", 3, 3],
        ["Team 2", 1, 2],
        ["Team 2", 2, 1],
        ["Team 2", 3, 2],
        ["Team 3", 1, 3],
        ["Team 3", 2, 3],
        ["Team 3", 3, 1]
      ]
    },
    'width': "100%",
    'height': "100%",
    'margin': {
      'left': 140,
      'right': 160,
      'top': 50,
      'bottom': 50
    },
    'transform': "",
    'colorScheme' : 'category10',
    'color': d3.scale.category10(),
    'format': d3.format("d"),
    'key': {'category': 0, 'sequence': 1, 'rank': 2},
    'chartLabel': dex.config.text({
      'text': "",
      'x': function () {
        return (chart.config.width - chart.config.margin.left -
          chart.config.margin.right) / 2;
      },
      'y': function (d) {
        return chart.config.height -
          (.5 * chart.config.margin.bottom);
      },
      'font': dex.config.font({
        'fontSize': '32px'
      }),
      'fill.fillColor': 'steelblue',
      'anchor': 'middle'
    }),
    'categoryLabel': dex.config.text({
      'x': 8,
      'dy': ".31em",
      'cursor': "pointer",
      'font': dex.config.font({
        'size': 16,
        'weight': 'bold',
      }),
      'fill.fillColor': function (d) {
        return chart.config.color(
          d.key);
      }
    }),
    'sequenceLabel': dex.config.text({
      'dx': 0,
      'anchor': 'middle',
      'dy': ".31em",
      'cursor': "pointer",
      'font': dex.config.font({
        'size': 32,
        'weight': 'bold',
      }),
      'fill.fillColor': function (d) {
        return "black";
      }
    }),
    'circle': dex.config.circle({
      'r': 6,
      'stroke': dex.config.stroke({
        'color': function (d) {
          return chart.config.color(d.key);
        },
        'width': 4,
      }),
      'fill.fillColor': 'white'
    }),
    'line': dex.config.line({
      'stroke': dex.config.stroke({
        'color': function (d) {
          return chart.config.color(d.key);
        },
        'width': 3,
        //'dasharray' : "1 1"
      }),
      'fill.fillColor': 'none'
    })
  };

  chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Bump Chart Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "Color Scheme",
              "type": "choice",
              "choices": dex.color.colormaps(),
              "target": "colorScheme"
            }
          ]
        },
        dex.config.gui.text({name: "Chart Label"}, "chartLabel"),
        dex.config.gui.text({name: "Category Label"}, "categoryLabel"),
        dex.config.gui.text({name: "Sequence Labels"}, "sequenceLabel"),
        dex.config.gui.circle({name: "Nodes"}, "circle"),
        dex.config.gui.link({name: "Lines"}, "line")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    chart.resize();
    dex.config.apply(chart);
    return chart;
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var chart = this;
    var config = chart.config;
    var csv = config.csv;
    var margin = config.margin;
    var width = +config.width - margin.left - margin.right;
    var height = +config.height - margin.top - margin.bottom;
    config.color = dex.color.getColormap(config.colorScheme);

    var categoryKey = dex.csv.getColumnName(csv, config.key.category);
    var sequenceKey = dex.csv.getColumnName(csv, config.key.sequence);
    var rankKey = dex.csv.getColumnName(csv, config.key.rank);

    var categoryIndex = dex.csv.getColumnNumber(csv, config.key.category);
    var sequenceIndex = dex.csv.getColumnNumber(csv, config.key.sequence);
    var rankIndex = dex.csv.getColumnNumber(csv, config.key.rank);

    //dex.console.log("cat", categoryKey, "sequence", sequenceKey, "rank", rankKey);

    d3.selectAll(config.parent).selectAll("*").remove();

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg.append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    var data = dex.csv.toJson(csv);
    //dex.console.log("JSON", JSON.stringify(data));

    var dataNest = d3.nest()
      .key(function (d) {
        return d[csv.header[categoryIndex]];
      })
      .entries(data);

    data = dataNest;

    var speed = 100;

    var x = d3.scale.linear()
      .range([0, width]);

    var clippingIndex = d3.scale.linear()
      .range([0, width]);

    var y = d3.scale.ordinal()
      .rangeRoundBands([height, 0], .1);

    var xAxis = d3.svg.axis()
      .scale(x)
      .tickSize(0)
      .tickFormat(d3.format("d"))
      .orient("bottom")
      .ticks(10);

    var xAxis1 = d3.svg.axis()
      .scale(x)
      .tickSize(0)
      .tickFormat(d3.format("d"))
      .orient("top")
      .ticks(10);

    var yAxis = d3.svg.axis()
      .scale(y)
      .tickSize(-width)
      .tickPadding(10)
      .tickFormat(d3.format("d"))
      .orient("left");

    var line = d3.svg.line()
      .x(function (d) {
        return x(+d[sequenceKey]);
      })
      .y(function (d) {
        return y(+d[rankKey]) + y.rangeBand() / 2;
      });

    var clip = svg.append("clipPath")
      .attr("id", "clip")
      .append("rect")
      .attr("width", 0)
      .attr("height", height);

    y.domain(d3.range(d3.min(data, function (series) {
        return d3.min(series.values, function (d) {
          return +d[rankKey];
        });
      }),
        d3.max(data, function (series) {
          return d3.max(series.values, function (d) {
            return +d[rankKey];
          });
        }) + 1)
        .reverse()
    );

    x.domain(d3.extent(data[0].values.map(function (d) {
      return +d[sequenceKey];
    })));

    clippingIndex.domain([1, data[0].values.length]);

    //set y axis
    rootG.append("g")
      .attr("class", "y axis")
      .call(yAxis)
      .style('fill', 'none');

    //set bottom axis y
    rootG.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(" + 0 + "," + height + ")")
      .call(xAxis);

    //set top axis
    rootG.append("g")
      .attr("class", "x axis")
      .call(xAxis1);

    // Style the axis labels.
    rootG.selectAll(".axis").filter(".x").selectAll(".tick").select("text")
      .call(dex.config.configureText, config.sequenceLabel);

    var key = rootG.selectAll(".key")
      .data(data)
      .enter().append("g")
      .attr("class", "key");

    var path = key.append("path")
      .attr("class", "line")
      .call(dex.config.configureLine, config.line)
      .attr("clip-path", function (d) {
        return "url(#clip)";
      })
      .attr("d", function (d) {
        return line(d.values);
      })
      .on("mouseover", function (d) {
        key.style("opacity", 0.2);
        key.filter(function (path) {
          return path.key === d.key;
        }).style("opacity", 1);
      })
      .on("mouseout", function (d) {
        key.style("opacity", 1);
      });

    var circleStart = key.append("circle")
      .call(dex.config.configureCircle, config.circle)
      .attr("cx", function (d) {
        return x(+d.values[0][sequenceKey]);
      })
      .attr("cy", function (d) {
        return y(+d.values[0][rankKey]) + y.rangeBand() / 2;
      })
      //    .style("fill", function(d) { return d.color; })
      .on("mouseover", function (d) {
        key.style("opacity", 0.2);
        key.filter(function (path) {
          return path.key === d.key;
        }).style("opacity", 1);
      })
      .on("mouseout", function (d) {
        key.style("opacity", 1);
      });

    var circleEnd = key.append("circle")
      .call(dex.config.configureCircle, config.circle)
      .attr("cx", function (d) {
        return x(+d.values[0][sequenceKey]);
      })
      .attr("cy", function (d) {
        return y(+d.values[0][rankKey]) + y.rangeBand() / 2;
      })
      .on("mouseover", function (d) {
        key.style("opacity", 0.2);
        key.filter(function (path) {
          return path.key === d.key;
        }).style("opacity", 1);
      })
      .on("mouseout", function (d) {
        key.style("opacity", 1);
      });

    // text label for the chart
    rootG.append("text")
      .call(dex.config.configureText, config.chartLabel);

    var label = key.append("text")
      .attr("transform", function (d) {
        //dex.console.log("D", d, sequenceKey);
        return "translate(" + (+x(d.values[0][sequenceKey])) +
          "," + (+y(d.values[0][rankKey]) + y.rangeBand() / 2) + ")";
      })
      .call(dex.config.configureText, config.categoryLabel)
      .on("mouseover", function (d) {
        key.style("opacity", 0.2);
        key.filter(function (path) {
          return path.key === d.key;
        }).style("opacity", 1);
      })
      .on("mouseout", function (d) {
        key.style("opacity", 1);
      })
      .text(function (d) {
        return " " + d.values[0][rankKey] + ". " + d.key;
      });

    var xIndex = 1;

    var transition = d3.transition()
      .duration(speed)
      .each("start", function start() {
        label.transition()
          .duration(speed)
          .ease('linear')
          .attr("transform", function (d) {
            //dex.console.log("D:" + xIndex, d, sequenceKey);
            return "translate(" + x(+d.values[xIndex][sequenceKey]) + "," + (y(+d.values[xIndex][rankKey]) + y.rangeBand() / 2) + ")";
          })
          .text(function (d) {
            return " " + d.values[xIndex][rankKey] + ". " + d.key;
          });

        circleEnd.transition()
          .duration(speed)
          .ease('linear')
          .attr("cx", function (d) {
            return x(+(d.values[xIndex][sequenceKey]));
          })
          .attr("cy", function (d) {
            return y(+(d.values[xIndex][rankKey])) + y.rangeBand() / 2;
          });

        clip.transition()
          .duration(speed)
          .ease('linear')
          .attr("width", clippingIndex(xIndex + 1))
          .attr("height", height);

        xIndex += 1;

        if (xIndex !== data[0].values.length) transition = transition.transition().each("start", start);

      });
    // Allow method chaining
    return chart;
  };
  chart.clone = function clone(userConfig) {
    return bumpchart(userConfig, chart.defaults);
  };

  $(document).ready(function () {
    // Make the entire chart draggable.
    if (chart.config.draggable) {
      $(chart.config.parent).draggable();
    }
  });

  return chart;
};

module.exports = bumpchart;
},{}],26:[function(require,module,exports){
var chord = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults = {
    // The parent container of this chart.
    "parent": "#ChordParent",
    // Set these when you need to CSS style components independently.
    "id": "ChordId",
    "class": "ChordClass",
    "resizable": true,
    // Our data...
    "csv": {
      // Give folks without data something to look at anyhow.
      "header": ["X", "Y", "Z"],
      "data": [
        [0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]
      ]
    },
    "width": "100%",
    "height": "100%",
    "margin": {
      "left": 50,
      "right": 50,
      "top": 50,
      "bottom": 50
    },
    "transform": "",
    "draggable" : false,
    "padding": 0.05,
    "nodes": {
      "mouseout": dex.config.link({
        "stroke.color": "black",
        //"stroke.dasharray": "5 5",
        "stroke.width": 0,
        "fill.fillColor": function (d, i) {
          //dex.console.log("COLORD", d);
          return (chart.config.color(chart.config.chordData.header[d.index]));
        },
        "fill.fillOpacity": 0.5,
        "fill.fill": "none",
        "d": d3.svg.arc(),
        "transform": ""
      }),
      "mouseover": dex.config.link({
        "stroke.color": "white",
        //"stroke.dasharray": "5 5",
        "stroke.width": 2,
        "fill.fillColor": function (d, i) {
          //dex.console.log("D", d)
          return (chart.config.color(chart.config.chordData.header[d.index]));
        },
        "fill.fillOpacity": 1,
        "fill.fill": "none",
        "d": d3.svg.arc(),
        "transform": ""
      })
    },
    "links": {
      "mouseout": dex.config.link({
        "stroke.color": "white",
        "stroke.dasharray": "",
        "stroke.width": 0,
        "fill.fillColor": function (d, i) {
          return (chart.config.color(chart.config.chordData.header[d.source.index]));
        },
        "fill.fillOpacity": 0.2,
        "fill.fill": "none",
        "d": d3.svg.chord(),
        "transform": ""
      }),
      "mouseover": dex.config.link({
        "stroke.color": "white",
        "stroke.dasharray": "",
        "stroke.width": 1,
        "fill.fillColor": function (d, i) {
          return (chart.config.color(chart.config.chordData.header[d.source.index]));
        },
        "transform": "",
        "fill.fillOpacity": 1,
        "fill.fill": "none",
        "d": d3.svg.chord()
      }),
    },
    "color": d3.scale.category20c(),
    "autoRadius" : true,
    "innerRadius": 350,
    "outerRadius": 400,
    "tick.start.x": 1,
    "tick.start.y": 0,
    "tick.end.x": 5,
    "tick.end.y": 0,
    "tick.padding": 10,
    "tick.stroke": dex.config.stroke({
      "width": 2,
      "color": "black"
    }),
    "title": dex.config.text(),
    "label": dex.config.text()
  };

  chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Chord Diagram Settings",
      "contents": [
        dex.config.gui.general(),
        dex.config.gui.dimensions(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Auto Radius",
              "description": "Turn auto-radius on/off.",
              "target": "autoRadius",
              "type": "boolean",
              "initialValue": true
            },
            {
              "name": "Inner Radius",
              "description": "The inner radius.",
              "target": "innerRadius",
              "type": "int",
              "minValue": 0,
              "maxValue": 1000,
              "initialValue": 350
            },
            {
              "name": "Outer Radius",
              "description": "The outer radius.",
              "target": "outerRadius",
              "type": "int",
              "minValue": 0,
              "maxValue": 1000,
              "initialValue": 400
            },
            {
              "name": "Padding",
              "description": "Padding between nodes.",
              "target": "padding",
              "type": "float",
              "minValue": 0,
              "maxValue": 1,
              "initialValue": 0.05
            }
          ]
        },
        dex.config.gui.editableText({name: "Title"}, "title"),
        dex.config.gui.text({name: "Labels"}, "label"),
        dex.config.gui.link({name: "Links"}, "links.mouseout"),
        dex.config.gui.link({name: "Links on Mouseover"}, "links.mouseover"),
        dex.config.gui.link({name: "Nodes"}, "nodes.mouseout"),
        dex.config.gui.link({name: "Nodes on Mouseover"}, "nodes.mouseover"),
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    chart.resize();
    dex.config.apply(chart);
    return chart;
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var chart = this;
    var config = chart.config;
    var csv = config.csv;
    var margin = config.margin;
    margin.top = +margin.top;
    margin.bottom = +margin.bottom;
    margin.left = +margin.left;
    margin.right = +margin.right;

    var width = +config.width - margin.left - margin.right;
    var height = +config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll("*").remove();

    var outer;
    var inner;
    if (config.autoRadius && config.autoRadius != "false") {
      outer = Math.min(width, height) / 2;
      inner = Math.max(outer - 20, 10);
    }
    else {
      outer = config.outerRadius;
      inner = config.innerRadius;
    }

    // Calculated attributes.
    config.nodes.mouseover.d.innerRadius(inner).outerRadius(outer + 2);
    config.nodes.mouseout.d.innerRadius(inner).outerRadius(outer);
    config.links.mouseover.d.radius(inner);
    config.links.mouseout.d.radius(inner);

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr("width", config.width)
      .attr("height", config.height);

    var rootG = svg.append("g")
      .attr("transform", "translate(" +
        (margin.left + (width / 2)) + "," +
        (margin.top + (height / 2)) + ") " +
        config.transform);

    chordData = dex.csv.getConnectionMatrix(csv);
    config.chordData = chordData;

    var chord = d3.layout.chord()
      .padding(+config.padding)
      .sortSubgroups(d3.descending)
      .matrix(chordData.connections);

    rootG.append("g")
      .attr("class", "arcs")
      .selectAll("path")
      .data(chord.groups)
      .enter().append("path")
      .attr("id", "fillpath")
      .call(dex.config.configureLink, config.nodes.mouseout)
      .on("mouseover", function (activeChord) {
        d3.select(this)
          .call(dex.config.configureLink, config.nodes.mouseover);

        rootG.selectAll("g.chord path")
          .filter(function (d) {

            return d.source.index == activeChord.index || d.target.index == activeChord.index;
          })
          .call(dex.config.configureLink, config.links.mouseover);
      })
      .on("mouseout", function (inactiveChord) {
        d3.select(this)
          .call(dex.config.configureLink, config.nodes.mouseout)
        //dex.console.log("INACTIVE", inactiveChord);
        rootG.selectAll("g.chord path")
          .filter(function (d) {
            return d.source.index == inactiveChord.index || d.target.index == inactiveChord.index;
          })
          .call(dex.config.configureLink, config.links.mouseout);
      });

    var ticks = rootG.append("g")
      .attr("id", "ChordTicks")
      .selectAll("g")
      .data(chord.groups)
      .enter().append("g")
      .selectAll("g")
      .data(groupTicks)
      .enter()
      .append("g")
      .attr("transform", function (d) {
        //console.dir(d);
        // Probably a bad idea, but getting parent angle data from parent.
        var startAngle = this.parentNode.__data__.startAngle;
        var endAngle = this.parentNode.__data__.endAngle;
        var midAngle = startAngle + (endAngle - startAngle) / 2.0;
        return "rotate(" + (midAngle * 180 / Math.PI - 90) + ")"
          + "translate(" + outer + ",0)";
      });

    ticks.append("line")
      .call(dex.config.configureLine, config.tick);

    ticks.append("text")
      //.call(dex.config.configureText, config.label)
      .attr("x", +config.tick.padding + (+config.tick.padding / 4))
      .attr("dy", ".35em")
      .attr("font-size", config.label.font.size)
      .attr("fill", config.label.fill)
      .attr("text-anchor", function (d) {
        return d.angle > Math.PI ? "end" : null;
      })
      .attr("transform", function (d) {
        return d.angle > Math.PI ? "rotate(180)translate(-" +
          ((+config.tick.padding * 2) + (+config.tick.padding / 2)) + ")" : null;
      })
      .text(function (d) {
        return d.label;
      });

    rootG.append("g")
      .attr("class", "chord")
      .selectAll("path")
      .data(chord.chords)
      .enter().append("path")
      .call(dex.config.configureLink, config.links.mouseout)
      .on("mouseover", function () {
        d3.select(this)
          .call(dex.config.configureLink, config.links.mouseover);
      })
      .on("mouseout", function () {
        d3.select(this)
          .call(dex.config.configureLink, config.links.mouseout);
      });

    var chartTitle = rootG.append("text").call(dex.config.configureText, config.title,
      config.title.text);

    /** Returns an array of tick angles and labels, given a group. */
    function groupTicks(d) {
      var k = (d.endAngle - d.startAngle) / d.value;
      return d3.range(0, d.value, 1000).map(function (v, i) {
        return {
          angle: v * k + d.startAngle,
          //label: i % 5 ? null : v / 1000 + "k"
          label: chordData.header[d.index]
        };
      });
    }

    dex.config.apply(chart);

    // Allow method chaining
    return chart;
  };

    chart.clone = function clone(override) {
        return chord(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    if (chart.config.draggable) {
      $(chart.config.parent).draggable();
    }
  });

  return chart;
}

module.exports = chord;
},{}],27:[function(require,module,exports){
var clusteredforce = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var defaults = {
    'parent': '#ClusteredForceParent',
    'id': "ClusteredForceId",
    'class': "ClusteredForceClass",
    'height': "100%",
    'width': "100%",
    'resizable': true,
    'margin': {
      'left': 100,
      'right': 100,
      'top': 50,
      'bottom': 50
    },
    'csv': {
      'header': ["X", "Y"],
      'data': [
        [0, 0],
        [1, 1],
        [2, 4],
        [3, 9],
        [4, 16]
      ]
    },
    'groups': [{'category': 0, 'value': 1, 'label': 0}],
    'transform': '',
    'color': d3.scale.category20(),
    'colorScheme' : 'category10',
    'padding': 10,
    // TODO: Add normalization function.
    'sizingFunction': function () {
      return d3.scale.linear()
    },
    'minRadius': 5,
    'maxRadius': 20,
    'gravity': 2,
    'charge': 0,
    'scaleColumns': true,
    'circle': dex.config.circle({
      'r': function (d) {
        return (dex.object.isNumeric(d.radius) ? d.radius : 1);
      },
      'fill': dex.config.fill({
        'fillColor': function (d, i) {
          var darkColor = dex.color.shadeColor(d.color, -10);
          var gradientId = "gradient" + d.color.substring(1)
          var grad = d3.select(chart.config.parent)
            .select("#gradients")
            .selectAll("#" + gradientId)
            .data([gradientId])
            .enter()
            .append("radialGradient")
            .attr("class", "colorGradient")
            .attr("id", gradientId)
            .attr("gradientUnits", "objectBoundingBox")
            .attr("fx", "30%")
            .attr("fy", "30%");

          grad.append("stop")
            .attr("offset", "0%")
            .attr("style", "stop-color:#FFFFFF");

          // Middle
          grad.append("stop")
            .attr("offset", "90%")
            .attr("style", "stop-color:" + d.color);

          // Outer Edges
          grad.append("stop")
            .attr("offset", "100%")
            .attr("style", "stop-color:" + darkColor);

          return "url(#" + gradientId + ")";
        }
      }),
      'stroke': dex.config.stroke(),
      'tooltip': function (d) {
        return d.text;
      },
      'transform': ''
    })
  };

  var chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Clustered Force Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Physics and Sizing",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "Color Scheme",
              "type": "choice",
              "choices": dex.color.colormaps(),
              "target": "colorScheme"
            },
            {
              "name": "Minimum Radius",
              "description": "The minimum radius of nodes.",
              "target": "minRadius",
              "type": "int",
              "minValue": 1,
              "maxValue": 100,
              "initialValue": 10
            },
            {
              "name": "Maximum Radius",
              "description": "The maximum radius of nodes.",
              "target": "maxRadius",
              "type": "int",
              "minValue": 1,
              "maxValue": 100,
              "initialValue": 50
            },
            {
              "name": "Gravity",
              "description": "The gravity.",
              "target": "gravity",
              "type": "int",
              "minValue": 0,
              "maxValue": 10,
              "initialValue": 2
            },
            {
              "name": "Charge",
              "description": "The charge of nodes.",
              "target": "charge",
              "type": "int",
              "minValue": 1,
              "maxValue": 100,
              "initialValue": 1
            },
            {
              "name": "Scale Columns",
              "description": "Scale columns or not.",
              "target": "scaleColumns",
              "type": "boolean",
              "initialValue": true
            },
            {
              "name": "Padding",
              "description": "Padding between nodes.",
              "target": "padding",
              "type": "int",
              "minValue": 0,
              "maxValue": 100,
              "initialValue": 1
            }
          ]
        },
        dex.config.gui.stroke({name: "Nodes"}, "circle.stroke")
      ]
    };
    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function () {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;
    config.color = config.color = dex.color.getColormap(config.colorScheme);

    var radius = d3.scale.sqrt().range([0, 12]);

    var nodes = [];

    var values = [];
    var min = null;
    var max = null;

    config.groups.forEach(function (group) {
      var valIndex = dex.csv.getColumnNumber(csv, group.value);
      var catIndex = dex.csv.getColumnNumber(csv, group.category);
      var labelIndex = dex.csv.getColumnNumber(csv, group.label);

      config.csv.data.forEach(function (row) {
        var value = +(row[valIndex]);
        nodes.push({
          'category': row[catIndex],
          'value': +value,
          'color': config.color(row[catIndex]),
          'text': "<table><tr><td>Label</td></td><td>" + row[labelIndex] +
          "</td></tr><tr><td>Category</td><td>" + row[catIndex] + "</td></tr>" +
          "<tr><td>Value</td><td>" + row[valIndex] +
          "</td></tr></table>"
        });
        if (min == null || min > +value) {
          min = +value;
        }

        if (max == null || max < +value) {
          max = +value;
        }
      })
    });

    var radiusScale = d3.scale.linear()
      .domain([min, max])
      .range([config.minRadius, config.maxRadius]);

    nodes.forEach(function (node) {
      node.radius = radiusScale(+node.value);
    });

    //dex.console.log("NODES", nodes, "VALUES", values, "EXTENTS", min, max);

    force = d3.layout.force()
      .nodes(nodes)
      .size([config.width, config.height])
      .gravity(config.gravity / 100.0)
      .charge(config.charge / 100.0)
      .on("tick", tick)
      .start();

    d3.selectAll(config.parent).selectAll("*").remove();

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    svg.append('defs')
      .attr('id', 'gradients');

    var rootG = svg.append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ')')
      .attr("transform", config.transform);

    var circle = rootG.selectAll("circle")
      .data(nodes)
      .enter().append("circle")
      .call(dex.config.configureCircle, config.circle)
      .call(force.drag);

    circle.append("text")
      .text(config.circle.tooltip);

    function tick(e) {
      circle
        .each(cluster(10 * e.alpha * e.alpha))
        .each(collide(.5))
        .attr("radius", function (d) {
          return (dex.object.isNumeric(d.radius) ? d.radius : 1);
        })
        .attr("cx", function (d) {
          return (dex.object.isNumeric(d.x) ? d.x : 0);
        })
        .attr("cy", function (d) {
          return (dex.object.isNumeric(d.y) ? d.y : 0);
        });
    }

    // Move d to be adjacent to the cluster node.
    function cluster(alpha) {
      var max = {};

      // Find the largest node for each cluster.
      nodes.forEach(function (d) {
        if (!(d.color in max) || (d.radius > max[d.color].radius)) {
          max[d.color] = d;
        }
      });

      return function (d) {
        var node = max[d.color],
          l,
          r,
          x,
          y,
          i = -1;

        if (node == d) return;

        x = d.x - node.x;
        y = d.y - node.y;
        l = Math.sqrt(x * x + y * y);
        r = d.radius + node.radius;
        if (l != r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          node.x += x;
          node.y += y;
        }
      };
    }

    // Resolves collisions between d and all other circles.
    function collide(alpha) {
      var quadtree = d3.geom.quadtree(nodes);
      return function (d) {
        var r = d.radius + radius.domain()[1] + config.padding,
          nx1 = d.x - r,
          nx2 = d.x + r,
          ny1 = d.y - r,
          ny2 = d.y + r;
        quadtree.visit(function (quad, x1, y1, x2, y2) {
          if (quad.point && (quad.point !== d)) {
            var x = d.x - quad.point.x,
              y = d.y - quad.point.y,
              l = Math.sqrt(x * x + y * y),
              r = d.radius + quad.point.radius + (d.color !== quad.point.color) * config.padding;
            if (l < r) {
              l = (l - r) / l * alpha;
              d.x -= x *= l;
              d.y -= y *= l;
              quad.point.x += x;
              quad.point.y += y;
            }
          }
          return x1 > nx2
            || x2 < nx1
            || y1 > ny2
            || y2 < ny1;
        });
      };
    }
  };

  chart.clone = function clone(override) {
    return clusteredforce(dex.config.expandAndOverlay(override, userConfig));
  };

  $(document).ready(function () {
    $(chart.config.parent).uitooltip({
      items: "circle",
      position: {
        my: "right bottom+50"
      },
      content: function () {
        return $(this).find("text").text();
      },
      track: true
    });

    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = clusteredforce;
},{}],28:[function(require,module,exports){
var dendrogram = function Dendrogram(userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults =
    {
      // The parent container of this chart.
      'parent': 'DendrogramParent',
      // Set these  when you need to CSS style components independently.
      'id': 'DendrogramId',
      'class': 'DendrogramClass',
      'resizable': true,
      'margin': {
        'top': 10,
        'bottom': 10,
        'left': 10,
        'right': 10
      },
      'transform': '',
      // diagonal, elbow
      'connectionType': 'diagonal',
      // Our data...
      'csv': {
        // Give folks without data something to look at anyhow.
        'header': ["X", "Y"],
        'data': [
          [0, 0],
          [1, 1],
          [2, 4],
          [3, 9],
          [4, 16]
        ]
      },
      // width and height of our chart.
      'width': "100%",
      'height': "100%",
      'connection': {
        'length': 180
//      'style': {
//        'stroke': dex.config.stroke()
//      }
      },
      'root': {
        'name': "ROOT",
        // Used?
        //'category': "ROOT"
      },
      // REM: Used?
      //'color': d3.scale.category20(),
      'node': {
        'expanded': {
          'label': dex.config.text({
            'x': 8,
            'y': 4,
            'font.weight': 'bold',
            'fill.fillColor': 'black',
            'text': function (d) {
              return (d.name) ? d.name : d.category;
            }
          }),
          'circle': dex.config.circle({
            'r': 4,
            'fill': {
              'fillColor': 'steelblue'
            }
          })
        },
        'collapsed': {
          'label': dex.config.text({
            'x': 8,
            'y': 4,
            'font.weight': 'bold',
            'text': function (d) {
              return (d.name) ? d.name : d.category;
            }
          }),
          'circle': dex.config.circle({
            'r': 5,
            'fill': {
              'fillColor': 'green',
              'fillOpacity': .8
            }
          })
        }
      },
      'link': dex.config.link({
        'fill': {
          'fillColor': 'none'
        },
        'stroke': dex.config.stroke({
          'color': 'green',
          'width': 1,
          'opacity': .3,
          'dasharray': "5 5"
        })
      })
    };

  chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Dendrogram Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "General",
          "contents": [
            {
              "name": "Root Name",
              "description": "The text associated with the root node.",
              "target": "root.name",
              "type": "string",
              "initialValue": chart.root.name || "ROOT"
            },
            {
              "name": "Connection Length",
              "description": "This controls the length of the connections.",
              "target": "connection.length",
              "type": "choice",
              "choices": ["fit-text", "10", "50", "100", "150", "200", "250", "300"],
              "initialValue": "fit-text"
            }
          ]
        },
        dex.config.gui.text({name: "Expanded Label"}, "node.expanded.label"),
        dex.config.gui.circle({name: "Expanded Circle"}, "node.expanded.circle"),
        dex.config.gui.text({name: "Collapsed Label"}, "node.collapsed.label"),
        dex.config.gui.circle({name: "Collapsed Circle"}, "node.collapsed.circle"),
        dex.config.gui.link({}, "link")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    chart.resize();
    dex.config.apply(chart);
    return chart;
  };

  chart.update = function update() {
    d3 = dex.charts.d3.d3v3;
    var chart = this;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;
    var json;
    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll("*").remove();

    var i = 0, root;

    var tree = d3.layout.tree()
      .size([height, width]);

    var cluster = d3.layout.cluster()
      .size([height, width]);

    var layout = tree;

    var connectionType;

    if (config.connectionType == "extended-elbow") {
      connectionType = function extendedElbow(d, i) {
        return "M" + d.source.y + "," + d.source.x
          + "H" + (d.source.y + 50)
          + "V" + d.target.x + "H" + d.target.y;
      }
    }
    else if (config.connectionType == "elbow") {
      connectionType = function elbow(d, i) {
        return "M" + d.source.y + "," + d.source.x
          + "V" + d.target.x + "H" + d.target.y;
      }
    }
    else {
      connectionType = d3.svg.diagonal()
        .projection(function (d) {
          return [d.y, d.x];
        });
    }

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg.append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    json =
      {
        "name": config.root.name,
        "category": config.root.category,
        "children": dex.csv.toHierarchicalJson(csv)
      };

    root = json;
    root.x0 = height / 2;
    root.y0 = 0;

    function toggleAll(d) {
      if (d.children) {
        d.children.forEach(toggleAll);
        toggle(d);
      }
      else if (d.kids) {
        d.kids.forEach(toggleAll);
        toggle(d);
      }
    }

    // Initialize the display to show a few nodes.
    //root.kids.forEach(toggleAll);

    chart.root = json;
    update(chart.root);

    function update(source) {
      var duration = d3.event && d3.event.altKey ? 5000 : 500;
      var depthY = new Array();

      // Compute the new tree layout.
      var nodes = layout.nodes(root).reverse();

      // Allow manually set lengths to be used instead of fixed length connectors
      var fixedLength = true;
      if (String(config.connection.length).indexOf(",") > -1) {
        fixedLength = false;
        depthY = String(config.connection.length).split(",")
      }
      else if (String(config.connection.length) === "fit-text") {
        //dex.console.log("COMPACT");
        var preText = d3.select(config.parent + " g").append("text");
        //var charWidth = charText.node().getBBox().width;

        //charText.call(dex.config.configureText);
        fixedLength = false;
        var depthMap = {};
        nodes.forEach(function (d) {
          preText.text(d.name);
          // Find start for each connection.
          var textLen = preText.node().getBBox().width;
          //dex.console.log("D", d, textLen);
          if (depthMap[d.depth]) {
            if (depthMap[d.depth] < textLen) {
              depthMap[d.depth] = textLen;
            }
          }
          else {
            depthMap[d.depth] = textLen;
          }
        });
        //dex.console.log("LENGTHS", depthMap);
        depthY = [0];
        var textPadding = 40;
        var textOffset = textPadding;
        for (i = 0; depthMap[i]; i++) {
          depthY.push(depthMap[i] + textOffset);
          textOffset += depthMap[i] + textPadding;
        }
        preText.remove();
      }

      // Set y offsets based on single fixed length or manual settings
      nodes.forEach(function (d) {
        if (fixedLength) {
          d.y = d.depth * config.connection.length;
        }
        else {
          d.y = +depthY[d.depth];
        }
      });

      // Update the nodes
      var node = rootG.selectAll("g.node")
        .data(nodes, function (d) {
          return d.id || (d.id = ++i);
        });

      // Enter any new nodes at the parent's previous position.
      var nodeEnter = node.enter().append("svg:g")
        .attr("class", "node")
        .attr("transform", function (d) {
          return "translate(" + source.y0 + "," + source.x0 + ")";
        })
        .on("click", function (d) {
          toggle(d);
          update(d);
        });

      // Come back here...
      nodeEnter.append("svg:circle")
        .each(function (d) {
          //dex.console.log("CALLING", this, d, i);
          var nodeConfig = (d._children) ?
            config.node.collapsed.circle : config.node.expanded.circle;
          d3.select(this).call(dex.config.configureCircle, nodeConfig);
        })
        .attr("r", 1e-6);

      // Add text nodes configured like we want them.
      nodeEnter.append("text")
        .each(function (d) {
          var nodeConfig = (d._children) ?
            config.node.collapsed.label : config.node.expanded.label;
          d3.select(this).call(dex.config.configureText, nodeConfig);
        })
        //.text(function(d) { return (d.name) ? d.name : d.category;})
        .style("fill-opacity", 1e-6);

      // Transition nodes to their new position.
      var nodeUpdate = node.transition()
        .duration(duration)
        .attr("transform", function (d) {
          return "translate(" + d.y + "," + d.x + ")";
        });

      nodeUpdate.selectAll("circle")
        .each(
          function (d) {
            var nodeConfig = (d._children) ?
              config.node.collapsed.circle : config.node.expanded.circle;
            d3.select(this).transition().call(dex.config.configureCircle, nodeConfig);
          });

      nodeUpdate.select("text")
        .each(
          function (d) {
            var nodeConfig = (d._children) ?
              config.node.collapsed.label : config.node.expanded.label;
            d3.select(this).call(dex.config.configureText, nodeConfig);
          })
        .style("fill-opacity", 1);

      // Transition exiting nodes to the parent's new position.
      var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function (d) {
          return "translate(" + (source.y) + "," + (source.x) + ")";
        })
        .remove();

      nodeExit.select("circle")
        .attr("r", 1e-6);

      nodeExit.select("text")
        .style("fill-opacity", 1e-6);

      // Update the links
      var link = rootG.selectAll("path.link")
        .data(layout.links(nodes), function (d) {
          return d.target.id;
        });

      // Enter any new links at the parent's previous position.
      link.enter().insert("svg:path", "g")
        .attr("class", "link")
        .call(dex.config.configureLink, config.link)
        //.style("fill", config.link.fill)
        //.style("fill-opacity", config.link.fillOpacity)
        .attr("d", function (d) {
          var o = {x: source.x0, y: source.y0};
          return connectionType({source: o, target: o});
        })
        .transition()
        .duration(duration)
        .attr("d", connectionType)
      ;

      // Transition links to their new position.
      link.transition()
        .duration(duration)
        .attr("d", connectionType);

      // Transition exiting nodes to the parent's new position.
      link.exit().transition()
        .duration(duration)
        .attr("d", function (d) {
          var o = {x: source.x, y: source.y};
          return connectionType({source: o, target: o});
        })
        .remove();

      // Stash the old positions for transition.
      nodes.forEach(function (d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }

    // Toggle children.
    function toggle(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      }
      else {
        d.children = d._children;
        d._children = null;
        d.children.forEach(function (child) {
          collapse(child);
        });
        //dex.console.log(d.children);
      }
    }

    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      }
    }

    dex.config.apply(chart);
    return chart;
  };

  chart.clone = function clone(override) {
    return dendrogram(dex.config.expandAndOverlay(override, userConfig));
  };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = dendrogram;
},{}],29:[function(require,module,exports){
var horizontallegend = function (userConfig) {
  var defaults = {
    'parent'     : null,
    'labels'     : ["A", "B", "C"],
    'id'         : "HorizontalLegend",
    'class'      : "HorizontalLegend",
    'transform'  : 'translate(20,20)',
    'tickLength' : 25,
    'color'      : d3.scale.category20c(),
    'caption'    : dex.config.text({
      'text'   : "Legend",
      'x'      : 0,
      'y'      : -6,
      'anchor' : 'start',
      'font'   : dex.config.font({'size' : 14, 'weight' : 'bold'}),
      'fill'   : dex.config.fill({'fillColor' : 'black'})
    }),
    'axis'       : dex.config.axis({
      'tickSize'    : 25,
      'tickPadding' : 10,
      'orient'      : 'bottom',
      'tickFormat'  : function (d) {
        return d;
      },
      'tickLine'    : dex.config.line({
        'stroke' : dex.config.stroke({'color' : 'grey', 'width' : 1}),
        'fill'   : dex.config.fill({'fillColor' : 'none'})
      }),
      'path'        : dex.config.path({
        'fill'   : dex.config.fill({'fillColor' : 'none'}),
        'stroke' : dex.config.stroke({'color' : 'grey', 'width' : 1})
      })
    }),
    'cell'       : dex.config.rectangle({
        'stroke' : dex.config.stroke(),
        'color'  : d3.scale.category10(),
        'height' : 20,
        'width'  : 30
      }
    )
  };

  //config = dex.object.overlay(dex.config.expand(userConfig), dex.config.expand(defaults));
  var chart = new dex.component(userConfig, defaults);
  var config = chart.config;

  chart.render = function () {
    this.update();
  };

  chart.update = function () {
    var chart = this;
    var config = chart.config;
    dex.console.log("HorizontalLegend config:", config);
    // Create our x scale
    var x = d3.scale.ordinal()
      .domain(config.labels)
      .range(d3.range(config.labels.length).map(function (i) {
        return i * config.cell.width;
      }));

    // Create the x axis.
    var xAxis = dex.config.createAxis(config.axis)
      .scale(x)
      .tickValues(config.labels);

    // Append a graphics node to the supplied svg node.
    var chartContainer = d3.select(config.parent).append("g")
      .attr("class", config["class"])
      .attr("id", config["id"])
      .attr("transform", config.transform);

    // Draw a colored rectangle for each ordinal range.
    chartContainer.selectAll("rect")
      .data(config.labels)
      .enter().append("rect")
      //.attr("height", config.cellHeight)
      .call(dex.config.configureRectangle, config.cell)
      .attr("x", function (d, i) {
        return x(i);
      });

    // Add the caption.
    chartContainer.call(xAxis).append("text")
      //.attr("class", "caption")
      .call(dex.config.configureText, config.caption);
    //.attr("y", config.captionYOffset)
    //.attr("x", config.captionXOffset)
    //.text("GEEZE");
    //.style("font-size", config.captionFontSize);

    chartContainer.select('path')
      .call(dex.config.configurePath, config.axis.path);

    chartContainer.selectAll(".tick line")
      .call(dex.config.configureLine, config.axis.tickLine);
  };

  $(document).ready(function () {
    // Make the entire chart draggable.
    $(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = horizontallegend;
},{}],30:[function(require,module,exports){
var motionbarchart = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var color = d3.scale.category20c();

  var defaults = {
    // The parent container of this chart.
    'parent': '#MotionBarChartParent',
    // Set these when you need to CSS style components independently.
    'id': 'MotionBarhartId',
    'class': 'MotionBarChartClass',
    // Our data...
    'csv': undefined,
    'resizable': true,
    // Tells us which columns represent what.
    'index': {
      'name': 0,
      'color': 0,
      'time': 1,
      'y': 2
    },
    // Chart dimensions.
    'width': '100%',
    'height': '100%',
    'margin': {
      top: 50,
      right: 120,
      bottom: 180,
      left: 150
    },

    'bar': dex.config.rectangle({
        'color': function (d, i) {
          return color(i);
        },
        'stroke.width': 1,
        'stroke.color': 'black',
        'events': {
          'mouseover': function () {
            d3.select(this)
              .style("stroke", 'red')
              .style("stroke-width", 2);
          },
          'mouseout': function () {
            d3.select(this)
              .style("stroke", chart.config.bar.stroke.color)
              .style("stroke-width", chart.config.bar.stroke.width);
          }
        }
      }
    ),

    // Main label configuration
    'label.font.size': 64,
    'label.fill.fillColor': 'steelblue',
    'label.fill.fillOpacity': 0.4,
    'label.y': function (d) {
      return chart.config.margin.top;
    },
    'label.dy': '.50em',
    'label.x': function (d) {
      return (chart.config.width - chart.config.margin.left - chart.config.margin.right) / 2;
    },

    'transform': '',
    'duration': 5000,

    'xaxis': dex.config.axis({
      'scale.type': 'linear',
      'orient': 'bottom',
      'label': dex.config.text({
        'anchor': 'start',
        'writingMode': 'tb',
        'dx': function (d) {
          return (chart.config.bar.width) / 2;
        },
        'dy': '.5em'
      }),
      'tick.stroke.color': 'black',
      'tick.stroke.width': 1,
      'tick.fill.fillColor': 'none',
      'axisLine.stroke.color': 'black',
      'axisLine.stroke.width': 1,
      'axisLine.stroke.dasharray': "0",
      'axisLine.fill.fillColor': 'none'
    }),
    'yaxis': dex.config.axis({
      'scale.type': 'linear',
      'orient': 'left',
      'label': dex.config.text({
        'anchor': 'end',
        'dx': '-.5em' //function(d) { return chart.config.margin.left; },
      }),
      'title': dex.config.text(),
      'tick.stroke.width': 1,
      'tick.fill.fillColor': 'none',
      'axisLine.stroke.color': 'black',
      'axisLine.stroke.width': 2,
      'axisLine.stroke.dasharray': "10 10",
      'axisLine.fill.fillColor': 'none'
    })
  };

  var chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function update() {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;

    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll('*').remove();

    var keyMap = {};

    var nameIndex = dex.csv.getColumnNumber(csv, config.index.name);
    var colorIndex = dex.csv.getColumnNumber(csv, config.index.color);
    var timeIndex = dex.csv.getColumnNumber(csv, config.index.time);
    var yIndex = dex.csv.getColumnNumber(csv, config.index.y);
    var sizeIndex = dex.csv.getColumnNumber(csv, config.index.size);

    csv.data.forEach(function (row) {
      var curName = row[nameIndex];
      var curColor = row[colorIndex];
      var curTime = row[timeIndex];
      var curY = row[yIndex];
      var curSize = +row[sizeIndex];

      if (!keyMap[curName]) {
        keyMap[curName] = {
          'name': curName,
          'color': curColor,
          'time': curTime,
          'y': [[curTime, curY]],
          'size': [[curTime, curSize]]
        };
      }
      else {
        keyMap[curName].y.push([curTime, curY]);
        keyMap[curName].size.push([curTime, curSize]);
      }
    });

    var uniques = dex.matrix.uniques(csv.data);

    var timeExtents = dex.matrix.extent(csv.data, [timeIndex]);
    //var xExtents = [0, uniques[nameIndex].length-1];
    var yExtents = dex.matrix.extent(csv.data, [yIndex]);

    //dex.console.log("EXTENTS: Y", yExtents, "UNIQUES", uniques[nameIndex]);

    // Various scales. These domains make assumptions of data, naturally.
    var xScale = d3.scale.ordinal()
      .domain(uniques[nameIndex].sort())
      .rangePoints([0, width]);

    //  d3.scale.linear().domain(xExtents).range([0, width - 60]);
    var yScale = dex.config.createScale(config.yaxis.scale)
      .domain([0, yExtents[1]]).range([height, 0]);

    // The x & y axes.
    var xAxis = dex.config.createAxis(config.xaxis)
      .scale(xScale);

    var yAxis = dex.config.createAxis(config.yaxis)
      .scale(yScale);

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg
      .append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    // Add the x-axis.
    rootG.append("g")
      .attr("class", "xaxis")
      .attr('width', width)
      .attr('height', height)
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

    // Add the y-axis.
    rootG.append("g")
      .attr("class", "yaxis")
      .call(yAxis);

    var xticks = rootG.selectAll(".xaxis .tick");

    var xtickLines = xticks.selectAll("line")
      .call(dex.config.configureStroke, config.xaxis.tick.stroke)
      .call(dex.config.configureFill, config.xaxis.tick.fill);

    var yticks = rootG.selectAll(".yaxis .tick");

    var yTickLines = yticks.selectAll("line")
      .call(dex.config.configureStroke, config.yaxis.tick.stroke)
      .call(dex.config.configureFill, config.yaxis.tick.fill);

    rootG.selectAll(".xaxis path")
      .call(dex.config.configureStroke, config.xaxis.axisLine.stroke)
      .call(dex.config.configureFill, config.xaxis.axisLine.fill);

    rootG.selectAll(".yaxis path")
      .call(dex.config.configureStroke, config.yaxis.axisLine.stroke)
      .call(dex.config.configureFill, config.yaxis.axisLine.fill);

    //var xTickLabels = xticks
    //  .append("text")
    //  .text("P" + config.csv.header[nameIndex]);

    //dex.console.log("XTICK-LABELS", xTickLabels);
    xticks.selectAll("text")
      .call(dex.config.configureText, config.xaxis.label);

    //xticks.selectAll("text")
    //  .call(dex.config.configureText, config.xaxis.label);

    // Add a y-axis label.
    rootG.append("text")
      .attr("class", "yLabel")
      .call(dex.config.configureText, config.yaxis.title)
      .text(config.csv.header[yIndex]);

    yticks.selectAll("text")
      .call(dex.config.configureText, config.yaxis.label);

    // Add the year label; the value is set on transition.
    var label = rootG.append("text")
      .attr("class", "timeLabel")
      .attr("text-anchor", "end")
      .call(dex.config.configureText, config.label)
      .text(timeExtents[0]);

    // Load the data.
    //d3.json("nations.json", function (nations) {

    // A bisector since many nation's data is sparsely-defined.
    var bisect = d3.bisector(function (d) {
      return d[0];
    });

    // Add a bar per nation. Initialize the data at min year value, and set the colors.
    var bars = rootG.append("g")
      .attr("class", "bars")
      .selectAll(".bar")
      .data(interpolateData(timeExtents[0]))
      .enter().append("rect")
      .attr("class", "bar")
      .call(dex.config.configureRectangle, config.bar)
      .call(position);
    //.sort(order);

    // Add a title.
    bars
      .append("tooltip-content")
      .text(function (d, i) {
        return "<table>" +
          "<tr><td>Name:</td><td>" + d.name + "</td></tr>" +
          "<tr><td>Category:</td><td>" + d.color + "</td></tr>" +
          "<tr><td>Value:</td><td>" + d.y + "</td></tr>" +
          "</table>";
      });

    // Add an overlay for the year label.
    var box = label.node().getBBox();

    var overlay = rootG.append("rect")
      .attr("class", "overlay")
      .attr("x", box.x)
      .attr("y", box.y)
      .attr("width", box.width)
      .attr("height", box.height)
      .attr("fill", "none")
      .style("pointer-events", "all")
      .style("cursor", "ew-resize")
      .on("mouseover", enableInteraction);

    // Start a transition that interpolates the data based on year.
    rootG.transition()
      .duration(config.duration)
      .ease("linear")
      .tween("year", tweenYear)
      .each("end", enableInteraction);

    // Positions the dots based on data.
    function position(bar) {
      var barWidth = Math.floor(width / bar.size() - 8);

      bar
        .attr("x", function (d, i) {
          return xScale(d.name);
        })
        .attr("y", function (d) {
          return yScale(d.y);
        })
        .attr("width", function (d) {
          return barWidth;
        })
        .attr("height", function (d) {
          //console.log(d.name + ": yScale(0)=" + yScale(0) + " - yScale(" + d.y + ")=" + yScale(d.y));
          // Some values were going negative...I might be sweeping a bug under the rug
          // but this at least filters these values.
          return Math.max(yScale(0) - yScale(d.y), 0);
        });
    }

    // After the transition finishes, you can mouseover to change the year.
    function enableInteraction() {
      //dex.console.log("ENABLING INTERACTION");
      var yearScale = d3.scale.linear()
        .domain(timeExtents)
        .range([box.x + 10, box.x + box.width - 10])
        .clamp(true);

      // Cancel the current transition, if any.
      rootG.transition().duration(0);

      overlay
        .on("mouseover", mouseover)
        .on("mouseout", mouseout)
        .on("mousemove", mousemove)
        .on("touchmove", mousemove);

      function mouseover() {
        label.classed("active", true);
      }

      function mouseout() {
        label.classed("active", false);
      }

      function mousemove() {
        displayYear(yearScale.invert(d3.mouse(this)[0]));
      }
    }

    // Tweens the entire chart by first tweening the year, and then the data.
    // For the interpolated data, the dots and label are redrawn.
    function tweenYear() {
      var year = d3.interpolateNumber(timeExtents[0], timeExtents[1]);
      return function (t) {
        displayYear(year(t));
      };
    }

    // Updates the display to show the specified year.
    function displayYear(year) {
      //dex.console.log("interpolateData(" + year + ")=",
      //  interpolateData(year));
      bars.data(interpolateData(year), function (d) {
        //dex.console.log("'" + d.name + "', interpolateData(" + year + ")=",
        //  interpolateData(year));
        return d.name;
      }).call(position);//.sort(order);
      label.text(Math.round(year));
    }

    // Interpolates the dataset for the given (fractional) year.
    function interpolateData(year) {
      var timeData = [];

      //
      for (var name in keyMap) {
        if (keyMap.hasOwnProperty(name)) {
          var entry = keyMap[name];

          //dex.console.log("ENTRY-DATA", entry);
          timeData.push({
            time: year,
            name: entry.name,
            color: entry.color,
            y: interpolateValues(entry.y, year),
            size: interpolateValues(entry.size, year)
          });
        }
      }
      //dex.console.log("interpolateData(" + year + ")=", timeData);
      return timeData;
    }

    // Finds (and possibly interpolates) the value for the specified year.
    function interpolateValues(values, year) {
      //dex.console.log("VALUES", values);
      var i = bisect.left(values, year, 0, values.length - 1),
        a = values[i];
      if (i > 0) {
        var b = values[i - 1],
          t = (year - a[0]) / (b[0] - a[0]);
        return a[1] * (1 - t) + b[1] * t;
      }
      return a[1];
    }
  };

    chart.clone = function clone(override) {
        return motionbarchart(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {

    // Add tooltips
    $(chart.config.parent).tooltip({
      items: "rect",
      content: function () {
        return $(this).find("tooltip-content").text();
      },
      track: true
    });
  });

  return chart;
};

module.exports = motionbarchart;
},{}],31:[function(require,module,exports){
var orbitallayout = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;
  var colors = d3.scale.category10();

  var defaults = {
    // The parent container of this chart.
    'parent': '#OrbitalLayoutParent',
    // Set these when you need to CSS style components independently.
    'id': 'OrbitalLayoutId',
    'class': 'OrbitalLayoutClass',
    'resizable': true,
    // Our data...
    'csv': {
      // Give folks without data something to look at anyhow.
      'header': ["X", "Y", "Z"],
      'data': [
        [0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]
      ]
    },
    'width': "100%",
    'height': "100%",
    'margin': {
      'left': 10,
      'right': 10,
      'top': 10,
      'bottom': 10
    },
    'transform': "",
    'title': dex.config.text(),
    'label': dex.config.text(),
    'radiusScale' : d3.scale.linear()
      .domain([0, 1, 2, 3, 4])
      .range([60, 20, 5, 2, 1])
      .clamp(true),
    'orbitScale' : d3.scale.linear()
      .domain([0, 5])
      .range([4.5, .3])
      .clamp(true),
    'circles': dex.config.circle({
      "r": function (d) {
        return chart.config.radiusScale(d.depth)
      },
      "fill.fillColor": function (d) {
        return colors(d.depth);
      }
    }),
    'orbits': dex.config.circle({
      'r': 5,
      'fill': {
        'fillColor': 'none',
        'fillOpacity': 1
      },
      'stroke': dex.config.stroke({
        'width': 1,
        'color': 'green',
        'opacity': .5,
        'dasharray': "2 2"
      })
    }),
    'refreshFrequencyMs': 50,
    'tickRadianStep': 0.004363323129985824
  };

  var chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;

    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll("*").remove();

    var data = dex.csv.toNestedJson(dex.csv.copy(csv));

    d3.layout.orbit = function () {
      var currentTickStep = 0;
      var orbitNodes;
      var orbitSize = [1, 1];
      var nestedNodes;
      var flattenedNodes = [];
      var orbitDispatch = d3.dispatch('tick');
      var tickInterval;
      var tickRadianStep = config.tickRadianStep;
      var orbitalRings = [];
      var orbitDepthAdjust = function () {
        return 2.95
      };
      var childrenAccessor = function (d) {
        return d.children
      };
      var tickRadianFunction = function () {
        return 1
      };

      function _orbitLayout() {

        return _orbitLayout;
      }

      _orbitLayout.mode = function () {
        //Atomic, Solar, other?
      }

      _orbitLayout.start = function () {
        //activate animation here
        tickInterval = setInterval(
          function () {
            currentTickStep++;
            flattenedNodes.forEach(function (_node) {
              if (_node.parent) {
                _node.x = _node.parent.x + ( (_node.parent.ring / 2) * Math.sin(_node.angle + (currentTickStep *
                    config.tickRadianStep * tickRadianFunction(_node))) );
                _node.y = _node.parent.y + ( (_node.parent.ring / 2) * Math.cos(_node.angle + (currentTickStep *
                    config.tickRadianStep * tickRadianFunction(_node))) );
              }
            })
            orbitalRings.forEach(function (_ring) {
              _ring.x = _ring.source.x;
              _ring.y = _ring.source.y;
            })
            orbitDispatch.tick();
          },
          config.refreshFrequencyMs);
      }

      _orbitLayout.stop = function () {
        //deactivate animation here
        clearInterval(tickInterval);
      }

      _orbitLayout.speed = function (_degrees) {
        if (!arguments.length) return tickRadianStep / (Math.PI / 360);
        tickRadianStep = tickRadianStep = _degrees * (Math.PI / 360);
        return this;
      }

      _orbitLayout.size = function (_value) {
        if (!arguments.length) return orbitSize;
        orbitSize = _value;
        return this;
        //change size here
      }

      _orbitLayout.revolution = function (_function) {
        //change ring size reduction (make that into dynamic function)
        if (!arguments.length) return tickRadianFunction;
        tickRadianFunction = _function;
        return this
      }

      _orbitLayout.orbitSize = function (_function) {
        //change ring size reduction (make that into dynamic function)
        if (!arguments.length) return orbitDepthAdjust;
        orbitDepthAdjust = _function;
        return this
      }

      _orbitLayout.orbitalRings = function () {
        //return an array of data corresponding to orbital rings
        if (!arguments.length) return orbitalRings;
        return this;
      }

      _orbitLayout.nodes = function (_data) {
        if (!arguments.length) return flattenedNodes;
        nestedNodes = _data;
        calculateNodes();
        return this;
      }

      _orbitLayout.children = function (_function) {
        if (!arguments.length) return childrenAccessor;

        //Probably should use d3.functor to turn a string into an object key
        childrenAccessor = _function;
        return this;
      }

      d3.rebind(_orbitLayout, orbitDispatch, "on");

      return _orbitLayout;
      function calculateNodes() {
        var _data = nestedNodes;
        //If you have an array of elements, then create a root node (center)
        //In the future, maybe make a binary star kind of thing?
        if (!childrenAccessor(_data)) {
          orbitNodes = {key: "root", values: _data}
          childrenAccessor(orbitNodes).forEach(function (_node) {
            _node.parent = orbitNodes;
          })
        }
        //otherwise assume it is an object with a root node
        else {
          orbitNodes = _data;
        }
        orbitNodes.x = orbitSize[0] / 2;
        orbitNodes.y = orbitSize[1] / 2;
        orbitNodes.deltaX = function (_x) {
          return _x
        }
        orbitNodes.deltaY = function (_y) {
          return _y
        }
        orbitNodes.ring = orbitSize[0] / 2;
        orbitNodes.depth = 0;

        flattenedNodes.push(orbitNodes);

        traverseNestedData(orbitNodes)

        function traverseNestedData(_node) {
          if (childrenAccessor(_node)) {
            var thisPie = d3.layout.pie().value(function (d) {
              return childrenAccessor(d) ? 4 : 1
            });
            var piedValues = thisPie(childrenAccessor(_node));

            orbitalRings.push({source: _node, x: _node.x, y: _node.y, r: _node.ring / 2});

            for (var x = 0; x < childrenAccessor(_node).length; x++) {

              childrenAccessor(_node)[x].angle = ((piedValues[x].endAngle - piedValues[x].startAngle) / 2) + piedValues[x].startAngle;

              childrenAccessor(_node)[x].parent = _node;
              childrenAccessor(_node)[x].depth = _node.depth + 1;

              childrenAccessor(_node)[x].x = childrenAccessor(_node)[x].parent.x + ( (childrenAccessor(_node)[x].parent.ring / 2) * Math.sin(childrenAccessor(_node)[x].angle) );
              childrenAccessor(_node)[x].y = childrenAccessor(_node)[x].parent.y + ( (childrenAccessor(_node)[x].parent.ring / 2) * Math.cos(childrenAccessor(_node)[x].angle) );

              childrenAccessor(_node)[x].deltaX = function (_x) {
                return _x
              }
              childrenAccessor(_node)[x].deltaY = function (_y) {
                return _y
              }
              childrenAccessor(_node)[x].ring = childrenAccessor(_node)[x].parent.ring / orbitDepthAdjust(_node);

              flattenedNodes.push(childrenAccessor(_node)[x]);
              traverseNestedData(childrenAccessor(_node)[x]);
            }
          }
        }
      }
    }

    var minSize = Math.min(width, height);

    orbit = d3.layout.orbit().size([minSize, minSize])
      .children(function (d) {
        return d.children
      })
      .revolution(function (d) {
        return d.depth
      })
      .orbitSize(function (d) {
        return config.orbitScale(d.depth)
      })
      .speed(.1)
      .nodes(data);

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg
      .append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    rootG.selectAll("g.node")
      .data(orbit.nodes())
      .enter()
      .append("g")
      .attr("class", "node")
      .attr("transform", function (d) {
        return "translate(" + d.x + "," + d.y + ")"
      })
      .on("mouseover", nodeOver)
      .on("mouseout", nodeOut)

    var circles = d3.selectAll("g.node")
      .append("circle");

    circles.call(dex.config.configureCircle, config.circles);

    rootG.selectAll("circle.orbits")
      .data(orbit.orbitalRings())
      .enter()
      .insert("circle", "g")
      .call(dex.config.configureCircle, config.orbits)
      .attr("class", "ring")
      .attr("r", function (d) {
        return d.r
      })
      .attr("cx", function (d) {
        return d.x
      })
      .attr("cy", function (d) {
        return d.y
      });

    orbit.on("tick", function () {
      d3.selectAll("g.node")
        .attr("transform", function (d) {
          return "translate(" + d.x + "," + d.y + ")"
        });

      d3.selectAll("circle.ring")
        .attr("cx", function (d) {
          return d.x
        })
        .attr("cy", function (d) {
          return d.y
        });
    });

    orbit.start();

    function nodeOver(d) {
      orbit.stop();
      var circle = d3.select(this).select("circle");
      circle.style("stroke", "black").style("stroke-width", 3);
      d3.select(this)
        .append("text")
        .text(d.name)
        .style("text-anchor", "middle")
        .attr("y", -config.radiusScale(d.depth) - 5);
    }

    function nodeOut() {
      orbit.start();
      d3.selectAll("text").remove();
      d3.selectAll("g.node > circle").style("stroke", "none").style("stroke-width", 0);
    }
  };

    chart.clone = function clone(override) {
        return orbitallayout(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = orbitallayout;
},{}],32:[function(require,module,exports){
var parallelcoordinates = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  defaults = {
    'parent': "ParallelCoordinatesParent",
    'id': "ParallelCoordinatesId",
    'class': "ParallelCoordinatesClass",
    'width': "100%",
    'height': "100%",
    'resizable': true,
    'color': d3.scale.category20(),
    'title': 'Parallel Coordinates',
    'csv': {
      'header': ["X", "Y"],
      'data': [
        [0, 0],
        [1, 1],
        [2, 4],
        [3, 9],
        [4, 16]
      ]
    },
    'normalize': false,
    'transform': '',
    'margin': {
      'left': 50,
      'right': 50,
      'top': 50,
      'bottom': 20
    },
    'axis': {
      'orient': 'left'
    },
    'axis.line': dex.config.line({
      'stroke': dex.config.stroke(
        {
          'color': function (d, i) {
            return "black";
          },
          'width': 1
        }),
      'fill': {
        'fillColor': "none",
        'fillOpacity': 1.0
      }
    }),
    'axis.label': dex.config.text({
      'font': {
        'size': function (d, i) {
          var uniques = _.uniq(_.flatten(dex.matrix.slice(chart.config.csv.data, [i])));

          var maxLabelLength =
            Math.min(("" + _.max(uniques,
              function (item) {
                return ("" + item).length;
              })).length, 40);

          // No need to adjust margins, initial transform already did.
          var maxFontSizeByHeight =
            ((chart.config.height) /
            (uniques.length ? uniques.length : 1) - 2);

          var maxFontSizeByWidth =
            (((chart.config.width) /
            (chart.config.csv.header.length - 1)) / maxLabelLength);

          //dex.console.log("AXIS-FONT-SIZE: I: " + i + ", MAX-HEIGHT: " + maxFontSizeByHeight +
          //", MAX-WIDTH: " + maxFontSizeByWidth + ", MAX-LABEL-LENGTH: " + maxLabelLength);
          return Math.min(Math.max(Math.min(maxFontSizeByWidth, maxFontSizeByHeight), 4), 18);
        }
      },
      'anchor': function (d, i) {
        if (i < chart.config.csv.header.length - 1) {
          return 'end';
        }
        else {
          return 'start';
        }
      },
      'dx': function (d, i) {
        return "-.5em"
      },
      'dy': ".35em",
      'fill.fillColor': 'black',
      'fill.fillOpacity': 1,
      'events': {
        'mouseover': function (d, i) {
          d3.select(this)
            .style('fill', 'red')
            .style('fill-opacity', 1);
        },
        'mouseout': function (d, i) {
          d3.select(this)
            .style('fill', 'black')
            .style('fill-opacity', 1);
        }
      }
    }),
    'verticalLabel': dex.config.text({
      // If you want to stagger labels.
      'dy': function (d, i) {
        return (i % 2) ?
          -chart.config.margin.top * .60 :
          -chart.config.margin.top * .20;
      },
      'font.size': function (d) {
        var maxFontSizeByHeight =
          chart.config.margin.top * .5;
        var maxFontSizeByWidth =
          (chart.config.width - chart.config.margin.left - chart.config.margin.right) /
          (chart.config.csv.header.length) / 10;
        //dex.console.log("TITLE-FONT-SIZE: MAX-HEIGHT: " + maxFontSizeByHeight +
        //", MAX-WIDTH: " + maxFontSizeByWidth);
        return Math.max(Math.min(maxFontSizeByWidth, maxFontSizeByHeight), 4);
      },
      'anchor': 'middle',
      'text': function (d) {
        return d;
      },
      'events': {
        'mouseover': function (d) {
          //dex.console.log("Mouseover detected...");
        }
      }
    }),
    'selected.link': {
      'stroke': dex.config.stroke(
        {
          'color': function (d, i) {
            return chart.config.color(i);
          },
          'width': 3
        }),
      'fill': {
        'fillColor': "none",
        'fillOpacity': .9
      },
      'events': {
        'mouseover': function () {
          d3.select(this)
            .style("stroke-width", chart.config.selected.link.stroke.width +
              Math.max(4, (chart.config.selected.link.stroke.width / 3)))
            .style("stroke-opacity", chart.config.selected.link.stroke.opacity);
        },
        'mouseout': function () {
          d3.select(this)
            .style("stroke-width", chart.config.selected.link.stroke.width)
            .style("stroke-opacity", chart.config.selected.link.stroke.opacity);
        }
      }
    },
    'unselected.link': {
      'stroke': dex.config.stroke(
        {
          'color': function (d, i) {
            return chart.config.color(i);
          },
          'width': .8,
          'dasharray': "1 2"
        }),
      'fill': {
        'fillColor': "none",
        'fillOpacity': 0.1
      }
    },
    'brush': {
      'width': 12,
      'x': -6,
      'opacity': .8,
      'color': "steelblue",
      'stroke': dex.config.stroke({'color': "black", 'width': 1})
    }
  };

  chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(userConfig) {
    var defaults = {
      "type": "group",
      "name": "Parallel Coordinates",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Normalize",
              "description": "Will normalize the scale of each column consistently, when true.",
              "target": "normalize",
              "type": "boolean",
              "initialValue": false
            },
            {
              "name": "Title",
              "description": "The title.",
              "target": "title",
              "type": "string",
              "initialValue": ""
            },
            {
              "name": "Axis Orientation",
              "description": "Axis orientation",
              "target": "axis.orient",
              "type": "choice",
              "choices": ["left", "right", "top", "bottom"],
              "initialValue": "left"
            }
          ]
        },
        dex.config.gui.brush({}, "brush"),
        dex.config.gui.text({name: "Tick Label"}, "axis.label"),
        dex.config.gui.path({name: "Axis Line"}, "axis.line"),
        dex.config.gui.text({name: "Axis Label"}, "verticalLabel"),
        dex.config.gui.link({name: "Selected Links"}, "selected.link"),
        dex.config.gui.link({name: "Unselected Links"}, "unselected.link")
      ]
    };
    var guiDef = dex.config.expandAndOverlay(userConfig, defaults);
    //guiDef = dex.config.gui.disable(guiDef, "axis.label.font.size");
    //dex.console.log("GUI-DEF", guiDef);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function update() {
    d3 = dex.charts.d3.d3v3;
    var chart = this;
    var config = chart.config;
    var csv = config.csv;
    var margin = config.margin;

    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(chart.config.parent).selectAll('*').remove();

    var numericColumns =
      dex.csv.getNumericColumnNames(csv);

    var jsonData = dex.csv.toJson(csv);

    var x = d3.scale.ordinal()
      .rangePoints([0, width], 1);

    var y = {};

    var line = d3.svg.line();

    // Holds unselected paths.
    var background;
    // Holds selected paths.
    var foreground;
    // Will hold our column names.
    var dimensions;
    var key;

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg
      .append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    // Extract the list of dimensions and create a scale for each.
    //x.domain(dimensions = d3.keys(cars[0]).filter(function(d)
    //{
    //  return d != "name" && (y[d] = d3.scale.linear()
    //    .domain(d3.extent(cars, function(p) { return +p[d]; }))
    //    .range([height, 0]));
    //}));
    var allExtents = []

    numericColumns.forEach(function (d) {
      allExtents = allExtents.concat(d3.extent(jsonData, function (p) {
        return +p[d];
      }));
    });

    var normalizedExtent = d3.extent(allExtents);

    // REM: Figure out how to switch over to consistent extents.  Snapping.
    x.domain(dimensions = d3.keys(jsonData[0]).filter(function (d) {
      if (d === "name") return false;

      if (dex.object.contains(numericColumns, d)) {
        var extent = d3.extent(jsonData, function (p) {
          return +p[d];
        });
        if (config.normalize) {
          extent = normalizedExtent;
        }

        y[d] = d3.scale.linear()
          .domain(extent)
          .range([height, 0]);
        allExtents.concat(extent);
      }
      else {
        y[d] = d3.scale.ordinal()
          .domain(jsonData.map(function (p) {
            return p[d];
          }))
          .rangePoints([height, 0]);
      }

      return true;
    }));

    // Add grey background lines for context.
    background = rootG.append("g")
      .attr("class", "background")
      .selectAll("path")
      .data(jsonData)
      .enter().append("path")
      .call(dex.config.configureLink, config.unselected.link)
      .attr("d", path)
      .attr("id", "fillpath");

    foreground = rootG.append("g")
      .selectAll("path")
      .data(jsonData)
      .enter().append("path")
      .attr("d", path)
      .call(dex.config.configureLink, config.selected.link);

    foreground
      .append("tooltip-content").text(function (d, i) {
      var info = "<table border=\"1\">";
      for (key in jsonData[i]) {
        info += "<tr><td><b><i>" + key + "</i></b></td><td>" + jsonData[i][key] + "</td></tr>"
      }
      return info + "</table>";
    });
//      .on("mouseover", function () {
//        d3.select(this)
//          .style("stroke-width", config.selected.link.stroke.width +
//          Math.max(4, (config.selected.link.stroke.width / 3)))
//          .style("stroke-opacity", config.selected.link.stroke.opacity);
//      })
//      .on("mouseout", function () {
//        d3.select(this)
//          .style("stroke-width", config.selected.link.stroke.width)
//          .style("stroke-opacity", config.selected.link.stroke.opacity);
//      });

    // Add a group element for each dimension.
    var g = rootG.selectAll(".dimension")
      .data(dimensions)
      .enter().append("g")
      .attr("class", "dimension")
      .attr("transform", function (d) {
        return "translate(" + x(d) + ")";
      });

    // Add an axis and title.
    g.append("g")
      .attr("class", "axis")
      .each(function (d, i) {

        var axisScale = dex.config.createScale(dex.config.scale(config.axis.scale));
        var axis = d3.svg.axis()
          .scale(axisScale);

        var myConfig = dex.object.clone(config.axis);
        // If the last label, turn it to the right.
        if (i == config.csv.header.length - 1) {
          myConfig.orient = 'right';
          myConfig.label.dx = function (d, i) {
            return ".5em";
          }
        }
        // Configure and apply the axis.
        dex.config.configureAxis(axis, myConfig, i);
        d3.select(this).call(axis.scale(y[d]));

        // Now that the axis has rendered, adjust the tick labels based on our spec.
        var tickLabels = d3.select(this)
          .selectAll('.tick')
          .selectAll("text")
          .call(dex.config.configureText, myConfig.label, i);
      })
      .append("text")
      .call(dex.config.configureText, config.verticalLabel);

    // Add and store a brush for each axis.
    g.append("g")
      .attr("class", "brush")
      .each(function (d) {
        d3.select(this).call(y[d].brush =
          d3.svg.brush().y(y[d])
            .on("brush", brush)
            .on("brushend", brushend));
      })
      .selectAll("rect")
      .call(dex.config.configureRectangle, config.brush);

    // Configure the axis lines:
    //dex.console.log("DOMAIN", d3.selectAll(".domain"));
    d3.selectAll(".domain")
      .call(dex.config.configurePath, config.axis.line);

    // Returns the path for a given data point.
    function path(d) {
      return line(dimensions.map(function (p) {
        return [x(p), y[p](d[p])];
      }));
    }

    // Handles a brush event, toggling the display of foreground lines.
    function brush() {
      // Get a list of our active brushes.
      var actives = dimensions.filter(function (p) {
          return !y[p].brush.empty();
        }),

        // Get an array of min/max values for each brush constraint.
        extents = actives.map(function (p) {
          return y[p].brush.extent();
        });

      foreground.style("display", function (d) {
        //dex.console.log("Calculating what lines to display: ", actives);
        return actives.every(
          // P is column name, i is an index
          function (p, i) {
            // Categorical
            //console.log("P: " + p + ", I: " + i);
            if (!dex.object.contains(numericColumns, p)) {
              return extents[i][0] <= y[p](d[p]) && y[p](d[p]) <= extents[i][1];
            }
            // Numeric
            else {
              return extents[i][0] <= d[p] && d[p] <= extents[i][1];
            }
          }) ? null : "none";
      });
    }

    // Handles a brush event, toggling the display of foreground lines.
    function brushend() {
      //dex.console.log("BRUSH-END: ", foreground);
      //dex.console.log("chart: ", chart);
      var activeData = [];
      var i;

      // WARNING:
      //
      // Can't find an elegant way to get back at the data so I am getting
      // at the data in a somewhat fragile manner instead.  Mike Bostock ever
      // changes the __data__ convention and this will break.
      for (i = 0; i < foreground[0].length; i++) {
        if (!(foreground[0][i]["style"]["display"] == "none")) {
          activeData.push(foreground[0][i]['__data__']);
        }
      }

      //dex.console.log("Selected: ", dex.json.toCsv(activeData, dimensions));
      chart.publish({"type": "select", "selected": dex.json.toCsv(activeData, dimensions)});
    }

    return chart;
  };

  chart.clone = function clone(override) {
    return parallelcoordinates(dex.config.expandAndOverlay(override, userConfig));
  };

  $(document).ready(function () {
    $(document).uitooltip({
      items: "path",
      content: function () {
        return $(this).find("tooltip-content").text();
      },
      track: true
    });
  });

  return chart;
};

module.exports = parallelcoordinates;
},{}],33:[function(require,module,exports){
var radarchart = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults = {
    // The parent container of this chart.
    'parent': '#RadarChartParent',
    // Set these when you need to CSS style components independently.
    'id': 'RadarChartId',
    'class': 'RadarChartClass',
    'resizable': true,
    // Our data...
    'csv': {
      // Give folks without data something to look at anyhow.
      'header': ["Salesman", "Q1", "Q2", "Q3", "Q4" ],
      'data': [
        ["Bob", Math.random(), Math.random(), Math.random(), Math.random()],
        ["Sue", Math.random(), Math.random(), Math.random(), Math.random()],
        ["Joe", Math.random(), Math.random(), Math.random(), Math.random()],
        ["Peg", Math.random(), Math.random(), Math.random(), Math.random()],
        ["Pat", Math.random(), Math.random(), Math.random(), Math.random()],
        ["Jim", Math.random(), Math.random(), Math.random(), Math.random()],
        ["Tim", Math.random(), Math.random(), Math.random(), Math.random()],
        ["Sam", Math.random(), Math.random(), Math.random(), Math.random()]
      ]
    },
    'width': "100%",
    'height': "100%",
    'transform': "",
    'margin': {
      top: 70,
      right: 50,
      bottom: 70,
      left: 50
    },
    'format': d3.format(','),
    'wrapWidth': 60,
    'levels': 5,
    'maxValue': 0,
    'labelFactor': 1,
    'dotRadius': 4,
    'opacityCircles': 0.1,
    'strokeWidth': 2,
    'roundStrokes': false,
    'color': d3.scale.category10(),
    'title': dex.config.text(),
    'label': dex.config.text({
      'fill.fillColor': 'green',
      'font.size': '16px',
      'anchor': function (d, i) {
        var degreesPerSection = 360 / (chart.attr('csv').header.length - 1);
        //dex.console.log("Degrees Per Section", degreesPerSection, degreesPerSection * (i-1));
        if (degreesPerSection * i < 10) {
          return "middle";
        }
        else if (degreesPerSection * i < 175) {
          return "start";
        }
        else if (degreesPerSection * i < 185) {
          return "middle";
        }

        return "end";
      },
      'dy' : function(d, i) {
        var degreesPerSection = 360 / (chart.attr('csv').header.length - 1);
        if (degreesPerSection * i < 10) {
          return '-1em';
        }
        else if (degreesPerSection * i < 175) {
          return '.3em';
        }
        else if (degreesPerSection * i < 185) {
          return '1em';
        }
        return '.3em';
      },
      'dx' : function(d, i) {
        var degreesPerSection = 360 / (chart.attr('csv').header.length - 1);
        if (degreesPerSection * i < 10) {
          return '0';
        }
        else if (degreesPerSection * i < 175) {
          return '1em';
        }
        else if (degreesPerSection * i < 185) {
          return '0';
        }
        return '-.3em'
      }
      //'dy': '.2em',
      //'dx': '.2em'
    }),
    'opacityArea': 0.25,
    // The spoke axis.
    'spoke': {
      'label': dex.config.text({
        'x': 4,
        'y': function (d) {
          var height = chart.attr('height');
          var width = chart.attr('width');
          var margin = chart.attr('margin');

          var radius = Math.min(height - margin.top - margin.bottom,
              width - margin.left - margin.right) / 2;
          return -d * radius / chart.config.levels
        },
        'dy': '.4em',
        'font.size': '16px',
        'fill.fillColor': 'red'
      }),
      'line': dex.config.line({
        'stroke.width': '1px',
        'stroke.color': 'blue',
        'stroke.dasharray': '5 5'
      })
    },
    'radar.circle': dex.config.circle({
      'opacity': 0.1,
      'fill': {
        'fillColor': '#CDCDCD',
        'fillOpacity': .15
      },
      'stroke': {
        'width': 1,
        'color': 'black',
        'opacity': .1,
        'dasharray': "0"
      },
      'events': {
        'mouseover': function () {
          d3.select(this)
            .style("stroke", 'red')
            .style("stroke-width", 2);
        },
        'mouseout': function () {
          d3.select(this)
            .style("stroke", chart.config.radar.circle.stroke.color)
            .style("stroke-width", chart.config.radar.circle.stroke.width);
        }
      }
    })
  };

  var chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var chart = this;
    var config = chart.config;
    var margin = config.margin;
    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;
    var csv = config.csv;

    // Remove the old, build from scratch.
    d3.selectAll(config.parent).selectAll('*').remove();

    // REM: Port to dex.csv method generically
    data = csv.data.map(function (row) {
      return {
        'key': row[0],
        'values': row.slice(1).map(function (d, i) {
          return {
            'axis': csv.header[i + 1],
            'value': +d
          }
        })
      }
    });

    data = data.map(function (d) {
      return d.values
    });

    var extents = dex.matrix.extent(csv.data, dex.range(1, csv.header.length - 1));

    //If the supplied maxValue is smaller than the actual one, replace by the max in the data
    var maxValue = extents[1];

    var allAxis = (data[0].map(function (i, j) {
        return i.axis
      })),	//Names of each axis
      total = allAxis.length,					//The number of different axes
      radius = Math.min(width / 2, height / 2),

      //Format = d3.format('%'),			 	//Percentage formatting
      angleSlice = Math.PI * 2 / total;			//The width in radians of each "slice"

    //Scale for the radius
    var rScale = d3.scale.linear()
      .range([0, radius])
      .domain([0, maxValue]);

    // Store in config for chart calculations.
    config.radiusScale = rScale;

    /////////////////////////////////////////////////////////
    //////////// Create the container SVG and g /////////////
    /////////////////////////////////////////////////////////

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg.append('g')
      .attr('transform', 'translate(' +
        (margin.left + config.width/2) + ',' +
        (margin.top + config.height/2) + ') ' +
        config.transform);

    /////////////////////////////////////////////////////////
    ////////// Glow filter for some extra pizzazz ///////////
    /////////////////////////////////////////////////////////

    //Filter for the outside glow
    var filter = rootG.append('defs').append('filter').attr('id', 'glow'),
      feGaussianBlur = filter.append('feGaussianBlur').attr('stdDeviation', '2.5').attr('result', 'coloredBlur'),
      feMerge = filter.append('feMerge'),
      feMergeNode_1 = feMerge.append('feMergeNode').attr('in', 'coloredBlur'),
      feMergeNode_2 = feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

    /////////////////////////////////////////////////////////
    /////////////// Draw the Circular grid //////////////////
    /////////////////////////////////////////////////////////

    //Wrapper for the grid & axes
    var axisGrid = rootG.append("g").attr("class", "axisWrapper");

    //Draw the background circles, broken in WebView
    axisGrid.selectAll(".levels")
      .data(d3.range(1, (config.levels + 1)).reverse())
      .enter()
      .append("circle")
      .attr("class", "gridCircle")
      // TODO: This breaks webview.
      //.style("filter", "url(#glow)")
      .call(dex.config.configureCircle, config.radar.circle)
      .attr("r", function (d, i) {
        return radius / config.levels * d;
      });

    //Text indicating at what % each level is

    axisGrid.selectAll(".axisLabel")
      .data(d3.range(1, (config.levels + 1)).reverse())
      .enter().append("text")
      .call(dex.config.configureText, config.spoke.label)
      .attr("class", "axisLabel")
      .text(function (d, i) {
        return config.format(maxValue * d / config.levels);
        //Format(maxValue * d / config.levels);
      });

    /////////////////////////////////////////////////////////
    //////////////////// Draw the axes //////////////////////
    /////////////////////////////////////////////////////////

    //Create the straight lines radiating outward from the center
    var axis = axisGrid.selectAll(".axis")
      .data(allAxis)
      .enter()
      .append("g")
      .attr("class", "axis");
    //Append the lines
    axis.append("line")
      .call(dex.config.configureLine, config.spoke.line)
      .attr("x1", 0)
      .attr("y1", 0)
      .attr("x2", function (d, i) {
        return rScale(maxValue * 1.05) * Math.cos(angleSlice * i);
      })
      .attr("y2", function (d, i) {
        return rScale(maxValue * 1.05) * Math.sin(angleSlice * i);
      })
      .attr("class", "line");
//      .style("stroke", "white")
//      .style("stroke-width", "2px");

    //Append the labels at each axis
    axis.append("text")
      .call(dex.config.configureText, config.label)
      .attr("class", "legend")
      //.style("font-size", "11px")
      //.attr("text-anchor", "middle")
      //.attr("dy", "0.35em")
      .attr("x", function (d, i) {
        return rScale(maxValue * config.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
      })
      .attr("y", function (d, i) {
        return rScale(maxValue * config.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
      })
      .text(function (d) {
        return d
      });
      //.call(wrap, config.wrapWidth);

    /////////////////////////////////////////////////////////
    ///////////// Draw the radar chart blobs ////////////////
    /////////////////////////////////////////////////////////

    //The radial line function
    var radarLine = d3.svg.line.radial()
      .interpolate("linear-closed")
      .radius(function (d) {
        return rScale(d.value);
      })
      .angle(function (d, i) {
        return i * angleSlice;
      });

    if (config.roundStrokes) {
      radarLine.interpolate("cardinal-closed");
    }

    //Create a wrapper for the blobs
    var blobWrapper = rootG.selectAll(".radarWrapper")
      .data(data)
      .enter().append("g")
      .attr("class", "radarWrapper");

    //Append the backgrounds
    blobWrapper
      .append("path")
      .attr("class", "radarArea")
      .attr("d", function (d, i) {
        return radarLine(d);
      })
      .style("fill", function (d, i) {
        return config.color(i);
      })
      .style("fill-opacity", config.opacityArea)
      .on('mouseover', function (d, i) {
        //Dim all blobs
        d3.selectAll(".radarArea")
          .transition().duration(200)
          .style("fill-opacity", 0.05);
        //Bring back the hovered over blob
        d3.select(this)
          .transition().duration(200)
          .style("fill-opacity", .7);
      })
      .on('mouseout', function () {
        //Bring back all blobs
        d3.selectAll(".radarArea")
          .transition().duration(200)
          .style("fill-opacity", config.opacityArea);
      });

    //Create the outlines
    blobWrapper.append("path")
      .attr("class", "radarStroke")
      .attr("d", function (d, i) {
        return radarLine(d);
      })
      .style("stroke-width", config.strokeWidth + "px")
      .style("stroke", function (d, i) {
        return config.color(i);
      })
      .style("fill", "none")
      .style("filter", "url(#glow)");

    //Append the circles
    blobWrapper.selectAll(".radarCircle")
      .data(function (d, i) {
        return d;
      })
      .enter().append("circle")
      .attr("class", "radarCircle")
      .attr("r", config.dotRadius)
      .attr("cx", function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      })
      .attr("cy", function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      })
      .style("fill", function (d, i, j) {
        return config.color(j);
      })
      .style("fill-opacity", 0.8);

    /////////////////////////////////////////////////////////
    //////// Append invisible circles for tooltip ///////////
    /////////////////////////////////////////////////////////

    //Wrapper for the invisible circles on top
    var blobCircleWrapper = rootG.selectAll(".radarCircleWrapper")
      .data(data)
      .enter().append("g")
      .attr("class", "radarCircleWrapper");

    //Append a set of invisible circles on top for the mouseover pop-up
    blobCircleWrapper.selectAll(".radarInvisibleCircle")
      .data(function (d, i) {
        return d;
      })
      .enter().append("circle")
      .attr("class", "radarInvisibleCircle")
      .attr("r", config.dotRadius * 1.5)
      .attr("cx", function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      })
      .attr("cy", function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      })
      .style("fill", "none")
      .style("pointer-events", "all")
      .on("mouseover", function (d, i) {
        newX = parseFloat(d3.select(this).attr('cx')) - 10;
        newY = parseFloat(d3.select(this).attr('cy')) - 10;

        tooltip
          .attr('x', newX)
          .attr('y', newY)
          .text(config.format(d.value))
          .transition().duration(200)
          .style('opacity', 1);
      })
      .on("mouseout", function () {
        tooltip.transition().duration(200)
          .style("opacity", 0);
      });

    //Set up the small tooltip for when you hover over a circle
    var tooltip = rootG.append("text")
      .attr("class", "tooltip")
      .style("opacity", 0);

    /////////////////////////////////////////////////////////
    /////////////////// Helper Function /////////////////////
    /////////////////////////////////////////////////////////

    //Taken from http://bl.ocks.org/mbostock/7555321
    //Wraps SVG text
    function wrap(text, width) {
      text.each(function () {
        var text = d3.select(this),
          words = text.text().split(/\s+/).reverse(),
          word,
          line = [],
          lineNumber = 0,
          lineHeight = 1.4, // ems
          y = text.attr("y"),
          x = text.attr("x"),
          dy = parseFloat(text.attr("dy")),
          tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

    // Allow method chaining
    return chart;
  };

    chart.clone = function clone(override) {
        return radarchart(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = radarchart;

},{}],34:[function(require,module,exports){
var radialtree = function (userConfig) {
  d3 = dex.charts.d3.d3v4;
  var chart;

  var defaults = {
    // The parent container of this chart.
    'parent': '#RadialTreeParent',
    'id': 'RadialTreeId',
    'class': 'RadialTreeClass',
    'resizable': true,
    // Our data...
    'csv': {
      // Give folks without data something to look at anyhow.
      'header': ["X", "Y", "Z"],
      'data': [
        [0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]
      ]
    },
    'nodeColorScheme': "category10",
    'linkColorScheme': "category10",
    'labelColorScheme': "category10",
    'width': "100%",
    'height': "100%",
    'transform': "",
    'label': dex.config.text({
        'dy': '.31em',
        "x": function (d) {
          return d.x < 180 && !d.children ? 6 : -6;
        },
        'fill.fillColor': function (d) {
          return chart.config.labelColor(d.depth);
        },
        'font': dex.config.font({
          'family': 'sans-serif',
          'size': 10,
        }),
        'anchor': function (d) {
          //dex.console.log("anchor", d);
          return d.x < 180 && !d.children ? "start" : "end";
        },
        'transform': function (d) {
          //dex.console.log("TRANSFORMING", d);
          return "rotate(" + (d.x < 180 ? d.x - 90 : d.x + 90) + ")";
        },
        'text': function (d) {
          //console.dir(d);
          return d.data.name;
        }
      }
    ),
    'link': dex.config.path({
      'stroke.color': function (d) {
        return chart.config.linkColor(d.depth);
      },
      'stroke.dasharray': '',
      'stroke.width': 4,
      'stroke.opacity': .5,
      'fill.fillOpacity': .1,
      'fill.fillColor': 'none',
      'd': function (d) {
        return "M" + project(d.x, d.y)
          + "C" + project(d.x, (d.y + d.parent.y) / 2)
          + " " + project(d.parent.x, (d.y + d.parent.y) / 2)
          + " " + project(d.parent.x, d.parent.y);
      }
    }),
    'connectionRatio': .9,
    'node': dex.config.circle({
      'r': 3,
      'stroke.color': function (d) {
        return chart.config.nodeColor(d.depth);
      },
      'fill.fillColor': 'white'
    }),
    'separationModel': function (a, b) {
      //dex.console.log("separation", a, b);
      return (a.parent == b.parent ? 1 : 3) / a.depth;
    },
    'connectionLength': 80,
    'maxAngle': 360,
    'radius': function () {
      return Math.min(
        (chart.config.width - chart.config.margin.left -
        chart.config.margin.right) / 2,
        (chart.config.height - chart.config.margin.top -
        chart.config.margin.bottom) / 2);
    },
    'margin': {
      'left': 30,
      'right': 30,
      'top': 60,
      'bottom': 60
    }
  };

  var chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Radial Tree Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        dex.config.gui.text({}, "label"),
        dex.config.gui.link({}, "link"),
        dex.config.gui.circle({name: "Node"}, "node"),
        {
          "name": "Connection Length",
          "description": "Connection length",
          "type": "int",
          "minValue": 0,
          "maxValue": 300,
          "initialValue": 80,
          "target": "connectionLength"
        },
        {
          "name": "Max Angle",
          "description": "Max angle",
          "type": "int",
          "minValue": 0,
          "maxValue": 360,
          "initialValue": 360,
          "target": "maxAngle"
        },
        {
          "name": "Link Color Scheme",
          "description": "Color Scheme For Links",
          "type": "choice",
          "choices": dex.color.colormaps(),
          "target": "linkColorScheme"
        },
        {
          "name": "Node Color Scheme",
          "description": "Color Scheme For Nodes",
          "type": "choice",
          "choices": dex.color.colormaps(),
          "target": "nodeColorScheme"
        },
        {
          "name": "Label Color Scheme",
          "description": "Color Scheme For Labels",
          "type": "choice",
          "choices": dex.color.colormaps(),
          "target": "labelColorScheme"
        }
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    d3 = dex.charts.d3.d3v4;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v4;
    var config = chart.config;
    config.linkColor =
      d3.scaleOrdinal(dex.color.palette[config.linkColorScheme]);
    config.labelColor =
      d3.scaleOrdinal(dex.color.palette[config.labelColorScheme]);
    config.nodeColor =
      d3.scaleOrdinal(dex.color.palette[config.nodeColorScheme]);
    var csv = config.csv;
    var margin = config.margin;

    var width = +config.width - margin.left - margin.right;
    var height = +config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll('*').remove();

    var data = dex.csv.toNestedJson(dex.csv.copy(csv));

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg.append("g")
      .attr("transform", "translate(" +
        (+margin.left + (+width / 2)) + "," +
        (+margin.top + (+height / 2)) + ") " +
        config.transform);

    chart.internalUpdate(data);

    return chart;
  };

  chart.internalUpdate = function (source) {
    d3 = dex.charts.d3.d3v4;
    var config = chart.config;
    var csv = config.csv;
    var margin = config.margin;

    var svg = d3.select(config.parent).select("svg");
    var g = svg.select("g");

    var tree = d3.tree()
      .size([config.maxAngle, config.radius()])
      .separation(config.separationModel);

    var hier = d3.hierarchy(source);
    var root = tree(hier);

    var link = g.selectAll(".link")
      .data(root.descendants().slice(1))
      .enter().append("path")
      .attr("class", "link")
      .call(dex.config.configurePath, config.link);

    //node.attr("y", function(d) { d.y = d.depth * 80; });

    var nodes = g.selectAll(".node")
      .data(root.descendants());

    //dex.console.log("DESCENDANTS", root.descendants());

    var nodeEnter = nodes.enter()
      .append("g")
      .attr("class", function (d) {
        return "node" + (d.children ? " node--internal" : " node--leaf");
      })
      .attr("transform", function (d) {
        return "translate(" + project(d.x, d.y) + ")";
      });
    //.on("click", click);

    nodeEnter.append("circle")
      .call(dex.config.configureCircle, config.node);

    //node.attr("y", function(d) { return d.depth * 40; });

    nodeEnter.append("text")
      .call(dex.config.configureText, config.label);


    var nodeExit = nodes.exit()
      .transition()
      .duration(config.duration)
      .remove();

    nodeExit.select("circle")
      .attr("r", 1e-6);

    nodeExit.select("text")
      .style("fill-opacity", 1e-6);

    function click(d) {
      d3 = dex.charts.d3.d3v4;
      //dex.console.log("CLICK", d);
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }

      chart.internalUpdate(d);
    }

    return chart;
  };

  chart.clone = function clone(override) {
    return radialtree(dex.config.expandAndOverlay(override, userConfig));
  };

  function project(x, y) {
    //dex.console.log('project(x,y)', x, y);
    var angle = (x - 90) / 180 * Math.PI;
    var radius = y * chart.config.connectionRatio;
    return [radius * Math.cos(angle), radius * Math.sin(angle)];
  }

  $(document).ready(function () {
    // Make the entire chart draggable.
    if (chart.config.draggable) {
      $(chart.config.parent).draggable();
    }
  });

  return chart;
};

module.exports = radialtree;

},{}],35:[function(require,module,exports){
var sankey = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var defaultColor = d3.scale.category20c();
  var chart;

  var defaults = {
    // The parent container of this chart.
    'parent': '#SankeyParent',
    // Set these when you need to CSS style components independently.
    'id': 'SankeyId',
    'class': 'SankeyClass',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'margin': {
      'left': 100,
      'right': 100,
      'top': 50,
      'bottom': 50
    },
    'transform': "",
    // Our data...
    'csv': {
      // Give folks without data something to look at anyhow.
      'header': ["X", "Y", "WEIGHT"],
      'data': [
        ["A1", "A2", 1],
        ["B1", "B2", 2],
        ["C1", "C2", 2],
        ["C2", "C3", 4]
      ]
    },
    'relationships': null,
    'layoutIterations': 32,
    'columnTitle': dex.config.text({
        'fill.fillColor': 'black',
        'x': function (d) {
          var center = window.innerWidth / 2;
          //var center = (typeof userConfig.width !== 'undefined' ?
          //  userConfig.width : defaults.width) / 2;

          var nodeWidth = (userConfig.mouseout && userConfig.mouseout.node &&
          userConfig.mouseout.node.rectangle && userConfig.mouseout.node.rectangle.width) ?
            userConfig.mouseout.node.rectangle.width : defaults.mouseout.node.rectangle.width;

          var nodePadding = (userConfig.mouseout && userConfig.mouseout.node &&
          userConfig.mouseout.node.padding) ?
            userConfig.mouseout.node.padding : defaults.mouseout.node.padding;

          //dex.console.log("d.x=" + d.x + ", width=" + window.innerWidth + ", nodeWidth=" + nodeWidth +
          //  ", nodePadding=" + nodePadding + ", center=" + center);
          if (+d > center) {
            //return +d-nodePadding-nodeWidth;
            return +d + nodeWidth / 2;
          }
          else {
            //return +d + nodeWidth + nodePadding;
            return +d + nodeWidth / 2;
          }
        },
        "y": 10,
        "writingMode": "tb",
        "glyphOrientationVertical": 0,
        "anchor": function (d, i) {
          //var center = (typeof userConfig.width !== 'undefined' ?
          // userConfig.width : defaults.width) / 2;
          var center = window.innerWidth / 2;

          if (+d > center) {
            // End if horizontal
            return "start";
          }
          else {
            return "start";
          }
        },
        "text": function (d, i) {
          return d + ", i" + i;
        }
      }
    ),
    'label': dex.config.text({
      'fill.fillColor': 'black',
      'x': function (d) {
        var center = window.innerWidth / 2;
        //var center = (typeof userConfig.width !== 'undefined' ?
        //  userConfig.width : defaults.width) / 2;

        var nodeWidth = (userConfig.mouseout && userConfig.mouseout.node &&
        userConfig.mouseout.node.rectangle &&
        userConfig.mouseout.node.rectangle.width) ?
          userConfig.mouseout.node.rectangle.width : defaults.mouseout.node.rectangle.width;

        var nodePadding = (userConfig.mouseout && userConfig.mouseout.node &&
        userConfig.mouseout.node.padding) ?
          userConfig.mouseout.node.padding : defaults.mouseout.node.padding;

        //dex.console.log("d.x=" + d.x + ", width=" + window.innerWidth + ", nodeWidth=" + nodeWidth +
        //  ", nodePadding=" + nodePadding + ", center=" + center);
        if (d.x > center) {
          return -nodePadding;
        }
        else {
          return nodeWidth + nodePadding;
        }
      },
      'y': function (d) {
        return d.dy / 2;
      },
      'transform': null,
      'dy': '.35em',
      'anchor': function (d, i) {
        //var center = (typeof userConfig.width !== 'undefined' ?
        // userConfig.width : defaults.width) / 2;
        var center = window.innerWidth / 2;

        if (d.x > center) {
          return "end";
        }
        else {
          return "start";
        }
      },
      'font': {
        'size': 14
      },
      'color': "black",
      'opacity': 1,
      'text': function (d) {
        return d.name;
      }
    }),
    //'columnLayout' : function(node, nodeMap) { return nodeMap[node.name].column },
    'mouseout': {
      'link': {
        'stroke': dex.config.stroke({
          'opacity': .2,
          'color': function (d) {
            return defaultColor(d.category);
          },
          'width': function (d) {
            //return 0;
            return Math.max(1, d.dy);
          }
        }),
        'fill': dex.config.fill({
          'fillColor': 'none',
          'fillOpacity': .4
        }),
        'curvature': 0.5
      },
      'node': {
        'padding': 4,
        'rectangle': dex.config.rectangle(
          {
            'width': 32,
            'color': function (d) {
              return defaultColor(d.name.replace(/ .*/, ""));
            },
            'height': function (d) {
              return d.dy;
            },
            'stroke': dex.config.stroke({
              'color': function (d) {
                return d3.rgb(d.color).darker(2);
              }
            })
          })
      }
    },
    'mouseover': {
      'link': {
        'stroke': dex.config.stroke({
          'opacity': .8,
          'width': function (d) {
            return Math.max(1, d.dy);
          },
          'color': function (d) {
            return defaultColor(d.category);
          }
        }),
        'fill': dex.config.fill({
          'fillColor': 'none',
          'fillOpacity': .8
        }),
      },
      'node': {
        'stroke': dex.config.stroke({
          'opacity': .8,
          'width': function (d) {
            return Math.max(1, d.dy);
          },
          'color': function (d) {
            return defaultColor(d.category);
          }
        }),
        'fill': dex.config.fill({
          'fillColor': 'none',
          'fillOpacity': .8
        })
      }
    },
    'node': {
      'padding': 4,
      'rectangle': dex.config.rectangle({
        'width': 32,
        'color': function (d) {
          return defaultColor(d.name.replace(/ .*/, ""));
        },
        'height': function (d) {
          return d.dy;
        },
        'stroke': dex.config.stroke({
          'color': function (d) {
            return d3.rgb(d.color).darker(2);
          }
        })
      })
    },
    "manualColumnLayout": false
  };

  var chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Sankey Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Layout Iterations",
              "description": "Number of iterations to determine optimal layout.",
              "target": "layoutIterations",
              "type": "int",
              "maxValue": 200,
              "minValue": 10,
              "initialValue": 32
            },
            {
              "name": "Manual Column Layout",
              "description": "Manual column layout.",
              "target": "manualColumnLayout",
              "type": "boolean",
              "initialValue": false
            }
          ]
        },
        dex.config.gui.text({"name": "Column Title"}, "columnTitle"),
        dex.config.gui.text({"name": "Labels"}, "label"),
        dex.config.gui.rectangle({"name": "Node Rectangle"}, "node.rectangle"),
        {
          "type": "group",
          "name": "On Mouseover",
          "contents": [
            dex.config.gui.link({"name": "Link On Mouseover"}, "mouseover.link"),
            dex.config.gui.rectangle({"name": "Node On Mouseover"}, "mouseover.node.rectangle")
          ]
        },
        {
          "type": "group",
          "name": "On Mouseout",
          "contents": [
            dex.config.gui.link({"name": "Link On Mouseout"}, "mouseout.link"),
            dex.config.gui.rectangle({"name": "Node On Mouseout"}, "mouseout.node.rectangle")
          ]
        }
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };
  // If we do not have specifically defined relationship fields, then lets
  // try to make an educated guess about what to do with them.  If the last
  // column is numeric, we will assume that this is to be used as a weight.
  // Otherwise, we will use a uniform weighting of 1 for each link.
  if (!chart.config.relationships) {
    // If we have less than 3 columns or the last column does not contain
    // numerics then we will create a set of relationships for each column
    // with a standard weight of 1 and a single category of 1.
    if (chart.config.csv.header.length < 3 || !dex.csv.isColumnNumeric(chart.config.csv, chart.config.csv.header.length - 1)) {
      chart.config.relationships = [];

      for (i = 1; i < chart.config.csv.header.length; i++) {
        chart.config.relationships.push(
          {
            'source': i - 1,
            'target': i,
            'value': function (csv, ri) {
              return 1;
            },
            'category': function (csv, ri) {
              return 1;
            },
            'column': function (csv, ri, ci) {
              return i;
            }
          });
      }
    }
    // If we fall through here, then the last column is numeric.  We will
    // use this for our weight.
    else {
      chart.config.relationships = [];

      for (i = 1; i < chart.config.csv.header.length - 1; i++) {
        chart.config.relationships.push(
          {
            'source': i - 1,
            'target': i,
            'value': function (csv, ri) {
              return csv.data[ri][csv.header.length - 1];
            },
            'category': function (csv, ri) {
              return 1;
            },
            'column': function (csv, ri, ci) {
              return i;
            }
          });
      }
    }
  }

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;

    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll('*').remove();

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg
      .append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    var sankeyData = [];

    var nodeMap = {};

    for (ri = 0; ri < config.relationships.length; ri++) {
      for (i = 0; i < config.csv.data.length; i++) {
        var relation = [];
        var source;
        var target;

        if (dex.object.isFunction(config.relationships[ri].source)) {
          source = config.relationships[ri].source(config.csv, i);
        }
        else {
          source =
            {
              'nodeName': config.csv.data[i][config.relationships[ri].source],
              'name': config.csv.data[i][config.relationships[ri].source],
              'column': (config.relationships[ri].column) ?
                config.relationships[ri].column(csv, i, config.relationships[ri].source) :
                config.relationships[ri].source
            };
        }

        if (dex.object.isFunction(config.relationships[ri].target)) {
          target = config.relationships[ri].target(config.csv, i);
        }
        else {
          target =
            {
              'nodeName': config.csv.data[i][config.relationships[ri].target],
              'name': config.csv.data[i][config.relationships[ri].target],
              'column': (config.relationships[ri].column) ?
                config.relationships[ri].column(csv, i, config.relationships[ri].target) :
                config.relationships[ri].target
            }
        }

        relation.source = source.nodeName;
        relation.target = target.nodeName;

        // Store this to translate nodenames back to display names.
        nodeMap[source.nodeName] = source;
        nodeMap[target.nodeName] = target;

        // Wrap source and target info:
        //dex.console.log("RELATION", config.relationships[ri]);
        if (typeof config.relationships[ri].category === "undefined") {
          //relation.category = csv.data[i][config.relationships[ri].source];
          relation.category = 1;
        }
        else if (dex.object.isFunction(config.relationships[ri].category)) {
          relation.category = config.relationships[ri].category(config.csv, i);
        }
        else {
          relation.category = config.relationships[ri].category;
        }

        relation.linkid = "L" + i;

        if (typeof config.relationships[ri].value === "undefined") {
          relation.value = 1;
        }
        else if (dex.object.isFunction(config.relationships[ri].value)) {
          relation.value = config.relationships[ri].value(config.csv, i);
        }
        else {
          relation.value = config.relationships[ri].value;
        }

        sankeyData.push(relation);
      }
    }
    //dex.console.log("sankeyData", sankeyData);
    var units = "Units";

    var formatNumber = d3.format(",.0f"),    // zero decimal places
      format = function (d) {
        return formatNumber(d) + " " + units;
      };

    function manualColumnLayout(nodes, nodeWidth, size) {
      var numSinks = 1;

      nodes.forEach(function (node) {
        //node.x = (nodeMap[node.name].column) * nodeWidth;
        node.x = (nodeMap[node.name].column - 1) * nodeWidth;
        numSinks = Math.max(numSinks, node.x);
        node.dx = nodeWidth;
      });

      var nodeBreadth = (size[0] - nodeWidth) / (numSinks - 1);
      nodes.forEach(function (node) {
        node.x *= nodeBreadth;
      });
    }

    // Set the sankey diagram properties
    var sankey = d3sankey()
      .nodeWidth(config.mouseout.node.rectangle.width)
      .nodePadding(config.mouseout.node.padding)
      .size([width - config.mouseout.node.padding, height - config.mouseout.node.padding]);

    if (config.manualColumnLayout) {
      sankey.columnLayout(manualColumnLayout);
    }

    var path = sankey.link();

    //set up graph in same style as original example but empty
    graph = {"nodes": [], "links": []};

    sankeyData.forEach(function (d, i) {
      graph.nodes.push({"name": d.source});
      graph.nodes.push({"name": d.target});
      graph.links.push({
        "source": d.source, "target": d.target, "value": +d.value,
        "category": d.category, "linkid": d.linkid
      });
    });

    //dex.console.log("GRAPH NODES 1", graph.nodes);

    //thanks Mike Bostock https://groups.google.com/d/msg/d3-js/pl297cFtIQk/Eso4q_eBu1IJ
    //this handy little function returns only the distinct / unique nodes
    graph.nodes = d3.keys(d3.nest()
      .key(function (d) {
        return d.name;
      })
      .map(graph.nodes));

    //dex.console.log("GRAPH NODES 2", graph.nodes);

    // it appears d3 with force layout wants a numeric source and target
    // so loop through each link replacing the text with its index from node
    graph.links.forEach(function (d, i) {
      graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
      graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
    });

    //now loop through each nodes to make nodes an array of objects rather than an array of strings
    graph.nodes.forEach(function (d, i) {
      graph.nodes[i] = {"name": d};
    });

    sankey
      .nodes(graph.nodes)
      .links(graph.links)
      .curvature(config.mouseout.link.curvature)
      .layout(config.layoutIterations);

    // add in the links
    var link = rootG.append("g").selectAll(".link")
      .data(graph.links)
      .enter().append("path")
      .attr("class", "link")
      .attr("id", function (d) {
        return d.linkid;
      })
      .attr("d", path)
      .call(dex.config.configureLink, config.mouseout.link)
      .sort(function (a, b) {
        return b.dy - a.dy;
      })
      .on("mouseover", function (d) {
        rootG.selectAll("#" + d.linkid)//.style("stroke-opacity", 1)
          .call(dex.config.configureLink, config.mouseover.link);
      })
      .on("mouseout", function (d) {
        rootG.selectAll("#" + d.linkid)//.style("stroke-opacity", config.link.stroke.opacity);
          .call(dex.config.configureLink, config.mouseout.link);
      });

    // add the link titles
    link.append("tooltip-content")
      .text(function (d) {
        return nodeMap[d.source.name].name + " -> " +
          nodeMap[d.target.name].name + "\n" + format(d.value);
      });

    // add in the nodes
    var node = rootG.append("g").selectAll(".node")
      .data(graph.nodes)
      .enter().append("g")
      .attr("class", "node")
      .attr("transform", function (d) {
        return "translate(" + d.x + "," + d.y + ")";
      })
      .call(d3.behavior.drag()
        .origin(function (d) {
          return d;
        })
        .on("dragstart", function () {
          this.parentNode.appendChild(this);
        })
        .on("drag", dragmove));

    // add the rectangles for the nodes
    node.append("rect")
      .call(dex.config.configureRectangle, config.mouseout.node.rectangle)
      .on("mouseover", function (d) {
        var links = (d.sourceLinks.length > 0) ?
          d.sourceLinks : d.targetLinks;

        links.forEach(function (link) {
          rootG.selectAll("#" + link.linkid)
            .call(dex.config.configureLink, config.mouseover.node);
        });
      })
      .on("mouseout", function (d) {

        var links = (d.sourceLinks.length > 0) ?
          d.sourceLinks : d.targetLinks;
        links.forEach(function (link) {
          rootG.selectAll("#" + link.linkid)
            .call(dex.config.configureLink, config.mouseout.link);
        });
      })
      .append("title")
      .text(function (d) {
        return nodeMap[d.name].name + "\n" + format(d.value);
      });

    config.label.text = function (d) {
      return nodeMap[d.name].name;
    };

    /////////// A HACK TO ADD TITLE LABELS
    var locations = {};
    var rects = rootG.selectAll("rect").each(function (rect) {
      locations[rect.x] = true;
    });

    var orderedLocations = dex.object.keys(locations).sort(function (a, b) {
      return a - b;
    });

    //var locationWidth = (orderedLocations[1] - orderedLocations[0]) / 2;

    //orderedLocations = orderedLocations.map(function(d) { return +d + locationWidth});

    var titles = rootG.append("g").selectAll("text")
      .data(orderedLocations)
      .enter()
      .append("text")
      .call(dex.config.configureText, config.columnTitle)
      .text(function (d, i) {
        return csv.header[i];
      });

    //////////// END OF HACK

    // add in the title for the nodes
    node.append("text")
      .call(dex.config.configureText, config.label);

    // the function for moving the nodes
    function dragmove(d) {
      d3.select(this).attr("transform",
        "translate(" + (
          d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))
        ) + "," + (
          d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
        ) + ")");
      sankey.relayout();
      link.attr("d", path);
    }
  };

  chart.clone = function clone(override) {
    return sankey(dex.config.expandAndOverlay(override, userConfig));
  };

  return chart;
}

// SANKEY.JS : from Mike Bostock
d3sankey = function () {
  var sankey = {},
    nodeWidth = 24,
    nodePadding = 8,
    columnLayout = defaultColumnLayout,
    curvature = .5,
    size = [1, 1],
    nodes = [],
    links = [];

  sankey.columnLayout = function (_) {
    if (!arguments.length) return columnLayout;
    columnLayout = _;
    return sankey;
  };

  sankey.curvature = function (_) {
    if (!arguments.length) return curvature;
    curvature = +_;
    return sankey;
  };

  sankey.nodeWidth = function (_) {
    if (!arguments.length) return nodeWidth;
    nodeWidth = +_;
    return sankey;
  };

  sankey.nodePadding = function (_) {
    if (!arguments.length) return nodePadding;
    nodePadding = +_;
    return sankey;
  };

  sankey.nodes = function (_) {
    if (!arguments.length) return nodes;
    nodes = _;
    return sankey;
  };

  sankey.links = function (_) {
    if (!arguments.length) return links;
    links = _;
    return sankey;
  };

  sankey.size = function (_) {
    if (!arguments.length) return size;
    size = _;
    return sankey;
  };

  sankey.layout = function (iterations) {
    computeNodeLinks();
    computeNodeValues();
    computeNodeBreadths(nodes);
    computeNodeDepths(iterations);
    computeLinkDepths();
    return sankey;
  };

  sankey.relayout = function () {
    computeLinkDepths();
    return sankey;
  };

  sankey.link = function () {
//    var curvature = .5;

    function link(d) {
      var x0 = d.source.x + d.source.dx,
        x1 = d.target.x,
        xi = d3.interpolateNumber(x0, x1),
        x2 = xi(curvature),
        x3 = xi(1 - curvature),
        y0 = d.source.y + d.sy + d.dy / 2,
        y1 = d.target.y + d.ty + d.dy / 2;
      return "M" + x0 + "," + y0
        + "C" + x2 + "," + y0
        + " " + x3 + "," + y1
        + " " + x1 + "," + y1;
    }

    link.curvature = function (_) {
      if (!arguments.length) return curvature;
      curvature = +_;
      return link;
    };

    return link;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks() {
    nodes.forEach(function (node) {
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    links.forEach(function (link) {
      var source = link.source,
        target = link.target;
      if (typeof source === "number") source = link.source = nodes[link.source];
      if (typeof target === "number") target = link.target = nodes[link.target];
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  // Compute the value (size) of each node by summing the associated links.
  function computeNodeValues() {
    nodes.forEach(function (node) {
      node.value = Math.max(
        d3.sum(node.sourceLinks, value),
        d3.sum(node.targetLinks, value)
      );
    });
  }

  // Iteratively assign the breadth (x-position) for each node.
  // Nodes are assigned the maximum breadth of incoming neighbors plus one;
  // nodes with no incoming links are assigned breadth zero, while
  // nodes with no outgoing links are assigned the maximum breadth.
  function computeNodeBreadths() {
    columnLayout(nodes, nodeWidth, size);
  }

  function defaultColumnLayout(nodes, nodeWidth, size) {
    var remainingNodes = nodes,
      visited = {},
      x = 0;

    //dex.console.log("NODE", nodes[0]);
    while (remainingNodes.length) {
      nextNodes = [];
      visited[remainingNodes[0].name] = true;
      remainingNodes.forEach(function (node) {
        node.x = x;
        node.dx = nodeWidth;
        node.sourceLinks.forEach(function (link) {
          if (!visited[link.target.name]) {
            nextNodes.push(link.target);
          }
          else {
            dex.console.log("CYCLE DETECTED AT: " + node.name + "->" + link.target.name);
          }
        });
      });
      remainingNodes = nextNodes;
      ++x;
    }

    moveSinksRight(x);
    scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
  }

  function moveSourcesRight() {
    nodes.forEach(function (node) {
      if (!node.targetLinks.length) {
        node.x = d3.min(node.sourceLinks, function (d) {
            return d.target.x;
          }) - 1;
      }
    });
  }

  function moveSinksRight(x) {
    nodes.forEach(function (node) {
      if (!node.sourceLinks.length) {
        node.x = x - 1;
      }
    });
  }

  function scaleNodeBreadths(kx) {
    nodes.forEach(function (node) {
      node.x *= kx;
    });
  }

  function computeNodeDepths(iterations) {
    var nodesByBreadth = d3.nest()
      .key(function (d) {
        return d.x;
      })
      .sortKeys(d3.ascending)
      .entries(nodes)
      .map(function (d) {
        return d.values;
      });

    //
    initializeNodeDepth();
    resolveCollisions();
    for (var alpha = 1; iterations > 0; --iterations) {
      relaxRightToLeft(alpha *= .99);
      resolveCollisions();
      relaxLeftToRight(alpha);
      resolveCollisions();
    }

    function initializeNodeDepth() {
      var ky = d3.min(nodesByBreadth, function (nodes) {
        return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
      });

      nodesByBreadth.forEach(function (nodes) {
        nodes.forEach(function (node, i) {
          node.y = i;
          node.dy = node.value * ky;
        });
      });

      links.forEach(function (link) {
        link.dy = link.value * ky;
      });
    }

    function relaxLeftToRight(alpha) {
      nodesByBreadth.forEach(function (nodes, breadth) {
        nodes.forEach(function (node) {
          if (node.targetLinks.length) {
            var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedSource(link) {
        return center(link.source) * link.value;
      }
    }

    function relaxRightToLeft(alpha) {
      nodesByBreadth.slice().reverse().forEach(function (nodes) {
        nodes.forEach(function (node) {
          if (node.sourceLinks.length) {
            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedTarget(link) {
        return center(link.target) * link.value;
      }
    }

    function resolveCollisions() {
      nodesByBreadth.forEach(function (nodes) {
        var node,
          dy,
          y0 = 0,
          n = nodes.length,
          i;

        // Push any overlapping nodes down.
        nodes.sort(ascendingDepth);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y0 - node.y;
          if (dy > 0) node.y += dy;
          y0 = node.y + node.dy + nodePadding;
        }

        // If the bottommost node goes outside the bounds, push it back up.
        dy = y0 - nodePadding - size[1];
        if (dy > 0) {
          y0 = node.y -= dy;

          // Push any overlapping nodes back up.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y + node.dy + nodePadding - y0;
            if (dy > 0) node.y -= dy;
            y0 = node.y;
          }
        }
      });
    }

    function ascendingDepth(a, b) {
      return a.y - b.y;
    }
  }

  function computeLinkDepths() {
    nodes.forEach(function (node) {
      node.sourceLinks.sort(ascendingTargetDepth);
      node.targetLinks.sort(ascendingSourceDepth);
    });
    nodes.forEach(function (node) {
      var sy = 0, ty = 0;
      node.sourceLinks.forEach(function (link) {
        link.sy = sy;
        sy += link.dy;
      });
      node.targetLinks.forEach(function (link) {
        link.ty = ty;
        ty += link.dy;
      });
    });

    function ascendingSourceDepth(a, b) {
      return a.source.y - b.source.y;
    }

    function ascendingTargetDepth(a, b) {
      return a.target.y - b.target.y;
    }
  }

  function center(node) {
    return node.y + node.dy / 2;
  }

  function value(link) {
    return link.value;
  }

  $(document).ready(function () {
    // Add tooltips
    $(document).uitooltip({
      items: "path",
      content: function () {
        return $(this).find("tooltip-content").text();
      },
      track: true
    });

    // Make the entire chart draggable.
    //$(sankey.config.parent).draggable();
  });

  return sankey;
};

module.exports = sankey;
},{}],36:[function(require,module,exports){
var scatterplot = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart = new dex.component(userConfig,
    {
      'parent'           : "#ScatterPlot",
      "id"               : "ScatterPlot",
      "class"            : "ScatterPlot",
      'width'            : "100%",
      'height'           : "100%",
      'csv'              : {
        'header' : ["X", "Y"],
        'data'   : [
          [0, 0],
          [1, 1],
          [2, 4],
          [3, 9],
          [4, 16]
        ],
      },
      'margin'           : {top : 20, right : 15, bottom : 60, left : 60},
      'selectedColor'    : "red",
      'unselectedColor'  : "steelblue",
      'unselectedRadius' : 8,
      'selectedRadius'   : 8,
      'xi'               : 0,
      'yi'               : 1,
      'transform'        : 'scale(.95) translate(60,0)'
    });

  chart.render = function () {
    d3 = dex.charts.d3.d3v3;
    window.onresize = this.resize;
    chart.resize();
  };

  chart.resize = function () {
    d3 = dex.charts.d3.d3v3;
    d3.selectAll("#" + chart.config.id).remove();
    var width = d3.select(chart.config.parent).property("clientWidth");
    var height = d3.select(chart.config.parent).property("clientHeight");
    chart.attr("width", width).attr("height", height).update();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var chart = this;
    var config = chart.config;
    var csv = config.csv;

    //console.log("CONFIG: " + this.config);
    //console.dir(this.registry);

    x = d3.scale.linear()
      .domain([0, d3.max(csv.data, function (d) {
        return d[0];
      })])
      .range([0, config.width]);

    y = d3.scale.linear()
      .domain([0, d3.max(csv.data, function (d) {
        return d[1];
      })])
      .range([config.height, 0]);

    var chartContainer = d3.select(config.parent)
      .append('g')
      .attr('class', config["class"])
      .attr('id', config["id"])
      .attr('transform', config.transform);

    // draw the x axis
    var xAxis = d3.svg.axis()
      .scale(x)
      .orient('bottom');

    var brush = d3.svg.brush()
      .x(x)
      .y(y)
      .on("brushstart", function (d) {
        brushstartHandler({});
      })
      .on("brush", function (d) {
        brushmoveHandler({});
      })
      .on("brushend", function (d) {
        brushendHandler({});
      });

    //console.log("BRUSH: " + brush);

    chartContainer.append('g')
      .attr('transform', 'translate(0,' + config.height + ')')
      .attr('class', 'main axis date')
      .call(xAxis);

    // draw the y axis
    var yAxis = d3.svg.axis()
      .scale(y)
      .orient('left');

    chartContainer.append('g')
      .attr('transform', 'translate(0,0)')
      .attr('class', 'main axis date')
      .call(yAxis);

    var g = chartContainer.append("svg:g")
      .attr("id", "pointContainer")
      .call(brush);

    g.selectAll("scatter-dots")
      .data(csv.data)
      .enter().append("svg:circle")
      .attr("id", "scatter-dot")
      .attr("cx", function (d) {
        return x(d[config.xi]);
      })
      .attr("cy", function (d) {
        return y(d[config.yi]);
      })
      .attr("r", config.unselectedRadius)
      .style("fill", config.unselectedColor)
      .on("mouseover", function (d) {
        mouseOverHandler({node : this, data : d});
      })
      .on("mouseout", function (d) {
        mouseOutHandler({node : this, data : d});
      });

    function brushstartHandler(chartEvent) {
      //console.log("brush start()");
      //console.log("brush empty? " + brush.empty());
      d3.selectAll("#scatter-dot")
        .attr("r", config.unselectedRadius)
        .style("fill", config.unselectedColor);
    }

    function brushmoveHandler(chartEvent) {
      //console.log("brush move(" + brush.extent() + ")");
    }

    function brushendHandler(chartEvent) {
      //console.log("brushend");
      //console.log("FOO: " + chart);
      //this.dump("ScatterPlot.brushendHandler()");
      //console.dir(config);
      //console.dir(registry);
      var extent = brush.extent();
      //console.dir(brush.extent());

      var data = [];

      var active = d3.selectAll("#scatter-dot")
        .filter(function (d, i) {
          //console.dir(extent);
          //console.dir(d);
          if (d[0] >= extent[0][0] && d[0] <= extent[1][0] &&
            d[1] >= extent[0][1] && d[1] <= extent[1][1]) {
            data.push([d[0], d[1]]);
            return this;
          }
          return null;
        })
        .attr("r", config.selectedRadius)
        .style("fill", config.selectedColor);

      chart.publish({type : "brushend", data : data});
    }

    function mouseOverHandler(chartEvent) {
      //console.log("mouseover");
      //console.log("MOUSEOVER: node=" + node + ", data=" + data + ", originator=" + originator);
      // If we're the originator of this event, notify our listeners to
      // update themselves in turn.

      // Pick yourself so you have access to all the D3 goodies you get
      // through selection.
      d3.select(chartEvent.node)
        .style("fill", config.selectedColor)
        .attr("r", config.selectedRadius);

      d3.select("#pointContainer")
        .append("text")
        .attr("x", x(chartEvent.data[0]))
        .attr("y", y(chartEvent.data[1]) - 10)
        .attr("dy", ".35m")
        .style("font-size", 14)
        .attr("text-anchor", "top")
        .attr("fill", "black")
        .text(function (d) {
          return chartEvent.data[1];
        });
    }

    function mouseOutHandler(chartEvent) {
      d3.select("#pointContainer").selectAll("text").remove();
      d3.select(chartEvent.node)
        .style("fill", config.unselectedColor)
        .attr("r", config.unselectedRadius);
    }
  };

    chart.clone = function clone(override) {
        return scatterplot(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = scatterplot;
},{}],37:[function(require,module,exports){
var sunburst = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults = {
    // The parent container of this chart.
    'parent': '#SunburstParent',
    // Set these when you need to CSS style components independently.
    'id': 'SunburstId',
    'class': 'SunburstChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'margin': {
      'left': 100,
      'right': 100,
      'top': 50,
      'bottom': 50
    },
    'shader': {
      'type': 'darken',
      'increment': .15
    },
    'transform': "",
    // Our data...
    'csv': {
      // Give folks without data something to look at anyhow.
      'header': ["X", "Y", "Z"],
      'data': [
        [0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]
      ]
    },
    'title': dex.config.text({
      'font.size': 24
    }),
    'label': dex.config.text({
      'fill.fillColor': 'white'
    }),
    'color': d3.scale.category20c()
  };

  chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Sunburst Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        dex.config.gui.text({"name": "Title"}, "title"),
        dex.config.gui.text({"name": "Labels"}, "label")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;
    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll("*").remove();

    var data = dex.csv.toNestedJson(dex.csv.copy(csv));

    var radius = Math.min(width, height) / 2;

    var x = d3.scale.linear()
      .range([0, 2 * Math.PI]);

    var y = d3.scale.linear()
      .range([0, radius]);

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg
      .append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        'translate(' + width / 2 + ',' + (height / 2) + ')' +
        config.transform);

    var partition = d3.layout.partition()
      .value(function (d) {
        return d.size;
      });

    var arc = d3.svg.arc()
      .startAngle(function (d) {
        d.startAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x)));
        return d.startAngle;
      })
      .endAngle(function (d) {
        d.endAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
        return d.endAngle;
      })
      .innerRadius(function (d) {
        d.innerRadius = Math.max(0, y(d.y));
        return d.innerRadius;
      })
      .outerRadius(function (d) {
        d.outerRadius = Math.max(0, y(d.y + d.dy));
        return d.outerRadius;
      });

    var root = data;

    var g = rootG.selectAll("g")
      .data(partition.nodes(root))
      .enter().append("g");

    var path = g.append("path")
      .attr("d", arc)
      .style("stroke", "white")
      .style("fill", function (d) {
        //dex.console.log("COLOR", (d.children ? d : d.parent).name,
        //  config.color((d.children ? d : d.parent).name));
        var colorCategory = (d.children ? d : d.parent).name;
        var pathColor = d3.rgb(config.color(colorCategory));
        if (config.shader.type == "darken") {
          return pathColor.darker(d.depth * config.shader.increment);
        }
        else if (config.shader.type == "brighten") {
          return pathColor.brighter(d.depth * config.shader.increment);
        }
        else {
          return pathColor;
        }
      })
      .on("click", click);

    function setBBox(d) {
      var bbox = this.getBBox();
      d.bbox = this.getBBox();
    }

    function getSize(d) {
      var hspace = d.outerRadius - d.innerRadius;
      var bbox = d.bbox;
      var wmargin = 10;
      var hmargin = 2;
      if (d.depth > 0) {
        var wscale = Math.max((1.0 * hspace - wmargin) / bbox.width, 2);

        // If we're dealing with a small sliver, impose height restrictions too.
        if (d.endAngle - d.startAngle < .2) {
          var chordLength = d.innerRadius * Math.sin(d.endAngle - d.startAngle);
          var hscale = Math.max((1.0 * chordLength - hmargin) / bbox.height, 2);
          d.scale = Math.max(Math.min(hscale, wscale), 2);
          //dex.console.log("CHORD-LENGTH", chordLength, d, hscale, wscale);
        }
        else {
          d.scale = wscale;
        }
      }
      else {
        d.scale = Math.max((d.outerRadius * 2.0 - wmargin) / bbox.width, 2);
      }
    }

    var text = g.append("text")
      .call(dex.config.configureText, config.label)
      //.style("writing-mode", "rl-tb")
      .attr("transform", function (d) {
        //dex.console.log("DT", d);
        if (d.depth > 0) {
          var rotation = computeTextRotation(d);

          var baseRotation = "rotate(" + rotation + ")";

          return baseRotation;
        }
        else {
          return "";
        }
      })
      .style("pointer-events", "none")
      .attr("alignment-baseline", "central")
      .style("text-anchor", function (d) {
        if (d.depth == 0) {
          return "middle";
        } else {
          return "start";
        }
      })
      .attr("x", function (d) {
        return y(d.y);
      })
      .attr("dx", "6") // margin
      .attr("dy", ".35em") // vertical-align
      .text(function (d) {
        return d.name;
      })
      .style("font-size", "1px")
      .each(setBBox)
      .each(getSize)
      .style("font-size", function (d) {
        return d.scale + "px";
      });

    g.selectAll("text")


    function click(d) {
      // fade out all text elements
      text.transition().attr("opacity", 0);

      path.transition()
        .duration(500)
        .attrTween("d", arcTween(d))
        .each("end", function (e, i) {
          // check if the animated element's data e lies within the visible angle span given in d
          if (e.x >= d.x && e.x < (d.x + d.dx)) {
            // get a selection of the associated text element
            var arcText = d3.select(this.parentNode).select("text");
            // fade in the text element and recalculate positions
            arcText.transition().duration(250)
              .attr("opacity", 1)
              .attr("transform", function (d) {
                if (d.depth > 0) {
                  return "rotate(" + computeTextRotation(e) + ")"
                }
                else {
                  return "";
                }
              })
              .attr("x", function (d) {
                return y(d.y);
              })
              .each(getSize)
              .style("font-size", function (d) {
                return d.scale + "px";
              });
          }
        });
    }

    d3.select(self.frameElement).style("height", height + "px");

// Interpolate the scales!
    function arcTween(d) {
      var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
        yd = d3.interpolate(y.domain(), [d.y, 1]),
        yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]);
      return function (d, i) {
        return i
          ? function (t) {
            return arc(d);
          }
          : function (t) {
            x.domain(xd(t));
            y.domain(yd(t)).range(yr(t));

            return arc(d);
          };
      };
    }

    function computeTextRotation(d) {
      return (x(d.x + d.dx / 2) - Math.PI / 2) / Math.PI * 180;
    }
    return chart;
  };

  chart.clone = function clone(override) {
    return sunburst(dex.config.expandAndOverlay(override, userConfig));
  };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = sunburst;
},{}],38:[function(require,module,exports){
var topojsonmap = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults = {
    'parent': '#TopoJsonMap',
    'id': 'TopoJsonMap',
    'class': 'TopoJsonMap',
    'toplology': undefined,
    'feature': undefined,
    'projection': d3.geo.albers(),
    'width': '100%',
    'height': '100%',
    'resizable': true,
    'transform': 'translate(0,0)',
    'feature' : {
      "topology" : undefined,
      "path" : dex.config.path({
        "fill.fillColor" : "lightgrey",
        "stroke.color" : "white"
      })
    },
    'margin': {
      'left': 0,
      'right': 0,
      'top': 0,
      'bottom': 0
    },
    "selectedColor": "steelblue",
    "unselectedColor": "lightgrey",
  };

  var selected = {};

  chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;

    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    dex.console.log("WIDTH", config.width, width, config.height, height);

    d3.selectAll(config.parent).selectAll("*").remove();

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg.append('g')
      .attr('transform', 'translate(' +
        (margin.left) + ',' +
        (margin.top) + ') ' +
        config.transform);

    var featureBounds,
      geo,
      geoLayer = {},
      slast,
      tlast;

    var projection = d3.geo.albersUsa()
      .scale(1000)
      .translate([width / 2, height / 2]);

    var path = d3.geo.path()
      .projection(projection);

    var zoom = d3.behavior.zoom()
      .translate([0, 0])
      .scale(1)
      .center([width / 2, height / 2])
      .scaleExtent([1, 8])
      .on("zoom", zoomed);

    function getFeaturesBox() {
      return {
        x: featureBounds[0][0],
        y: featureBounds[0][1],
        width: featureBounds[1][0] - featureBounds[0][0],
        height: featureBounds[1][1] - featureBounds[0][1]
      };
    }

    // fits the geometry layer inside the viewport
    function fitGeoInside() {
      var bbox = getFeaturesBox(),
        scale = 0.95 / Math.max(bbox.width / width, bbox.height / height),
        trans = [-(bbox.x + bbox.width / 2) * scale + width / 2, -(bbox.y + bbox.height / 2) * scale + height / 2];

      geoLayer.scale = scale;
      geoLayer.translate = trans;

      geo.attr('transform', [
        'translate(' + geoLayer.translate + ')',
        'scale(' + geoLayer.scale + ')'
      ].join(' '));

      postTransformOperations(geoLayer.scale);
    }

    // transform geoParent
    function setGeoTransform(scale, trans) {
      zoom.scale(scale)
        .translate(trans);

      tlast = trans;
      slast = scale;

      rootG.attr('transform', [
        'translate(' + trans + ')',
        'scale(' + scale + ')'
      ].join(' '));

      postTransformOperations(scale * geoLayer.scale);

    }

    // scale strokes for fussy browsers
    function postTransformOperations(scale) {
      geo.selectAll('path')
        .style('stroke-width', 1 / scale);
    }

    // limits panning
    // XXX: this could be better
    function limitBounds(scale, trans) {

      var bbox = getFeaturesBox();
      var outer = width - width * scale;
      var geoWidth = bbox.width * geoLayer.scale * scale,
        geoLeft = -((width * scale) / 2 - ((geoWidth) / 2)),
        geoRight = outer - geoLeft;


      if (scale === slast) {
        //trans[0] = Math.min(0, Math.max(trans[0], width - width * scale));
        trans[1] = Math.min(0, Math.max(trans[1], height - height * scale));

        if (geoWidth > width) {
          if (trans[0] < tlast[0]) { // panning left
            trans[0] = Math.max(trans[0], geoRight);
          } else if (trans[0] > tlast[0]) { // panning right
            trans[0] = Math.min(trans[0], geoLeft);
          }
        } else {

          if (trans[0] < geoLeft) {
            trans[0] = geoLeft;
          } else if (trans[0] > geoRight) {
            trans[0] = geoRight;
          }
        }
      }

      setGeoTransform(scale, trans);
    }

    // zoom behavior on 'zoom' handler
    function zoomed() {
      var e = d3.event,
        scale = (e && e.scale) ? e.scale : zoom.scale(),
        trans = (e && e.translate) ? e.translate : zoom.translate();

      limitBounds(scale, trans);
    }

    // set the map's initial state
    // geoParent layer to scale 1
    // geo layer is scaled to fit viewport
    function initialize() {
      tlast = null;
      slast = null;
      setGeoTransform(1, [0, 0]);
      fitGeoInside();
    }

    function passThru(d) {
      var e = d3.event;

      var prev = this.style.pointerEvents;
      this.style.pointerEvents = 'none';

      var el = document.elementFromPoint(d3.event.x, d3.event.y);

      var e2 = document.createEvent('MouseEvent');
      e2.initMouseEvent(e.type, e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);

      el.dispatchEvent(e2);

      this.style.pointerEvents = prev;
    }

    // load topojson & make map
    var topology = chart.config.toplogy;

    var features = topojson.feature(
      config.topology, config.feature.topology).features;

    var collection = {
      'type': 'FeatureCollection',
      'features': features
    };

    featureBounds = path.bounds(collection);

    rootG
      .append('rect')
      .attr('class', 'bg')
      .attr('pointer-events', 'none')
      .attr('fill', 'none')
      .attr('width', width)
      .attr('height', height);

    geo = rootG.append("g");

    geo.selectAll('.feature')
      .data(features)
      .enter()
      .append("path")
      .attr("class", "feature")
      .attr("d", path)
      .call(dex.config.configurePath, config.feature.path)
      .on("mouseover", function (d) {
        chart.publish({
          "type": "mouseover",
          "target": d
        });
      })
      .on("mousedown", function (d) {
        if (selected[d.id]) {
          chart.publish({
            "type": "unselect",
            "target": d
          });
          selected[d.id] = false;
          d3.select(this).style("fill", config.unselectedColor);
        }
        else {
          chart.publish({
            "type": "select",
            "target": d
          });
          selected[d.id] = true;
          d3.select(this).style("fill", config.selectedColor);
        }
      });

    svg.append("rect")
      .attr("class", "overlay")
      .attr("width", width)
      .attr("height", height)
      .style("pointer-events", "all")
      .style("fill", "none")
      .on("mousedown", passThru)
      .on("mouseover", passThru)
      .call(zoom);

    initialize();
  };

    chart.clone = function clone(override) {
        return topojsonmap(dex.config.expandAndOverlay(override, userConfig));
    };

  return chart;
};

module.exports = topojsonmap;
},{}],39:[function(require,module,exports){
var treemap = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart = null;

  var defaults = {
    'parent': '#TreemapParent',
    // Set these when you need to CSS style components independently.
    'id': 'TreemapId',
    'class': 'TreemapClass',
    'resizable': true,
    // Our data...
    'csv': undefined,
    'title': 'Level: ',
    'margin': {
      'left': 10,
      'right': 10,
      'top': 25,
      'bottom': 10
    },
    'shader': {
      'type': 'darken',
      'increment': .1
    },
    'manualSizing': false,
    'width': '100%',
    'height': '100%',
    'transform': '',
    'color': d3.scale.category10(),
    'navbar': dex.config.rectangle({
      'fill.fillColor': 'steelblue',
      'y': function () {
        return -chart.config.margin.top;
      },
      'width': function () {
        return chart.config.width
          - chart.config.margin.left - chart.config.margin.right;
      },
      'height': function () {
        return chart.config.margin.top;
      }
    }),
    'navbarLabel': dex.config.text({
      'x': 6,
      'y': function () {
        return 6 - chart.config.margin.top;
      },
      'dy': '.75em',
      'fill.fillColor': 'white'
    }),
    'label': dex.config.text({
      //'dy': '1em',
      'fill.fillColor': 'white'
    })
  };

  var chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function update() {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;
    var color = config.color;

    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll("*").remove();

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg
      .append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    var formatNumber = d3.format(",d");
    var transitioning;

    var x = d3.scale.linear()
      .domain([0, width])
      .range([0, width]);

    var y = d3.scale.linear()
      .domain([0, height])
      .range([0, height]);

    var tmap = d3.layout.treemap()
      .children(function (d, depth) {
        return depth ? null : d._children;
      })
      .value(function (d) {
        return d.size;
      })
      .sort(function (a, b) {
        return a.size - b.size;
      })
      .ratio(height / width * 0.5 * (1 + Math.sqrt(5)))
      .round(false);

    var grandparent = rootG.append("g")
      .attr("class", "grandparent");

    grandparent.append("rect")
      .call(dex.config.configureRectangle, config.navbar);

    grandparent.append("text")
      .call(dex.config.configureText, config.navbarLabel);

    var chartData = dex.csv.toNestedJson(csv, config.manualSizing);

    //dex.console.log("chartData", chartData);

    initialize(chartData);
    accumulate(chartData);
    layout(chartData);
    display(chartData);

    function initialize(root) {
      root.x = root.y = 0;
      root.dx = width;
      root.dy = height;
      root.depth = 0;
    }

    // Aggregate the values for internal nodes. This is normally done by the
    // treemap layout, but not here because of our custom implementation.
    // We also take a snapshot of the original children (_children) to avoid
    // the children being overwritten when when layout is computed.
    function accumulate(d) {
      return (d._children = d.children)
        ? d.size = d.children.reduce(function (p, v) {
          return p + accumulate(v);
        }, 0)
        : d.size;
    }

    // Compute the treemap layout recursively such that each group of siblings
    // uses the same size (11) rather than the dimensions of the parent cell.
    // This optimizes the layout for the current zoom state. Note that a wrapper
    // object is created for the parent node for each group of siblings so that
    // the parents dimensions are not discarded as we recurse. Since each group
    // of sibling was laid out in 11, we must rescale to fit using absolute
    // coordinates. This lets us use a viewport to zoom.
    function layout(d) {
      if (d._children) {
        tmap.nodes({_children: d._children});
        d._children.forEach(function (c) {
          c.x = d.x + c.x * d.dx;
          c.y = d.y + c.y * d.dy;
          c.dx *= d.dx;
          c.dy *= d.dy;
          c.parent = d;
          layout(c);
        });
      }
    }

    function display(d) {
      grandparent
        .datum(d.parent)
        .on("click", transition)
        .select("text")
        .text(config.title + name(d));

      var g1 = rootG.insert("g", ".grandparent")
        .datum(d)
        .attr("class", "depth");

      var g = g1.selectAll("g")
        .data(d._children)
        .enter().append("g");

      g.filter(function (d) {
        return d._children;
      })
        .classed("children", true)
        .on("click", transition);

      g.selectAll(".child")
        .data(function (d) {
          return d._children || [d];
        })
        .enter().append("rect")
        .attr("class", "child")
        .call(rect);

      g.append("rect")
        .attr("class", "parent")
        .call(rect)
        .append("title")
        .text(function (d) {
          return formatNumber(d.size);
        });

      g.append("text")
      //.call(dex.config.configureText, config.label)
        .text(function (d) {
          return d.name;
        })
        .call(text)
        .style("font-size", "1px")
        .each(getSize)
        .style("font-size", function (d) {
          return Math.min(64, d.scale) + "px";
        })
        .style('fill', 'white')
        .attr('text-anchor', 'start')
        // Only works on chrome:
        //.style('alignment-baseline', 'hanging')
        .attr('dx', '.1em')
        .attr('dy', '.8em');

      // AWESOME Text Fitter
      function getSize(d) {
        var bbox = this.getBBox();
        var cbbox = this.parentNode.getBBox();
        var hMargin = Math.min(30, cbbox.height * .1);
        var wMargin = Math.min(30, cbbox.width * .1);
        var wscale = Math.min((cbbox.width - wMargin) / bbox.width);
        var hscale = Math.min((cbbox.height - hMargin) / bbox.height);

        d.scale = Math.min(wscale, hscale);
        d.hscale = hscale;
        d.wscale = wscale;
        d.bbox = bbox;
        d.cbox = cbbox;
      }

      function transition(d) {
        if (transitioning || !d) return;
        transitioning = true;

        //dex.console.log("DISPLAY", d);

        var g2 = display(d),
          t1 = g1.transition().duration(300),
          t2 = g2.transition().duration(300);

        // Update the domain only after entering new elements.
        x.domain([d.x, d.x + d.dx]);
        y.domain([d.y, d.y + d.dy]);

        // Enable anti-aliasing during the transition.
        rootG.style("shape-rendering", null);

        // Draw child nodes on top of parent nodes.
        rootG.selectAll(".depth").sort(function (a, b) {
          return a.depth - b.depth;
        });

        // Fade-in entering text.
        g2.selectAll("text")
          .style("fill-opacity", 0);

        // Transition to the new view.
        t1.selectAll("rect").call(rect);
        t2.selectAll("rect").call(rect);
        //t1.selectAll("text").call(text).style("fill-opacity", 0);
        //t2.selectAll("text").call(text).style("fill-opacity", 1);

        // Remove the old node when the transition is finished.
        t1.remove().each("end", function () {
          rootG.style("shape-rendering", "crispEdges");
          transitioning = false;
        });

        // Text resizing breaks if I do it mid-transition.
        t2.each("end", function () {
          g2.selectAll("text")
            .call(text)
            .style("font-size", "1px")
            .each(getSize)
            .style("font-size", function (d) {
              return Math.min(64, d.scale) + "px";
            })
            .attr('text-anchor', 'start')
            .style('fill', 'white')
            .style("fill-opacity", 1)
            .attr('dx', '.1em')
            .attr('dy', '.8em');
        });
      }

      return g;
    }

    function text(text) {
      text.attr("x", function (d) {
        return x(d.x);
      })
        .attr("y", function (d) {
          return y(d.y);
        });
    }

    function rect(rect) {
      var shader = {};
      rect.attr("x", function (d) {
        return x(d.x);
      })
        .attr("y", function (d) {
          return y(d.y);
        })
        .attr("width", function (d) {
          return x(d.x + d.dx) - x(d.x);
        })
        .attr("height", function (d) {
          return y(d.y + d.dy) - y(d.y);
        })
        .style("fill", function (d) {
          if (!(d.parent.name in shader)) {
            shader[d.parent.name] = {'currentShade': 0};
          }
          if (!(d.name in shader[d.parent.name])) {
            shader[d.parent.name][d.name] = shader[d.parent.name].currentShade;
            shader[d.parent.name].currentShade += config.shader.increment;
          }
          //dex.console.log("SHADING-RECT", d, shader[d.parent.name]);

          if (config.shader.type == 'darken') {
            return d3.rgb(color(d.parent.name))
              .darker(shader[d.parent.name][d.name]);
          }
          else if (config.shader.type == 'lighten') {
            return d3.rgb(color(d.parent.name))
              .brighter(shader[d.parent.name][d.name]);
          }
          else {
            return color(d.parent.name);
          }
        });
    }

    function name(d) {
      //dex.console.log("NAME", d);
      return d.parent
        ? name(d.parent) + " > " + d.name + " (" +
        formatNumber(d.size) + ")"
        : d.name + " (" + formatNumber(d.size) + ")";
    }

    return chart;
  };

    chart.clone = function clone(override) {
        return treemap(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = treemap;
},{}],40:[function(require,module,exports){
var treemapBarChart = function (userConfig) {
  d3 = dex.charts.d3.d3v4;
  var chart;

  var defaults = {
    // The parent container of this chart.
    'parent': '#TreemapBarChartParent',
    // Set these when you need to CSS style components independently.
    'id': 'TreemapBarChartId',
    'class': 'TreemapBarChartClass',
    'resizable': true,
    // Our data...
    'csv': {
      // HERE IS THE STOP POINT...
      // Give folks without data something to look at anyhow.
      'header': ["Country", "Continent", "Trade Indicator", "Year", 'Gross'],
      'data': [
        ['US', 'North America', 'Imports', 2000, 10000000],
        ['US', 'North America', 'Exports', 2000, 10000000],
        ['US', 'North America', 'Imports', 2001, 15000000],
        ['US', 'North America', 'Exports', 2001, 30000000],
        ['Japan', 'Asia', 'Imports', 2000, 5000000],
        ['Japan', 'Asia', 'Exports', 2000, 30000000],
        ['Japan', 'Asia', 'Imports', 2001, 6000000],
        ['Japan', 'Asia', 'Exports', 2001, 30000000],
        ['Canada', 'North America', 'Imports', 2000, 6000000],
        ['Canada', 'North America', 'Exports', 2000, 4000000],
        ['Canada', 'North America', 'Imports', 2001, 3000000],
        ['Canada', 'North America', 'Exports', 2001, 1000000],
      ]
    },
    'index': {
      'divider': 0,
      'color': 1,
      'category': 2,
      'x': 3,
      'value': 4
    },
    'width': "100%",
    'height': "100%",
    'transform': "",
    'colorScheme': d3.schemeCategory20,
    // <text fill="#000" y="9" x="0.5" dy="0.71em">Property Crime</text>
    // <text fill="#000" y="9" x="0.5" dy=".71em" dx="0" font-family="sans-serif" font-size="14" font-weight="normal" font-style="normal" text-decoration="none" word-spacing="normal" letter-spacing="normal" variant="normal" transform="" style="text-anchor: start; fill: grey; fill-opacity: 1;">Violent Crime</text>
    'categoryLabel': dex.config.text({
        "x": .5,
        "y": 9,
        "dy": ".71em",
        'font' : dex.config.font({'size': 10}),
        'anchor': 'middle'
      }
    ),
    'margin': {
      'top': 25,
      'right': 15,
      'bottom': 100,
      'left': 60
    },
    // <text fill="#000" y="3" x="0.5" dy="0.71em">2000</text>
    'xLabel': dex.config.text({
        "x": .5,
        "y": 15,
        "dy": ".71em",
        'font.size': 16,
        'fill.fillColor': 'steelblue',
        'anchor': 'middle'
      }
    )
  };

  var chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function update() {
    d3 = dex.charts.d3.d3v4;
    var config = chart.config;
    var margin = config.margin;
    var csv = config.csv;

    var width = config.width - margin.left - margin.right;
    var height = config.height - margin.top - margin.bottom;

    d3.selectAll(config.parent).selectAll("*").remove();

    var svg = d3.select(config.parent)
      .append("svg")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr('width', config.width)
      .attr('height', config.height);

    var rootG = svg
      .append('g')
      .attr('transform', 'translate(' +
        margin.left + ',' + margin.top + ') ' +
        config.transform);

    var colorDomain = dex.csv.uniqueArray(config.csv, config.index.color);
    var categoryDomain = dex.csv.uniqueArray(config.csv, config.index.category);
    //dex.console.log("COLOR-DOMAIN", colorDomain, "CATEGORY-DOMAIN", categoryDomain);
    //var orderedContinents = ['Asia', 'North America', 'Europe', 'South America', 'Africa', 'Australia']
    var color = d3.scaleOrdinal()
      .domain(colorDomain)
      .range(config.colorScheme)

    /*
     var dollarFormat = d3.format('$,')
     var tickFormat = function (n) {
     return n === 0 ? '$0'
     : n < 1000000 ? dollarFormat(n / 1000) + ' billion'
     : dollarFormat(n / 1000000) + ' trillion'
     }
     */

    var options = {
      key: config.csv.header[config.index.value],
      divider: null
    }

    var chartData = csvToJson(config.csv, []);

    function csvToJson(csv, hierarchy) {
      var csvStr = csv.header.join(",") + "\n";
      csv.data.forEach(function (row) {
        csvStr += row.join(",") + "\n";
      })
      var data = d3.csvParse(csvStr);
      var jsonData = d3.nest()
        .key(function (d) {
          return d[config.csv.header[config.index.x]]
        })
        .sortKeys(d3.ascending)
        .key(function (d) {
          return d[config.csv.header[config.index.category]]
        })
        .sortKeys(d3.ascending)
        .key(function (d) {
          return d[config.csv.header[config.index.color]]
        })
        .sortKeys(d3.ascending)
        .entries(data)
        .map(function (d) {
          return {
            "x": d.key,
            "children": d.values.map(function (d) {
              return {
                "divider": d.key,
                "children": d.values.map(function (d) {
                  return {
                    "color": d.key,
                    "children": d.values
                  };
                })
              };
            })
          };
        });
      return {"children": jsonData};
    }

    var root = d3.hierarchy(chartData).sum(function (d) {
      return d[options.key]
    })
    var xData = root.children

    xData.sort(function (a, b) {
      return a.data.x - b.data.x
    })

    var svg = rootG
      .append('g')
      .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

    var x0 = d3.scaleBand()
      .domain(xData.map(function (d) {
        return d.data.x
      }).sort())
      .range([0, width])
      .padding(0.15);

    var x1 = d3.scaleBand()
      .domain(categoryDomain)
      .rangeRound([0, x0.bandwidth()])
      .paddingInner(0.1);

    var y = d3.scaleLinear()
      .domain([0, d3.max(xData, function (d) {
        return d3.max(d.children, function (e) {
          return e.value
        })
      })]).nice()
      .range([0, height]);

    var x0Axis = d3.axisBottom()
      .scale(x0)
      .tickSize(0);

    var x1Axis = d3.axisBottom()
      .scale(x1);

    var yAxis = d3.axisLeft()
      .tickSize(-width)
      //.tickFormat(tickFormat)
      .scale(y.copy().range([height, 0]));

    svg.append('g')
      .attr('class', 'x0 axis')
      .attr('transform', 'translate(0,' + (height + 22) + ')')
      .call(x0Axis);

    var gy = svg.append('g')
      .attr('class', 'y axis')
      .call(yAxis);

    var xs = svg.selectAll('.x')
      .data(xData, function (d) {
        return d.data.x
      })
      .enter().append('g')
      .attr('class', 'x')
      .attr('transform', function (d) {
        return 'translate(' + x0(d.data.x) + ',0)'
      });

    xs.append('g')
      .attr('class', 'x1 axis')
      .attr('transform', 'translate(0,' + height + ')')
      .call(x1Axis);

    d3.select('#inflation-adjusted').on('change', function () {
      options.key = this.checked ? 'adj_value' : 'value';
      tmUpdate();
    });

    tmUpdate();

    function sum(d) {
      //dex.console.log("SUM:", d[config.csv.header[config.index.divider]], "OPTS", options)
      return !options.divider ||
      options.divider === d[config.csv.header[config.index.divider]] ? d[options.key] : 0;
    }

    function tmUpdate() {
      d3 = dex.charts.d3.d3v4;
      root.sum(sum)

      var t = d3.transition()

      var dividerData = d3.merge(xData.map(function (d) {
        return d.children
      }))

      y.domain([0, d3.max(dividerData.map(function (d) {
        return d.value
      }))]).nice()

      // We use a copied Y scale to invert the range for display purposes
      yAxis.scale(y.copy().range([height, 0]))
      gy.transition(t).call(yAxis)

      var dividers = xs.selectAll('.divider')
        .data(function (d) {
            return d.children
          },
          function (d) {
            return d.data.divider
          })
        .each(function (d) {
          // UPDATE
          // The copied branches are orphaned from the larger hierarchy, and must be
          // updated separately (see note at L152).
          d.treemapRoot.sum(sum)
          d.treemapRoot.children.forEach(function (d) {
            d.sort(function (a, b) {
              return b.value - a.value
            })
          })
        })

      dividers = dividers.enter().append('g')
        .attr('class', 'divider')
        .attr('transform', function (d) {
          return 'translate(' + x1(d.data.divider) + ',' + height + ')'
        })
        .each(function (d) {
          // ENTER
          // Note that we can use .each on selections as a way to perform operations
          // at a given depth of the hierarchy tree.
          d.children.sort(function (a, b) {
            return colorDomain.indexOf(b.data.color) -
              colorDomain.indexOf(a.data.color)
          })
          d.children.forEach(function (d) {
            d.sort(function (a, b) {
              return b.value - a.value
            })
          })
          d.treemap = d3.treemap().tile(d3.treemapResquarify)

          // The treemap layout must be given a root node, so we make a copy of our
          // child node, which creates a new tree from the branch.
          d.treemapRoot = d.copy()
        })
        .merge(dividers)
        .each(function (d) {
          // UPDATE + ENTER
          d.treemap.size([x1.bandwidth(), y(d.value)])(d.treemapRoot)
        })

      // d3.hierarchy gives us a convenient way to access the parent datum. This line
      // adds an index property to each node that we'll use for the transition delay.
      root.each(function (d) {
        d.index = d.parent ? d.parent.children.indexOf(d) : 0
      })

      dividers.transition(t)
        .delay(function (d, i) {
          return d.parent.index * 150 + i * 50
        })
        .attr('transform', function (d) {
          return 'translate(' + x1(d.data.divider) + ',' + (height - y(d.value)) + ')'
        })

      var colors = dividers.selectAll('.color')
      // Note that we're using our copied branch.
        .data(function (d) {
            return d.treemapRoot.children
          },
          function (d) {
            return d.data.color
          })

      colors = colors.enter().append('g')
        .attr('class', 'color')
        .merge(colors)

      var countries = colors.selectAll('.divider')
        .data(function (d) {

            return d.children
          },
          function (d) {
            //dex.console.log("COUNTRY-DATA", d, d.data[config.csv.header[config.index.divider]])
            return d.data[config.csv.header[config.index.divider]]
          })

      var enterCountries = countries.enter().append('rect')
        .attr('class', 'divider')
        .attr('x', function (d) {
          return d.value ? d.x0 : x1.bandwidth() / 2
        })
        .attr('width', function (d) {
          return d.value ? d.x1 - d.x0 : 0
        })
        .attr('y', 0)
        .attr('height', 0)
        .style('fill', function (d) {
          //dex.console.log("COLOR", d.parent.data.color)
          return color(d.parent.data.color)
        })

      countries = countries.merge(enterCountries)

      enterCountries
        .on('mouseover', function (d) {
          chart.publish({"type" : "mouseover", "selected" : d});
          svg.classed('hover-active', true)
          countries.classed('hover', function (e) {
            //dex.console.log("E-HOVER", e.data[config.csv.header[config.index.divider]], d.data[config.csv.header[config.index.divider]])
            return e.data[config.csv.header[config.index.divider]] === d.data[config.csv.header[config.index.divider]]
          })
        })
        .on('mouseout', function () {
          chart.publish({"type" : "mouseout", "selected" : this });
          svg.classed('hover-active', false)
          countries.classed('hover', false)
        })
        .on('click', function (d) {

          //dex.console.log("ON-CLICK", options, d, d.data[config.csv.header[config.index.divider]])
          chart.publish({"type" : "click", "selected" : d});
          options.divider = options.divider === d.data[config.csv.header[config.index.divider]] ? null : d.data[config.csv.header[config.index.divider]]
          tmUpdate()
        })
        .append('title')
        .text(function (d) {
          return (
          config.csv.header[config.index.color] +
          " = " + d.data[config.csv.header[config.index.color]] +
          "\n" + config.csv.header[config.index.divider] +
          "  = " + d.data[config.csv.header[config.index.divider]] +
          "\n" + config.csv.header[config.index.value] + " = " +
          d.data[config.csv.header[config.index.value]]);
        });

      countries.filter(function (d) {
        return d.data[config.csv.header[config.index.divider]] === options.divider
      })
        .each(function (d) {
          d3.select(this.parentNode).raise()
        })
        .raise()

      countries
        .transition(t)
        .attr('x', function (d) {
          return d.value ? d.x0 : x1.bandwidth() / 2
        })
        .attr('width', function (d) {
          return d.value ? d.x1 - d.x0 : 0
        })
        .attr('y', function (d) {
          return d.value ? d.y0 : d.parent.parent.y1 / 2
        })
        .attr('height', function (d) {
          return d.value ? d.y1 - d.y0 : 0
        })

      d3 = dex.charts.d3.d3v3;
    }

    // Style category axis
    catAxisG = d3.select(config.parent).selectAll(".x1");
    //dex.console.log("CatAxisG", catAxisG);
    catAxisG.selectAll("text")
      .call(dex.config.configureText, config.categoryLabel);

    // Styling x axis
    xAxisG = d3.select(config.parent).selectAll(".x0");
    //dex.console.log("CatAxisG", catAxisG);
    xAxisG.selectAll("text")
      .call(dex.config.configureText, config.xLabel);

    return chart;
  };

    chart.clone = function clone(override) {
        return treemapBarChart(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(sankey.config.parent).draggable();
  });

  return chart;
};

module.exports = treemapBarChart;
},{}],41:[function(require,module,exports){
var verticallegend = function (userConfig) {

  var defaults = {
    'labels'          : ["A", "B", "C"],
    'id'              : "VerticalLegend",
    'class'           : "VerticalLegend",
    'resizeable'      : false,
    'parent'          : null,
    'height'          : 250,
    'width'           : 250,
    //'transform'       : 'translate(100,100)',
    //'xoffset'         : 50,
    //'yoffset'         : 30,
    //'cellWidth'       : 30,
    //'cellHeight'      : 20,
    'tickLength'      : 5,
    'caption'         : "Legend",
    'captionFontSize' : 14,
    'captionXOffset'  : -30,
    'captionYOffset'  : -20,
    'margin'          : {
      'top'    : 10,
      'bottom' : 10,
      'left'   : 20,
      'right'  : 10
    },
    'cell'            : {
      'appearance.mouseover.rect.width' : 35,
      'appearance.mouseout.rect.width'  : 30,
      'appearance.mousedown.rect.width' : 50,
      'appearance.mouseup.rect.width'   : 35,
      'rect'                            : dex.config.rectangle({
        'width'  : 30,
        'height' : 20,
        'y'      : function (d) {
          return chart.config.yscale(d);
        },
        'x'      : function (d) {
          return chart.config.width / 10;
        },
        'events' : {
          'mouseover' : function (d, i) {
            dex.console.log("mouseover event(d=" + d + ", i=" + i + ")");
            //dex.console.log("this", d3.select(this), "Mouseover config",
            //chart.config);
            //dex.console.log("cell.events.mouseover.config",
            //  chart.config.cell.appearance.mouseover);
            d3.select(this).call(dex.config.configureRectangle,
              chart.config.cell.appearance.mouseover.rect);
            chart.publish({"type" : "mouseover", "d" : d});
          },
          'mouseout'  : function (d) {
            dex.console.log("mouseout event(d=" + d + ", i=" + i + ")");
            d3.select(this).call(dex.config.configureRectangle,
              chart.config.cell.appearance.mouseout.rect);
            chart.publish({"type" : "mouseout", "d" : d});
          },
          'mousedown' : function (d) {
            dex.console.log("mousedown event(d=" + d + ", i=" + i + ")");
            d3.select(this).call(dex.config.configureRectangle,
              chart.config.cell.appearance.mousedown.rect);
            chart.publish({"type" : "mousedown", "d" : d});
          },
          'mouseup'   : function (d) {
            dex.console.log("mouseup event(d=" + d + ", i=" + i + ")");
            d3.select(this).call(dex.config.configureRectangle,
              chart.config.cell.appearance.mouseup.rect);
            chart.publish({"type" : "mouseup", "d" : d});
          }
        }
      }),
      'label'                           : dex.config.text({
        'text'        : function (d) {
          return d;
        },
        'font.scale'  : function (d) {
          dex.console.log("FONT.SCALE: width=" + chart.config.width + 'x' + chart.config.height);
          var scale = d3.scale.linear()
            .domain([0, 150])
            .range([0, 32]);
          return scale;
        },
        'font.weight' : "bold",
        'font.size'   : function (d) {
          dex.console.log("FONT-SIZE: width=" + chart.config.width +
          ", height=" + chart.config.height +
          ", fontScale=" + chart.config.cell.label.font.scale()(chart.config.width * .2));
          return chart.config.cell.label.font.scale()(chart.config.width * .2);
        },
        'anchor'      : 'end',
        'y'           : function (d) {
          return chart.config.yscale(d);
        },
        'dx'          : function (d, i) {
          dex.console.log("dx", chart.config.cell.label.font.size(d));
          return -1 * chart.config.cell.label.font.size(d) / 2;
          //dex.console.log("this", this, "select(this)", d3.select(this), chart.config);
          //return -(chart.config.cell.label.font.size / 2);
        },
        'dy'          : function (d, i) {
          //dex.console.log("CURENT-FONT-SIZE " + chart.config.cell.label.font.size(d))
          ;         // return Math.floor(chart.config.cell.rect.height / 2);// + Math.floor(chart.config.cell.label.font.size(d) / 2);
          return 0;
        },
        'fill'        : dex.config.fill({'fillColor' : 'black'})
      })
    },
    'title'           : dex.config.text({
      'text'       : 'title.text',
      'anchor'     : 'middle',
      'font.scale' : function (d) {
        dex.console.log("TITLE.FONT.SCALE: width=" + chart.config.width + 'x' + chart.config.height);
        var scale = d3.scale.linear()
          .domain([0, 200])
          .range([4, 64]);
        return scale;
      },
      'font.size'  : function (d) {
        dex.console.log("TITLE-FONT-SIZE: width=" + chart.config.width +
        ", height=" + chart.config.height +
        ", fontScale=" + chart.config.cell.label.font.scale()(
          Math.min(chart.config.width, chart.config.height) / 5));
        return chart.config.title.font.scale()
        (Math.min(chart.config.width, chart.config.height) * .2);
      },
      'y'          : function (d) {
        return chart.config.height / 12;
      },
      'x'          : function (d) {
        return chart.config.width / 10 + chart.config.cell.rect.width / 2;
      }
    })
  };

  // Create our chart.
  var chart = new dex.component(userConfig, defaults);
  var config = chart.config;

  chart.render = function render() {
    window.onresize = this.resize;
    chart.resize();
  };

  chart.resize = function resize() {
    if (chart.config.resizeable) {

      var width = d3.select(chart.config.parent).property("clientWidth");
      var height = d3.select(chart.config.parent).property("clientHeight");
      var cellWidth = width * .4;
      var cellHeight = height * .8 / (chart.config.labels.length + 1);
      dex.console.log("Resizing VerticalLegend: " + width + "x" + height);
      chart
        .attr("width", width)
        .attr("height", height)
        .attr("cell.rect.width", cellWidth)
        .attr("cell.rect.height", cellHeight)
        .attr("margin.top", height * .1)
        .attr("margin.bottom", height * .1)
        .attr("margin.left", width * .1)
        .attr("margin.right", width * .1)
        .attr("cell.appearance.mouseover.rect.width", cellWidth * 1.1)
        .attr("cell.appearance.mouseout.rect.width", cellWidth)
        .attr("cell.appearance.mousedown.rect.width", cellWidth * 1.2)
        .attr("cell.appearance.mouseup.rect.width", cellWidth * 1.1)
        .attr("cell.label.dx", width * .4)
        .attr("cell.rect.x", width * .5)
        .attr("title.y", height * .08)
        .attr("title.x", width * .4 + cellWidth / 2)
        .attr("cell.label.x", width * .1)
        .update();
    }
    else {
      chart.update();
    }
  };

  chart.update = function update() {
    var chart = this;
    var config = this.config;
    dex.console.log("RESIZE");
    dex.console.log(config.id + ": " + config.width + "x" + config.height);
    d3.selectAll("#" + config.id).remove();

    config.yscale = d3.scale.ordinal()
      .domain(config.labels)
      .rangeBands([config.margin.top, config.height - config.margin.bottom]);

    // Append a graphics node to the supplied svg node.
    var chartContainer = d3.select(config.parent).append("g")
      .attr("id", config["id"])
      .attr("class", config["class"])
      .attr("transform", config.transform);

    var rects = chartContainer.selectAll("rect")
      .data(config.labels)
      .enter()
      .append("rect")
      .call(dex.config.configureRectangle, config.cell.rect);

    chartContainer.selectAll("label")
      .data(config.labels)
      .enter().append("text")
      .call(dex.config.configureText, config.cell.label);

    chartContainer.append("text")
      .call(dex.config.configureText, config.title)
      .text(config.title.text);
  };

  $(document).ready(function () {
    // Make the entire chart draggable.
    $(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = verticallegend;
},{}],42:[function(require,module,exports){
/**
 *
 * This module provides D3 based visualization components.
 *
 * @module dex/charts/d3
 *
 */
var d3 = {};

d3.d3v4 = require("../../../lib/d3.v4.4.0.min");
d3.d3v3 = require("../../../lib/d3.v3.5.17.min");

//d3.Axis = require("./Axis");
d3.BumpChart = require("./BumpChart");
d3.Chord = require("./Chord");
d3.ClusteredForce = require("./ClusteredForce");
d3.Dendrogram = require("./Dendrogram");
//d3.HeatMap = require("./HeatMap");
//d3.HorizonChart = require("./../../../graveyard/HorizonChart");
d3.HorizontalLegend = require("./HorizontalLegend");
//d3.LineChart = require("./LineChart");
d3.MotionBarChart = require("./MotionBarChart");
//d3.MotionChart = require("./MotionChart");
//d3.MotionCircleChart = require("./MotionCircleChart");
//d3.MotionLineChart = require("./MotionLineChart");
d3.OrbitalLayout = require("./OrbitalLayout");
d3.ParallelCoordinates = require("./ParallelCoordinates");
d3.RadarChart = require("./RadarChart");
d3.RadialTree = require("./RadialTree");
d3.Sankey = require("./Sankey");
//d3.SankeyParticles = require("./SankeyParticles");
d3.ScatterPlot = require("./ScatterPlot");
d3.Sunburst = require("./Sunburst");
//d3.TitledTreemap = require("./TitledTreemap");
d3.Treemap = require("./Treemap");
d3.VerticalLegend = require("./VerticalLegend");
d3.TreemapBarChart = require("./TreemapBarChart");
d3.TopoJsonMap = require("./TopoJsonMap");

module.exports = d3;
},{"../../../lib/d3.v3.5.17.min":5,"../../../lib/d3.v4.4.0.min":6,"./BumpChart":25,"./Chord":26,"./ClusteredForce":27,"./Dendrogram":28,"./HorizontalLegend":29,"./MotionBarChart":30,"./OrbitalLayout":31,"./ParallelCoordinates":32,"./RadarChart":33,"./RadialTree":34,"./Sankey":35,"./ScatterPlot":36,"./Sunburst":37,"./TopoJsonMap":38,"./Treemap":39,"./TreemapBarChart":40,"./VerticalLegend":41}],43:[function(require,module,exports){
var ringnetwork = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults = {
    // The parent container of this chart.
    'parent': '#RingNetworkParent',
    // Set these when you need to CSS style components independently.
    'id': 'RingNetworkId',
    'class': 'RingNetworkClass',
    'resizable': true,
    // Sample default data...
    'csv': {
      'header': ["NAME", "GENDER", "VEHICLE"],
      'data': [
        ["JIM", "M", "CAR"],
        ["JOE", "M", "CAR"],
        ["PAT", "M", "TRUCK"],
        ["SALLY", "F", "TRUCK"]
      ]
    },
    'type': "rings",
    'connect': 'last',
    //'connect' : 'all',
    'width': "100%",
    'height': "100%",
    'transform': "",
    'margin': {
      'left': 100,
      'right': 100,
      'top': 50,
      'bottom': 50
    }
  };

  var chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    return chart.resize();
  };

  chart.update = function () {
    d3 = dex.charts.d3.d3v3;
    var chart = this;
    var config = chart.config;
    var csv = config.csv;

    // Nuke the old one
    d3.selectAll(config.parent).selectAll("*").remove();

    var connections = [];

    var rootMap = {};
    var cmap = {};

    // Connect everything in the row to the first column.
    //if (config.connect == 'first') {
    // TODO: Support other connection models here.
    for (var ri = 0; ri < csv.data.length; ri++) {
      if (_.isUndefined(rootMap[csv.data[ri][0]])) {
        connections.push({'source': csv.header[0], 'target': csv.data[ri][0]});
        rootMap[csv.data[ri][0]] = 1;
      }

      for (var ci = 1; ci < csv.header.length; ci++) {
        var src = csv.data[ri][0];
        var dest = csv.data[ri][ci];

        if (_.isUndefined(cmap[src + " -> " + dest])) {
          connections.push({'source': src, 'target': dest});
          cmap[src + " -> " + dest] = 1;
        }
      }
    }

    dex.console.debug("Connections", connections);

    // instantiate d3plus
    var viz = d3plus.viz()
      .container(config.parent)
      .type(config.type)
      .edges(connections)
      .focus(csv.header[0]);

    if (config.edges) {
      viz.edges(config.edges);
    }

    viz.draw();
  };

    chart.clone = function clone(override) {
        return ringnetwork(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = ringnetwork;
},{}],44:[function(require,module,exports){
/**
 *
 * This module provides d3plus based visualizations.
 *
 * @module dex/charts/d3plus
 *
 */
var d3plus = {};

d3plus.RingNetwork = require("./RingNetwork");

module.exports = d3plus;
},{"./RingNetwork":43}],45:[function(require,module,exports){
var echart = function (userConfig) {
    var chart;
    var internalChart = undefined;
    var effectiveOptions;

    var defaults = {
      'parent': '#EChartParent',
      'id': 'EChartId',
      'class': 'EChartClass',
      'resizable': true,
      'csv': {
        'header': [],
        'data': []
      },
      'palette': "ECharts",
      'series': {},
      'width': "100%",
      'height': "100%",
    };

    chart = new dex.component(userConfig, defaults);

    chart.render = function render() {
      var config = chart.config;
      var csv = config.csv;

      echarts.dispose(d3.select(config.parent)[0][0]);
      d3.select(config.parent).selectAll("*").remove();

      dex.console.log("PARENT: '" + config.parent + "'");
      //if (internalChart !== undefined) {
      //  internalChart.dispose();
      //}
      internalChart = echarts.init(
        d3.select(config.parent)[0][0]);

      // Calls update automatically.
      chart.resize();

      return chart;
    };

    chart.update = function () {
      var config = chart.config;
      var csv = config.csv;

      if (config.categorizationMethod) {
        config.categories = dex.csv.getCategorizationMethod(csv,
          config.categorizationMethod);
      }

      var dataOptions = getOptions(csv);
      effectiveOptions = dex.config.expandAndOverlay(config.options, dataOptions);
      internalChart.setOption(effectiveOptions);
      internalChart.resize();
    };

    function getOptions(csv) {
      var commonOptions = {
        color: dex.color.palette[chart.config.palette]
      };
      var chartType = dex.object.getValue(chart.config, "type", "line");
      switch (chartType) {
        case "force" :
        case "circular" :
        case "graph" :
          return getGraphOptions(commonOptions, csv);
        case "timeline":
          return getTimelineOptions(commonOptions, csv);
        case "radar":
          return getRadarOptions(commonOptions, csv);
        case "steam":
          return getSteamOptions(commonOptions, csv);
        case "heatmap":
          return getHeatmapOptions(commonOptions, csv);
        case "polar":
          return getPolarOptions(commonOptions, csv);
        case "linechart":
        case "areachart":
        case "bar":
          return getCartesianOptions(commonOptions, csv);
        case "pie":
          return getPieOptions(commonOptions, csv);
        case 'single-axis':
          return getSingleAxisOptions(commonOptions, csv);
        default:
          return getCartesianOptions(commonOptions, csv);
      }
    }

    function getPieOptions(commonOptions, csv) {
      var config = chart.config;
      var options = dex.config.expandAndOverlay({
        tooltip: {
          trigger: 'item',
          formatter: "{a} <br/>{b}: {c} ({d}%)"
        },
        legend: {
          orient: 'vertical',
          x: 'left',
          data: []
        },
        series: []
      }, commonOptions);
      var gtypes = dex.csv.guessTypes(csv);

      // Get our indices:
      var seriesIndex = dex.csv.getColumnNumber(csv, config.seriesIndex);
      var nameIndex = dex.csv.getColumnNumber(csv, config.nameIndex);
      var valueIndex = dex.csv.getColumnNumber(csv, config.valueIndex);
      var aggregationFunction = chart.config.aggregationFunction;

      var pieCsv = dex.csv.columnSlice(csv, [seriesIndex, nameIndex, valueIndex]);

      var frames = dex.csv.getFramesByIndex(csv, seriesIndex);

      //dex.console.log("FRAMES", frames);
      var legendNames = {};

      var maxPercent = chart.config.maxPercent || 80.0;
      var maxPadding = chart.config.maxPadding || 10;
      var availableRadius = chart.config.radius ||
        Math.floor(maxPercent / (frames.frames.length + 2));
      var padding = chart.config.padding ||
        (Math.min((frames.frames.length <= 1) ? 0 :
          Math.floor(maxPercent / (2 * frames.frames.length - 2)), maxPadding));

      var startRadius = 0;
      var endRadius = Math.floor(availableRadius * 2);

      frames.frames.forEach(function (frame, fi) {
        var nvp = {};
        frame.data.forEach(function (row, ri) {
            if (nvp[row[0]] === undefined) {
              nvp[row[0]] = [];
            }
            nvp[row[0]].push(row[1]);
          }
        );
        var data = [];
        for (var name in nvp) {
          legendNames[name] = 1;
          data.push({"name": name, "value": aggregationFunction(nvp[name])});
        }
        var series = dex.config.expandAndOverlay(chart.config.series,
          {
            name: frames.frameIndices[fi],
            radius: [startRadius + "%", endRadius + "%"],
            data: data
          });
        options.series.push(series);
        startRadius = padding + endRadius;
        endRadius = startRadius + availableRadius;
      });

      options.legend.data = Object.keys(legendNames);

      dex.console.log("OPTIONS", options);
      return options;
    }

    function getPolarOptions(commonOptions, csv) {
      var config = chart.config;
      var options = dex.config.expandAndOverlay({
        legend: {data: []},
        series: [],
        polar: {}
      }, commonOptions);
      var gtypes = dex.csv.guessTypes(csv);

      // Get our indices:
      var angleIndex = dex.csv.getColumnNumber(csv, config.angleIndex);
      var valueIndex = dex.csv.getColumnNumber(csv, config.valueIndex);
      var seriesIndex = dex.csv.getColumnNumber(csv, config.seriesIndex);
      var radiusIndex = dex.csv.getColumnNumber(csv, config.radiusIndex);

      // Will contain required data indices for series.
      var columns = [];

      // We always need values.
      columns.push(valueIndex);
      //dex.console.log("ANGLE INDEX: ", config.angleIndex, angleIndex);

      switch (config.series.type) {
        case "line":
        case "scatter":
        case "bar" : {
          if (angleIndex === undefined) {
            options.angleAxis = {
              type: 'value',
              startAngle: 0
            };
          }
          else {
            if (gtypes[angleIndex] == "string" ||
              chart.config.angleAxisType == "category") {
              options.angleAxis = {
                type: "category",
                data: dex.csv.uniqueArray(csv, angleIndex)
              }
            }
            else {
              var extents = dex.csv.extent(csv, angleIndex);
              //dex.console.log("EXTENT", extents);
              options.angleAxis = {
                type: "value",
                min: "dataMin",
                max: "dataMax",
                boundaryGap: true
              };
              columns.push(angleIndex);
            }
          }

          if (radiusIndex === undefined) {
            options.radiusAxis = {};
          }
          else {
            if (gtypes[radiusIndex] == "string" ||
              chart.config.radiusAxisType == "category") {
              options.radiusAxis = {
                type: "category",
                data: dex.csv.uniqueArray(csv, radiusIndex)
              };
            }
            else {
              options.radiusAxis = {};
            }
          }

          break;
        }
      }

      if (options.radiusAxis.type == "category" &&
        options.angleAxis.type == "category") {
        columns = [radiusIndex, angleIndex, valueIndex];
      }
      var seriesNames = [];

      //dex.console.log("COLUMNS", columns);

      if (seriesIndex !== undefined) {
        seriesNames = dex.csv.uniqueArray(csv, seriesIndex);
        //dex.console.log("SERIES-NAMES", seriesNames);
        options.legend.data = seriesNames;

        seriesNames.forEach(function (seriesName) {
            var series = dex.config.expandAndOverlay(config.series,
              {
                name: seriesName,
                coordinateSystem: 'polar',
                type: 'line',
                data: function (csv) {
                  var selectedCsv = dex.csv.selectRows(csv, function (row) {
                    return row[seriesIndex] == seriesName;
                  });

                  if (columns.length == 1) {
                    return selectedCsv.data.map(function (row) {
                      return row[columns[0]];
                    });
                  }
                  else {
                    return dex.csv.columnSlice(selectedCsv, columns).data;
                  }
                }(chart.config.csv)
              });
            options.series.push(series);
          }
        );
      }
      else {
        var series = dex.config.expandAndOverlay(config.series,
          {
            name: 'Series',
            coordinateSystem: 'polar',
            type: 'line',
            data: csv.data.map(function (row) {
              return row[0];
            })
          });
        options.series.push(series);
      }

      dex.console.log("OPTIONS", options);
      return options;
    }

    function getCartesianOptions(commonOptions, csv) {
      var options = dex.config.expandAndOverlay({}, commonOptions);
      //var gtypes = dex.csv.guessTypes(csv);

      var xyCsv = dex.csv.removeColumn(csv, 0);
      options.legend = {data: xyCsv.remaining.header};

      options.xAxis = {
        type: 'category',
        boundaryGap: false,
        data: xyCsv.removed.data.map(function (row) {
          return row[0]
        })
      };
      options.yAxis = {type: 'value'};
      options.series = [];

      xyCsv.remaining.header.forEach(function (h) {
        var series = dex.config.expandAndOverlay(chart.config.series,
          {name: h, type: 'line', data: []});
        options.series.push(series);
      });

      xyCsv.remaining.data.forEach(function (row, ri) {
        row.forEach(function (col, ci) {
          options.series[ci].data.push(col);
        });
      });

      //dex.console.log("OPTIONS", options);
      return options;
    }

    function getSingleAxisOptions(commonOptions, csv) {
      var options = dex.config.expandAndOverlay({
        tooltip: {
          position: 'top'
        },
        title: [],
        singleAxis: [],
        series: []
      }, commonOptions);

      var frames = dex.csv.getFramesByIndex(csv, 0);

      var scatterHeightPercent = 90;
      var percentIncrement = scatterHeightPercent / frames.frameIndices.length;
      var topOffset = 0;
      var heightOffset = 0;

      frames.frames.forEach(function (frame, fi) {

        options.title.push({
          textBaseline: 'middle',
          top: "" + ((fi + .5) * scatterHeightPercent / frames.frameIndices.length) + "%",
          text: frames.frameIndices[fi]
        });

        options.singleAxis.push({
          left: 150,
          type: 'category',
          boundaryGap: true,
          data: dex.matrix.slice(frame.data, [0]),
          top: (fi * percentIncrement + topOffset) + '%',
          height: (percentIncrement + heightOffset) + '%',
          axisLabel: {interval: 2}
        });

        var series = dex.config.expandAndOverlay(chart.config.series, {
          singleAxisIndex: fi,
          coordinateSystem: 'singleAxis',
          type: 'scatter',
          data: dex.matrix.slice(frame.data, [0, 1]),
          symbolSize: function (dataItem) {
            return chart.config.sizeScale(dataItem[1]);
          }
        });
        options.series.push(series);
      });

      //dex.console.log("OPTIONS", options);
      return options;
    }

    function getSteamOptions(commonOptions, csv) {
      dex.console.log("COMMON-OPTS", commonOptions, "CSV", csv);
      var options = dex.config.expandAndOverlay({
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'line',
            lineStyle: {
              color: 'rgba(0,0,0,0.2)',
              width: 1,
              type: 'solid'
            }
          }
        },
        title: [],
        singleAxis: {
          scale: true,
          bottom: "10%",
          axisPointer: {
            animation: true,
            label: {
              show: true
            }
          },
        },
        series: [],
        legend: {}
      }, commonOptions);

      var xIndex = dex.csv.getColumnNumber(csv, chart.config.xIndex);
      var yIndex = dex.csv.getColumnNumber(csv, chart.config.yIndex);
      var seriesIndex = dex.csv.getColumnNumber(csv, chart.config.seriesIndex);

      // Will contain required data indices for series.
      var columns = [xIndex, yIndex, seriesIndex];

      var seriesData = dex.csv.include(csv, columns);

      var columnTypes = dex.csv.guessTypes(seriesData);

      switch (columnTypes[0]) {
        case "string": {
          options.singleAxis.type = "category";
          break;
        }
        case "date": {
          options.singleAxis.type = "time";
          break;
        }
        default: {
          options.singleAxis.type = "value";
        }
      }

      options.legend.data = dex.csv.uniqueArray(seriesData, 2);

      options.dataZoom = [
        {
          show: true,
          realtime: true,
          start: 0,
          end: 100,
          singleAxisIndex: 0
        }
      ];

      //dex.console.log("LEGEND", options.legend, "SERIES-DATA", seriesData);

      var series = dex.config.expandAndOverlay(chart.config.series, {
        type: 'themeRiver',
        itemStyle: {
          emphasis: {
            shadowBlur: 20,
            shadowColor: 'rgba(0, 0, 0, 0.8)'
          }
        },
        data: seriesData.data
      });

      options.series.push(series);

      dex.console.log("OPTIONS", options);
      return options;
    }

    function getHeatmapOptions(commonOptions, csv) {
      var options = dex.config.expandAndOverlay({
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'line',
            lineStyle: {
              color: 'rgba(0,0,0,0.2)',
              width: 1,
              type: 'solid'
            }
          }
        },
        title: [],
        singleAxis: {
          max: 'dataMax',
          axisPointer: {
            animation: true,
            label: {
              show: true
            }
          },
        },
        series: [],
        legend: {}
      }, commonOptions);

      var xIndex = dex.csv.getColumnNumber(csv, chart.config.xIndex);
      var yIndex = dex.csv.getColumnNumber(csv, chart.config.yIndex);
      var seriesIndex = dex.csv.getColumnNumber(csv, chart.config.seriesIndex);

      // Will contain required data indices for series.
      var columns = [xIndex, yIndex, seriesIndex];

      var seriesData = dex.csv.include(csv, columns);

      var columnTypes = dex.csv.guessTypes(seriesData);

      switch (columnTypes[0]) {
        case "string": {
          options.singleAxis.type = "category";
          break;
        }
        case "date": {
          options.singleAxis.type = "time";
          break;
        }
        default: {
          options.singleAxis.type = "value";
        }
      }

      options.legend.data = dex.csv.uniqueArray(seriesData, 2);

      dex.console.log("LEGEND", options.legend, "SERIES-DATA", seriesData);

      var series = dex.config.expandAndOverlay(chart.config.series, {
        type: 'themeRiver',
        itemStyle: {
          emphasis: {
            shadowBlur: 20,
            shadowColor: 'rgba(0, 0, 0, 0.8)'
          }
        },
        data: seriesData.data
      });

      options.series.push(series);

      dex.console.log("OPTIONS", options);
      return options;
    }

    function getRadarOptions(commonOptions, csv) {
      var options = dex.config.expandAndOverlay({
        tooltip: {},
        series: [],
        legend: {},
        radar: {}
      }, commonOptions);

      var radiusIndex = dex.csv.getColumnNumber(csv, chart.config.radiusIndex);
      var angleIndex = dex.csv.getColumnNumber(csv, chart.config.angleIndex);
      var seriesIndex = dex.csv.getColumnNumber(csv, chart.config.seriesIndex);

      var maxRadius = dex.csv.extent(csv, [radiusIndex])[1];
      var minRadius = dex.csv.extent(csv, [radiusIndex])[0];

      options.radar.indicator = dex.csv.uniqueArray(csv, angleIndex)
        .reverse().map(function (value) {
          return {text: "" + value, max: maxRadius, min: minRadius};
        });

      // Per-series max.
      /**
       options.radar.indicator.forEach(function(indicator) {
        var maxRadius = dex.csv.extent(dex.csv.selectRows(csv, function(row) {
          //dex.console.log("ROW", row, row[angleIndex], indicator, row[radiusIndex]);
          return indicator.text === ("" + row[angleIndex]);
        }), [radiusIndex])[1];
        indicator.max = maxRadius;
      });
       **/

      //dex.console.log("INDICATOR: " + JSON.stringify(options.radar.indicator));

      options.legend.data = dex.csv.uniqueArray(csv, seriesIndex);

      var series = dex.config.expandAndOverlay(chart.config.series, {
        type: 'radar',
        name: "Series Name",
        data: options.legend.data.map(function (seriesName) {
          return {
            name: seriesName,
            value: dex.csv.selectRows(csv, function (row) {
              return row[seriesIndex] === seriesName;
            }).data.map(function (row) {
              return row[radiusIndex]
            })
          }
        })
      });

      options.series.push(series);

      dex.console.log("OPTIONS", options);
      return options;
    }

    function getGraphOptions(commonOptions, csv) {
      var options = dex.config.expandAndOverlay({}, commonOptions);

      var nodes = {};
      var nodeId = 0;

      // Dynamically determine our categorization function:
      var categorize = dex.csv.getCsvFunction(csv, chart.config.categories);

      // Cateorize all data in csv.
      var catMap = {};
      var catNum = 0;

      csv.data.forEach(function (row, ri) {
        row.forEach(function (col, ci) {
          var category = categorize(csv, ri, ci);
          if (typeof catMap[category] == "undefined") {
            catMap[category] = catNum;
            catNum++;
          }
        });
      });
      var categories = Object.keys(catMap).map(function (key) {
        return {name: key};
      });

      csv.data.forEach(function (row, ri) {
        row.forEach(function (col, ci) {
          var category = catMap[categorize(csv, ri, ci)];
          var key = col + "::" + category;
          nodes[key] = nodes[key] || {
              id: nodeId++,
              name: col,
              symbolSize: 10,
              itemStyle: null,
              category: category,
              value: 0,
              draggable: true,
              label: {normal: {show: true}}
            };
          nodes[key].value++;
          nodes[key].symbolSize += 5;
        });
      });

      var links = [];

      var linkId = 0;
      csv.data.forEach(function (row, ri) {
        row.forEach(function (col, ci) {
          if (ci < (row.length - 1)) {
            var sourceCat = catMap[categorize(csv, ri, ci)];
            var targetCat = catMap[categorize(csv, ri, ci + 1)];

            links.push({
              id: linkId,
              source: nodes[row[ci] + "::" + sourceCat]["id"],
              target: nodes[row[ci + 1] + "::" + targetCat]["id"]
            });
            linkId++;
          }
        });
      });

      options.legend = {
        //selectedMode: 'single',
        orient: 'vertical',
        left: true,
        top: true,
        show: true,
        data: categories
      };

      options.series = dex.config.expandAndOverlay(chart.config.series,
        {
          name: "series",
          type: 'graph',
          layout: 'circular',

          lineStyle: {
            normal: {
              color: 'source',
              curveness: 0.3
            }
          },
          links: links,
          data: Object.keys(nodes).map(function (key) {
            return nodes[key];
          }),
          categories: categories,
          roam: true,
          label: {
            normal: {
              position: 'right',
              formatter: '{b}'
            }
          }
        });

      //dex.console.log("OPTIONS", options);
      return options;
    }

    function getTimelineOptions(commonOptions, csv) {

      // Dynamically determine our categorization function:
      var getCategory = dex.csv.getRowFunction(csv, chart.config.categories);
      var getSequence = dex.csv.getRowFunction(csv, chart.config.sequences);

      // Cateorize all data in csv.
      var catMap = {};
      var seqMap = {};
      var category;
      var sequence;

      csv.data.forEach(function (row, ri) {
        category = getCategory(row, ri);
        sequence = getSequence(row, ri);

        //dex.console.log("CAT", category, "SEQ", sequence);

        catMap[category] = 1;

        if (typeof seqMap[sequence] == "undefined") {
          seqMap[sequence] = {};
        }

        seqMap[sequence][category] = row;
      });

      var categories = Object.keys(catMap).sort();
      var sequences = Object.keys(seqMap).sort();

      var baseData = [];

      // Fill in gaps of data, carry down most recent data
      // entry, or first encountered if there is none yet.

      var curSeq = {};
      sequences.forEach(function (seq) {
        categories.forEach(function (cat) {
          if ((typeof seqMap[seq][cat]) == "undefined") {
            if ((typeof curSeq[cat]) == "undefined") {
              seqMap[seq][cat] = [0, 0, 0, cat, seq];
            }
            else {
              seqMap[seq][cat] = curSeq[cat];
            }
          }
          curSeq[cat] = seqMap[seq][cat];
        });
      });

      categories.forEach(function (cat) {
        baseData.push(seqMap[sequences[0]][cat]);
      });
      //dex.console.log("BASE-DATA", baseData);

      var options = dex.config.expandAndOverlay({
        "baseOption": {
          "timeline": {
            "axisType": "category",
            "orient": "vertical",
            "autoPlay": true,
            "inverse": true,
            "playInterval": 1000,
            "left": null,
            "right": 20,
            "top": 20,
            "bottom": 20,
            "width": 55,
            "height": null,
            "label": {
              "normal": {
                "textStyle": {
                  "color": "#999"
                }
              },
              "emphasis": {
                "textStyle": {
                  "color": "#fff"
                }
              }
            },
            "symbol": "none",
            "lineStyle": {"color": "#555"},
            "checkpointStyle": {
              "color": "#bbb",
              "borderColor": "#777",
              "borderWidth": 2
            },
            "controlStyle": {
              "showNextBtn": true,
              "showPrevBtn": true,
              "normal": {
                "color": "#666",
                "borderColor": "#666"
              },
              "emphasis": {
                "color": "#aaa",
                "borderColor": "#aaa"
              }
            },
            "data": sequences
          },
          "backgroundColor": "#404a59",
          "title": [{
            "text": 1800,
            "textAlign": "center",
            "left": "63%",
            "top": "55%",
            "textStyle": {"fontSize": 100, "color": "rgba(255, 255, 255, 0.7)"}
          }],
          "tooltip": {
            "padding": 5,
            "backgroundColor": "#222",
            "borderColor": "#777",
            "borderWidth": 1,
            formatter: function (obj) {
              //dex.console.log("OBJECT", obj);
              return "<table>" +
                "<tr><td>" + csv.header[3] + ": </td><td>" + obj.data[3] + "</td></tr>" +
                "<tr><td>" + csv.header[4] + ": </td><td>" + obj.data[4] + "</td></tr>" +
                "<tr><td>" + csv.header[0] + ": </td><td>" + obj.data[0] + "</td></tr>" +
                "<tr><td>" + csv.header[1] + ": </td><td>" + obj.data[1] + "</td></tr>" +
                "<tr><td>" + csv.header[2] + ": </td><td>" + obj.data[2] + "</td></tr>" +
                "</table>";
            }
          },
          "grid": {
            "left": "12%",
            "right": "110"
          },
          "xAxis": {
            "type": "value",
            "name": csv.header[0],
            "max": dex.csv.extent(csv, [0])[1],
            "min": dex.csv.extent(csv, [0])[0],
            "nameGap": 25,
            "nameLocation": "middle",
            "nameTextStyle": {"fontSize": 18},
            "splitLine": {"show": false},
            "axisLine": {"lineStyle": {"color": "#ccc"}},
            "axisLabel": {"formatter": "{value}"}
          },
          "yAxis": {
            "type": "value",
            "name": csv.header[1],
            "max": dex.csv.extent(csv, [1])[1],
            "nameTextStyle": {"color": "#ccc", "fontSize": 18},
            "axisLine": {"lineStyle": {"color": "#ccc"}},
            "splitLine": {"show": false},
            "axisLabel": {"formatter": "{value}"}
          },
          "visualMap": [{
            "show": false,
            "dimension": 3,
            "categories": categories,
            "calculable": true,
            "precision": 0.1,
            "textGap": 30,
            "textStyle": {"color": "#ccc"},
            "inRange": {"color": ["#bcd3bb", "#e88f70", "#edc1a5", "#9dc5c8", "#e1e8c8", "#7b7c68", "#e5b5b5", "#f0b489", "#928ea8", "#bda29a", "#bcd3bb", "#e88f70", "#edc1a5", "#9dc5c8", "#e1e8c8", "#7b7c68", "#e5b5b5", "#f0b489", "#928ea8", "#bda29a"]}
          }],
          "series": [{
            "type": "scatter",
            "itemStyle": {
              "normal": {
                "opacity": 0.8,
                "shadowBlur": 10,
                "shadowOffsetX": 0,
                "shadowOffsetY": 0,
                "shadowColor": "rgba(0, 0, 0, 0.5)"
              }
            },
            "data": baseData
          }],
          "animationDurationUpdate": 1000,
          "animationEasingUpdate": "quinticInOut"
        },
        options: []
      }, commonOptions);

      sequences.forEach(function (seq) {
        var option = {
          "title": {
            show: true,
            text: seq
          }
        };
        var data = [];
        categories.forEach(function (cat) {
          data.push(seqMap[seq][cat]);
        });
        option.series = dex.config.expandAndOverlay(chart.config.series,
          {
            name: +seq,
            type: 'scatter',
            data: data,
            symbolSize: function (row) {
              //dex.console.log("SIZE OF", row);
              if (typeof row == "undefined") {
                return chart.config.radius.min;
              }
              //return 10;
              var size = chart.config.sizes(row);
              if (typeof size == "undefined" || size < 0) {
                return chart.config.radius.min;
              }
              else {
                return size;
              }
            }
          });
        option.series.type = 'scatter';
        options.options.push(option);
      });

      return options;
    }

    $(document).ready(function () {
      // Make the entire chart draggable.
      if (chart.config.draggable) {
        $(chart.config.parent).draggable();
      }
    });

    return chart;
  }
;

module.exports = echart;
},{}],46:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Line Chart.
 *
 * @name dex/charts/echarts/LineChart
 *
 * @param userConfig
 * @returns LineChart
 */
var linechart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#ECharts_LineChart',
    'id': 'ECharts_LineChart',
    'class': 'ECharts_LineChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'linechart',
    'palette': "ECharts",
    'series.symbol': 'circle',
    'series.symbolSize': 10,
    'series.type': 'line',
    'series.showSymbol': true,
    'series.showAllSymbol': false,
    'series.stack': false,
    'series.clipOverflow': true,
    'series.connectNulls': false,
    'series.step': false,
    "options": {
      dataZoom: [
        {
          orient: 'horizontal',
          show: true,
          realtime: true,
          start: 0,
          end: 100,
          xAxisIndex: 0
        },
        {
          orient: 'vertical',
          show: true,
          realtime: true,
          start: 0,
          end: 100,
          yAxisIndex: 0
        }
      ],
      tooltip: {
        formatter: 'Group {a}: ({c})'
      }
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Line Chart Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist: true}),
              "initialValue": "category10"
            },
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            },
            {
              "name": "Symbol Shape",
              "description": "The shape of the symbol.",
              "type": "choice",
              "choices": ["circle", "rect", "roundRect", "triangle", "diamond", "pin", "arrow"],
              "target": "series.symbol"
            },
            {
              "name": "Symbol Size",
              "description": "The size of the symbols",
              "type": "int",
              "target": "series.symbolSize",
              "minValue": 0,
              "maxValue": 50,
              "initialValue": 5
            },
            {
              "name": "Series Type",
              "description": "The series type",
              "type": "choice",
              "target": "series.type",
              "choices": ["line", "scatter", "effectScatter", "bar"]
            },
            {
              "name": "Stack Series",
              "description": "Stack the series or not.",
              "type": "boolean",
              "target": "series.stack",
              "initialValue": false
            },
            {
              "name": "Clip Overflow",
              "description": "Clip overflow.",
              "type": "boolean",
              "target": "series.clipOverflow",
              "initialValue": true
            },
            {
              "name": "Connect Nulls",
              "description": "Connect nulls.",
              "type": "boolean",
              "target": "series.connectNulls",
              "initialValue": false
            },
            {
              "name": "Step",
              "description": "Stack the series or not.",
              "type": "boolean",
              "target": "series.step",
              "initialValue": false
            }
          ]
        },
        dex.config.gui.echartsLabel({name: "Normal Label"}, "series.label.normal"),
        dex.config.gui.echartsLabel({name: "Emphasis Label"}, "series.label.emphasis")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = linechart;
},{}],47:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Network.
 *
 * @name dex/charts/echarts/network
 *
 * @param userConfig
 * @returns Network
 */
var network = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#ECharts_Network',
    'id': 'ECharts_Network',
    'class': 'ECharts_Network',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'force',
    // Each node is a unique category
    'categories' : dex.csv.getCsvFunction(),
    'palette': "ECharts",
    'series.circular' : {},
    'series.type': 'graph',
    'series.layout': 'force',
    'series.force' : {
      repulsion: 50,
      gravity: .1,
      edgeLength: 100,
      layoutAnimation: true
    },
    "options": {
      'series.lineStyle.normal.curveness' : 0,
      title: {
        text: 'Title',
        subtext: 'Subtext',
        bottom: true,
        left: true
      },
      tooltip: {}
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Network Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist:true}),
              "initialValue": "category10"
            },
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            },
            {
              "name": "Layout",
              "description": "The shape of the symbol.",
              "type": "choice",
              "choices": ["force", "circular", "none"],
              "target": "series.layout",
              "initialValue": "force"
            },
            {
              "name": "Categorize",
              "description": "Categorization Methods",
              "type": "choice",
              "choices": Object.keys(dex.csv.getCategorizationMethods(csv)),
              "target": "categorizationMethod"
            },
            {
              "name": "Symbol Shape",
              "description": "The shape of the symbol.",
              "type": "choice",
              "choices": ["circle", "rect", "roundRect", "triangle", "diamond", "pin", "arrow"],
              "target": "series.symbol"
            },
            {
              "name": "Symbol Size",
              "description": "The size of the symbols",
              "type": "int",
              "target": "series.symbolSize",
              "minValue": 0,
              "maxValue": 50,
              "initialValue": 5
            },
            {
              "name": "Node Scale Ratio",
              "description": "Affects mouse zoom increment.",
              "type": "float",
              "target": "series.nodeScaleZoom",
              "minValue": 0,
              "maxValue": 2,
              "initialValue": .6
            },
            {
              "name": "Draggable",
              "description": "Allow the network diagram to be dragged or not.",
              "type": "boolean",
              "target": "series.draggable",
              "initialValue": false
            }
          ]
        },
        {
          "type": "group",
          "name": "Force Layout",
          "contents": [
            {
              "name": "Initial Layout",
              "description": "Initial layout.",
              "type": "choice",
              "choices": ["circular", "random"],
              "target": "series.force.initLayout",
              "initialValue": "circular"
            },
            {
              "name": "Gravity",
              "description": "The gravitational factor.",
              "type": "float",
              "target": "series.force.gravity",
              "minValue": -10,
              "maxValue": 10,
              "initialValue": .1
            },
            {
              "name": "Repulsion",
              "description": "The repulsive force between nodes.",
              "type": "int",
              "target": "series.force.repulsion",
              "minValue": -1000,
              "maxValue": 1000,
              "initialValue": 50
            },
            {
              "name": "Edge Length",
              "description": "The distance between nodes before repulsion and gravity are applied.",
              "type": "int",
              "target": "series.force.edgeLength",
              "minValue": 0,
              "maxValue": 1000,
              "initialValue": 30
            },
            {
              "name": "Layout Animation",
              "description": "Show the iteration layout or not.",
              "type": "boolean",
              "target": "series.force.layoutAnimation",
              "initialValue": true
            }
          ]
        },
        dex.config.gui.echartsLineStyle({name: "Line Style"}, "series.lineStyle.normal"),
        dex.config.gui.echartsLineStyle({name: "Line Style (Emphasis)"}, "series.lineStyle.emphasis"),
        dex.config.gui.echartsLabel({name: "Normal Label"}, "series.label.normal"),
        dex.config.gui.echartsLabel({name: "Emphasis Label"}, "series.label.emphasis")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = network;
},{}],48:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Pie Chart
 *
 * @name dex/charts/echarts/PieChart
 *
 * @param userConfig
 * @returns PieChart
 */
var piechart = function (userConfig) {
  var chart;
  var sizeScale = undefined;
  var defaults = {
    'parent': '#ECharts_PieChart',
    'id': 'ECharts_PieChart',
    'class': 'ECharts_PieChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'pie',
    'palette': 'ECharts',
    'seriesIndex': 0,
    'nameIndex': 1,
    'valueIndex': 2,
    'aggregationMethod': "Sum",
    'aggregationFunction': function (values) {
      return values.reduce(function (acc, value) {
        return acc + value;
      }, 0);
    },
    // Dynamic but can be overriden.
    maxPadding: undefined,
    maxPercent: undefined,
    radius: undefined,
    padding: undefined,
    'series.type': 'pie',
    'series.selectedMode': 'single',
    'series.label.normal.position': 'inner'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  chart.subscribe(chart, "attr", function (event) {
    if (event.attr == "aggregationMethod") {
      switch (event.value) {
        case "Average": {
          chart.config.aggregationFunction = function (values) {
            var sum = values.reduce(function (acc, value) {
              return acc + value;
            }, 0);
            return sum / values.length;
          }
        }
        case "Count": {
          chart.config.aggregationFunction = function (values) {
            return values.length;
          }
        }
        case "Count Distinct": {
          chart.config.aggregationFunction = function (values) {
            return dex.array.unique(values).length;
          }
        }
        case "Sum":
        default: {
          chart.config.aggregationFunction = function (values) {
            return values.reduce(function (acc, value) {
              return acc + value;
            }, 0);
          }
        }
      }
    }
  });

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Pie Chart Settings",
      "contents": [
        {
          "type": "group",
          "name": "General",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist:true}),
              "initialValue": "category10"
            },
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            },
            dex.config.gui.echartsTitle({}, "options.title"),
            {
              "name": "Aggregation Method",
              "description": "The aggregation method",
              "type": "choice",
              "choices": ["Sum", "Average", "Count", "Count Distinct"],
              "target": "aggregationMethod",
              "initialValue": "Sum"
            }
          ]
        },
        {
          "type": "group",
          "name": "Series and Axis",
          "contents": [
            {
              "name": "Series Index",
              "description": "The series index.",
              "type": "choice",
              "choices": chart.config.csv.header,
              "target": "seriesIndex"
            },
            {
              "name": "Name Index",
              "description": "The radius index.",
              "type": "choice",
              "choices": chart.config.csv.header,
              "target": "nameIndex"
            },
            {
              "name": "Value Index",
              "description": "The value index.",
              "type": "choice",
              "choices": chart.config.csv.header,
              "target": "valueIndex"
            }
          ]
        }
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = piechart;
},{}],49:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Polar Plot
 *
 * @name dex/charts/echarts/PolarPlot
 *
 * @param userConfig
 * @returns PolarPlot
 */
var polarplot = function (userConfig) {
  var chart;
  var sizeScale = undefined;
  var defaults = {
    'parent': '#ECharts_PolarPlot',
    'id': 'ECharts_PolarPlot',
    'class': 'ECharts_PolarPlot',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'polar',
    'palette': 'ECharts',
    'seriesIndex': 0,
    'angleIndex': 1,
    'valueIndex': 2,
    'radiusIndex': undefined,
    'radius': {'min': 1, 'max': 20},
    'sizeMethod': 'linear',
    'sizeScale': function (value) {
      // No size scale exists, so let's establish one.
      if (typeof sizeScale == "undefined") {
        // We have a value index to size upon.
        if (chart.config.valueIndex !== undefined) {
          sizeScale = dex.csv.getScalingMethod(
            chart.config.csv, chart.config.sizeMethod,
            dex.csv.extent(chart.config.csv,
              [dex.csv.getColumnNumber(chart.config.csv, chart.config.valueIndex)]),
            [chart.config.radius.min, chart.config.radius.max]);
        }
        // There is no value index to size upon. so we will try another
        // approach:
        //
        // 1. Create a csv which omits radius and angle indices from consideration
        // 2. Omit non-numerics as well.
        // 3. Get the extents from the remaining columns.
        // 4. Map these extents to a scale based on radius min/max range.
        else {
          var excludes = [];
          if (chart.config.radiusIndex != undefined) {
            excludes.push(dex.csv.getColumnNumber(chart.config.radiusIndex));
          }
          if (chart.config.angleIndex !== undefined) {
            excludes.push(dex.csv.getColumnNumber(chart.config.angleIndex));
          }
          var sizeCsv;
          if (excludes.length == 0) {
            sizeCsv = chart.config.csv;
          }
          else {
            sizeCsv = dex.csv.exclude(chart.config.csv, excludes);
          }
          var ncols = dex.csv.getNumericIndices(sizeCsv);
          var extents = dex.csv.extent(sizeCsv, ncols);
          dex.console.log("EXTENTS", extents);
          sizeScale = dex.csv.getScalingMethod(
            chart.config.csv, chart.config.sizeMethod, extents,
            [chart.config.radius.min, chart.config.radius.max]);
        }
      }
      // If an array, value index is always first.
      if (Array.isArray(value)) {
        return sizeScale(value[2] || value[0]);
      }
      // If a simple value, size on it.  IE: Polar Bar Chart
      return sizeScale(value);
    },
    'series.coordinateSystem': 'polar',
    'series.type': 'line',
    'series.itemStyle.normal.opacity': .6,
    'series.itemStyle.emphasis.opacity': .9,
    "series.symbolSize": function (d) {
      //dex.console.log("SIZING D", d);
      if (typeof chart.config.sizeScale != "undefined") {
        //dex.console.log("SIZING D", d, chart.config.sizeScale(+d[2]));
        return chart.config.sizeScale(d);
      }
      return 5;
    },
    "options": {
      tooltip: {
        formatter: 'Group {a}: ({c})'
      },
      dataZoom: [
        {
          orient: 'vertical',
          show: true,
          realtime: true,
          start: 0,
          end: 100,
          angleAxisIndex: 0
        },
        {
          show: true,
          realtime: true,
          start: 0,
          end: 100,
          radiusAxisIndex: 0
        }
      ]
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  chart.subscribe(chart, "attr", function (event) {
    if (event.attr == "radius" || event.attr == "sizeMethod" ||
      event.attr == "radius.min" || event.attr == "radius.max") {
      // Causes next call to sizeScale to recreate it.
      sizeScale = undefined;
    }

    if (event.attr == "valueIndex" && event.value == "none") {
      sizeScale = undefined;
    }
  });

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Polar Plot Settings",
      "contents": [
        {
          "type": "group",
          "name": "General",
          "contents": [
            {
              "name": "Chart Type",
              "description": "The chart type.",
              "type": "choice",
              "choices": ["line", "bar", "scatter"],
              "target": "series.type"
            },
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist:true}),
              "initialValue": "category10"
            },
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            },
            dex.config.gui.echartsTitle({}, "options.title")
          ]
        },
        {
          "type": "group",
          "name": "Scaling",
          "contents": [
            {
              "name": "Minimum Radius",
              "description": "The minimum radius.",
              "type": "int",
              "minValue": 0,
              "maxValue": 200,
              "target": "radius.min",
              "initialValue": 5
            },
            {
              "name": "Maximum Radius",
              "description": "The maximum radius.",
              "type": "int",
              "minValue": 0,
              "maxValue": 200,
              "target": "radius.max",
              "initialValue": 5
            },
            {
              "name": "Size Scaling Method",
              "description": "The type of scaling method",
              "type": "choice",
              "target": "sizeMethod",
              "choices": ["linear", "pow", "log", "sqrt", "time"],
              "initialValue": "linear"
            }
          ]
        },
        {
          "type": "group",
          "name": "Series and Axis",
          "contents": [
            {
              "name": "Stack Series",
              "description": "To stack or not to stack, that is the question.",
              "type": "boolean",
              "target": "series.stack"
            },
            {
              "name": "Angle Axis Data Type",
              "description": "Angle axis data type.",
              "type": "choice",
              "choices": ["dynamic", "category"],
              "target": "angleAxisType"
            },
            {
              "name": "Radius Axis Data Type",
              "description": "Radius axis data type.",
              "type": "choice",
              "choices": ["dynamic", "category"],
              "target": "radiusAxisType"
            },
            {
              "name": "Value Index",
              "description": "The value index.",
              "type": "choice",
              "choices": dex.array.combine(["none"], chart.config.csv.header),
              "target": "valueIndex"
            },
            {
              "name": "Radius Index",
              "description": "The radius index.",
              "type": "choice",
              "choices": dex.array.combine(["none"], chart.config.csv.header),
              "target": "radiusIndex"
            },
            {
              "name": "Angle Index",
              "description": "The angle index.",
              "type": "choice",
              "choices": dex.array.combine(["none"], chart.config.csv.header),
              "target": "angleIndex"
            },
            {
              "name": "Series Index",
              "description": "The series index.",
              "type": "choice",
              "choices": dex.array.combine(["none"], chart.config.csv.header),
              "target": "seriesIndex"
            }
          ]
        }
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = polarplot;
},{}],50:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Steam Graph.
 *
 * @name dex/charts/echarts/RadarChart
 *
 * @param userConfig
 * @returns RadarChart
 */
var radarchart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#ECharts_RadarChart',
    'id': 'ECharts_RadarChart',
    'class': 'ECharts_RadarChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'palette': 'ECharts',
    'seriesIndex': 0,
    'angleIndex': 1,
    'radiusIndex': 2,
    'type': 'radar',
    'series.itemStyle': {
      normal: {
        lineStyle: {
          width: 1,
          opacity: .8
        }
      },
      emphasis: {
        lineStyle: { width: 5, opacity: 1 },
        areaStyle: "solid"
      }
    },
    "options": {
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Radar Chart Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist:true}),
              "initialValue": "category10"
            },
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            }
          ]
        },
        dex.config.gui.echartsLabel({name: "Normal Label"}, "series.label.normal"),
        dex.config.gui.echartsLabel({name: "Emphasis Label"}, "series.label.emphasis")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = radarchart;
},{}],51:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Single Axis ScatterPlot.
 *
 * @name dex/charts/echarts/SingleAxisScatterPlot
 *
 * @param userConfig
 * @returns SingleAxisScatterPlot
 */
var singleaxisscatterplot = function (userConfig) {
  var chart;
  var sizeScale = undefined;

  var defaults = {
    'parent': '#ECharts_SingleAxisScatterPlot',
    'id': 'ECharts_LineChart',
    'class': 'ECharts_LineChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'single-axis',
    'radius': {'min': 1, 'max': 50},
    'sizeMethod': 'linear',
    'sizeScale': function (value) {
      if (typeof sizeScale == "undefined") {
        dex.console.log("EXTENT", dex.csv.extent(chart.config.csv, [2]));
        sizeScale = dex.csv.getScalingMethod(
          chart.config.csv, chart.config.sizeMethod,
          dex.csv.extent(chart.config.csv, [2]),
          [chart.config.radius.min, chart.config.radius.max]);
      }
      return sizeScale(value);
    },
    'palette': 'category10',
    'series.coordinateSystem': 'singleAxis',
    'series.symbol': 'circle',
    'series.type': 'scatter',
    'series.itemStyle': {
      normal: {
        shadowBlur: 10,
        shadowColor: 'rgba(150, 36, 50, 0.5)',
        shadowOffsetY: 5,
        color: function (item) {
          return new echarts.graphic.RadialGradient(0.7, 0.5, 1, [{
            offset: .3,
            color: dex.color.palette[chart.config.palette][
            item.seriesIndex % dex.color.palette[
              chart.config.palette].length],
          }, {
            offset: 1,
            color: 'black'
          }])
        }
      }
    },
    "options": {
      dataZoom: [
        {
          handleSize: '100%',
          filterMode: 'empty',
          singleAxisIndex: dex.range(0, dex.csv.uniqueArray(csv, 0).length)
        }
      ],
      tooltip: {
        formatter: function(d) {
          return "<table><tr><td><b>" + csv.header[1] + ":</b></td><td>" +
              d.data[0] + "</td></tr><tr><td><b>" + csv.header[2] +
              ":</b></td><td>" + d.data[1] + "</td></tr></table>";
        }
      }
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Single Axis ScatterPlot Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            },
            {
              "name": "Symbol Shape",
              "description": "The shape of the symbol.",
              "type": "choice",
              "choices": ["circle", "rect", "roundRect", "triangle", "diamond", "pin", "arrow"],
              "target": "series.symbol"
            },
            {
              "name": "Minimum Symbol Size",
              "description": "The minimum size of the symbols",
              "type": "int",
              "target": "radius.min",
              "minValue": 0,
              "maxValue": 100,
              "initialValue": 5
            },
            {
              "name": "Maximum Symbol Size",
              "description": "The maximum size of the symbols",
              "type": "int",
              "target": "radius.max",
              "minValue": 0,
              "maxValue": 100,
              "initialValue": 50
            },
            {
              "name": "Size Scaling Method",
              "description": "The type of scaling method",
              "type": "choice",
              "target": "sizeMethod",
              "choices" : [ "linear", "pow", "log", "sqrt", "time" ],
              "initialValue": "linear"
            },
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist:true}),
              "initialValue": "category10"
            },
            {
              "name": "Series Type",
              "description": "The series type",
              "type": "choice",
              "target": "series.type",
              "choices": [ "scatter", "effectScatter" ]
            }
          ]
        },
        dex.config.gui.echartsItemStyle({name: "Item Style"}, "series.itemStyle.normal"),
        dex.config.gui.echartsItemStyle({name: "Item Style (Emphasis)"}, "series.itemStyle.emphasis"),
        dex.config.gui.echartsLabel({name: "Label"}, "series.label.normal"),
        dex.config.gui.echartsLabel({name: "Label (Emphasis)"}, "series.label.emphasis")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = singleaxisscatterplot;
},{}],52:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Steam Graph.
 *
 * @name dex/charts/echarts/SteamGraph
 *
 * @param userConfig
 * @returns SteamGraph
 */
var steamgraph = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#ECharts_SteamGraph',
    'id': 'ECharts_SteamGraph',
    'class': 'ECharts_SteamGraph',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'xIndex': 1,
    'yIndex': 2,
    'seriesIndex': 0,
    'type': 'steam',
    "options": {
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Steam Graph Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist:true}),
              "initialValue": "category10"
            },
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            },
          ]
        },
        dex.config.gui.echartsLabel({name: "Normal Label"}, "series.label.normal"),
        dex.config.gui.echartsLabel({name: "Emphasis Label"}, "series.label.emphasis")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = steamgraph;
},{}],53:[function(require,module,exports){
/**
 *
 * This module provides a ECharts Timeline.
 *
 * @name dex/charts/echarts/Timeline
 *
 * @param userConfig
 * @returns Timeline
 */
var timeline = function (userConfig) {
  var chart;
  var sizeScale = d3.scale.linear();

  var defaults = {
    'parent': '#ECharts_Timeline',
    'id': 'ECharts_Timeline',
    'class': 'ECharts_Timeline',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'timeline',
    'palette': 'ECharts',
    'radius' : { min: 5, max: 50 },
    categories: function (row) {
      return row[3];
    },
    sequences: function (row) {
      return +row[4];
    },
    sizes: function (row) {
      //dex.console.log("SIZING ROW: ", row);
      return chart.config.sizeScale(+row[2]);
    },
    'series.type': 'timeline',
    "options": {
    }
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.echarts.EChart(combinedConfig);

  var sizeExtents = dex.csv.extent(chart.config.csv, [2]);

  sizeScale.domain(sizeExtents)
    .range([+chart.config.radius.min, +chart.config.radius.max]);

  chart.config.sizeScale = sizeScale;

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "EChart Timeline Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Color Scheme",
              "description": "The color scheme.",
              "target": "palette",
              "type": "choice",
              "choices": dex.color.colormaps({shortlist:true}),
              "initialValue": "category10"
            },
            {
              "name": "Background Color",
              "description": "The color of the background.",
              "target": "options.backgroundColor",
              "type": "color",
              "initialValue": "#ffffff"
            },
            {
              "name": "Symbol Shape",
              "description": "The shape of the symbol.",
              "type": "choice",
              "choices": ["emptyCircle", "circle", "rect", "roundRect", "triangle", "diamond", "pin", "arrow"],
              "target": "series.symbol",
              "initialValue": "emptyCircle"
            },
            {
              "name": "Symbol Size",
              "description": "The size of the symbols",
              "type": "int",
              "target": "series.symbolSize",
              "minValue": 0,
              "maxValue": 50,
              "initialValue": 5
            }
          ]
        },
        dex.config.gui.echartsLabel({name: "Normal Label"}, "series.label.normal"),
        dex.config.gui.echartsLabel({name: "Emphasis Label"}, "series.label.emphasis")
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  return chart;
};
module.exports = timeline;
},{}],54:[function(require,module,exports){
/**
 *
 * This module provides ECharts 3.0 based visualization components.
 *
 * @module dex/charts/echarts
 *
 */
var echarts = {};

echarts.EChart = require("./EChart");
echarts.LineChart = require("./LineChart");
echarts.PolarPlot = require("./PolarPlot");
echarts.Timeline = require("./Timeline");
echarts.Network = require("./Network");
echarts.SingleAxisScatterPlot = require("./SingleAxisScatterPlot");
echarts.PieChart = require("./PieChart");
echarts.SteamGraph = require("./SteamGraph");
echarts.RadarChart = require("./RadarChart");

module.exports = echarts;
},{"./EChart":45,"./LineChart":46,"./Network":47,"./PieChart":48,"./PolarPlot":49,"./RadarChart":50,"./SingleAxisScatterPlot":51,"./SteamGraph":52,"./Timeline":53}],55:[function(require,module,exports){
var scatterplot = function (userConfig) {
  d3 = dex.charts.d3.d3v3;
  var chart;

  var defaults = {
    'parent': '#Elegans_ScatterPlotParent',
    'id': 'Elegans_ScatterPlotId',
    'class': 'Elegans_ScatterPlotParentClass',
    'resizable': true,
    'csv': {
      'header': [],
      'data': []
    },
    'series': [
      {
        'name': 'series-1',
        'coordinates': {'x': 0, 'y': 1, 'z': 2},
        'group': undefined,
        'shape': 'circle',
        'size': 1,
      }
    ],
    'stage': {
      width: 700,
      height: 530,
      world_width: 500,
      world_height: 500,
      axis_labels: {x: "X", y: "Y", z: "Z"},
      bg_color: 0xffffff,
      player: false,
      space_mode: 'wireframe',
      range: {x: [0, 0], y: [0, 0], z: [0, 0]},
      autorange: true,
      grid: true,
      perspective: true,
      orbit: false,
      save_image: false
    },
    //'shapes': ["circle", "cross", "rect", "diamond", "circle", "circle"],
    'color': d3.scale.category10(),
    'width': "100%",
    'height': "100%",
  };

  chart = new dex.component(userConfig, defaults);
  var internalChart;

  chart.render = function render() {
    d3 = dex.charts.d3.d3v3;
    var config = chart.config;
    var csv = config.csv;

    var tcsv = dex.csv.transpose(csv);

    d3.select(config.parent).selectAll("*").remove();

    chart.resize();

    internalChart = new Elegans.Stage(d3.select(config.parent)[0][0], config.stage);
    config.series.forEach(function (series) {

      //dex.console.log("SERIES", series);
      var groups;
      if (series.group) {
        //dex.console.log("GROUPING BY: " + series.group + " = " +
        //  dex.csv.getColumnNumber(series.group));
        groups = dex.csv.group(csv, [dex.csv.getColumnNumber(csv, series.group)]);
        //dex.console.log("GROUP", group);
        groups.forEach(function (group) {
          group.name = group.key;
        })
      }
      else {
        groups = [series];
        groups[0].csv = csv;
      }

      //dex.console.log("GROUPS", csv, groups);

      groups.forEach(function (group) {
        //dex.console.log("GROUP", group);
        data = {
          'x': dex.csv.getColumnData(group.csv, series.coordinates.x),
          'y': dex.csv.getColumnData(group.csv, series.coordinates.y),
          'z': dex.csv.getColumnData(group.csv, series.coordinates.z)
        };

        //dex.console.log("GROUP", group);

        internalChart.add(new Elegans.Scatter(data, {
          fill_color: config.color(group.name),
          shape: series.shape,
          name: group.name,
          size: series.size
        }));
      });
    });

    internalChart.render();

    return chart;
  };

  chart.update = function () {
    //d3 = dex.charts.d3.d3v3;
    //internalChart.resize();
  };

    chart.clone = function clone(override) {
        return scatterplot(dex.config.expandAndOverlay(override, userConfig));
    };

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = scatterplot;
},{}],56:[function(require,module,exports){
/**
 * @module dex/charts/c3
 */
var elegans = {};

elegans.ScatterPlot = require("./ScatterPlot");

module.exports = elegans;
},{"./ScatterPlot":55}],57:[function(require,module,exports){
var gridstermultiples = function (userConfig) {
  var chart;
  var gridster;
  var cells = [];

  var defaults = {
    'parent': '#GridsterMultiplesParent',
    'id': 'GridsterMultiplesId',
    'class': 'GridsterMultiplesClass',
    'resizable': true,
    'frames': {},
    'width': "100%",
    'height': "100%",
    'cell': {
      'width': 6,
      'height': 6
    },
    'baseChart': dex.charts.d3.Dendrogram(),
    'gridsterConfig': {
      widget_base_dimensions: [50, 50],
      widget_margins: [1, 1],
      //helper: 'clone',
      animate: false,
      draggable: {
        enabled: true,
        start: function (e, ui) {
          dex.console.log("DRAG-START", e, ui);
        },
        handle: '.drag-handle'
      },
      resize: {
        enabled: true,
        min_size: [1, 1],
        stop: function (event, ui, $widget) {
          dex.console.log("Event", event, ui, $widget);
          cells.forEach(function (cell, i) {
            cell.render();
          })
        }
      }
    }
  };

  chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Multiples Configuration",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Cell Width",
              "description": "Cell Width",
              "type": "int",
              "minValue": 1,
              "maxValue": 20,
              "initialValue": 6,
              "target": "cell.width"
            },
            {
              "name": "Cell Height",
              "description": "Cell Height",
              "type": "int",
              "minValue": 1,
              "maxValue": 20,
              "initialValue": 6,
              "target": "cell.height"
            }
          ]
        }
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.render = function render() {
    var config = chart.config;
    var frames = config.frames;

    if (config.charts) {
      // Unregisters any window resize handlers.
      config.charts.forEach(function(oldChart) { oldChart.deleteChart(); })
    }
    d3.selectAll(config.parent).selectAll("*").remove();

    //dex.console.log("FRAMES", frames);

    var numFrames = frames.frames.length;

    var gridsterContainer = d3.select(config.parent)
      .append("div")
      .attr("id", config["id"])
      .attr("class", "gridster")
      .attr("width", config.width)
      .attr("height", config.height)
      .append("ul");

    //dex.console.log("Invoking gridster constructor");

    gridster = $(".gridster ul")
      .gridster(config.gridsterConfig)
      .data('gridster');

    cells = [];
    frames.frames.forEach(function (frame, i) {
      var widget = "<li><table id='widget-table' style='word-break:break-all;'>" +
        "<tr id='widget-header-row'><td id='widget-header' class='drag-handle'>" +
        frames.frameIndices[i] +
        "</td></tr>" +
        "<tr><td id='widget-content' colspan='2'><div id='" + (config.id + i) +
        "' height='100%' width='100%'></div></td></tr></table></li>"

      gridster.add_widget(widget, config.cell.width, config.cell.height);

      //         var cellChart = config.baseChart
      //           .clone()
      //         .attr("parent", "#" + config.id + i)
      //       .attr("csv", frame);
      var cellChart = config.baseChart.clone({
        "parent": "#" + config.id + i,
        "csv": frame
      });
      cellChart.render();
      cells.push(cellChart);
    });

    chart.config.charts = cells;
    return chart;
  };

  chart.update = function () {
    cells.forEach(function (cell) {
      cell.update();
    })
  };

  $(document).ready(function () {
    var config = chart.config;
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = gridstermultiples;
},{}],58:[function(require,module,exports){
/**
 * @module dex/charts/gridster
 */
var multiples = {};

multiples.GridsterMultiples = require("./GridsterMultiples");

module.exports = multiples;
},{"./GridsterMultiples":57}],59:[function(require,module,exports){
var bubblechart = function (userConfig) {
    d3 = dex.charts.d3.d3v3;
    var chart;

    var defaults = {
        'parent': '#Nvd3_BubbleChartParent',
        'id': 'Nvd3_BubbleChartId',
        'class': 'Nvd3_BubbleChartClass',
        'resizable': true,
        'csv': {
            'header': [],
            'data': []
        },
        'width': "100%",
        'height': "100%",
        'legend': 'right'
    };

    var chart = new dex.component(userConfig, defaults);
    var internalChart;

    chart.render = function render() {
        d3 = dex.charts.d3.d3v3;
        var config = chart.config;
        var csv = config.csv;

        var types = dex.csv.guessTypes(csv);
        dex.console.log("TYPES", types);;

        var xlabels = [];

        d3.select(config.parent).selectAll("*").remove();
        var groups = dex.csv.group(csv, [0]);
        var nvd3Data = groups.map(function (group) {
            //dex.console.log("KEY", group.key, group);
            return {
                'key': group.key,
                'values': group.csv.data.map(function (row, i) {
                    //dex.console.log("ROW", row);
                    var values = {};
                    if (types[1] == "string") {
                        values.x = i;
                        values.xlabel = row[1];
                    }
                    else if (types[1] == "date") {
                        values.x = new Date(row[1]);
                    }
                    else {
                        values.x = +row[1];
                    }

                    if (types[2] == "string") {
                        values.y = i;
                        values.ylabel = row[2];
                    }
                    else if (types[2] == "date") {
                        values.y = new Date(row[2]);
                    }
                    else {
                        values.y = +row[2];
                    }

                    if (types[3] == "string") {
                        values.size = 1;
                    }
                    else if (types[2] == "date") {
                        values.size = 1;
                    }
                    else {
                        values.size = +row[3];
                    }

                    return values;
                })
            }
        });

        var nvd3Chart = nv.models.scatterChart()
            .showDistX(true)
            .showDistY(true)
            .useVoronoi(true)
            .color(d3.scale.category10().range())
            .duration(300);

        //nvd3Chart.xAxis.tickFormat(d3.format('.02f'));
        nvd3Chart.yAxis.tickFormat(d3.format('.1f'));
        nvd3Chart.xAxis
            .showMaxMin(false)
            .tickFormat(function (d) {
                if (types[1] == "date") {
                    return d3.time.format('%x')(new Date(d))
                }
                else if (types[1] == "string") {
                    return nvd3Data[0].values[d].xlabel;
                }
                else {
                    return d3.format(".1f")(d);
                }
            });

        nvd3Chart.yAxis
            .showMaxMin(false)
            .tickFormat(function (d) {
                if (types[2] == "date") {
                    //return d3.format(".1f")(d);
                    return d3.time.format('%x')(new Date(d))
                }
                else if (types[2] == "string") {
                    return nvd3Data[0].values[d].ylabel;
                }
                else {
                    return d3.format(".1f")(d);
                }
            });

        var svg = d3.select(config.parent)
            .append("svg")
            .attr("id", config["id"])
            .attr("class", config["class"])
            .attr('width', config.width)
            .attr('height', config.height)
            .datum(nvd3Data)
            .transition()
            .duration(500)
            .call(nvd3Chart);

        nv.utils.windowResize(nvd3Chart.update);

        internalChart = nv.addGraph(function () {
            return nvd3Chart;
        }, function () {
            d3.selectAll(".nv-legend-symbol").on('click',
                function () {
                    dex.console.log("Clicked Legend Of", nvd3Chart.datum());
                });
        });

        return chart
    };

    chart.update = function () {
        d3 = dex.charts.d3.d3v3;
        //internalChart.load({'columns': chart.config.csv.data});
    };

    chart.clone = function clone(override) {
        return bubblechart(dex.config.expandAndOverlay(override, userConfig));
    };

    $(document).ready(function () {
        // Make the entire chart draggable.
        //$(chart.config.parent).draggable();
    });

    return chart;
};

module.exports = bubblechart;
},{}],60:[function(require,module,exports){
var stackedareachart = function (userConfig) {
    d3 = dex.charts.d3.d3v3;
    var chart;

    var defaults = {
        'parent': '#Nvd3_StackedAreaChart',
        'id': 'Nvd3_StackedAreaChartId',
        'class': 'Nvd3_StackedAreaChartClass',
        'resizable': true,
        'csv': {
            'header': [],
            'data': []
        },
        'width': "100%",
        'height': "100%",
        'legend': 'right'
    };

    var chart = new dex.component(userConfig, defaults);
    var internalChart;

    chart.render = function render() {
        d3 = dex.charts.d3.d3v3;
        var config = chart.config;
        var csv = config.csv;

        var types = dex.csv.guessTypes(csv);
        //dex.console.log("TYPES", types);

        d3.select(config.parent).selectAll("*").remove();

        //dex.console.log("CSV", csv, dex.csv.group(csv, [0]));
        var groups = dex.csv.group(csv, [0]);


        var nvd3Data = groups.map(function (group) {
            //dex.console.log("KEY", group.key, group);
            return {
                'key': group.key,
                'values': group.csv.data.map(function (row, i) {
                    //dex.console.log("ROW", row);
                    var values = {};
                    if (types[1] == "string") {
                        values.x = i;
                        values.xlabel = row[1];
                    }
                    else if (types[1] == "date") {
                        values.x = new Date(row[1]);
                    }
                    else {
                        values.x = +row[1];
                    }

                    if (types[2] == "string") {
                        values.y = i;
                        values.ylabel = row[2];
                    }
                    else if (types[2] == "date") {
                        values.y = new Date(row[2]);
                    }
                    else {
                        values.y = +row[2];
                    }
                    return values;
                })
            }
        });

        var nvd3Chart = nv.models.stackedAreaChart()
            .clipEdge(true)
            .useInteractiveGuideline(true);

        nvd3Chart.xAxis
            .showMaxMin(false)
            .tickFormat(function (d, i) {
                if (types[1] == "date") {
                    return d3.time.format('%x')(new Date(d))
                }
                else if (types[1] == "number") {
                    return d3.format(".1f")(d)
                }
                else {
                    dex.console.log("D", d, nvd3Data);
                    return nvd3Data[0].values[d].xlabel;
                }
            });

        nvd3Chart.yAxis
            .tickFormat(function (d) {
                if (types[2] == "date") {
                    return d3.time.format('%x')(new Date(d))
                }
                else if (types[2] == "number") {
                    return d3.format(".1f")(d)
                }
                else {
                    return d;
                }
            });

        var svg = d3.select(config.parent)
            .append("svg")
            .attr("id", config["id"])
            .attr("class", config["class"])
            .attr('width', config.width)
            .attr('height', config.height)
            .datum(nvd3Data)
            .transition()
            .duration(500)
            .call(nvd3Chart);

        nv.utils.windowResize(nvd3Chart.update);

        internalChart = nv.addGraph(function () {
            return nvd3Chart;
        }, function () {
            d3.selectAll(".nv-legend-symbol").on('click',
                function () {
                    dex.console.log("Clicked Legend Of", nvd3Chart);
                });
        });

        return chart;
    };

    chart.update = function () {
        d3 = dex.charts.d3.d3v3;
        //internalChart.load({'columns': chart.config.csv.data});
    };

    chart.clone = function clone(override) {
        return stackedareachart(dex.config.expandAndOverlay(override, userConfig));
    };

    $(document).ready(function () {
        // Make the entire chart draggable.
        if (chart.config.draggable) {
            $(chart.config.parent).draggable();
        }
    });

    return chart;
};

module.exports = stackedareachart;
},{}],61:[function(require,module,exports){
/**
 *
 * This module provides NVD3 based visualization components.
 *
 * @module dex/charts/nvd3
 *
 */
var nvd3 = {};

nvd3.StackedAreaChart = require("./StackedAreaChart");
nvd3.BubbleChart = require("./BubbleChart");

module.exports = nvd3;
},{"./BubbleChart":59,"./StackedAreaChart":60}],62:[function(require,module,exports){
/**
 *
 * This module provides a TauCharts AreaChart.
 *
 * @name dex/charts/taucharts/AreaChart
 *
 * @param userConfig
 * @returns AreaChart
 */
var areachart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#TauCharts_AreaChart',
    'id': 'TauCharts_AreaChart',
    'class': 'TauCharts_AreaChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'area'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.taucharts.TauChart(combinedConfig);

  return chart;
};
module.exports = areachart;
},{}],63:[function(require,module,exports){
/**
 *
 * This module provides a TauCharts BarChart.
 *
 * @name dex/charts/taucharts/BarChart
 *
 * @param userConfig
 * @returns BarChart
 */
var barchart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#TauCharts_BarChart',
    'id': 'TauCharts_BarChart',
    'class': 'TauCharts_BarChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'bar'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.taucharts.TauChart(combinedConfig);

  return chart;
};
module.exports = barchart;
},{}],64:[function(require,module,exports){
/**
 *
 * This module provides a TauCharts HorizontalBarChart.
 *
 * @name dex/charts/taucharts/HorizontalBarChart
 *
 * @param userConfig
 * @returns HorizontalBarChart
 */
var horizontalbarchart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#TauCharts_HorizontalBarChart',
    'id': 'TauCharts_HorizontalBarChart',
    'class': 'TauCharts_HorizontalBarChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'horizontal-bar'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.taucharts.TauChart(combinedConfig);

  return chart;
};
module.exports = horizontalbarchart;
},{}],65:[function(require,module,exports){
/**
 *
 * This module provides a TauCharts HorizontalStackedBarChart.
 *
 * @name dex/charts/taucharts/HorizontalStackedBarChart
 *
 * @param userConfig
 * @returns HorizontalStackedBarChart
 */
var horizontalstackedbarchart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#TauCharts_HorizontalStackedBarChart',
    'id': 'TauCharts_HorizontalStackedBarChart',
    'class': 'TauCharts_HorizontalStackedBarChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'horizontal-stacked-bar'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.taucharts.TauChart(combinedConfig);

  return chart;
};
module.exports = horizontalstackedbarchart;
},{}],66:[function(require,module,exports){
/**
 *
 * This module provides a TauCharts Line Chart.
 *
 * @name dex/charts/taucharts/LineChart
 *
 * @param userConfig
 * @returns LineChart
 */
var linechart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#TauCharts_LineChart',
    'id': 'TauCharts_LineChart',
    'class': 'TauCharts_LineChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'line'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.taucharts.TauChart(combinedConfig);

  return chart;
};
module.exports = linechart;
},{}],67:[function(require,module,exports){
/**
 *
 * This module provides a TauCharts Scatterplot.
 *
 * @name dex/charts/taucharts/ScatterPlot
 *
 * @param userConfig
 * @returns ScatterPlot
 */
var scatterplot = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#TauCharts_ScatterPlot',
    'id': 'TauCharts_ScatterPlot',
    'class': 'TauCharts_ScatterPlot',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'scatterplot'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.taucharts.TauChart(combinedConfig);

  return chart;
};
module.exports = scatterplot;
},{}],68:[function(require,module,exports){
/**
 *
 * This module provides a TauCharts StackedBarChart.
 *
 * @name dex/charts/taucharts/StackedBarChart
 *
 * @param userConfig
 * @returns StackedBarChart
 */
var stackedbarchart = function (userConfig) {
  var chart;
  var defaults = {
    'parent': '#TauCharts_StackedBarChart',
    'id': 'TauCharts_StackedBarChart',
    'class': 'TauCharts_StackedBarChart',
    'resizable': true,
    'width': "100%",
    'height': "100%",
    'type': 'stacked-bar'
  };

  var combinedConfig = dex.config.expandAndOverlay(userConfig, defaults);
  chart = dex.charts.taucharts.TauChart(combinedConfig);

  return chart;
};
module.exports = stackedbarchart;
},{}],69:[function(require,module,exports){
var tauchart = function (userConfig) {
  var chart;
  var internalChart = undefined;
  var effectiveOptions;

  var TitlePlugin = function (title) {
    return {

      // Initialize plugin
      init: function (chart) {
        // Create plugin content
        this._node = document.createElement('h1');
        this._node.textContent = title;
        this._node.setAttribute('align', 'center');
        // Insert plugin content to chart panel
        chart.insertToHeader(this._node);
      },

      // Cleanup plugin resources
      destroy: function () {
        if (this._node.parentElement) {
          this._node.parentElement.removeChild(this._node);
        }
      }
    };
  };

  var defaults = {
    'parent': '#TauChartParent',
    'id': 'TauChartId',
    'class': 'TauChartClass',
    'resizable': true,
    'type': "scatterplot",
    'csv': {
      'header': [],
      'data': []
    },
    'plugins': {
      'title': true,
      'trendline': false,
      'legend': true,
      'quickfilter': true,
      'tooltip': true
    },
    'color': 0,
    'reverseColormap': false,
    'colormap': 'category10',
    'x': 1,
    'y': 2,
    'size': undefined,
    'split': undefined,
    'width': "100%",
    'height': "100%",
    'fitXAxis': false,
    'fitYAxis': false,
    'title': "Title",
    options: {
      guide: {
        size: {minSize: 10, maxSize: 10}
      }
    }
  };

  chart = new dex.component(userConfig, defaults);

  chart.render = function render() {
    var config = chart.config;
    var csv = config.csv;

    if (internalChart !== undefined) {
      internalChart.destroy();
    }
    d3.select(config.parent).selectAll("*").remove();

    var options = getOptions(config);

    internalChart = new tauCharts.Chart(options).renderTo(config.parent);

    return chart;
  };

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "TauChart Settings",
      "contents": [
        {
          "name": "Chart Type",
          "description": "The type of chart.",
          "type": "choice",
          "choices": ["scatterplot", "line", "area", "bar", "horizontal-bar",
            "stacked-bar", "horizontal-stacked-bar"],
          "target": "options.type",
          "initialValue": "scatterplot"
        },
        {
          "name": "Colormap",
          "description": "Colormap.",
          "type": "choice",
          "choices": dex.color.colormaps({shortlist: true}),
          "target": "colormap",
          "initialValue": "category10"
        },
        {
          "name": "Reverse Colormap",
          "description": "Reverse the colormap?",
          "type": "boolean",
          "target": "reverseColormap",
          "initialValue": true
        },
        {
          "name": "Fit Model Settings",
          "description": "Fit settings.",
          "type": "choice",
          "choices": ["normal", "minimal", "entire-view", "fit-width",
            "fit-height"],
          "target": "options.settings.fitModel",
          "initialValue": "normal"
        },
        {
          "name": "Fit X-Axis to Data",
          "description": "Fit X-Axis to Data.",
          "type": "boolean",
          "target": "fitXAxis",
          "initialValue": false
        },
        {
          "name": "Fit Y-Axis to Data",
          "description": "Fit Y-Axis to Data.",
          "type": "boolean",
          "target": "fitYAxis",
          "initialValue": false
        },
        {
          "name": "X Density Padding",
          "description": "X Density Padding.",
          "type": "float",
          "minValue": 1,
          "maxValue": 50,
          "target": "options.settings.xDensityPadding",
          "initialValue": "0.25"
        },
        {
          "name": "Y Density Padding",
          "description": "Y Density Padding.",
          "type": "float",
          "minValue": 1,
          "maxValue": 50,
          "target": "options.settings.yDensityPadding",
          "initialValue": "0.25"
        },
        {
          "name": "Min Size",
          "description": "Minimum Size",
          "type": "int",
          "minValue": 0,
          "maxValue": 200,
          "target": "options.guide.size.minSize",
          "initialValue": "1"
        },
        {
          "name": "Max Size",
          "description": "Maximum Size",
          "type": "int",
          "minValue": 0,
          "maxValue": 200,
          "target": "options.guide.size.maxSize",
          "initialValue": "25"
        },
        {
          "name": "Animation Speed",
          "description": "Animation speed.",
          "type": "int",
          "minValue": 0,
          "maxValue": 2000,
          "target": "options.settings.animationSpeed",
          "initialValue": "750"
        },
        {
          "name": "ASynchronous Rendering",
          "description": "Enable asyncrhonous rendering.",
          "type": "boolean",
          "target": "options.settings.asyncRendering",
          "initialValue": true
        },
        {
          "name": "Fit Model Settings",
          "description": "Fit settings.",
          "type": "choice",
          "choices": ["normal", "minimal", "entire-view", "fit-width",
            "fit-height"],
          "target": "options.settings.fitModel",
          "initialValue": "normal"
        },
        {
          "name": "X-Axis",
          "description": "The X Axis",
          "type": "choice",
          "choices": chart.config.csv.header,
          "target": "options.x"
        },
        {
          "name": "Y-Axis",
          "description": "The Y Axis",
          "type": "choice",
          "choices": chart.config.csv.header,
          "target": "options.y"
        },
        {
          "name": "Color",
          "description": "The color",
          "type": "choice",
          "choices": dex.array.combine(["none"], chart.config.csv.header),
          "target": "options.color"
        },
        {
          "name": "Size",
          "description": "Size by.",
          "type": "choice",
          "choices": dex.array.combine(["none"], chart.config.csv.header),
          "target": "options.size"
        },
        {
          "name": "Split",
          "description": "Split colors/series on.",
          "type": "choice",
          "choices": dex.array.combine(["none"], chart.config.csv.header),
          "target": "options.split"
        },
        {
          "name": "Enable Legend",
          "description": "Enable the legend.",
          "type": "boolean",
          "target": "plugins.legend",
          "initialValue": true
        },
        {
          "name": "Enable Tooltips",
          "description": "Enable tooltips.",
          "type": "boolean",
          "target": "plugins.tooltips",
          "initialValue": true
        },
        {
          "name": "Enable Quick Filters",
          "description": "Enable the quick filters.",
          "type": "boolean",
          "target": "plugins.quickfilters",
          "initialValue": true
        },
        {
          "name": "Enable Trend Lines",
          "description": "Enable the trendlines plugin.",
          "type": "boolean",
          "target": "plugins.trendline",
          "initialValue": false
        }
      ]
    };

    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.update = function () {
    var config = chart.config;
    var csv = config.csv;

    chart.render();
  };

  chart.subscribe(chart, "attr", function (event) {
    if (event.attr == "color") {
      switch (event.value) {
        case "none":
          config.color = undefined;
      }
    }

    if (event.attr == "size") {
      switch (event.value) {
        case "none":
          config.size = undefined;
      }
    }

    if (event.attr == "valueIndex" && event.value == "none") {
      sizeScale = undefined;
    }
  });

  function getOptions(config) {
    var options = {
      data: {},
      type: config.type,
      x: ((config.x !== undefined) ?
        dex.csv.getColumnName(config.csv, config.x) :
        undefined),
      y: ((config.y !== undefined) ?
        dex.csv.getColumnName(config.csv, config.y) :
        undefined),
      color: ((config.color !== undefined) ?
        dex.csv.getColumnName(config.csv, config.color) :
        undefined),
      size: ((config.size !== undefined) ?
        dex.csv.getColumnName(config.csv, config.size) :
        undefined),
      split: ((config.split !== undefined) ?
        dex.csv.getColumnName(config.csv, config.split) :
        undefined),
      plugins: [],
      guide: {
        color: {
          brewer: ((config.reverseColormap === true) ?
            dex.array.copy(dex.color.palette[config.colormap]).reverse() :
            dex.color.palette[config.colormap])
        }
      }
    };

    if (config.fitXAxis) {
      var xextents = dex.matrix.extent(config.csv.data,
        [dex.csv.getColumnNumber(config.csv, config.x)]);
      options.guide.x = {min: xextents[0], max: xextents[1]};
      options.guide.x.nice = false;
    }

    if (config.fitYAxis) {
      var yextents = dex.matrix.extent(config.csv.data,
        [dex.csv.getColumnNumber(config.csv, config.y)]);
      options.guide.y = {min: yextents[0], max: yextents[1]};
      options.guide.y.nice = false;
    }

    dex.console.log("TITLE", config.plugins);
    if (config.plugins.title) {
      options.plugins.push(TitlePlugin(config.title));
    }

    if (config.plugins.tooltip) {
      options.plugins.push(tauCharts.api.plugins.get('tooltip')());
    }
    if (config.plugins.legend) {
      options.plugins.push(tauCharts.api.plugins.get('legend')());
    }
    if (config.plugins.quickfilter) {
      options.plugins.push(tauCharts.api.plugins.get('quick-filter')());
    }
    if (config.plugins.trendline) {
      options.plugins.push(tauCharts.api.plugins.get('trendline')());
    }

    options.data = dex.csv.toStrictJson(config.csv);

    dex.console.log("OPTIONS", options);
    return dex.config.expandAndOverlay(config.options, options);
  }

  $(document).ready(function () {
    // Make the entire chart draggable.
    if (chart.config.draggable) {
      $(chart.config.parent).draggable();
    }
  });

  return chart;
};

module.exports = tauchart;
},{}],70:[function(require,module,exports){
/**
 *
 * This module provides TauChart based visualization components.
 *
 * @module dex/charts/taucharts
 *
 */
var taucharts = {};

taucharts.TauChart = require("./TauChart");
taucharts.AreaChart = require("./AreaChart");
taucharts.LineChart = require("./LineChart");
taucharts.ScatterPlot = require("./ScatterPlot");
taucharts.BarChart = require("./BarChart");
taucharts.StackedBarChart = require("./StackedBarChart");
taucharts.HorizontalBarChart = require("./HorizontalBarChart");
taucharts.HorizontalStackedBarChart = require("./HorizontalStackedBarChart");
module.exports = taucharts;
},{"./AreaChart":62,"./BarChart":63,"./HorizontalBarChart":64,"./HorizontalStackedBarChart":65,"./LineChart":66,"./ScatterPlot":67,"./StackedBarChart":68,"./TauChart":69}],71:[function(require,module,exports){
var scatterplot = function (userConfig) {
  var defaults = {
    // The parent container of this chart.
    'parent'  : null,
    // Set these when you need to CSS style components independently.
    'id'      : 'ScatterPlot3D',
    'class'   : 'ScatterPlot3D',
    // Our data...
    'csv'     : {
      // Give folks without data something to look at anyhow.
      'header' : ["X", "Y", "Z"],
      'data'   : [[0, 0, 0], [1, 1, 1], [2, 4, 8], [3, 9, 27]]
    },
    'width'   : 400,
    'height'  : 400,
    'xoffset' : 20,
    'yoffset' : 0
  };

  var chart = new dex.component(userConfig, defaults);

  chart.render = function () {
    this.update();
  };

  chart.update = function () {
    var chart = this;
    var config = chart.config;
    var csv = config.csv;

    var bounds =
    {
      'maxx' : dex.matrix.max(csv.data, 0),
      'minx' : dex.matrix.min(csv.data, 0),
      'maxy' : dex.matrix.max(csv.data, 1),
      'miny' : dex.matrix.min(csv.data, 1),
      'maxz' : dex.matrix.max(csv.data, 2),
      'minz' : dex.matrix.min(csv.data, 2)
    };

    var i, j;

// <!--
    function mousewheel(event) {
      var fovMAX = 160;
      var fovMIN = 1;

      camera.fov -= event.wheelDeltaY * 0.05;
      camera.fov = Math.max(Math.min(camera.fov, fovMAX), fovMIN);
      camera.projectionMatrix = new THREE.Matrix4().makePerspective(camera.fov, config.width / config.height, camera.near, camera.far);
    }

    function generateTexture() {
      // draw a circle in the center of the canvas
      var size = 128;

      // create canvas
      var canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;

      // get context
      var context = canvas.getContext('2d');

      // draw circle
      var centerX = size / 2;
      var centerY = size / 2;
      var radius = size / 2;

//var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
//        gradient.addColorStop( 0, 'rgba(255,255,255,1)' );
//        gradient.addColorStop( 0.2, 'rgba(0,255,255,1)' );
//        gradient.addColorStop( 0.4, 'rgba(0,0,64,1)' );
//        gradient.addColorStop( 1, 'rgba(0,0,0,1)' );

      context.beginPath();
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      //context.fillStyle = gradient;
      //context.fillRect( 0, 0, canvas.width, canvas.height );
      context.fillStyle = "#FFFFFF";
      context.fill();

      return canvas;
    }

    function createTextCanvas(text, color, font, size) {
      size = size || 24;
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      var fontStr = (size + 'px ') + (font || 'Arial');
      ctx.font = fontStr;
      var w = ctx.measureText(text).width;
      var h = Math.ceil(size);
      canvas.width = w;
      canvas.height = h;
      ctx.font = fontStr;
      ctx.fillStyle = color || 'black';
      ctx.fillText(text, 0, Math.ceil(size * 0.8));
      return canvas;
    }

    function createText2D(text, color, font, size, segW, segH) {
      var canvas = createTextCanvas(text, color, font, size);
      var plane = new THREE.PlaneGeometry(canvas.width, canvas.height, segW, segH);
      var tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      var planeMat = new THREE.MeshBasicMaterial({
        map : tex, color : 0xffffff, transparent : true
      });
      var mesh = new THREE.Mesh(plane, planeMat);
      mesh.scale.set(0.25, 0.25, 0.25);
      mesh.doubleSided = true;
      return mesh;
    }

    var maxRange = Math.max(Math.max(bounds.maxx - bounds.minx, bounds.maxy - bounds.miny),
      bounds.maxz - bounds.minz);
    var renderer = new THREE.WebGLRenderer({antialias : true});
    var w = config.width;
    var h = config.height;
    renderer.setSize(w, h);

//document.body.appendChild(renderer.domElement);
    config.parent.appendChild(renderer.domElement);

    renderer.setClearColorHex(0xEEEEEE, 1.0);

//var camera = new THREE.PerspectiveCamera(45, w/h, 1, 1000 );
    var camera = new THREE.PerspectiveCamera(45, w / h, 1, 100000);
//var camera = new THREE.OrthographicCamera( w / - 2, w / 2, h / 2, h / - 2, 1, h );
    camera.position.z = bounds.maxz * 4;
    camera.position.x = 0;
    camera.position.y = bounds.maxy * 1.25;

    var scene = new THREE.Scene();
//scene.fog = new THREE.FogExp2( 0xFFFFFF, 0.000005 );

    var scatterPlot = new THREE.Object3D();
    scene.add(scatterPlot);

    scatterPlot.rotation.y = 0.5;
    function v(x, y, z) {
      return new THREE.Vertex(new THREE.Vector3(x, y, z));
    }

//var lineGeo = new THREE.CubeGeometry(bounds.maxx - bounds.maxx, bounds.maxy - bounds.miny,
//  bounds.maxz - bounds.minz);

    var xAxisGeo = new THREE.Geometry();
    var yAxisGeo = new THREE.Geometry();
    var zAxisGeo = new THREE.Geometry();
    var boundaryGeo = new THREE.Geometry();

    xAxisGeo.vertices.push(v(bounds.minx, 0, 0), v(bounds.maxx, 0, 0));
    yAxisGeo.vertices.push(v(0, bounds.miny, 0), v(0, bounds.maxy, 0));
    zAxisGeo.vertices.push(v(0, 0, bounds.minz), v(0, 0, bounds.maxz));
    boundaryGeo.vertices.push(
      v(bounds.minx, bounds.maxy, bounds.minz), v(bounds.maxx, bounds.maxy, bounds.minz),
      v(bounds.minx, bounds.miny, bounds.minz), v(bounds.maxx, bounds.miny, bounds.minz),
      v(bounds.minx, bounds.maxy, bounds.maxz), v(bounds.maxx, bounds.maxy, bounds.maxz),
      v(bounds.minx, bounds.miny, bounds.maxz), v(bounds.maxx, bounds.miny, bounds.maxz),

      v(bounds.minx, 0, bounds.maxz), v(bounds.maxx, 0, bounds.maxz),
      v(bounds.minx, 0, bounds.minz), v(bounds.maxx, 0, bounds.minz),
      v(bounds.minx, bounds.maxy, 0), v(bounds.maxx, bounds.maxy, 0),
      v(bounds.minx, bounds.miny, 0), v(bounds.maxx, bounds.miny, 0),

      v(bounds.maxx, bounds.miny, bounds.minz), v(bounds.maxx, bounds.maxy, bounds.minz),
      v(bounds.minx, bounds.miny, bounds.minz), v(bounds.minx, bounds.maxy, bounds.minz),
      v(bounds.maxx, bounds.miny, bounds.maxz), v(bounds.maxx, bounds.maxy, bounds.maxz),
      v(bounds.minx, bounds.miny, bounds.maxz), v(bounds.minx, bounds.maxy, bounds.maxz),

      v(0, bounds.miny, bounds.maxz), v(0, bounds.maxy, bounds.maxz),
      v(0, bounds.miny, bounds.minz), v(0, bounds.maxy, bounds.minz),
      v(bounds.maxx, bounds.miny, 0), v(bounds.maxx, bounds.maxy, 0),
      v(bounds.minx, bounds.miny, 0), v(bounds.minx, bounds.maxy, 0),

      v(bounds.maxx, bounds.maxy, bounds.minz), v(bounds.maxx, bounds.maxy, bounds.maxz),
      v(bounds.maxx, bounds.miny, bounds.minz), v(bounds.maxx, bounds.miny, bounds.maxz),
      v(bounds.minx, bounds.maxy, bounds.minz), v(bounds.minx, bounds.maxy, bounds.maxz),
      v(bounds.minx, bounds.miny, bounds.minz), v(bounds.minx, bounds.miny, bounds.maxz),

      v(bounds.minx, 0, bounds.minz), v(bounds.minx, 0, bounds.maxz),
      v(bounds.maxx, 0, bounds.minz), v(bounds.maxx, 0, bounds.maxz),
      v(0, bounds.maxy, bounds.minz), v(0, bounds.maxy, bounds.maxz),
      v(0, bounds.miny, bounds.minz), v(0, bounds.miny, bounds.maxz)
    );

    var xAxisMat = new THREE.LineBasicMaterial({color : 0xff0000, lineWidth : 1});
    var xAxis = new THREE.Line(xAxisGeo, xAxisMat);
    xAxis.type = THREE.Lines;
    scatterPlot.add(xAxis);

    var yAxisMat = new THREE.LineBasicMaterial({color : 0x0000ff, lineWidth : 1});
    var yAxis = new THREE.Line(yAxisGeo, yAxisMat);
    yAxis.type = THREE.Lines;
    scatterPlot.add(yAxis);

    var zAxisMat = new THREE.LineBasicMaterial({color : 0x00ff00, lineWidth : 1});
    var zAxis = new THREE.Line(zAxisGeo, zAxisMat);
    zAxis.type = THREE.Lines;
    scatterPlot.add(zAxis);

    var boundaryMat = new THREE.LineBasicMaterial({color : 0x090909, lineWidth : 1, transparent : true});
    var boundary = new THREE.Line(boundaryGeo, boundaryMat);
    boundary.type = THREE.Lines;
    scatterPlot.add(boundary);

    var fontSize = Math.max(Math.round(maxRange / 4), 8);
    var fontOffset = Math.min(Math.round(fontSize / 4), 8);
    console.log("OFFSET: " + fontOffset);
    console.log("  FONT: " + fontSize);

    var titleX = createText2D("-" + csv.header[0], new THREE.Color().setRGB(1, 0, 0), "", fontSize);
    titleX.position.x = bounds.minx - fontOffset;
    scatterPlot.add(titleX);

    var titleX = createText2D(csv.header[0], new THREE.Color().setRGB(1, 0, 0), "", fontSize);
    titleX.position.x = bounds.maxx + fontOffset;
    scatterPlot.add(titleX);

    var titleY = createText2D('-' + csv.header[1], new THREE.Color().setRGB(1, 0, 0), "", fontSize);
    titleY.position.y = bounds.miny - fontOffset;
    scatterPlot.add(titleY);

// (text, color, font, size, segW, segH)
    var titleY = createText2D(csv.header[1], new THREE.Color().setRGB(1, 0, 0), "", fontSize);
    titleY.position.y = bounds.maxy + fontOffset;
    scatterPlot.add(titleY);

    var titleZ = createText2D('-' + csv.header[2], new THREE.Color().setRGB(1, 0, 0), "", fontSize);
    titleZ.position.z = bounds.minz - fontOffset;
    scatterPlot.add(titleZ);

    var titleZ = createText2D(csv.header[2], new THREE.Color().setRGB(1, 0, 0), "", fontSize);
    titleZ.position.z = bounds.maxz + fontOffset;
    scatterPlot.add(titleZ);

    attributes = {

      size        : {type : 'f', value : []},
      customColor : {type : 'c', value : []}

    };

    uniforms =
    {
      amplitude : {type : "f", value : 1.0},
      color     : {type : "c", value : new THREE.Color(0xff0000)}
      //texture: { type: "t", value: THREE.ImageUtils.loadTexture( "textures/ball.png" ) },
    };

    var texture = new THREE.Texture(generateTexture());
    texture.needsUpdate = true; // important

//var mat = new THREE.ParticleBasicMaterial({vertexColors:true, size: 1});
//var mat = new THREE.ParticleBasicMaterial( { blending: THREE.AdditiveBlending, vertexColors: true, size: 1, map: THREE.ImageUtils.loadTexture( 'textures/ball.png' ) } );
//var mat = new THREE.ParticleBasicMaterial({vertexColors:true, size: 1});
//var mat = new THREE.ParticleCanvasMaterial( { size: 50, map: new THREE.Texture( generateSprite() ), blending: THREE.AdditiveBlending } );
    var mat = new THREE.ParticleBasicMaterial(
      {
        size         : Math.max(maxRange / 25, 1),
        map          : texture,
        blending     : THREE.AdditiveBlending, // required
        depthTest    : false, // required
        transparent  : false,
        opacity      : 0.7,
        vertexColors : true // optional
      });

    var pointGeo = new THREE.Geometry();

//var pointCount = 1000;

    var colors =
      [
        new THREE.Color().setRGB(1, 0, 0),
        new THREE.Color().setRGB(0, 0, 1),
        new THREE.Color().setRGB(0, 1, 0),
        new THREE.Color().setRGB(1, 0, 1),
        new THREE.Color().setRGB(1, 1, 0),
        new THREE.Color().setRGB(0, 1, 1),
        new THREE.Color().setRGB(.5, .5, .5)
      ];

    for (i = 0; i < csv.data.length; i++) {
      //var x = Math.random() * 100 - 50;
      //var y = x*0.8+Math.random() * 20 - 10;
      //var z = x*0.7+Math.random() * 30 - 15;

      for (j = 2; j < csv.header.length; j++) {
        pointGeo.vertices.push(new THREE.Vertex(new THREE.Vector3(csv.data[i][0], csv.data[i][1], csv.data[i][j])));
        pointGeo.colors.push(colors[(j - 2) % colors.length]);
      }
    }

    var points = new THREE.ParticleSystem(pointGeo, mat);
    scatterPlot.add(points);

//camera.lookAt( scatterPlot );
//camera.target.position.copy( scatterPlot );

    renderer.render(scene, camera);
    var paused = false;
    var last = new Date().getTime();
    var down = false;
    var sx = 0, sy = 0;
    window.onmousedown = function (ev) {
      down = true;
      sx = ev.clientX;
      sy = ev.clientY;
    };

    window.addEventListener('DOMMouseScroll', mousewheel, false);
    window.addEventListener('mousewheel', mousewheel, false);

    window.onmouseup = function () {
      down = false;
    };
    window.onmousemove = function (ev) {
      if (down) {
        var dx = ev.clientX - sx;
        var dy = ev.clientY - sy;
        scatterPlot.rotation.y += dx * 0.01;
        camera.position.y += dy;
        sx += dx;
        sy += dy;
      }
    };

    var animating = false;
    window.ondblclick = function () {
      animating = !animating;
    };
    function animate(t) {
      if (!paused) {
        last = t;
        if (animating) {
          var v = pointGeo.vertices;
          for (i = 0; i < v.length; i++) {
            var u = v[i];
            u.angle += u.speed * 0.01;
            u.position.x = Math.cos(u.angle) * u.radius;
            u.position.z = Math.sin(u.angle) * u.radius;
          }
          pointGeo.__dirtyVertices = true;
        }
        renderer.clear();
        camera.lookAt(scene.position);
        renderer.render(scene, camera);
      }
      window.requestAnimationFrame(animate, renderer.domElement);
    };
    animate(new Date().getTime());
    onmessage = function (ev) {
      paused = (ev.data == 'pause');
    };
//-->

  };

    chart.clone = function clone(override) {
        return scatterplot(dex.config.expandAndOverlay(override, userConfig));
    };

  return chart;
};

module.exports = scatterplot;
},{}],72:[function(require,module,exports){
/**
 *
 * This module provides ThreeJS/WebGL based visualization components.
 *
 * @module dex/charts/threejs
 *
 */
var threejs = {};

threejs.ScatterPlot = require("./ScatterPlot");

module.exports = threejs;
},{"./ScatterPlot":71}],73:[function(require,module,exports){
var network = function (userConfig) {
  var chart;

  var defaults =
    {
      // The parent container of this chart.
      'parent': '#Network',
      // Set these when you need to CSS style components independently.
      'id': 'Network',
      'class': 'Network',
      'resizable': true,
      'csv': {
        'header': [],
        'data': []
      },
      'dataModel': 'default',
      'width': "100%",
      'height': "100%",
      'options': {
        nodes: {
          shape: 'dot',
          scaling: {
            label: {
              min: 8,
              max: 64
            }
          },
          'font': {
            'color': '#C04D3B'
          }
        },
        'edges': {
          //'arrows' : 'from',
          'shadow': true
        },
        'physics': {
          'solver': 'forceAtlas2Based',
          //'solver' : 'hierarchicalRepulsion',
          //'solver' : 'repulsion',
          //'solver' : 'barnesHut',
          'forceAtlas2Based': {
            'gravitationalConstant': -50,
            'springConstant': .08,
            'centralGravity': .02,
            'damping': .1,
            'avoidOverlap': .0,
            'springLength': 100
          },
          maxVelocity: 50,
          minVelocity: 0.2,
          stabilization: {
            enabled: true,
            iterations: 200,
            updateInterval: 100,
            onlyDynamicEdges: false,
            fit: true
          },
        },
      }
    };

  var chart = new dex.component(userConfig, defaults);

  chart.getGuiDefinition = function getGuiDefinition(config) {
    var defaults = {
      "type": "group",
      "name": "Network Settings",
      "contents": [
        dex.config.gui.dimensions(),
        dex.config.gui.general(),
        {
          "type": "group",
          "name": "Miscellaneous",
          "contents": [
            {
              "name": "Auto Resize",
              "type": "boolean",
              "description": "Auto resize",
              "initialValue": true,
              "target": "options.autoResize"
            },
            {
              "name": "Click To Use",
              "type": "boolean",
              "description": "Click to use",
              "initialValue": false,
              "target": "options.clickToUse"
            }
          ]
        },
        {
          "type": "group",
          "name": "Edges",
          "contents": [
            {
              "name": "Dashes",
              "type": "boolean",
              "description": "Dashes",
              "initialValue": false,
              "target": "options.edges.dashes"
            },
            {
              "name": "Arrow Strike Through",
              "type": "boolean",
              "description": "Arrow strike through",
              "initialValue": true,
              "target": "options.edges.arrowStrikeThrough"
            },
            {
              "name": "Physics",
              "type": "boolean",
              "description": "Physics",
              "initialValue": true,
              "target": "options.edges.physics"
            }
          ]
        },
        {
          "type": "group",
          "name": "Layout",
          "contents": [
            {
              "name": "Hierarchical",
              "type": "boolean",
              "description": "Hierarchical",
              "initialValue": false,
              "target": "options.layout.hierarchical"
            },
            {
              "name": "Improved Layout",
              "type": "boolean",
              "description": "Improved layout",
              "initialValue": true,
              "target": "options.layout.improvedLayout"
            }
          ]
        },
        {
          "type": "group",
          "name": "Nodes",
          "contents": [
            {
              "name": "Border Width",
              "type": "int",
              "description": "Border width",
              "minValue": 0,
              "maxValue": 10,
              "initialValue": 1,
              "target": "options.nodes.borderWidth"
            },
            {
              "name": "Border Width (Selected)",
              "type": "int",
              "description": "Border width",
              "minValue": 0,
              "maxValue": 10,
              "initialValue": 2,
              "target": "options.nodes.borderWidthSelected"
            },
            {
              "name": "Chosen",
              "type": "boolean",
              "description": "Chosen",
              "initialValue": true,
              "target": "options.nodes.chosen"
            },
            {
              "name": "Label Highlight Bold",
              "type": "boolean",
              "description": "Label highlight bold",
              "initialValue": true,
              "target": "options.nodes.labelHighlightBold"
            },
            {
              "name": "Physics",
              "type": "boolean",
              "description": "Physics",
              "initialValue": true,
              "target": "options.nodes.physics"
            },
            {
              "name": "Shape",
              "type": "choice",
              "description": "Shape of node",
              "choices": ["ellipse", "circle", "database",
                "box", "text", "diamond", "dot", "star", "triangle",
                "triangleDown", "square"],
              "initialValue": "ellipse",
              "target": "options.nodes.shape"
            },
            {
              "name": "Mass",
              "type": "int",
              "description": "Border width",
              "minValue": 1,
              "maxValue": 10,
              "initialValue": 1,
              "target": "options.nodes.mass"
            }
          ]
        },
        {
          "type": "group",
          "name": "Physics",
          "contents": [
            {
              "name": "Physics Enabled",
              "type": "boolean",
              "description": "Physics",
              "initialValue": true,
              "target": "options.physics.enabled"
            },
            {
              "name": "Solver",
              "type": "choice",
              "description": "Solver",
              "choices": ["barnesHut", "repulsion",
                "hierarchicalRepulsion", "forceAtlas2Based"],
              "initialValue": "barnesHut",
              "target": "options.nodes.solver"
            }
          ]
        }
      ]
    };
    var guiDef = dex.config.expandAndOverlay(config, defaults);
    dex.config.gui.sync(chart, guiDef);
    return guiDef;
  };

  chart.resize = function resize() {
    //dex.console.log("PARENT: '" + chart.config.parent + "'");
    if (chart.config.resizable) {
      var width = $("" + chart.config.parent).width();
      var height = $("" + chart.config.parent).height();
      dex.console.log("RESIZE: " + width + "x" + height);
      chart.attr("width", width)
        .attr("height", height)
        .update();
    }
    else {
      chart.update();
    }
  };

  chart.render = function render() {

    //var chart = this;
    var config = chart.config;
    var csv = config.csv;
    window.onresize = this.resize;

    d3.select(config.parent).selectAll("*").remove();
    var target = (config.parent && config.parent[0] == '#') ?
      config.parent.substring(1) : config.parent;
    var container = document.getElementById(target);

    var options = {};
    var network = new vis.Network(container, chart.createData(), config.options);
  };

  chart.update = function () {
    var chart = this;
    var config = chart.config;
    var csv = config.csv;
    chart.render();
  };

  chart.clone = function clone(override) {
    return network(dex.config.expandAndOverlay(override, userConfig));
  };

  chart.createData = function () {

    var nodes = null;
    var edges = null;
    var network = null;
    var linkWeight = 0;
    var csv = chart.config.csv;

    var nodeMap = {};
    var linkMap = {};

    var colors = ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00'];

    var id = 1;

    var weightIndex = csv.header.indexOf("WEIGHT");

    // Create node map.
    csv.header.map(function (h, ci) {
      if (!h.startsWith("WEIGHT")) {
        csv.data.map(function (row) {
          if (!nodeMap[h + ":" + row[ci]]) {
            nodeMap[h + ":" + row[ci]] = {
              'id': id,
              'label': row[ci],
              'linksIn': 0,
              'linksOut': 0,
              'weight': (weightIndex >= 0) ? row[weightIndex] : 1,
              'color': colors[ci % colors.length],
              'group': ci
            };
            id++;
          }
          else {
            nodeMap[h + ":" + row[ci]]['weight'] +=
              (weightIndex >= 0) ? row[weightIndex] : 1;
          }
        });
      }
    });

    // Count links from C1 -> C2 -> ... -> Cx
    for (var ci = 1; ci < csv.header.length; ci++) {
      if (!csv.header[ci].startsWith("WEIGHT")) {
        for (var ri = 0; ri < csv.data.length; ri++) {
          var src = csv.header[ci - 1] + ":" + csv.data[ri][ci - 1];
          var dest = csv.header[ci] + ":" + csv.data[ri][ci];
          var linkKey = src + "->" + dest;
          nodeMap[src]['linksOut']++;
          nodeMap[dest]['linksIn']++;

          linkWeight = (weightIndex >= 0) ? csv.data[ri][weightIndex] : 1;

          if (!linkMap[linkKey]) {
            linkMap[linkKey] = {
              'from': nodeMap[src].id,
              'to': nodeMap[dest].id,
              'linkCount': 1,
              'weight': linkWeight,
              'label': nodeMap[src].label + "->" + nodeMap[dest].label +
              ": 1 link, weight = " + linkWeight
            };
          }
          else {
            linkMap[linkKey]['linkCount']++;
            linkMap[linkKey]['linkWeight'] += linkWeight;
            linkMap[linkKey]['label'] =
              nodeMap[src].label + "->" + nodeMap[dest].label +
              ": " + linkMap[linkKey]['linkCount'] + " links, weight = " +
              linkMap[linkKey]['weight'];
          }
        }
      }
    }

    nodes = [];
    edges = [];

    // Populate nodes
    for (var key in nodeMap) {
      var node = nodeMap[key];
      nodes.push({
        'id': node.id,
        'value': node.weight,
        'label': node.label,
        'color': node.color,
        'group': node.group
      });
    }

    // Populate edges
    for (var key in linkMap) {
      var edge = linkMap[key];
      edges.push({
        'from': edge.from,
        'to': edge.to,
        'value': edge.weight,
        'title': edge.label,
        'font': {'align': 'middle'}
      });
    }

    //dex.console.log("NODES", nodes, "EDGES", edges);

    return {
      nodes: nodes,
      edges: edges
    };
  };

  return chart;
};

module.exports = network;
},{}],74:[function(require,module,exports){
/**
 *
 * This module provides routines for dealing with arrays.
 *
 * @module dex/charts/vis
 *
 */
var vis = {};

vis.Network = require("./Network");

module.exports = vis;
},{"./Network":73}],75:[function(require,module,exports){
/**
 *
 * This module provides routines for dealing with colors.
 *
 * @module dex/color
 *
 * @property {string[]} palette.c64Dark           - The commodore 64 dark palette.
 * @property {string[]} palette.c64Light          - The commodore 64 light palette.
 * @property {string[]} palette.divergingDark12   - Diverging dark colors.
 * @property {string[]} palette.divergingPastel12 - Diverging pastelles.
 * @property {string[]} palette.hueSoft128        - 128 colors with soft separation.
 * @property {string[]} palette.hueHard128        - 128 colors with hard separation.
 * @property {string[]} palette.crayola8          - The original 8 crayola colors.
 * @property {string[]} palette.crayola120        - 120 crayola colors.
 * @property {string[]} palette.YlGn              - Colorbrewer YlGn palettes 3-9.
 * @property {string[]} palette.YlGnBu            - Colorbrewer YlGnBu palettes 3-9.
 * @property {string[]} palette.GnBu              - Colorbrewer GnBu palettes 3-9.
 * @property {string[]} palette.BuGn              - Colorbrewer BuGn palettes 3-9.
 * @property {string[]} palette.PuBuGn            - Colorbrewer PuBuGn palettes 3-9.
 * @property {string[]} palette.PuBu              - Colorbrewer PuBu palettes 3-9.
 * @property {string[]} palette.BuPu              - Colorbrewer BuPu palettes 3-9.
 * @property {string[]} palette.RdPu              - Colorbrewer RdPu palettes 3-9.
 * @property {string[]} palette.PuRd              - Colorbrewer PuRd palettes 3-9.
 * @property {string[]} palette.OrRd              - Colorbrewer OrRd palettes 3-9.
 * @property {string[]} palette.YlOrRd            - Colorbrewer YlOrRd palettes 3-9.
 * @property {string[]} palette.YlOrBr            - Colorbrewer YlOrBr palettes 3-9.
 * @property {string[]} palette.Purples           - Colorbrewer Purples palettes 3-9.
 * @property {string[]} palette.Blues             - Colorbrewer Blues palettes 3-9.
 * @property {string[]} palette.Greens            - Colorbrewer Greens palettes 3-9.
 * @property {string[]} palette.Oranges           - Colorbrewer Oranges palettes 3-9.
 * @property {string[]} palette.Reds              - Colorbrewer Reds palettes 3-9.
 * @property {string[]} palette.Greys             - Colorbrewer Greys palettes 3-9.
 * @property {string[]} palette.PuOr              - Colorbrewer PuOr palettes 3-11.
 * @property {string[]} palette.BrBG              - Colorbrewer BrBG palettes 3-11.
 * @property {string[]} palette.PRGn              - Colorbrewer PRGn palettes 3-11.
 * @property {string[]} palette.PiYG              - Colorbrewer PiYG palettes 3-11.
 * @property {string[]} palette.RdBu              - Colorbrewer RdBu palettes 3-11.
 * @property {string[]} palette.RdGy              - Colorbrewer RdGy palettes 3-11.
 * @property {string[]} palette.RdYlBu            - Colorbrewer RdYlBu palettes 3-11.
 * @property {string[]} palette.Spectral          - Colorbrewer Spectral palettes 3-11.
 * @property {string[]} palette.RdYlGn            - Colorbrewer RdYlGn palettes 3-11.
 * @property {string[]} palette.Accent            - Colorbrewer Accent palettes 3-8.
 * @property {string[]} palette.Dark2             - Colorbrewer Dark2 palettes 3-8.
 * @property {string[]} palette.Paired            - Colorbrewer Paired palettes 3-12.
 * @property {string[]} palette.Pastel1           - Colorbrewer Pastel1 palettes 3-9.
 * @property {string[]} palette.Pastel2           - Colorbrewer Pastel2 palettes 3-8.
 * @property {string[]} palette.Set1              - Colorbrewer Set1 palettes 3-9.
 * @property {string[]} palette.Set2              - Colorbrewer Set2 palettes 3-8.
 * @property {string[]} palette.Set3              - Colorbrewer Set3 palettes 3-12.
 *
 */

module.exports = function color(dex) {

  return {
    /**
     *
     * Given a color, lighten or darken it by the requested percent.
     *
     * @param {string} color The color to modify.
     * @param {number} percent A floating point number in the range of [-1.0, 1.0].  Negative
     * values will lighten the color, positive values will darken it.
     *
     * @returns {string} The lightened or darkened color in the form of #ffffff.
     *
     */
    'shadeColor': function (color, percent) {
      var f = parseInt(color.slice(1), 16), t = percent < 0 ? 0 : 255,
        p = percent < 0 ? percent * -1 : percent,
        R = f >> 16, G = f >> 8 & 0x00FF, B = f & 0x0000FF;
      return "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) *
        0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
    },

    /**
     *
     * Given two colors, blend them together.
     *
     * @param color1
     * @param color2
     * @param percent
     * @returns {string}
     *
     */
    'blendColors': function (color1, color2, percent) {
      var f = parseInt(color1.slice(1), 16), t = parseInt(color2.slice(1), 16),
        R1 = f >> 16, G1 = f >> 8 & 0x00FF,
        B1 = f & 0x0000FF, R2 = t >> 16,
        G2 = t >> 8 & 0x00FF, B2 = t & 0x0000FF;

      return "#" + (0x1000000 + (Math.round((R2 - R1) * percent) + R1) * 0x10000 +
        (Math.round((G2 - G1) * percent) + G1) * 0x100 +
        (Math.round((B2 - B1) * percent) + B1)).toString(16).slice(1);
    },
    /**
     *
     * Given an palette or array of colors and some optional color
     * assignmeents, create a colormap.
     *
     * @param {string[]} palette An array of colors within this colormap.
     * @param {object} presets An optional mapping of domain values and
     * preset color assignments.
     *
     * @returns {Function} Returns the colormap function.
     *
     * @example
     * // Assigns a colormap of red, white and blue
     * var usColormap = dex.color.colormap(['red', 'white', 'blue']);
     * @example
     * // Assigns a colormap of grey, brown and yellow and reserves red for
     * // Republicans and blue for Democrats.
     * var usPartyColors = dex.color.colormap(['grey', 'brown', 'yellow'],
     *   { 'Republican' : 'red', 'Democrat' : 'blue' });
     *
     */
    'colormap': function (palette, presets) {
      var numColors = palette.length;
      var data2Color = presets || {};
      var currentColor = 0;

      return function (d) {
        if (data2Color[d]) {
          //dex.console.log("Existing Color: " + d + " = " + data2Color[d]);
          return data2Color[d];
        }
        else {
          data2Color[d] = palette[currentColor % numColors];
          //dex.console.log("New Color[" + currentColor + "]: " + d + " = " + data2Color[d]);
          currentColor++;
          return data2Color[d];
        }
      };
    },
    /**
     *
     * Return the list of available named colormaps.
     *
     * @return {string[]} The list of available colormaps.
     *
     */
    'colormaps': function (options) {
      var opts = options || {};
      if (opts.shortlist) {
        return [
          "Stop Light", "White to Red", "White to Blue",
          "Red White and Blue", "ECharts",
          "category10", "category20b", "category20c", "category20", "c64Dark",
          "c64Light", "divergingDark12", "divergingPastel12", "hueSoft128",
          "hueHard128", "crayola8", "crayola120", "YlGn_9",
          "YlGnBu_9", "GnBu_9", "BuGn_9", "PuBuGn_9", "PuBu_9",
          "BuPu_9", "RdPu_9", "PuRd_9", "OrRd_9", "YlOrRd_9", "YlOrBr_9",
          "Purples_9", "Blues_9", "Greens_9", "Oranges_9", "Reds_9",
          "Greys_9", "PuOr_11", "BrBG_11", "PRGn_11", "PiYG_11",
          "RdBu_11", "RdGy_11", "RdYlBu_11",
          "Spectral_4", "Spectral_8", "Spectral_11",
          "RdYlGn_11", "Accent_8", "Dark2_8", "Paired_12",
          "Pastel1_9", "Pastel2_8", "Set1_9", "Set2_8", "Set3_12"
        ];
      }
      return Object.keys(dex.color.palette);
    },

    /**
     *
     * Given a domain of 2 or more items and a range of 2 colors,
     * return a categorical interpolation across the two colors
     * based upon the supplied range.
     *
     * @param {string[]} domain 2 or more items in a categorical domain.
     * @param {string[]} range An array of 2 colors.
     * @returns {Function} A colormap function.
     *
     */
    'interpolateCategorical': function (domain, range) {
      var color = d3.scale.ordinal()
        .domain(domain)
        .range(d3.range(domain.length).map(d3.scale.linear()
          .domain([0, domain.length - 1])
          .range(range)
          .interpolate(d3.interpolateLab)));

      return function (d) {
        return color(d);
      };
    },
    /**
     *
     * Get the named colormap with the assigned presets.
     *
     * @param paletteName The name of the color palette to be used.
     * @param presets Optional user defined color presets which are
     * assigned via categorial domain.
     *
     * @returns {Function} The colormap function.
     *
     */
    'getColormap': function (paletteName, presets) {
      var colormap = dex.color.colormap(dex.color.palette[paletteName], presets);
      return function (d) {
        return colormap(d);
      };
    },
    'palette': {
      'Stop Light': [ '#ff0000', '#ffff00', '#00ff00' ],
      'White to Red': [ '#ffffff', '#ff0000' ],
      'White to Blue': [ '#ffffff', '#0000ff' ],
      'Red White and Blue': [ '#ff0000', '#ffffff', '#0000ff' ],
      'ECharts': [
        '#c23531','#2f4554', '#61a0a8', '#d48265',
        '#91c7ae','#749f83',  '#ca8622', '#bda29a',
        '#6e7074', '#546570', '#c4ccd3'
      ],
      'category10': [
        '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
        '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
      ],
      'category20b': [
        '#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939',
        '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39',
        '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b',
        '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'
      ],
      'category20c': [
        '#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d',
        '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476',
        '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc',
        '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'
      ],
      'category20': [
        '#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c',
        '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5',
        '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f',
        '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'
      ],
      'c64Dark': [
        '#000000', '#880000', '#AAFFEE', '#CC44CC', '#00CC55',
        '#0000AA', '#EEEE77', '#DD8855', '#664400', '#FF7777',
        '#333333', '#777777', '#AAFF66', '#0088FF', '#BBBBBB'
      ],
      'c64Light': [
        '#FFFFFF', '#880000', '#AAFFEE', '#CC44CC', '#00CC55',
        '#0000AA', '#EEEE77', '#DD8855', '#664400', '#FF7777',
        '#333333', '#777777', '#AAFF66', '#0088FF', '#BBBBBB'
      ],
      'divergingDark12': [
        '#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99',
        '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a',
        '#ffff99', '#b15928'],
      'divergingPastel12': [
        '#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3',
        '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd',
        '#ccebc5', '#ffed6f'],
      'hueSoft128': [
        "#62a96c", "#9844ed", "#37b335", "#6334ce", "#6cac16",
        "#3c4ce7", "#5e9222", "#6d19b6", "#66b450", "#b229cc",
        "#348f2d", "#de50ee", "#23af6d", "#e72fc2", "#8ea42f",
        "#2d2bb8", "#ae9620", "#7a62f3", "#d5942b", "#3c52d6",
        "#e47b24", "#542da9", "#84a953", "#a35de9", "#768930",
        "#a047c8", "#2d8346", "#f128a4", "#558338", "#d75eda",
        "#355f17", "#9d229f", "#9f8d30", "#534bbf", "#ed5322",
        "#4483f2", "#dc312d", "#5d70e7", "#ad7523", "#a272e8",
        "#6c6e1a", "#68208f", "#ada257", "#26439f", "#ba3a1e",
        "#4397dd", "#e72754", "#48a9a2", "#ed2f74", "#3d8d67",
        "#e75abe", "#305d3b", "#b82891", "#86a46f", "#7c41a4",
        "#d28047", "#5556b3", "#b0531f", "#6a8fe0", "#8d2f0d",
        "#3ba8c4", "#ce3f4c", "#3783a3", "#e97059", "#3e69b6",
        "#a18447", "#ba71d5", "#4d4f22", "#bc4eae", "#6ba385",
        "#df3d80", "#43857c", "#eb57a1", "#1c5b5a", "#be297b",
        "#6d7d4c", "#837edd", "#805f27", "#b38ad8", "#704117",
        "#9f95db", "#94292c", "#70a2c7", "#b52c58", "#48706b",
        "#ee6b99", "#344b46", "#e56177", "#376093", "#c36758",
        "#31477e", "#bb8965", "#554286", "#a19b6f", "#6f1f6a",
        "#7b9587", "#8f3888", "#505a47", "#cd7ec9", "#6e6246",
        "#ab579c", "#55412f", "#dd79b2", "#305061", "#c05081",
        "#7f98a6", "#982256", "#506c7f", "#793626", "#6e82b0",
        "#7f3441", "#7e64a9", "#845941", "#7d2453", "#af9992",
        "#80416f", "#847063", "#a76794", "#434460", "#ce8d8f",
        "#603d63", "#d17b92", "#623e43", "#a58bad", "#a16460",
        "#746687", "#a45269", "#886574"],
      'hueHard128': [
        "#74b6b1", "#5500bb", "#47c323", "#9a2bdf", "#47a100",
        "#1d1ab7", "#00a646", "#d629e2", "#79bc4c", "#d34fff",
        "#8d9c00", "#a253ff", "#5a7c00", "#ff3cde", "#176100",
        "#c100b2", "#007533", "#f400a3", "#54be82", "#5c0392",
        "#e39800", "#005ae1", "#ff8902", "#3685ff", "#fc6900",
        "#00329f", "#cea635", "#986fff", "#a18600", "#c872ff",
        "#777800", "#6d7dff", "#dca036", "#0048a4", "#ed001d",
        "#02b1f9", "#ba0000", "#55aeff", "#d03e00", "#649aff",
        "#ca5a00", "#0061c1", "#f49339", "#472881", "#93b65a",
        "#b5009a", "#017745", "#ff52ca", "#335500", "#fd77f6",
        "#009377", "#d20096", "#00babf", "#dc003d", "#00a9a5",
        "#ff3a5d", "#37b9d7", "#e10058", "#017c7b", "#ff5a4b",
        "#018dd1", "#c36c00", "#9d95ff", "#9e6f00", "#de89fe",
        "#7c5c00", "#73007f", "#bdab5a", "#ff64c6", "#0e4527",
        "#cf0069", "#77b899", "#c50070", "#005c48", "#ff6199",
        "#017690", "#a20016", "#5eb3ec", "#882300", "#016bb8",
        "#ff8557", "#153a73", "#f69158", "#004875", "#ff5f63",
        "#0088b6", "#ff7962", "#016291", "#d5a255", "#6e0e5d",
        "#a2b177", "#91005c", "#b2ac87", "#ac004f", "#005264",
        "#ff5f84", "#353e31", "#de8ee6", "#5a4a00", "#bf9af1",
        "#834700", "#98aada", "#7a0c0b", "#90aec8", "#900036",
        "#abad94", "#433268", "#d4a16d", "#2f3a5d", "#ff6d7b",
        "#433c10", "#e48ed2", "#523609", "#f887b5", "#483a20",
        "#f68aa5", "#44364f", "#e89770", "#5f284c", "#b0aaa6",
        "#6e1f29", "#c1a0c8", "#652a13", "#c7a0b3", "#4d3636",
        "#fa8b8e", "#582f3e", "#df989e"
      ],
      'crayola8': [
        'red', 'yellow', 'blue', 'green',
        'orange', 'brown', 'violet', 'black'],
      'crayola120': [
        '#EFDBC5', '#CD9575', '#FDD9B5', '#78DBE2',
        '#87A96B', '#FFA474', '#FAE7B5', '#9F8170',
        '#FD7C6E', '#232323', '#1F75FE', '#ADADD6',
        '#199EBD', '#7366BD', '#DE5D83', '#CB4154',
        '#B4674D', '#FF7F49', '#EA7E5D', '#B0B7C6',
        '#FFFF99', '#1CD3A2', '#FFAACC', '#DD4492',
        '#1DACD6', '#BC5D58', '#DD9475', '#9ACEEB',
        '#FFBCD9', '#FDDB6D', '#2B6CC4', '#EFCDB8',
        '#6E5160', '#1DF914', '#71BC78', '#6DAE81',
        '#C364C5', '#CC6666', '#E7C697', '#FCD975',
        '#A8E4A0', '#95918C', '#1CAC78', '#F0E891',
        '#FF1DCE', '#B2EC5D', '#5D76CB', '#CA3767',
        '#3BB08F', '#FDFC74', '#FCB4D5', '#FFBD88',
        '#F664AF', '#CD4A4A', '#979AAA', '#FF8243',
        '#C8385A', '#EF98AA', '#FDBCB4', '#1A4876',
        '#30BA8F', '#1974D2', '#FFA343', '#BAB86C',
        '#FF7538', '#E6A8D7', '#414A4C', '#FF6E4A',
        '#1CA9C9', '#FFCFAB', '#C5D0E6', '#FDD7E4',
        '#158078', '#FC74FD', '#F780A1', '#8E4585',
        '#7442C8', '#9D81BA', '#FF1DCE', '#FF496C',
        '#D68A59', '#FF48D0', '#E3256B', '#EE204D',
        '#FF5349', '#C0448F', '#1FCECB', '#7851A9',
        '#FF9BAA', '#FC2847', '#76FF7A', '#9FE2BF',
        '#A5694F', '#8A795D', '#45CEA2', '#FB7EFD',
        '#CDC5C2', '#80DAEB', '#ECEABE', '#FFCF48',
        '#FD5E53', '#FAA76C', '#FC89AC', '#DBD7D2',
        '#17806D', '#DEAA88', '#77DDE7', '#FDFC74',
        '#926EAE', '#F75394', '#FFA089', '#8F509D',
        '#EDEDED', '#A2ADD0', '#FF43A4', '#FC6C85',
        '#CDA4DE', '#FCE883', '#C5E384', '#FFB653'
      ],
      "YlGn_3": ["#f7fcb9", "#addd8e", "#31a354"],
      "YlGn_4": ["#ffffcc", "#c2e699", "#78c679", "#238443"],
      "YlGn_5": ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
      "YlGn_6": ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
      "YlGn_7": ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
      "YlGn_8": ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
      "YlGn_9": ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
      "YlGnBu_3": ["#edf8b1", "#7fcdbb", "#2c7fb8"],
      "YlGnBu_4": ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
      "YlGnBu_5": ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
      "YlGnBu_6": ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
      "YlGnBu_7": ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
      "YlGnBu_8": ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
      "YlGnBu_9": ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
      "GnBu_3": ["#e0f3db", "#a8ddb5", "#43a2ca"],
      "GnBu_4": ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
      "GnBu_5": ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
      "GnBu_6": ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
      "GnBu_7": ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
      "GnBu_8": ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
      "GnBu_9": ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
      "BuGn_3": ["#e5f5f9", "#99d8c9", "#2ca25f"],
      "BuGn_4": ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
      "BuGn_5": ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
      "BuGn_6": ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
      "BuGn_7": ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
      "BuGn_8": ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
      "BuGn_9": ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
      "PuBuGn_3": ["#ece2f0", "#a6bddb", "#1c9099"],
      "PuBuGn_4": ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
      "PuBuGn_5": ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
      "PuBuGn_6": ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
      "PuBuGn_7": ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
      "PuBuGn_8": ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
      "PuBuGn_9": ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
      "PuBu_3": ["#ece7f2", "#a6bddb", "#2b8cbe"],
      "PuBu_4": ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
      "PuBu_5": ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
      "PuBu_6": ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
      "PuBu_7": ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
      "PuBu_8": ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
      "PuBu_9": ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
      "BuPu_3": ["#e0ecf4", "#9ebcda", "#8856a7"],
      "BuPu_4": ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
      "BuPu_5": ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
      "BuPu_6": ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
      "BuPu_7": ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
      "BuPu_8": ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
      "BuPu_9": ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
      "RdPu_3": ["#fde0dd", "#fa9fb5", "#c51b8a"],
      "RdPu_4": ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
      "RdPu_5": ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
      "RdPu_6": ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
      "RdPu_7": ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
      "RdPu_8": ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
      "RdPu_9": ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
      "PuRd_3": ["#e7e1ef", "#c994c7", "#dd1c77"],
      "PuRd_4": ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
      "PuRd_5": ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
      "PuRd_6": ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
      "PuRd_7": ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
      "PuRd_8": ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
      "PuRd_9": ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
      "OrRd_3": ["#fee8c8", "#fdbb84", "#e34a33"],
      "OrRd_4": ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
      "OrRd_5": ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
      "OrRd_6": ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
      "OrRd_7": ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
      "OrRd_8": ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
      "OrRd_9": ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
      "YlOrRd_3": ["#ffeda0", "#feb24c", "#f03b20"],
      "YlOrRd_4": ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
      "YlOrRd_5": ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
      "YlOrRd_6": ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
      "YlOrRd_7": ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
      "YlOrRd_8": ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
      "YlOrRd_9": ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
      "YlOrBr_3": ["#fff7bc", "#fec44f", "#d95f0e"],
      "YlOrBr_4": ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
      "YlOrBr_5": ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
      "YlOrBr_6": ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
      "YlOrBr_7": ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
      "YlOrBr_8": ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
      "YlOrBr_9": ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
      "Purples_3": ["#efedf5", "#bcbddc", "#756bb1"],
      "Purples_4": ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
      "Purples_5": ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
      "Purples_6": ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
      "Purples_7": ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
      "Purples_8": ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
      "Purples_9": ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
      "Blues_3": ["#deebf7", "#9ecae1", "#3182bd"],
      "Blues_4": ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
      "Blues_5": ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
      "Blues_6": ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
      "Blues_7": ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
      "Blues_8": ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
      "Blues_9": ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
      "Greens_3": ["#e5f5e0", "#a1d99b", "#31a354"],
      "Greens_4": ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
      "Greens_5": ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
      "Greens_6": ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
      "Greens_7": ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
      "Greens_8": ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
      "Greens_9": ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
      "Oranges_3": ["#fee6ce", "#fdae6b", "#e6550d"],
      "Oranges_4": ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
      "Oranges_5": ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
      "Oranges_6": ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
      "Oranges_7": ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
      "Oranges_8": ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
      "Oranges_9": ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
      "Reds_3": ["#fee0d2", "#fc9272", "#de2d26"],
      "Reds_4": ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
      "Reds_5": ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
      "Reds_6": ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
      "Reds_7": ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
      "Reds_8": ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
      "Reds_9": ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
      "Greys_3": ["#f0f0f0", "#bdbdbd", "#636363"],
      "Greys_4": ["#f7f7f7", "#cccccc", "#969696", "#525252"],
      "Greys_5": ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
      "Greys_6": ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
      "Greys_7": ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
      "Greys_8": ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
      "Greys_9": ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
      "PuOr_3": ["#f1a340", "#f7f7f7", "#998ec3"],
      "PuOr_4": ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
      "PuOr_5": ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
      "PuOr_6": ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
      "PuOr_7": ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
      "PuOr_8": ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
      "PuOr_9": ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
      "PuOr_10": ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
      "PuOr_11": ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
      "BrBG_3": ["#d8b365", "#f5f5f5", "#5ab4ac"],
      "BrBG_4": ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
      "BrBG_5": ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
      "BrBG_6": ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
      "BrBG_7": ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
      "BrBG_8": ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
      "BrBG_9": ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
      "BrBG_10": ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
      "BrBG_11": ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
      "PRGn_3": ["#af8dc3", "#f7f7f7", "#7fbf7b"],
      "PRGn_4": ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
      "PRGn_5": ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
      "PRGn_6": ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
      "PRGn_7": ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
      "PRGn_8": ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
      "PRGn_9": ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
      "PRGn_10": ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
      "PRGn_11": ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
      "PiYG_3": ["#e9a3c9", "#f7f7f7", "#a1d76a"],
      "PiYG_4": ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
      "PiYG_5": ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
      "PiYG_6": ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
      "PiYG_7": ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
      "PiYG_8": ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
      "PiYG_9": ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
      "PiYG_10": ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
      "PiYG_11": ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
      "RdBu_3": ["#ef8a62", "#f7f7f7", "#67a9cf"],
      "RdBu_4": ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
      "RdBu_5": ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
      "RdBu_6": ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
      "RdBu_7": ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
      "RdBu_8": ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
      "RdBu_9": ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
      "RdBu_10": ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
      "RdBu_11": ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
      "RdGy_3": ["#ef8a62", "#ffffff", "#999999"],
      "RdGy_4": ["#ca0020", "#f4a582", "#bababa", "#404040"],
      "RdGy_5": ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
      "RdGy_6": ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
      "RdGy_7": ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
      "RdGy_8": ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
      "RdGy_9": ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
      "RdGy_10": ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
      "RdGy_11": ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
      "RdYlBu_3": ["#fc8d59", "#ffffbf", "#91bfdb"],
      "RdYlBu_4": ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
      "RdYlBu_5": ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
      "RdYlBu_6": ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
      "RdYlBu_7": ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
      "RdYlBu_8": ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
      "RdYlBu_9": ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
      "RdYlBu_10": ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
      "RdYlBu_11": ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
      "Spectral_3": ["#fc8d59", "#ffffbf", "#99d594"],
      "Spectral_4": ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
      "Spectral_5": ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
      "Spectral_6": ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
      "Spectral_7": ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
      "Spectral_8": ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
      "Spectral_9": ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
      "Spectral_10": ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
      "Spectral_11": ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
      "RdYlGn_3": ["#fc8d59", "#ffffbf", "#91cf60"],
      "RdYlGn_4": ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
      "RdYlGn_5": ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
      "RdYlGn_6": ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
      "RdYlGn_7": ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
      "RdYlGn_8": ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
      "RdYlGn_9": ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
      "RdYlGn_10": ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
      "RdYlGn_11": ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
      "Accent_3": ["#7fc97f", "#beaed4", "#fdc086"],
      "Accent_4": ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
      "Accent_5": ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
      "Accent_6": ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
      "Accent_7": ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
      "Accent_8": ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
      "Dark2_3": ["#1b9e77", "#d95f02", "#7570b3"],
      "Dark2_4": ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
      "Dark2_5": ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
      "Dark2_6": ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
      "Dark2_7": ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
      "Dark2_8": ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
      "Paired_3": ["#a6cee3", "#1f78b4", "#b2df8a"],
      "Paired_4": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
      "Paired_5": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
      "Paired_6": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
      "Paired_7": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
      "Paired_8": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
      "Paired_9": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
      "Paired_10": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
      "Paired_11": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
      "Paired_12": ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
      "Pastel1_3": ["#fbb4ae", "#b3cde3", "#ccebc5"],
      "Pastel1_4": ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
      "Pastel1_5": ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
      "Pastel1_6": ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
      "Pastel1_7": ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
      "Pastel1_8": ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
      "Pastel1_9": ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"],
      "Pastel2_3": ["#b3e2cd", "#fdcdac", "#cbd5e8"],
      "Pastel2_4": ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
      "Pastel2_5": ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
      "Pastel2_6": ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
      "Pastel2_7": ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
      "Pastel2_8": ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
      "Set1_3": ["#e41a1c", "#377eb8", "#4daf4a"],
      "Set1_4": ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
      "Set1_5": ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
      "Set1_6": ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
      "Set1_7": ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
      "Set1_8": ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
      "Set1_9": ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
      "Set2_3": ["#66c2a5", "#fc8d62", "#8da0cb"],
      "Set2_4": ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
      "Set2_5": ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
      "Set2_6": ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
      "Set2_7": ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
      "Set2_8": ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
      "Set3_3": ["#8dd3c7", "#ffffb3", "#bebada"],
      "Set3_4": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
      "Set3_5": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
      "Set3_6": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
      "Set3_7": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
      "Set3_8": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
      "Set3_9": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
      "Set3_10": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
      "Set3_11": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
      "Set3_12": ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072",
        "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
    }
  };
};

},{}],76:[function(require,module,exports){
module.exports = function (dex) {
  return function (userConfig, defaultConfig) {
    var cmp = this;
    cmp.userConfig = userConfig || {};
    cmp.defaultConfig = defaultConfig || {};
    cmp.saved = {};
    cmp.debug = false;

    // Do this to curry the original component reference.
    return createComponent(cmp);

    function createComponent(cmp) {
      // Allows component construction from other components.
      if (userConfig.hasOwnProperty('config')) {
        cmp.config = dex.config.expandAndOverlay(cmp.userConfig, cmp.defaultConfig);
      }
      // Else, we have a configuration.
      else {
        cmp.config = dex.config.expandAndOverlay(cmp.userConfig, cmp.defaultConfig);
      }

      dex.console.debug("dex.component Configuration", cmp.config);

      if (!cmp.config.channel) {
        cmp.config.channel = (cmp.config.parent || "#parent") + "/" +
          (cmp.config.id || "unknown-id");
      }

      cmp.attr = function (name, value) {
        //dex.console.log("SETTING-ATTR: '" + name + "'='" + value + "'", cmp.config);

        if (arguments.length == 0) {
          return cmp.config;
        }
        else if (arguments.length == 1) {
          // REM: Need to getHierarchical
          //dex.console.log("HIERARCHY=" + dex.object.getHierarchical(cmp.config, name));
          return dex.object.getHierarchical(cmp.config, name);
        }
        else if (arguments.length == 2) {
          // This will handle the setting of a single attribute
          dex.object.setHierarchical(cmp.config, name, value, '.');
          cmp.publish({type: "attr", attr: name, value: value});
        }
        //dex.console.log("UPDATED CONFIG", cmp.config);
        return cmp;
      };

      cmp.clone = function (userConfig) {
        dex.console.log("No clone function defined for", cmp);
      };

      cmp.getGuiDefinition = function (userConfig, prefix) {
        return {
          "type": "group",
          "name": cmp.config.id + " Settings",
          "contents": [
            dex.config.gui.dimensions(userConfig, prefix),
            dex.config.gui.general(userConfig, prefix)
          ]
        };
      };

      cmp.subscribe = function (source, eventType, callback) {
        if (arguments.length == 3) {
          var channel = source.config.channel + '/' + eventType;

          dex.console.log("subscribe to " + channel);
          if (arguments.length < 3) {
            dex.console.log("failed");
            return false;
          }
          return dex.bus.subscribe(channel, callback);
        }
        else {
          return false;
        }
      };

      cmp.unsubscribe = function (handle) {
        dex.bus.unsubscribe(handle);
        return cmp;
      },

        /**
         *
         * Publish an event to the component's subscribers.
         *
         * @method dex.component.publish
         *
         * @param event - The event to publish.  An event can be any object, however,
         * it must define a property named "type".
         * @param event.type - The type of the event we are publishing.
         *
         */
        cmp.publish = function (event) {
          var channel;

          if (!event || !event.type) {
            dex.console.warn("publish of event to " + cmp.channel + " failed.");
            dex.bus.publish("error", {
              type: "error",
              "description": "Error publishing event: '" + event + "' to '" + cmp.channel + "'"
            });
          }
          else {
            channel = cmp.config.channel + '/' + event.type;
            dex.console.debug("publish to " + channel);
            dex.bus.publish(channel, event);
          }
          return cmp;
        };

      /**
       *
       * A default no-op implementation of render.  Subclasses should
       * override this method with one which provides an initial rendering
       * of their specific component.  This is a great place to put
       * one-time only initialization logic.
       *
       * @method dex.component.render
       *
       */
      cmp.render = function () {
        console.log("Unimplemented routine: render()");
        return cmp;
      };

      /**
       *
       * A default no-op implementation of update.  This will update the
       * current component relative to any new setting or data changes.
       *
       * @method dex.component.update
       *
       */
      cmp.update = function () {
        console.log("Unimplemented routine: update()");
        return cmp;
      };

      // Generic routine for resizing a cmp instance.
      cmp.resize = function () {
        if (cmp.config && cmp.config.resizable) {
          var width = d3.select(cmp.config.parent).property("clientWidth");
          var height = d3.select(cmp.config.parent).property("clientHeight");

          dex.console.debug("Resizing: " + cmp.config.parent + ">" + cmp.config.id +
            "." + cmp.config.class + " to (" +
            width + "w x " + height + "h)");

          if (!_.isNumber(height)) {
            height = "100%";
          }

          if (!_.isNumber(width)) {
            width = "100%";
          }

          if (width == 0) {
            width = 200;
          }

          if (height == 0) {
            height = 200;
          }

          return cmp.attr("width", width)
            .attr("height", height)
            .update();
        }
        else {
          return cmp.update();
        }
      };

      cmp.deleteChart = function () {
        if (window.attachEvent) {
          window.detachEvent('onresize', cmpresize);
        }
        else if (window.removeEventListener) {
          dex.console.debug("window.removeEventListener");
          window.removeEventListener('resize', cmp.resize, true);
        }
        else {
          dex.console.log("window does not support event binding");
        }
      };

      cmp.attrSave = function (name, value) {
        dex.console.log("attrSave(" + name + "," + value + ")", cmp);
        if (arguments.length == 2) {
          cmp.saved[name] = value;
        }
        cmp.attr(name, value);
        return cmp;
      };

      // Used to load cmp state from the DOM.
      cmp.load = function () {
        dex.console.log("Loading Chart: " + cmp.config.id);
        $("body #dexjs-config div[chart-id=" + cmp.config.id + "]").each(function (i, obj) {
          dex.console.log("  Setting: '" + obj.getAttribute("name") + "'='" +
            obj.getAttribute("value") + "'");
          cmp.attrSave(obj.getAttribute("name"), obj.getAttribute("value"));
        });
        dex.console.log("Loading completed for " + cmp.config.id);
        return cmp;
      };

      // Used to save chart state within the DOM.
      cmp.save = function () {
        // Add dexjs-config if it does not exist.
        if ($("body #dexjs-config").length == 0) {
          $("body").append("<div id='dexjs-config'></div>");
        }

        // Remove old contents.
        $("body #dexjs-config div[chart-id='" + cmp.config.id + "']").remove();

        $config = $("body #dexjs-config");
        dex.console.log("Saving chart to DOM...");
        Object.keys(cmp.saved).forEach(function (savedKey) {
          dex.console.log("Saving: " + savedKey);
          $config.append($("<div></div>")
            .attr("chart-id", cmp.config.id)
            .attr("name", savedKey)
            .attr("value", cmp.saved[savedKey]));
        });
        return cmp;
      };
      if (window.attachEvent) {
        dex.console.debug("window.attachEvent");
        window.attachEvent('onresize', cmp.resize);
      }
      else if (window.addEventListener) {
        dex.console.debug("window.addEventListener");
        window.addEventListener('resize', cmp.resize, true);
      }
      else {
        dex.console.log("window does not support event binding");
      }
      return cmp;
    };
  };
};


},{}],77:[function(require,module,exports){
/**
 *
 * Config module.
 * @module dex/config
 *
 */

module.exports = function config(dex) {

  return {

    /**
     *
     * This routine supports a shorthand notation allowing the
     * user to specify deeply nested configuration options without
     * having to deal with nested json structures.
     *
     * Options like:
     *
     * {
 *   'cell' : {
 *     'rect' : {
 *       'width' : 10,
 *       'height' : 20,
 *       'events' : {
 *         'mouseover' : function(d) { console.log("MouseOver: " + d); }
 *       }
 *     }
 *   }
 * }
     *
     * Can now be described more succinctly and more readably as:
     *
     * {
 *   'cell.rect.width'            : 10,
 *   'cell.rect.height'           : 20,
 *   'cell.rect.events.mouseover' : function(d) { console.log("Mouseover: " + d); }
 * }
     *
     * Or a hybrid strategy can be used:
     *
     * {
 *   'cell.rect' : {
 *     'width' : 10,
 *     'height' : 20,
 *     'events.mouseover' : function(d) { console.log("Mouseover: " + d); }
 *   }
 * }
     *
     * @param {object} config The configuration to expand.
     * @returns {*} The expanded configuration.  The original configuration
     *   is left untouched.
     *
     */
    'expand': function expand(config) {
      var name, ci;
      var expanded = {};

      // We have nothing, return nothing.
      if (!config) {
        return config;
      }

      //dex.console.log("dex.config.expand(config=", config);

      for (var name in config) {
        if (config.hasOwnProperty(name)) {
          // Name contains hierarchy:
          if (name && name.indexOf('.') > -1) {
            expanded[name] = config[name];
            dex.object.setHierarchical(expanded, name,
              dex.object.clone(expanded[name]), '.');
            delete expanded[name];
          }
          // Simple name
          else {
            // If the target is an object with no children, clone it.
            if (dex.object.isEmpty(config[name])) {
              //dex.console.log("SET PRIMITIVE: " + name + "=" + config[name]);
              expanded[name] = dex.object.clone(config[name]);
              //expanded[name] = config[name];
            }
            else {
              //dex.console.log("SET OBJECT: " + name + " to the expansion of", config[name]);
              expanded[name] = dex.config.expand(config[name]);
            }
          }
        }
      }

      //dex.console.log("CONFIG", config, "EXPANDED", expanded);
      return expanded;
    },

    /**
     *
     * This routine will take two hierarchies, top and bottom, and expand dot ('.')
     * delimited names such as: 'foo.bar.biz.baz' into a structure:
     * { 'foo' : { 'bar' : { 'biz' : 'baz' }}}
     * It will then overlay the top hierarchy onto the bottom one.  This is useful
     * for configuring objects based upon a default configuration while allowing
     * the client to conveniently override these defaults as needed.
     *
     * @param {object} top - The top object hierarchy.
     * @param {object} bottom - The bottom, base object hierarchy.
     * @returns {object} - A new object representing the expanded top object
     * hierarchy overlaid on top of the expanded bottom object hierarchy.
     *
     */
    'expandAndOverlay': function expandAndOverlay(top, bottom) {
      //dex.console.log(
      //dex.config.getCallerString(arguments.callee.caller),
      //"TOP", top,
      //"BOTTOM", bottom,
      //"EXPANDED TOP", dex.config.expand(top),
      //"EXPANDED BOTTOM", dex.config.expand(bottom));
      return dex.object.overlay(dex.config.expand(top),
        dex.config.expand(bottom));
    },

    'apply': function apply(chart) {
      var config = chart.config;

      var node = d3.select(config.parent).select("svg");
      //dex.console.log("APPLYING STYLE TO NODE:", node);
      if (node && config && config.apply) {
        config.apply.forEach(function (applyConfig) {
          var affectedNodes = node.selectAll(applyConfig["select"]);

          if (applyConfig && applyConfig.styles) {
            for (styleName in applyConfig.styles) {
              affectedNodes.style(styleName, applyConfig.styles[styleName]);
            }
          }

          if (applyConfig && applyConfig.attributes) {
            for (attributeName in applyConfig.attributes) {
              affectedNodes.attr(attributeName, applyConfig.attributes[attributeName]);
            }
          }
        });
      }
    },

    /**
     *
     * Return the configuration for a font after the user's customizations
     * have been applied.
     *
     * @param {d3font_spec} custom - The user customizations.
     * @returns {d3font_spec} - An object containing the font's specifications
     * after the user's customizations have been applied.
     *
     */
    'font': function font(custom) {
      var defaults = {
        'family': 'sans-serif',
        'size': 14,
        'style': 'normal',
        'weight': 'normal',
        'variant': 'normal'
      };

      var fontSpec = dex.config.expandAndOverlay(custom, defaults);
      return fontSpec;
    },

    /**
     *
     * Configure the given font with the supplied font specification.
     *
     * @param {object} node - The node to be configured.
     * @param {d3font_spec} fontSpec - The font specification to be applied.
     *
     * @returns {*} The node after having the font specification applied.
     *
     */
    'configureFont': function configureFont(node, fontSpec, i) {
      //dex.console.log("CONFIG-FONT: " + i);
      if (fontSpec) {
        dex.config.setAttr(node, 'font-family', fontSpec.family, i);
        dex.config.setStyle(node, 'font-size', fontSpec.size, i);
        dex.config.setAttr(node, 'font-weight', fontSpec.weight, i);
        dex.config.setAttr(node, 'font-style', fontSpec.style, i);
        dex.config.setAttr(node, 'variant', fontSpec.variant, i);
      }
      return node;
    },

    /**
     *
     * Construct a text speficiation.
     *
     * @param {d3text_spec} custom - The user's adjustments to the default text
     * specification.
     *
     * @returns {d3text_spec} A revised text specification after having applied
     * the user's modfiications.
     *
     */
    'text': function text(custom) {
      var defaults =
        {
          'font': dex.config.font(),
          'x': 0,
          'y': 0,
          'textLength': undefined,
          'lengthAdjust': undefined,
          'transform': '',
          'text': undefined,
          "decoration": "none",
          'dx': 0,
          'dy': 0,
          'writingMode': undefined,
          'anchor': 'start',
          'fill': dex.config.fill(),
          'stroke': dex.config.stroke({
            'width' : 0
          }),
          'format': undefined,
          'events': dex.config.events()
        };

      var textSpec = dex.config.expandAndOverlay(custom, defaults);
      return textSpec;
    },

    /**
     *
     * This routine will dynamically configure an SVG text entity based upon the
     * supplied configuration.
     *
     * @param {object} node The SVG text node to be configured.
     * @param {d3text_spec} textSpec The text specification for this node.
     *
     * @returns {*} The node after having applied the text specification.
     *
     */
    'configureText': function configureText(node, textSpec, i) {
      //dex.console.log("CONFIG-TEXT: " + i);
      if (textSpec) {
        dex.config.setAttr(node, "x", textSpec.x, i);
        dex.config.setAttr(node, "y", textSpec.y, i);
        dex.config.setAttr(node, "dx", textSpec.dx, i);
        dex.config.setAttr(node, "dy", textSpec.dy, i);
        dex.config.setStyle(node, "text-anchor", textSpec.anchor, i);
        dex.config.configureFont(node, textSpec.font, i);
        dex.config.configureFill(node, textSpec.fill, i);
        dex.config.configureStroke(node, textSpec.stroke, i);
        dex.config.setAttr(node, 'textLength', textSpec.textLength, i);
        dex.config.setAttr(node, 'lengthAdjust', textSpec.lengthAdjust, i);
        dex.config.setAttr(node, 'transform', textSpec.transform, i);
        dex.config.setStyle(node, "text-decoration", textSpec.decoration, i);
        dex.config.setAttr(node, 'writing-mode', textSpec.writingMode, i);
        dex.config.callIfDefined(node, 'text', textSpec.text, i);
        dex.config.configureEvents(node, textSpec.events, i);
      }
      return node;
    },

    /**
     *
     * Construct a stroke specification.
     *
     * @param {d3text_spec} strokeSpec - The user's customizations to the specification.
     *
     * @returns {d3text_spec} The stroke specification after having applied the user's
     * configuration.
     *
     */
    'stroke': function stroke(strokeSpec) {
      var defaults =
        {
          'width': 1,
          'color': "black",
          'opacity': 1,
          'dasharray': '',
          'transform': '',
          'lineCap': '',
          'lineJoin': '',
          'miterLimit': ''
        };

      var config = dex.config.expandAndOverlay(strokeSpec, defaults);
      return config;
    },

    /**
     *
     * Apply a stroke specification to a node.
     *
     * @param {object} node - The node to be configured.
     * @param {d3stroke_spec} strokeSpec - The stroke specification to be applied.
     * @returns The newly configured node.
     */
    'configureStroke': function configureStroke(node, strokeSpec, i) {
      if (strokeSpec) {
        dex.config.setAttr(node, "stroke", strokeSpec.color, i);
        dex.config.setStyle(node, 'stroke-width', strokeSpec.width, i);
        dex.config.setStyle(node, 'stroke-opacity', strokeSpec.opacity, i);
        dex.config.setStyle(node, 'stroke-dasharray', strokeSpec.dasharray, i);
        dex.config.setStyle(node, 'stroke-linecap', strokeSpec.lineCap, i);
        dex.config.setStyle(node, 'stroke-linejoin', strokeSpec.lineJoin, i);
        dex.config.setStyle(node, 'stroke-miterlimit', strokeSpec.miterLimit, i);
        dex.config.setAttr(node, 'transform', strokeSpec.transform, i);
      }
      return node;
    },
    /**
     *
     * Construct a fill specification which allow the user to override any
     * its settings.
     *
     * @param {d3fill_spec} custom - The user's customizations.
     * @returns {d3fill_spec} A fill specification which has applied the user's
     * customizations.
     *
     */
    'fill': function fill(custom) {
      var defaults =
        {
          'fillColor': "grey",
          'fillOpacity': 1,
          'fillRule' : "nonzero"
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    /**
     *
     * Apply a fill specification to a node.
     *
     * @param {object} node - The node to be configured.
     * @param {d3fill_spec} config - The fill specification.
     *
     * @returns {object} The node after having applied the fill specification.
     *
     */
    'configureFill': function configureFill(node, config, i) {
      if (config) {
        dex.config.setStyle(node, 'fill', config.fillColor, i);
        dex.config.setStyle(node, 'fill-opacity', config.fillOpacity, i);
        dex.config.setStyle(node, 'fill-rule', config.fillRule, i);
      }
      return node;
    },

    /**
     *
     * Construct a link specification which allows the user to override any
     * of the settings.
     *
     * @param {d3link_spec} custom - The users customizations.
     *
     * @returns {d3link_spec} A link specification generated by combining the
     * default with the user's customizations.
     *
     */
    'link': function link(custom) {
      var defaults =
        {
          'fill': dex.config.fill(),
          'stroke': dex.config.stroke(),
          'transform': '',
          'd': undefined,
          'events': dex.config.events()
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    /**
     *
     * Apply a link specification to a node.
     *
     * @param {object} node - The node to apply the specification to.
     * @param {d3link_spec} config - The link specification.
     *
     * @returns {object} The node after having applied the specification.
     *
     */
    'configureLink': function configureLink(node, config, i) {
      if (config) {
        dex.config.configureStroke(node, config.stroke, i);
        dex.config.configureFill(node, config.fill, i);
        dex.config.setAttr(node, 'transform', config.transform, i);
        dex.config.setAttr(node, 'd', config.d, i);
        dex.config.configureEvents(node, config.events, i);
      }
      return node;
    },

    /**
     *
     * Construct a rectangle specification which allows the user to override any
     * of the settings.
     *
     * @param {d3rect_spec} custom - The users customizations.
     *
     * @returns {d3rect_spec} A rectangle specification generated by combining the
     * default with the user's customizations.
     *
     */
    'rectangle': function rectangle(custom) {
      var config =
        {
          'width': 50,
          'height': 50,
          'x': 0,
          'y': 0,
          'rx': 0,
          'ry': 0,
          'stroke': dex.config.stroke(),
          'opacity': 1,
          'color': d3.scale.category20(),
          'transform': undefined,
          'events': dex.config.events()
        };
      if (custom) {
        config = dex.object.overlay(custom, config);
      }
      return config;
    },

    'configureRectangle': function configureRectangle(node, config, i) {
      if (config) {
        dex.config.setAttr(node, 'width', config.width, i);
        dex.config.setAttr(node, 'height', config.height, i);
        dex.config.setAttr(node, 'x', config.x, i);
        dex.config.setAttr(node, 'y', config.y, i);
        dex.config.setAttr(node, 'rx', config.rx, i);
        dex.config.setAttr(node, 'ry', config.ry, i);
        dex.config.setAttr(node, 'opacity', config.opacity, i);
        dex.config.setAttr(node, 'fill', config.color, i);
        dex.config.setAttr(node, 'transform', config.transform, i);
        dex.config.configureStroke(node, config.stroke, i);
        dex.config.configureEvents(node, config.events, i);
      }
      return node;
    },

    /**
     *
     * Construct an events specification which allows the user to override any
     * of the settings.
     *
     * @param {d3events_spec} custom - The users customizations.
     *
     * @returns {d3events_spec} An events specification generated by combining the
     * default with the user's customizations.
     *
     */
    'events': function events(custom) {
      var defaults =
        {
          // REM: Deletes any existing events.
          //'mouseover': function (d) {
          //console.log("Default mouseover");
          //}
        };
      var config = defaults;

      if (custom) {
        config = dex.object.overlay(custom, defaults);
      }
      return config;
    },

    'configureEvents': function configureEvents(node, config, i) {
      //dex.console.log("Configure Events", config, i);
      if (config) {
        for (var key in config) {
          //dex.console.log("KEY", key, "VALUE", config[key]);
          dex.config.setEventHandler(node, key, config[key], i);
        }
      }

      return node;
    },

    /**
     *
     * Construct an line specification which allows the user to override any
     * of the settings.
     *
     * @param {d3line_spec} custom - The users customizations.
     *
     * @returns {d3line_spec} A line specification generated by combining the
     * default with the user's customizations.
     *
     */
    'line': function line(custom) {
      var defaults =
        {
          'start': dex.config.point(),
          'end': dex.config.point(),
          'stroke': dex.config.stroke(),
          'fill': dex.config.fill(),
          'interpolate': undefined
        };
      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    'configureLine': function configureLine(node, config, i) {
      if (config) {
        dex.config.setAttr(node, 'x1', config.start.x, i);
        dex.config.setAttr(node, 'y1', config.start.y, i);
        dex.config.setAttr(node, 'x2', config.end.x, i);
        dex.config.setAttr(node, 'y2', config.end.y, i);
        dex.config.configureStroke(node, config.stroke, i);
        dex.config.configureFill(node, config.fill, i);
        if (config.interpolate) {
          //dex.console.log("interpolate", node, config, i);
          node.interpolate(config.interpolate);
          // I think this is closer to correct....but breaks the motion line chart
          //node.interpolate(dex.config.optionValue(config.interpolate, i));
        }
      }
      return node;
    },

    /**
     *
     * Construct an path specification which allows the user to override any
     * of the settings.
     *
     * @param {d3path_spec} custom - The users customizations.
     *
     * @returns {d3path_spec} A path specification generated by combining the
     * default with the user's customizations.
     *
     */
    'path': function path(custom) {
      var defaults =
        {
          'fill': dex.config.fill(),
          'stroke': dex.config.stroke(),
          'd': undefined
        };
      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    'configurePath': function configurePath(node, config, i) {
      if (config) {
        dex.config.configureFill(node, config.fill, i);
        dex.config.configureStroke(node, config.stroke, i);
        dex.config.setAttr(node, 'd', config.d, i);
      }
      return node;
    },

    'getCallers': function getCallers(caller) {
      var callers = [caller];
      var currentCaller = caller;
      //for (; currentCaller; currentCaller = currentCaller.caller) {
      //  if (currentCaller.name) {
      //    callers.push(currentCaller.name);
      //  }
      //}

      return callers.reverse();
    },

    'getCallerString': function getCallerString(caller) {
      return dex.config.getCallers(caller).join("->");
    },

    'setEventHandler': function setEventHandler(node, eventType, eventHandler, i) {
      var callerStr = dex.config.getCallerString(arguments.callee.caller);

      //dex.console.debug(callerStr + ": setEventHandler(node=" + node + ", eventType=" + eventType + ", eventHandler=" + eventHandler);
      if (!node) {
        dex.console.debug(callerStr + ": dex.config.setEventHandler(eventType='" + eventType + "eventHandler=" + eventHandler + ") : node is null.");
        return node;
      }
      if (!dex.object.isFunction(node.on)) {
        dex.console.debug(callerStr + ": dex.config.setEventHandler(eventType='" + eventType + "', eventHandler='" + eventHandler +
          "') : target node is missing function: node.on(eventType,eventHandler).  Node dump:", node);
        return node;
      }
      if (typeof eventHandler != 'undefined') {
        dex.console.debug(callerStr + ": Set Event Handler: '" + eventType + "'='" + eventHandler + "'");
        node.on(eventType, eventHandler);
      }
      else {
        dex.console.debug(callerStr += ": Undefined Event Handler: '" + eventType + "'='" + eventHandler + "'");
      }
      return node;
    },

    'setAttr': function setAttr(node, name, value, i) {
      var callerStr = dex.config.getCallerString(arguments.callee.caller);
      if (!node) {
        dex.console.debug(callerStr + ": dex.config.setAttr(name='" + name + "value=" + value + ") : node is null.");
        return node;
      }
      if (!dex.object.isFunction(node.attr)) {
        dex.console.debug(callerStr + ": dex.config.setAttr(name='" + name + "', value='" + value +
          "') : target node is missing function: node.attr.  Node dump:", node);
        return node;
      }
      if (typeof value != 'undefined') {
        dex.console.debug(callerStr + ": Set Attr: '" + name + "'='" + value + "'");
        node.attr(name, dex.config.optionValue(value, i));
      }
      else {
        dex.console.debug(callerStr += ": Undefined Attr: '" + name + "'='" + value + "'");
      }
      return node;
    },

    'setStyle': function setStyle(node, name, value, i) {
      var callerStr = dex.config.getCallerString(arguments.callee.caller);
      if (!node) {
        dex.console.warn(callerStr + ": dex.config.setAttr(name='" + name + "value=" + value + ") : node is null.");
        return node;
      }
      if (!dex.object.isFunction(node.style)) {
        dex.console.debug(callerStr + ": dex.config.setStyle(name='" + name + "', value='" + value +
          "') : target node is missing function: node.style.  Node Dump:", node);
        return node;
      }
      if (typeof value !== 'undefined' && node && dex.object.isFunction(node.style)) {
        dex.console.debug(callerStr + ": Set Style: name='" + name + "', Value Dump:",
          dex.config.optionValue(value, i));
        node.style(name, dex.config.optionValue(value, i));
      }
      else {
        dex.console.debug(callerStr + ": Undefined Style: name='" + name + "', Value Dump:", value);
      }
      return node;
    },

    'optionValue': function optionValue(option, i) {
      //dex.console.log("OPTION-I: " + i);

      // Curry value i:
      if (typeof i !== 'undefined') {
        return function (d) {
          //dex.console.log("OPTION", option, "D", d, "I", i);
          if (dex.object.isFunction(option)) {
            return option(d, i);
          }
          else {
            return option;
          }
        };
      }
      else {
        return function (d, i) {
          //dex.console.log("OPTION", option, "D", d, "I", i);
          if (dex.object.isFunction(option)) {
            return option(d, i);
          }
          else {
            return option;
          }
        };
      }
    },

    /**
     *
     * Is this correct?  It looks suspect to me.
     *
     * @param node
     * @param fn
     * @param value
     * @param i
     * @returns {*}
     */
    'callIfDefined': function callIfDefined(node, fn, value, i) {
      //dex.console.log("CALL-IF-DEFINED: fn=" + fn + ", value=" + value + ", I=" + i);
      if (typeof value === 'undefined') {
        //dex.console.log("Skipping: " + fn + "()");
      }
      else {
        //dex.console.log("Calling: '" + fn + "(" + value + ")");
        return node[fn](dex.config.optionValue(value, i));
      }

      return node;
    },

    /**
     *
     * Construct an point specification which allows the user to override any
     * of the settings.
     *
     * @param {d3point_spec} custom - The users customizations.
     *
     * @returns {d3point_spec} A point specification generated by combining the
     * default with the user's customizations.
     *
     */
    'point': function point(custom) {
      var config =
        {
          'x': undefined,
          'y': undefined
        };
      if (custom) {
        config = dex.object.overlay(custom, config);
      }
      return config;
    },

    'configurePoint': function configurePoint(node, config, i) {
      if (config) {
        node
          .attr('x', dex.config.optionValue(config.center.cx, i))
          .attr('y', dex.config.optionValue(config.center.cy, i));
      }
      return node;
    },

// Configures: opacity, color, stroke.
    'configureShapeStyle': function configureShapeStyle(node, config, i) {
      if (config) {
        node
          .call(dex.config.configureStroke, config.stroke, i)
          .attr('opacity', config.opacity)
          .style('fill', config.color);
      }
      return node;
    },

    /**
     *
     * Construct an circle specification which allows the user to override any
     * of the settings.
     *
     * @param {d3circle_spec} custom - The users customizations.
     *
     * @returns {d3circle_spec} A circle specification generated by combining the
     * default with the user's customizations.
     *
     */
    'circle': function circle(custom) {
      var config = {
        'cx': 0,
        'cy': 0,
        'r': 10,
        'fill': dex.config.fill(),
        'stroke': dex.config.stroke(),
        'transform': '',
        'title': '',
        'events': dex.config.events()
      };
      if (custom) {
        config = dex.object.overlay(custom, config);
      }
      return config;
    },

    'configureCircle': function configureCircle(node, config, i) {
      if (config) {
        dex.config.setAttr(node, "r", config.r, i);
        dex.config.setAttr(node, "cx", config.cx, i);
        dex.config.setAttr(node, "cy", config.cy, i);
        dex.config.setAttr(node, "transform", config.transform, i);
        dex.config.setAttr(node, "title", config.title, i);
        dex.config.configureStroke(node, config.stroke, i);
        dex.config.configureFill(node, config.fill, i);
        dex.config.configureEvents(node, config.events, i);
      }
      return node;
    },

    /**
     *
     * Construct an tick specification which allows the user to override any
     * of the settings.
     *
     * @param {d3tick_spec} custom - The users customizations.
     *
     * @returns {d3tick_spec} A tick specification generated by combining the
     * default with the user's customizations.
     *
     */
    'tick': function tick(custom) {
      var config = {
        'count': 5,
        //'tickValues'  : undefined,
        'subdivide': 3,
        'size': {
          'major': 5,
          'minor': 3,
          'end': 5
        },
        'padding': 5,
        'format': d3.format(",d"),
        'label': dex.config.text()
      };
      if (custom) {
        config = dex.object.overlay(custom, config);
      }
      return config;
    },
    'callConditionally': function callConditionally(fn, value, i) {
      //dex.console.log("- FN:" + fn);
      //dex.console.log("- VALUE:" + value);
      if (value !== undefined) {
        //dex.console.log("- CALLING: " + fn + " of " + value);
        if (i !== undefined) {
          fn(value, i);
        }
        else {
          fn(value);
        }
      }
      else {
      }
    },

    /**
     *
     * Configure the input parameters for configuring an axis.
     * Certain defaults are imposed should the "custom" variable
     * not specify that parameter.
     *
     * @param custom The user supplied axis configuration.
     *
     * @returns {d3axis_spec} The axis specification with
     * user supplied overrides applied.
     *
     */
    'axis': function axis(custom) {
      var defaults = {
        'scale': dex.config.scale({'type': 'linear'}),
        'orient': 'bottom',
        'ticks': undefined,
        'tickValues': undefined,
        'tickSize': undefined,
        'innerTickSize': undefined,
        'outerTickSize': undefined,
        'tickPadding': undefined,
        'tickFormat': undefined
        //'label'         : dex.config.text()
      };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    /**
     *
     * Create an axis with the specified configuration.
     *
     * @param axis The axis to configure.
     * @param config The user specified axis configuration.
     *
     * @returns {*} The newly configured axis.
     */
    'configureAxis': function configureAxis(axis, config, i) {
      //dex.console.log("CONFAXIS: " + i);
      if (config) {
        [
          'scale',
          'orient',
          'ticks',
          'tickValues',
          'tickSize',
          'innerTickSize',
          'outerTickSize',
          'tickPadding',
          'tickFormat'
        ].forEach(function (fn) {
          //dex.console.log("Calling: " + fn);
          dex.config.callConditionally(axis[fn], config[fn], i);
        });
      }
      return axis;
    },

    'createAxis': function createAxis(userConfig, i) {
      var config = dex.config.axis(userConfig);
      return dex.config.configureAxis(d3.svg.axis(), config, i);
    },

    /**
     *
     * Construct a {d3axis_spec} based on reasonable defaults with
     * user customizations applied on top.
     *
     * @param custom The user customizations.
     *
     * @returns {d3scale_spec} The scale specification with
     * user supplied overrides applied.
     *
     */
    'scale': function scale(custom) {
      var fmap =
        {
          'linear': dex.config.linearScale,
          'sqrt': dex.config.sqrtScale,
          'pow': dex.config.powScale,
          'time': dex.config.timeScale,
          'log': dex.config.logScale,
          'ordinal': dex.config.ordinalScale,
          'quantile': dex.config.quantileScale,
          'quantize': dex.config.quantizeScale,
          'identity': dex.config.identityScale
        };

      var defaults =
        {
          'type': 'linear'
        };

      var config = dex.config.expandAndOverlay(custom, defaults);

      return fmap[config.type](config);
    },

    /**
     *
     * Given a scale specification, create, configure, and return a
     * scale which meets that specification.
     *
     * @param {d3scale_spec} scaleSpec
     * @returns {Object} Returns a d3.scale with the supplied specification.
     *
     */
    'createScale': function createScale(scaleSpec) {
      var scale;

      var fmap =
        {
          'linear': d3.scale.linear,
          'sqrt': d3.scale.sqrt,
          'pow': d3.scale.pow,
          'time': d3.time.scale,
          'log': d3.scale.log,
          'ordinal': d3.scale.ordinal,
          'quantile': d3.scale.quantile,
          'quantize': d3.scale.quantize,
          'identity': d3.scale.identity
        };

      if (scaleSpec) {
        scale = fmap[scaleSpec.type]();

        // Since we create a non-parameterized scale, here we parameterize it based upon
        // the supplied specification
        dex.config.configureScale(scale, scaleSpec);
      }
      else {
        scale = d3.scale.linear();
      }

      return scale;
    },

    /**
     *
     * Construct a linear {d3scale_spec} based on reasonable
     * defaults with user customizations applied on top.
     *
     * @param custom The user customizations.
     *
     * @returns {d3scale_spec} The linear scale specification with
     * user supplied overrides applied.
     *
     */
    'linearScale': function linearScale(custom) {
      var defaults =
        {
          'type': 'linear',
          'domain': [0, 100],
          'range': [0, 800],
          'rangeRound': undefined,
          'interpolate': undefined,
          'clamp': undefined,
          'nice': undefined
        };

      var linearScaleSpec = dex.config.expandAndOverlay(custom, defaults);
      return linearScaleSpec;
    },

    /**
     *
     * Construct a power {d3scale_spec} based on reasonable
     * defaults with user customizations applied on top.
     *
     * @param custom The user customizations.
     *
     * @returns {d3scale_spec} The power scale specification with
     * user supplied overrides applied.
     *
     */
    'powScale': function powScale(custom) {
      var defaults =
        {
          'type': 'pow',
          'domain': [0, 100],
          'range': [0, 800],
          'rangeRound': undefined,
          'interpolate': undefined,
          'clamp': undefined,
          'nice': undefined
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    /**
     *
     * Construct a sqrt {d3scale_spec} based on reasonable
     * defaults with user customizations applied on top.
     *
     * @param custom The user customizations.
     *
     * @returns {d3scale_spec} The sqrt scale specification with
     * user supplied overrides applied.
     *
     */
    'sqrtScale': function sqrtScale(custom) {
      var defaults =
        {
          'type': 'sqrt',
          'domain': [0, 100],
          'range': [0, 800],
          'rangeRound': undefined,
          'interpolate': undefined,
          'clamp': undefined,
          'nice': undefined
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    /**
     *
     * Construct a log {d3scale_spec} based on reasonable
     * defaults with user customizations applied on top.
     *
     * @param custom The user customizations.
     *
     * @returns {d3scale_spec} The log scale specification with
     * user supplied overrides applied.
     *
     */
    'logScale': function logScale(custom) {
      var defaults =
        {
          'type': 'log',
          'domain': [0, 100],
          'range': [0, 800],
          'rangeRound': undefined,
          'interpolate': undefined,
          'clamp': undefined,
          'nice': undefined
        };

      var logSpec = dex.config.expandAndOverlay(custom, defaults);
      return logSpec;
    },

    /**
     *
     * Construct a ordinal {d3scale_spec} based on reasonable
     * defaults with user customizations applied on top.
     *
     * @param custom - The user customizations.
     * @param {object} [custom.rangeRoundBands] -
     * @param {object} [custom.rangeBands] -
     * @param {object} [custom.rangePoints] - rangePoints(interval [, padding]) : Sets the output range from the specified continuous
     * interval. The array interval contains two elements representing the minimum and maximum
     * numeric value. This interval is subdivided into n evenly-spaced points, where n is the
     * number of (unique) values in the input domain. The first and last point may be offset
     * from the edge of the interval according to the specified padding, which defaults to zero.
     * The padding is expressed as a multiple of the spacing between points. A reasonable value
     * is 1.0, such that the first and last point will be offset from the minimum and maximum
     * value by half the distance between points.
     * @param {object} [custom.rangeBands] -
     *
     * @returns {d3scale_spec} The ordinal scale specification with
     * user supplied overrides applied.
     *
     */
    'ordinalScale': function ordinalScale(custom) {
      var defaults =
        {
          'type': 'ordinal',
          'domain': undefined,
          'range': undefined,
          'rangeRoundBands': undefined,
          'rangePoints': undefined,
          'rangeBands': undefined
        };

      var ordinalSpec = dex.config.expandAndOverlay(custom, defaults);
      return ordinalSpec;
    },

    'timeScale': function timeScale(custom) {
      var defaults =
        {
          'type': 'time',
          'domain': undefined,
          'range': undefined,
          'rangeRound': undefined,
          'interpolate': undefined,
          'clamp': undefined,
          'ticks': undefined,
          'tickFormat': undefined
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    'quantileScale': function quantileScale(custom) {
      var defaults =
        {
          'type': 'quantile',
          'domain': undefined,
          'range': undefined
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    'quantizeScale': function quantizeScale(custom) {
      var defaults =
        {
          'type': 'quantize',
          'domain': undefined,
          'range': undefined
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    'identityScale': function identityScale(custom) {
      var defaults =
        {
          'type': 'identity',
          'domain': undefined,
          'range': undefined
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    'thresholdScale': function thresholdScale(custom) {
      var defaults =
        {
          'type': 'threshold',
          'domain': undefined,
          'range': undefined
        };

      var config = dex.config.expandAndOverlay(custom, defaults);
      return config;
    },

    'configureScale': function configureScale(scale, config) {
      if (config) {
        for (var property in config) {
          dex.console.trace("ConfigureScale Property: '" + property + "'");
          if (config.hasOwnProperty(property) && property !== 'type' && config[property] !== undefined) {
            dex.console.trace("Property: '" + property + "'");
            dex.config.callConditionally(scale[property], config[property]);
          }
          else {
            dex.console.debug("Missing Property: '" + property + "'");
          }
        }
      }

      return scale;
    },

    'gui': require("./gui")(dex)
  };
};
},{"./gui":78}],78:[function(require,module,exports){
/**
 *
 * gui definition module.
 * @module dex/config/gui
 *
 */

module.exports = function gui(dex) {
  return {
    'dimensions': function dimensions(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Chart Dimensions",
        "contents": [
          {
            "name": "Height",
            "description": "The height of the chart.",
            "target": ns + "height",
            "type": "int",
            "minValue": 0,
            "maxValue": 2000,
            "initialValue": 600
          },
          {
            "name": "Width",
            "description": "The width of the chart.",
            "target": ns + "width",
            "type": "int",
            "minValue": 0,
            "maxValue": 2000,
            "initialValue": 800
          },
          {
            "name": "Top Margin",
            "description": "The top margin of the chart.",
            "target": ns + "margin.top",
            "type": "int",
            "minValue": 0,
            "maxValue": 500,
            "initialValue": 50
          },
          {
            "name": "Bottom Margin",
            "description": "The bottom margin of the chart.",
            "target": ns + "margin.bottom",
            "type": "int",
            "minValue": 0,
            "maxValue": 500,
            "initialValue": 50
          },
          {
            "name": "Left Margin",
            "description": "Left top margin of the chart.",
            "target": "margin.left",
            "type": "int",
            "minValue": 0,
            "maxValue": 500,
            "initialValue": 50
          },
          {
            "name": "Right Margin",
            "description": "The right margin of the chart.",
            "target": "margin.right",
            "type": "int",
            "minValue": 0,
            "maxValue": 500,
            "initialValue": 50
          },
          {
            "name": "Transform",
            "description": "A transform to be applied to the chart.",
            "target": ns + "transform",
            "type": "string",
            "initialValue": ""
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'font': function font(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Font",
        "contents": [
          {
            "name": "Font Size",
            "description": "The size of the font.",
            "target": ns + "size",
            "type": "int",
            "minValue": 1,
            "maxValue": 256,
            "initialValue": 12
          },
          {
            "name": "Font Family",
            "description": "The font family.",
            "target": ns + "family",
            "type": "choice",
            "choices": ["courier", "sans-serif", "times-roman"],
            "initialValue": "sans-serif"
          },
          {
            "name": "Font Style",
            "description": "The font style.",
            "target": ns + "style",
            "type": "choice",
            "choices": ["normal", "italic", "oblique", "inherit"],
            "initialValue": "normal"
          },
          {
            "name": "Font Weight",
            "description": "The weight of the font.",
            "target": "weight",
            "type": "choice",
            "choices": ["normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500",
              "600", "700", "800", "900"],
            "initialValue": "normal"
          },
          {
            "name": "Font Variant",
            "description": "The font variant.",
            "target": "variant",
            "type": "choice",
            "choices": ["normal", "inherit", "small-caps"],
            "initialValue": "normal"
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'text': function text(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Text",
        "contents": [
          {
            "type": "group",
            "name": "General",
            "contents": [
              {
                "name": "Transform",
                "description": "A transform to be applied to the text.",
                "target": ns + "transform",
                "type": "string",
                "initialValue": ""
              },
              {
                "name": "Format",
                "description": "The text format.",
                "target": ns + "format",
                "type": "string",
                "initialValue": ""
              },
              {
                "name": "Anchor",
                "description": "The text anchor.",
                "target": ns + "anchor",
                "type": "choice",
                "choices": ["middle", "start", "end"],
                "initialValue": "middle"
              },
              {
                "name": "X Offset",
                "description": "The x offset of the text.",
                "target": ns + "dx",
                "type": "int",
                "minValue": -2000,
                "maxValue": 2000,
                "initialValue": 0
              },
              {
                "name": "Y Offset",
                "description": "The y offset of the text.",
                "target": ns + "dy",
                "type": "int",
                "minValue": -2000,
                "maxValue": 2000,
                "initialValue": 0
              },
              {
                "name": "Text Decoration",
                "description": "The text decoration.",
                "target": ns + "decoration",
                "type": "choice",
                "choices": ["none", "underline", "overline", "line-through", "blink", "inherit"],
                "initialValue": "none"
              },
              {
                "name": "Writing Mode",
                "description": "The text writing mode family.",
                "target": ns + "writingMode",
                "type": "choice",
                "choices": ["inherit", "lr-tb", "rl-tb", "tb-rl", "lr", "rl", "tb"],
                "initialValue": "inherit"
              },
              {
                "name": "Text Length",
                "description": "The text length.",
                "target": ns + "textLength",
                "type": "int",
                "minValue": 1,
                "maxValue": 2000,
                "initialValue": ""
              },
              {
                "name": "Length Adjust",
                "description": "The text length adjustment.",
                "target": ns + "lengthAdjust",
                "type": "choice",
                "choices": ["", "spacing", "spacingAndGlyphs"],
                "initialValue": ""
              }
            ]
          },
          dex.config.gui.font(config.font || {}, ns + "font"),
          dex.config.gui.fill(config.fill || {}, ns + "fill"),
          dex.config.gui.stroke(config.stroke || {}, ns + "stroke")
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'editableText': function text(config, prefix) {
      var config = dex.config.gui.text(config, prefix);
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      config.contents[0].contents.unshift(
        {
          "name": "Text Contents",
          "description": "The text.",
          "target": ns + "text",
          "type": "string",
          "initialValue": ""
        }
      );
      return config;
    },
    'fill': function fill(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Fill",
        "contents": [
          {
            "name": "Fill",
            "description": "The fill color or none.",
            "target": ns + "fillColor",
            "type": "color",
            "colors": ["none", "black", "white", "red", "green",
              "blue", "orange", "yellow", "pink", "gray", "maroon",
              "teal", "cyan", "navy", "steelblue", "olive", "silver"],
            "initialValue": "none"
          },
          {
            "name": "Fill Opacity",
            "description": "The text anchor.",
            "target": ns + "fillOpacity",
            "type": "float",
            "minValue": 0.0,
            "maxValue": 1.0,
            "initialValue": 1.0
          },
          {
            "name": "Fill Rule",
            "description": "The fill color or none.",
            "target": ns + "fillRule",
            "type": "choice",
            "choices": ["nonzero", "evenodd", "inherit"],
            "initialValue": "nonzero"
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'link': function link(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Link",
        "contents": [
          dex.config.gui.fill(config.fill || {}, ns + "fill"),
          dex.config.gui.stroke(config.stroke || {}, ns + "stroke")
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'stroke': function stroke(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Stroke",
        "contents": [
          {
            "name": "Width",
            "description": "The with (in pixels) of the stroke.",
            "target": ns + "width",
            "type": "float",
            "minValue": 0.0,
            "maxValue": 10.0,
            "initialValue": 1.0
          },
          {
            "name": "Color",
            "description": "This control allows the user to select the color by name, or 'none'.",
            "target": ns + "color",
            "type": "choice",
            "choices": ["none", "red", "green", "blue", "black", "white", "yellow",
              "purple", "orange", "pink", "cyan", "steelblue", "grey"],
            "initialValue": "black"
          },
          {
            "name": "Color",
            "description": "The stroke color, this control allows the selection of any color.",
            "target": ns + "color",
            "type": "color"
          },
          {
            "name": "Opacity",
            "description": "The stroke opacity.",
            "target": ns + "opacity",
            "type": "float",
            "minValue": 0.0,
            "maxValue": 1.0,
            "initialValue": 1.0
          },
          {
            "name": "Dash Array",
            "description": "The stroke dash array.",
            "target": ns + "dasharray",
            "type": "string",
            "initialValue": ""
          },
          {
            "name": "transform",
            "description": "The stroke transformation.",
            "target": ns + "transform",
            "type": "string",
            "initialValue": ""
          },
          {
            "name": "Line Cap",
            "description": "The line cap.",
            "target": ns + "lineCap",
            "type": "choice",
            "choices": ["inherit", "butt", "round", "square"],
            "initialValue": "inherit"
          },
          {
            "name": "Line Join",
            "description": "The line join.",
            "target": ns + "lineJoin",
            "type": "choice",
            "choices": ["miter", "round", "bevel", "inherit"],
            "initialValue": "miter"
          },
          {
            "name": "Miter Limit",
            "description": "The miter limit.",
            "target": ns + "miterLimit",
            "type": "float",
            "minValue": 0.0,
            "maxValue": 20.0,
            "initialValue": 4.0
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'general': function general(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "General Options",
        "contents": [
          {
            "name": "Resizable",
            "description": "This determines whether the chart is resizable or not.",
            "target": ns + "resizable",
            "type": "boolean",
            "initialValue": true
          },
          {
            "name": "Draggable",
            "description": "This determines whether the chart is draggable or not.",
            "target": ns + "draggable",
            "type": "boolean",
            "initialValue": false
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'circle': function circle(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Circle",
        "contents": [
          {
            "type": "group",
            "name": "General",
            "contents": [
              {
                "name": "Radius",
                "description": "This determines the radius of the circle.",
                "target": ns + "r",
                "type": "float",
                "minValue": 0,
                "maxValue": 200,
                "initialValue": 5
              },
              {
                "name": "Transform",
                "description": "A transform to be applied to the circle.",
                "target": ns + "transform",
                "type": "string",
                "initialValue": ""
              }
            ]
          },
          dex.config.gui.fill(config.fill || {}, ns + "fill"),
          dex.config.gui.stroke(config.stroke || {}, ns + "stroke")
        ]
      };
      dex.config.gui.fill(config, ns + "fill");
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'path': function path(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Path",
        "contents": [
          dex.config.gui.fill(config.fill || {}, ns + "fill"),
          dex.config.gui.stroke(config.stroke || {}, ns + "stroke")
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'brush': function path(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Brush",
        "contents": [
          {
            "type": "group",
            "name": "Appearance",
            "contents": [
              {
                "name": "Brush Color",
                "type": "color",
                "target": ns + "color",
                "description": "Brush color",
                "intialValue": "steelblue"
              },
              {
                "name": "Brush Opacity",
                "type": "float",
                "target": ns + "opacity",
                "minValue": 0,
                "maxValue": 1,
                "description": "Brush color",
                "intialValue": .8
              },
              {
                "name": "Brush Width",
                "type": "int",
                "description": "Brush Width",
                "target": ns + "width",
                "minValue": 0,
                "maxValue": 30,
                "intialValue": 12
              },
              {
                "name": "Brush X Offset",
                "type": "int",
                "description": "Brush X Offset",
                "target": ns + "x",
                "minValue": -30,
                "maxValue": 30,
                "intialValue": -6
              }
            ]
          },
          dex.config.gui.stroke(config.stroke || {}, ns + "stroke")
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'rectangle': function circle(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Rectangle",
        "contents": [
          {
            "type": "group",
            "name": "General",
            "contents": [
              {
                "name": "Height",
                "description": "This determines the height of the rectangle.",
                "target": ns + "height",
                "type": "float",
                "minValue": 0,
                "maxValue": 200,
                "initialValue": 5
              },
              {
                "name": "Width",
                "description": "This determines the width of the rectangle.",
                "target": ns + "width",
                "type": "float",
                "minValue": 0,
                "maxValue": 200,
                "initialValue": 5
              },
              {
                "name": "X Radius",
                "description": "The x radius.",
                "target": ns + "rx",
                "type": "float",
                "minValue": 0,
                "maxValue": 200,
                "initialValue": 0
              },
              {
                "name": "Y Radius",
                "description": "The y radius.",
                "target": ns + "ry",
                "type": "float",
                "minValue": 0,
                "maxValue": 200,
                "initialValue": 0
              },
              {
                "name": "Transform",
                "description": "A transform to be applied to the rectangle.",
                "target": ns + "transform",
                "type": "string",
                "initialValue": ""
              }
            ]
          },
          dex.config.gui.fill(config.fill || {}, ns + "fill"),
          dex.config.gui.stroke(config.stroke || {}, ns + "stroke")
        ]
      };
      dex.config.gui.fill(config, ns + "fill");
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    // ECharts configuration:
    'echartsTextStyle': function fill(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Text Style",
        "contents": [
          {
            "name": "Text Color",
            "description": "The color of the text.",
            "target": ns + "color",
            "type": "color",
            "initialValue": "#ffffff"
          },
          {
            "name": "Font Style",
            "description": "The color of the text.",
            "target": ns + "fontStyle",
            "type": "choice",
            "choices": ["normal", "italic", "oblique"],
            "initialValue": "normal"
          },
          {
            "name": "Font Weight",
            "description": "The weight of the text.",
            "target": ns + "fontWeight",
            "type": "choice",
            "choices": ["normal", "bold", "bolder", "lighter",
              "100", "200", "300", "400", "500", "600", "700",
              "800", "900"],
            "initialValue": "normal"
          },
          {
            "name": "Font Family",
            "description": "The color of the text.",
            "target": ns + "fontFamily",
            "type": "choice",
            "choices": [
              "sans-serif", "arial", "courier", "courier new",
              "arial narrow", "allegro", "lucidia console",
              "lucida sans", "times", "arial rounded mt bold"
            ],
            "initialValue": "sans-serif"
          },
          {
            "name": "Font Size",
            "description": "The font family.",
            "target": ns + "fontSize",
            "type": "int",
            "minValue": 0,
            "maxValue": 128,
            "initialValue": 12
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'echartsLabel': function fill(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Label",
        "contents": [
          dex.config.gui.echartsTextStyle(config.textStyle || {},
            ns + "textStyle"),
          {
            "name": "Show Label",
            "description": "Show or hide the label.",
            "target": ns + "show",
            "type": "boolean",
            "initialValue": false
          },
          {
            "name": "Position",
            "description": "Position of the label.",
            "target": ns + "position",
            "type": "choice",
            "choices": ["top", "left", "right", "bottom",
              "inside", "insideLeft", "insideRight", "insideTop",
              "insideBottom", "insideLeftTop", "insideLeftBottom",
              "insideRightTop", "insideRightBottom"],
            "initialValue": "top"
          },
          {
            "name": "Formatter",
            "description": "Formatter of the label.",
            "target": ns + "formatter",
            "type": "string",
            "initialValue": ""
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'echartsItemStyle': function fill(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Item Style",
        "contents": [
          {
            "name": "Color",
            "description": "Color.",
            "target": ns + "color",
            "type": "color",
            "initialValue": "#aaa"
          },
          {
            "name": "Border Color",
            "description": "Border color.",
            "target": ns + "borderColor",
            "type": "color",
            "initialValue": "#aaa"
          },
          {
            "name": "Border Width",
            "description": "Border Width.",
            "target": ns + "borderWidth",
            "type": "float",
            "minValue": 0,
            "maxValue": 10,
            "initialValue": 1
          },
          {
            "name": "Shadow Blur",
            "description": "Shadow blur.",
            "target": ns + "shadowBlur",
            "type": "float",
            "minValue": 0,
            "maxValue": 20,
            "initialValue": 0
          },
          {
            "name": "Shadow Color",
            "description": "Shadow color.",
            "target": ns + "shadowColor",
            "type": "color",
            "initialValue": "#aaa"
          },
          {
            "name": "Opacity",
            "description": "Opacity.",
            "target": ns + "opacity",
            "type": "float",
            "minValue": 0,
            "maxValue": 1,
            "initialValue": 1
          },
          {
            "name": "Border Type",
            "description": "Border type.",
            "target": ns + "borderType",
            "type": "choice",
            "choices": ["solid", "dashed", "dotted"],
            "initialValue": "solid"
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'echartsLineStyle': function fill(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Line Style",
        "contents": [
          {
            "name": "Color",
            "description": "Line color.",
            "target": ns + "color",
            "type": "color",
            "initialValue": "#aaa"
          },
          {
            "name": "Width",
            "description": "Line Width.",
            "target": ns + "width",
            "type": "float",
            "minValue": 0,
            "maxValue": 10,
            "initialValue": 1
          },
          {
            "name": "Shadow Blur",
            "description": "Shadow blur.",
            "target": ns + "shadowBlur",
            "type": "float",
            "minValue": 0,
            "maxValue": 20,
            "initialValue": 0
          },
          {
            "name": "Shadow Color",
            "description": "Shadow color.",
            "target": ns + "shadowColor",
            "type": "color",
            "initialValue": "#aaa"
          },
          {
            "name": "Opacity",
            "description": "Opacity.",
            "target": ns + "opacity",
            "type": "float",
            "minValue": 0,
            "maxValue": 1,
            "initialValue": 1
          },
          {
            "name": "Curveness",
            "description": "Curveness.",
            "target": ns + "curveness",
            "type": "float",
            "minValue": 0,
            "maxValue": 1,
            "initialValue": 0
          }
        ]
      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    'echartsTitle': function fill(config, prefix) {
      var ns = (typeof prefix !== 'undefined') ? (prefix + ".") : "";
      var userConfig = config || {};
      var defaults = {
        "type": "group",
        "name": "Title",
        "contents": [
          {
            "name": "Text",
            "description": "The text.",
            "target": ns + "text",
            "type": "string",
            "initialValue": ""
          },
          {
            "name": "Sub Text",
            "description": "The subtext.",
            "target": ns + "subtext",
            "type": "string",
            "initialValue": ""
          },
          {
            "name": "Link",
            "description": "An optional hyperlink.",
            "target": ns + "link",
            "type": "string",
            "initialValue": ""
          },
          {
            "name": "Link Target",
            "description": "A tab target to open hyperlink in.",
            "target": ns + "target",
            "type": "string",
            "initialValue": ""
          },
          {
            "name": "Horizontal Alignment",
            "description": "Text alignment.",
            "target": ns + "textAlign",
            "type": "choice",
            "choices": ["left", "center", "right"],
            "initialValue": "center"
          },
          {
            "name": "Vertical Alignment",
            "description": "Vertical alignment of title.",
            "target": ns + "textBaseline",
            "type": "choice",
            "choices": ["top", "middle", "bottom"],
            "initialValue": "top"
          },
          {
            "name": "Sub Link",
            "description": "An optional hyperlink.",
            "target": ns + "sublink",
            "type": "string",
            "initialValue": ""
          },
          {
            "name": "Sub Link Target",
            "description": "A tab target to open hyperlink in.",
            "target": ns + "subtarget",
            "type": "string",
            "initialValue": ""
          },
          dex.config.gui.echartsTextStyle(config.textStyle || {}, ns + "textStyle"),
          dex.config.gui.echartsTextStyle(config.subtextStyle || {}, ns + "subtextStyle")
        ]

      };
      return dex.config.expandAndOverlay(userConfig, defaults);
    },
    // Utility functions here:
    'disable': function disable(config, field) {
      if (config.type == "group") {
        config.contents.forEach(function (elt, i) {
          if (elt.hasOwnProperty("target") && elt.target == field) {
            delete config.contents[i];
          }
          else {
            disable(elt, field);
          }
        })
      }

      return config;
    },
    'sync': function sync(chart, guiDef) {
      if (guiDef.type == "group") {
        guiDef.contents.forEach(function (elt, i) {
          sync(chart, elt);
        })
      }
      else {
        var value = chart.attr(guiDef.target);
        var valueType = typeof value;
        if (valueType != "undefined" && valueType != "function") {
          guiDef.initialValue = value;
          //dex.console.log(guiDef.target + "=" + chart.attr(guiDef.target));
        }
      }

      return guiDef;
    }
  };
};
},{}],79:[function(require,module,exports){
/**
 *
 * This module provides console logging capabilities.
 *
 * @module dex/console
 *
 */

module.exports = function (dex) {

  /**
   *
   * @type {{TRACE: number, DEBUG: number, NORMAL: number, WARN: number, FATAL: number, NONE: number}}
   */
  dex.logLevels = {
    'TRACE': 5,
    'DEBUG': 4,
    'NORMAL': 3,
    'WARN': 2,
    'FATAL': 1,
    'NONE': 0
  };

  dex.logLevel = dex.logLevels.NORMAL;

  return {

////
//
// dex.console : This module provides routines assisting with console output.
//
////

    /**
     * Log this message if the current log level is greater than or equal
     * to dex.console.logLevel.
     *
     * @param msgLevel The log level for this message.
     * @param msg One or more messages to be logged.  Strings will simply
     * use console.log while objects will use console.dir.
     *
     * @returns {dex.console}
     */
    'logWithLevel': function (msgLevel, msg) {
//  console.log(dex.console.logLevel());
//  console.log(msgLevel);
//  console.dir(msg);

      if (dex.logLevel >= msgLevel) {
        for (i = 0; i < msg.length; i++) {
          if (typeof msg[i] == 'object') {
            console.dir(msg[i]);
          }
          else {
            console.log(msg[i]);
          }
        }
      }
      return this;
    },

    /**
     * Write one or more TRACE level messages.
     *
     * @param msg One or more TRACE messages to log.
     *
     * @returns {dex.console|*}
     */
    'trace': function () {
      return dex.console.logWithLevel(dex.logLevels.TRACE, arguments)
    },

    /**
     * Write one or more DEBUG level messages.
     *
     * @param msg One or more DEBUG messages to log.
     *
     * @returns {dex.console|*}
     */
    'debug': function () {
      return dex.console.logWithLevel(dex.logLevels.DEBUG, arguments)
    },

    /**
     * Write one or more NORMAL level messages.
     *
     * @param msg One or more NORMAL messages to log.
     *
     * @returns {dex.console|*}
     *
     */
    'log': function () {
      //console.log("caller is " + arguments.callee.caller.toString());
      return dex.console.logWithLevel(dex.logLevels.NORMAL, arguments)
    },

    /**
     * Write one or more WARN level messages.
     *
     * @param msg One or more WARN messages to log.
     *
     * @returns {dex.console|*}
     *
     */
    'warn': function () {
      return dex.console.logWithLevel(dex.logLevels.WARN, arguments)
    },

    /**
     * Write one or more FATAL level messages.
     *
     * @param msg One or more FATAL messages to log.
     *
     * @returns {dex.console|*}
     */
    'fatal': function () {
      return dex.console.logWithLevel(dex.logLevels.FATAL, arguments)
    },

    /**
     * This function returns the current log level.
     *
     * @returns The current log level.
     *
     */
    'logLevel': function (_) {
      if (!arguments.length) return dex.logLevel;
      dex.logLevel = dex.logLevels[_];
      return dex.logLevel;
    },

    'logLevels': function () {
      return dex.logLevels;
    }
  };
};
},{}],80:[function(require,module,exports){
/**
 *
 * This module provides support for dealing with csv structures.  This
 * is the core datatype on which dexjs components operate.
 *
 * @module dex/csv
 *
 */

module.exports = function csv(dex) {

  return {
    /**
     *
     * @param header
     * @param data
     * @returns {{header: *, data: *}}
     */
    'csv': function (header, data) {
      var csv = {
        "header": header,
        "data": data
      };

      return csv;
    },

    /**
     *
     * @param csv
     * @returns {{header: *, data: {header, data}}}
     */
    'transpose': function (csv) {
      return {
        "header": csv.header,
        "data": dex.matrix.transpose(csv.data)
      };
    },

    /**
     * Given a CSV, create a connection matrix suitable for feeding into a chord
     * diagram.  Ex, given CSV:
     *
     * @param csv
     * @returns {{header: Array, connections: Array}|*}
     *
     */
    'getConnectionMatrix': function (csv) {
      var matrix = [];
      var ri, ci;
      var row;
      var cid;
      var header = [];
      var nameToIndex = {};
      var connectionMatrix;
      var uniques;
      var nameIndices = [];
      var src, dest;

      // Create a list of unique values to relate to one another.
      uniques = dex.matrix.uniques(csv.data);
      // Flatten them into our header.
      header = dex.matrix.flatten(uniques);

      // Create a map of names to header index for each column.
      nameToIndex = new Array(uniques.length);
      for (ri = 0, cid = 0; ri < uniques.length; ri++) {
        nameToIndex[ri] =
          {};
        for (ci = 0; ci < uniques[ri].length; ci++) {
          nameToIndex[ri][header[cid]] = cid;
          cid += 1;
        }
      }

      // Create a N x N matrix of zero values.
      matrix = new Array(header.length);
      for (ri = 0; ri < header.length; ri++) {
        row = new Array(header.length);
        for (ci = 0; ci < header.length; ci++) {
          row[ci] = 0;
        }
        matrix[ri] = row;
      }
      //dex.console.log("nameToIndex", nameToIndex, "matrix", matrix);

      for (ri = 0; ri < csv.data.length; ri++) {
        for (ci = 1; ci < csv.header.length; ci++) {
          src = nameToIndex[ci - 1][csv.data[ri][ci - 1]];
          dest = nameToIndex[ci][csv.data[ri][ci]];

          //dex.console.log(csv.data[ri][ci-1] + "<->" + csv.data[ri][ci], src + "<->" + dest);
          matrix[src][dest] = 1;
          matrix[dest][src] = 1;
        }
      }

      connectionMatrix = {"header": header, "connections": matrix};
      //dex.console.log("Connection Matrix", connectionMatrix);
      return connectionMatrix;
    },

    'limitRows' : function(csv, limit) {
      var newCsv = {
        header: dex.array.copy(csv.header),
        data: []
      }

      var i = 0;
      for (i=0; i < csv.data.length && i < limit; i++) {
        newCsv.data.push(dex.array.copy(csv.data[i]));
      }

      return newCsv;
    },

    'getColumnNumber': function (csv, colIndex, defaultValue) {
      if (colIndex === undefined) {
        return defaultValue;
      }

      var colNum = csv.header.indexOf(colIndex);

      if (colNum >= 0) {
        return colNum;
      }

      if (colIndex >= 0 && colIndex < csv.header.length) {
        return colIndex;
      }

      return undefined;
    },

    /**
     *  Given a csv and a column index, return the name of the column.
     *  If a string is supplied, return the string if it is the name
     *  of a header.  If an integer is supplied, return the name of
     *  the header if that header exists.  This allows us to enable
     *  users to index columns via header name or by index.
     *
     * @param csv The csv for which we're retrieving the column name.
     * @param colIndex The name of the column header or its index.
     *
     * @returns {*} Null if the column index does not exist, the name
     * of the corresponding header otherwise.
     */
    'getColumnName': function (csv, colIndex) {
      if (colIndex === undefined) {
        return null;
      }

      if (colIndex >= 0 && colIndex < csv.header.length) {
        return csv.header[colIndex];
      }

      if (csv.header.indexOf(colIndex) >= 0) {
        return colIndex;
      }

      return null;
    },

    /**
     *
     * Retrieve the column referred to by the column index.  The
     * column index can be a header name or a value column number.
     *
     * @param csv The csv we're retrieving the data from.
     * @param colIndex The index of the column we wish to retrieve.
     *
     */
    'getColumnData': function (csv, colIndex) {
      var i = dex.csv.getColumnNumber(csv, colIndex);

      return csv.data.map(function (row) {
        return row[i];
      });
    },

    /**
     *
     * @param csv
     * @param keyIndex - Numerical header index or name.
     * @returns {{}}
     */
    'createMap': function (csv, keyIndex) {
      // CSV undefined
      if (csv === undefined) {
        throw "dex.csv.createMap(csv, keyIndex) : csv is undefined.";
      }
      if (keyIndex === undefined) {
        keyIndex = 0;
      }
      else {
        // 0 : number
        // [0] : object
        // '0' : string
        dex.console.log("UNKNOWN-TYPE", typeof(keyIndex));
      }
      return {};
    },

    'json2Csv': function (json) {
      var csv = {'header': [], 'data': []};
      if (_.isUndefined(json) || json.length <= 0) {
        return csv;
      }
      csv.header = _.keys(json[0]);
      json.forEach(function (jsonRow) {
        var row = [];
        csv.header.forEach(function (columnName) {
          row.push(jsonRow[columnName]);
        });
        csv.data.push(row);
      });

      return csv;
    },

    /**
     *
     * @param csv
     * @param rowIndex
     * @param columnIndex
     * @returns {*}
     */
    'toJson': function (csv, rowIndex, columnIndex) {
      var jsonData = [];
      var ri, ci, jsonRow;

      if (arguments.length >= 3) {
        jsonRow = {};
        jsonRow[csv.header[columnIndex]] = csv.data[rowIndex][columnIndex];
        return jsonRow;
      }
      else if (arguments.length === 2) {
        var jsonRow =
          {};
        for (ci = 0; ci < csv.header.length; ci += 1) {
          jsonRow[csv.header[ci]] = csv.data[rowIndex][ci];
        }
        return jsonRow;
      }
      else if (arguments.length === 1) {
        for (ri = 0; ri < csv.data.length; ri++) {
          var jsonRow =
            {};
          for (ci = 0; ci < csv.header.length; ci++) {
            jsonRow[csv.header[ci]] = csv.data[ri][ci];
            //dex.console.log(csv.header[ci] + "=" + csv.data[ri][ci], jsonRow);
          }
          jsonData.push(jsonRow);
        }
      }
      return jsonData;
    },

    'toStrictJson': function(csv) {
      var gtypes = dex.csv.guessTypes(csv);
      var jsonData = [];
      csv.data.forEach(function(row, ri) {
        var jsonRow = {};
        csv.header.forEach(function(header, hi) {
          switch (gtypes[hi]) {
            case "number": {
              jsonRow[header] = +(row[hi]);
              break;
            }
            case "date": {
              jsonRow[header] = new Date(row[hi]);
              break;
            }
            default: {
              jsonRow[header] = row[hi];
            }
          }
        });
        jsonData.push(jsonRow);
      });
      return jsonData;
    },

    /**
     *
     * @param csv
     * @returns {{}}
     */
    'toColumnArrayJson': function (csv) {
      var json = {};
      var ri, ci, jsonRow;

      if (arguments.length === 1) {
        for (ci = 0; ci < csv.header.length; ci++) {
          json[csv.header[ci]] = [];
        }

        for (ri = 0; ri < csv.data.length; ri++) {
          for (ci = 0; ci < csv.header.length; ci++) {
            json[csv.header[ci]].push(csv.data[ri][ci]);
          }
        }
      }

      return json;
    },

    /**
     *
     * Make a copy of this csv.
     *
     * @param {csv} csv The csv to copy.
     * @returns {csv} A copy of the original csv.
     *
     */
    'copy': function (csv) {
      var copy = {
        'header': dex.array.copy(csv.header),
        'data': dex.matrix.copy(csv.data)
      };
      return copy;
    },

    /**
     *
     * A utility transform for dealing with some of D3's more finiky formats.
     *
     * csv =
     * {
 * 	 header : {C1,C2,C3},
 *   data   : [
 *     [A,B,C],
 *     [A,B,D]
 *   ]
 * }
     * into:
     * json =
     * {
 * 	"name"     : rootName,
 *  "category" : category,
 *  "children" :
 *  [
 *    "children" :
 *     [
 *       {
 *         "name"     : "A",
 *         "category" : "C1",
 *         "children" :
 *         [
 *           {
 * 	           "name" : "B",
 *             "category" : "C2",
 *             "children" :
 *             [
 *               {
 *                 "name"     : "C",
 *                 "category" : "C3",
 *                 "size"     : 1
 *               }
 *               {
 *                 "name"     : "D",
 *                 "category" : "C3",
 *                 "size"     : 1
 *               }
 *             ]
 *           }
 *         ]
 *       }
 *     ]
 *  ]
 * }
     *
     * @param {Object} csv
     */
    'toHierarchicalJson': function (csv) {
      var connections = dex.csv.connections(csv);
      return getChildren(connections, 0);

      function getChildren(connections, depth) {
        //dex.console.log("connections:", connections, "depth="+depth);
        var kids = [], cname;

        if (typeof connections === 'undefined') {
          return kids;
        }

        for (cname in connections) {
          //dex.console.log("CNAME", cname);
          if (connections.hasOwnProperty(cname)) {
            kids.push(createChild(cname, csv.header[depth],
              getChildren(connections[cname], depth + 1)));
          }
        }

        return kids;
      }

      function createChild(name, category, children) {
        var child =
          {
            "name": name,
            "category": category,
            "children": children
          };
        return child;
      }
    },

    /**
     *
     * Transforms:
     * csv =
     * {
 * 	 header : {C1,C2,C3},
 *   data   : [
 *     [A,B,C],
 *     [A,B,D]
 *   ]
 * }
     * into:
     * connections =
     * { A:{B:{C:{},D:{}}}}
     *
     * @param {Object} csv
     *
     */
    'connections': function (csv) {
      var connections =
        {};
      var ri;

      for (ri = 0; ri < csv.data.length; ri++) {
        dex.object.connect(connections, csv.data[ri]);
      }

      //dex.console.log("connections:", connections);
      return connections;
    },

    /**
     *
     * @param csv
     * @param keyIndex
     * @returns {{}}
     *
     */
    'createRowMap': function (csv, keyIndex) {
      var map =
        {};
      var ri;

      for (ri = 0; ri < csv.data.length; ri++) {
        if (csv.data[ri].length == csv.header.length) {
          map[csv.data[ri][keyIndex]] = csv.data[ri];
        }
      }
      return map;
    },

    /**
     *
     * @param csv
     * @param columns
     * @returns {{}}
     */
    'columnSlice': function (csv, columns) {
      var slice = {};
      var columnNumbers = columns.map(function (column) {
        return dex.csv.getColumnNumber(csv, column);
      });

      slice.header = dex.array.slice(csv.header, columnNumbers);
      slice.data = dex.matrix.slice(csv.data, columnNumbers);

      return slice;
    },

    'include': function (csv, columns) {
      var slice = {};
      var columnNumbers = columns.map(function (column) {
        return dex.csv.getColumnNumber(csv, column);
      });

      slice.header = dex.array.slice(csv.header, columnNumbers);
      slice.data = dex.matrix.slice(csv.data, columnNumbers);

      return slice;
    },

    'exclude': function (csv, columns) {
      var slice = {};
      var columnNumbers = columns.map(function (column) {
        return dex.csv.getColumnNumber(csv, column);
      });
      var complement = dex.range(0, csv.header.length).filter(function (elt) {
        return !(columnNumbers.includes(elt));
      });

      slice.header = dex.array.slice(csv.header, complement);
      slice.data = dex.matrix.slice(csv.data, complement);

      return slice;
    },

    'removeColumn': function (csv, column) {
      var columnIndex = dex.csv.getColumnNumber(csv, column);
      var columns = dex.range(0, csv.header.length);
      columns.splice(columnIndex, 1);

      return {
        removed: dex.csv.columnSlice(csv, [columnIndex]),
        remaining: dex.csv.columnSlice(csv, columns)
      };
    },

    /**
     *
     * @param csv
     * @returns {Array}
     */
    'getNumericColumnNames': function (csv) {
      var possibleNumeric =
        {};
      var i, j, ri, ci;
      var numericColumns = [];

      for (i = 0; i < csv.header.length; i++) {
        possibleNumeric[csv.header[i]] = true;
      }

      // Iterate thru the data, skip the header.
      for (ri = 0; ri < csv.data.length; ri++) {
        for (ci = 0; ci < csv.data[ri].length && ci < csv.header.length; ci++) {
          if (possibleNumeric[csv.header[ci]] && !dex.object.isNumeric(csv.data[ri][ci])) {
            possibleNumeric[csv.header[ci]] = false;
          }
        }
      }

      for (ci = 0; ci < csv.header.length; ci++) {
        if (possibleNumeric[csv.header[ci]]) {
          numericColumns.push(csv.header[ci]);
        }
      }

      return numericColumns;
    },

    'getCategorizationMethods': function (csv) {
      var methods = {
        'Column Type': function (csv, ri, ci) {
          return csv.header[ci];
        },
        'Column Value': function (csv, ri, ci) {
          return csv.data[ri][ci];
        },
        'Row Number': function (csv, ri, ci) {
          return ri;
        },
        "None": function (csv, ri, ci) {
          return "Uncategorized";
        }
      };

      var getColumnValue = function (columnIndex) {
        return function (csv, ri, ci) {
          return csv.data[ri][columnIndex];
        };
      };

      csv.header.forEach(function (h, hi) {
        methods[csv.header[hi] + " Value"] = getColumnValue(hi);
      });

      return methods;
    },
    'getCategorizationMethod': function (csv, method) {
      var methods = dex.csv.getCategorizationMethods(csv);
      if (((typeof method) == "undefined") ||
        ((typeof methods[method]) == "undefined")) {
        return function () {
          return "Uncategorized";
        };
      }
      else {
        return methods[method];
      }
    },
    'getCsvFunction': function (csv, param) {
      if (param) {
        // User supplied category function:
        if (dex.object.isFunction(param)) {
          return param;
        }
        // Array of sequences; 1 per row
        else if (dex.object.isArray(param)) {
          return function (csv, ri, ci) {
            return param[ri];
          }
        }
        // A column index to use for categorization
        else {
          var catIndex = dex.csv.getColumnNumber(csv, param);
          var catCurry = function (catIndex) {
            return function (csv, ri, ci) {
              return csv.data[ri][catIndex];
            }
          };
          return catCurry(catIndex);
        }
      }
      // Else, every unique node is it's own category.
      else {
        return function (csv, ri, ci) {
          if (typeof ci == "undefined") {
            return csv.data[ri][0];
          }

          return csv.data[ri][ci];
        }
      }
    },

    'getScalingMethods': function (csv) {
      var methods;

      // v4 methods
      if (d3.version == "4.0") {
        methods = {
          'linear': d3.scaleLinear(),
          'pow': d3.scalePow(),
          'log': d3.scaleLog()
        };
      }
      else {
        methods = {
          'linear': d3.scale.linear(),
          'pow': d3.scale.pow(),
          'log': d3.scale.log()
        };
      }

      return methods;
    },
    'getScalingMethod': function (csv, method, domain, range) {
      var methods = dex.csv.getScalingMethods(csv);
      if (((typeof method) == "undefined") ||
        ((typeof methods[method]) == "undefined")) {
        return function (value) {
          return value;
        };
      }
      else {
        return methods[method].domain(domain).range(range);
      }
    },

    'getRowFunction': function (csv, param) {
      if (param) {
        // User supplied category function:
        if (dex.object.isFunction(param)) {
          return param;
        }
        // A row index to use for categorization
        else {
          return function (row) {
            return row[param];
          }
        }
      }
      // Else, just return the value.
      else {
        return function (row, ri) {
          if (typeof ri == "undefined") {
            return row[0];
          }

          return row[ri];
        }
      }
    },

    /**
     *
     * @param csv
     * @returns {Array}
     */
    'guessTypes': function (csv) {
      var guessedTypes = [];
      var i = 0;
      var testResults = [];
      dex.console.log("GUESSING TYPES OF ", csv);
      csv.header.forEach(function (hdr) {
        testResults.push({"notNumber": false, "notDate": false})
      });
      var numCols = csv.header.length;

      csv.data.forEach(function (row) {
        for (i = 0; i < numCols; i++) {

          if (!testResults[i]["notDate"]) {
            if (Object.prototype.toString.call(row[i]) === '[object Date]') {
              testResults[i]["notNumber"] = true;
            }
            else {
              var date = new Date(row[i]);
              if (isNaN(date.getTime())) {
                //dex.console.log("not date" + i);
                testResults[i]["notDate"] = true;
              }
            }
          }

          if (!testResults[i]["notNumber"]) {
            if (isNaN(row[i])) {
              //dex.console.log(row[i], i, "is not a number")
              testResults[i]["notNumber"] = true;
            }
          }
        }
      });

      for (i = 0; i < numCols; i++) {
        var results = testResults[i];
        if (!results.notNumber) {
          guessedTypes.push("number");
        }
        else if (!results.notDate) {
          guessedTypes.push("date");
        }
        else {
          guessedTypes.push("string");
        }
      }

      return guessedTypes;
    },

    /**
     *
     * @param csv
     * @returns {*}
     */
    'strictTypes': function strictTypes(csv) {
      var types = dex.csv.guessTypes(csv);

      for (var i = 0; i < types.length; i++) {
        if (types[i] == 'date') {
          csv.data.forEach(function (row, ri) {
            csv.data[ri][i] = new Date(csv.data[ri][i]);
          })
        }
        else {
          if (types[i] == 'number') {
            csv.data.forEach(function (row, ri) {
              dex.console.log("row[" + ri + "]=" + row[ri]);
              csv.data[ri][i] = new Double(csv.data[ri][i]);
            })
          }
        }
      }

      return csv;
    },

    'getRankedCsv': function (csv, nameIndex, sequenceIndex, valueIndex, options) {
      var rankedCsv = dex.csv.copy(csv);
      var opts = options || {};
      var orderDescending = opts.descending || false;

      var si = dex.csv.getColumnNumber(csv, sequenceIndex);
      var ni = dex.csv.getColumnNumber(csv, nameIndex);
      var vi = dex.csv.getColumnNumber(csv, valueIndex);

      rankedCsv.data.sort(function (row1, row2) {
        if (+row1[si] == +row2[si]) {
          if (+row1[vi] == +row2[vi]) {
            if (row1[ni] < row2[ni]) {
              return -1;
            }
            else if (row1[ni] > row2[ni]) {
              return 1;
            }
            else {
              return 0;
            }
          }
          else {
            if (orderDescending) {
              return +row2[vi] - +row1[vi];
            }
            else {
              return +row1[vi] - +row2[vi];
            }
          }
        }
        else {
          return +row1[si] - +row2[si];
        }
      });

      rankedCsv.header.push("rank");
      var rank = 0;
      var prev = undefined;
      rankedCsv.data.forEach(function (row) {
        if (prev == row[si]) {
          rank++;
          row.push(rank);
        }
        else {
          row.push(1);
          rank = 1;
        }
        prev = row[si];
      });

      return rankedCsv;
    },

    'uniqueArray': function (csv, columnIndex) {
      return dex.array.unique(dex.matrix.flatten(
        dex.matrix.slice(csv.data, [columnIndex])));
    },

    'uniques': function (csv, columns) {
      return dex.matrix.uniques(csv.data, columns);
    },

    'selectRows': function (csv, fn) {
      var subset = [];
      csv.data.forEach(function (row) {
        if (fn(row)) {
          subset.push(row);
        }
      });

      return {'header': csv.header, 'data': subset};
    },

    'extent': function (csv, columns) {
      return dex.matrix.extent(csv.data, columns);
    },

    getFramesByColumn: function (csv, x) {
      var xIndex = dex.csv.getColumnNumber(csv, x);
      var frames = {frameIndices: [], frames: []};

      csv.header.forEach(function (h, hi) {
        if (hi != xIndex) {
          var frame = {
            header: [csv.header[xIndex], h],
            data: []
          };
          frames.frameIndices.push(h);
          csv.data.forEach(function (row) {
            frame.data.push([row[xIndex], row[hi]]);
          });
          frames.frames.push(frame);
        }
      });

      return frames;
    },

    getFramesByColumns: function (csv, columns) {
      var columnIndexes = columns.map(function (col) {
        return dex.csv.getColumnNumber(csv, col);
      });

      var axisCsv = dex.csv.include(csv, columnIndexes);
      var seriesCsv = dex.csv.exclude(csv, columnIndexes);

      // If there are no series.
      if (seriesCsv.header.length == 0) {
        return {
          frameIndices: [ axisCsv.header.join(" vs ") ],
          frames: [ axisCsv ]
        }
      }

      dex.console.log(columnIndexes, "AXIS", axisCsv, "SERIES", seriesCsv);

      var frames = {
        frameIndices: [],
        frames: []
      };

      seriesCsv.header.forEach(function (h, hi) {
        frames.frameIndices.push(h);
        var frame = dex.csv.copy(axisCsv);
        frame.header.push(h);
        seriesCsv.data.forEach(function (row, ri) {
          frame.data[ri].push(row[hi]);
        });
        frames.frames.push(frame);
      });
      return frames;
    },

    /**
     *
     * This routine will return a frames structure based on a csv and
     * an index.  It will first identify all unique values within the
     * selected column, then sort them into an array of frame indexes.
     * From there, it will return an array of csv where the elements
     * contain the specified frame index at the cooresponding location.
     * This routine supports things such as time/value filtering for
     * things like a time or slicing dimension for various charts.
     * IE: No need to write a motion bubble chart, simply combine a
     * vcr-player with a regular bubble chart connected to play/rewind
     * events and motion will follow.
     *
     * @param csv
     * @param columnIndex
     * @returns {{frameIndices: Array.<T>, frames: Array}}
     */
    'getFramesByIndex': function (csv, columnIndex, sort) {
      var types = dex.csv.guessTypes(csv);
      //dex.console.log("TYPES", types);
      var frameIndices;

      if (types[columnIndex] == "number") {
        frameIndices = dex.array.orderedUnique(csv.data.map(function (row) {
          return row[columnIndex]
        }));

        if ((typeof sort) != "undefined") {
          frameIndices = frameIndices.sort(function (a, b) {
            return a - b
          });
        }
      }
      else if (types[columnIndex] == "date") {
        frameIndices = dex.array.orderedUnique(csv.data.map(function (row) {
          return row[columnIndex]
        }));

        if ((typeof sort) != "undefined") {
          frameIndices = frameIndices.sort(function (a, b) {
            a = new Date(a);
            b = new Date(b);
            return a > b ? 1 : a < b ? -1 : 0;
          });
        }
      }
      else {
        frameIndices = dex.array.orderedUnique(csv.data.map(function (row) {
          return row[columnIndex]
        }));

        if (sort) {
          frameIndices = frameIndices.sort();
        }
      }
      //dex.console.log("FRAME-INDICES", frameIndices)
      var header = dex.array.copy(csv.header);
      var frameIndexName = header.splice(columnIndex, 1);
      var frames = [];

      for (var fi = 0; fi < frameIndices.length; fi++) {
        var frame = {header: header};
        var frameData = [];

        for (var ri = 0; ri < csv.data.length; ri++) {
          if (csv.data[ri][columnIndex] == frameIndices[fi]) {
            var frameRow = dex.array.copy(csv.data[ri]);
            frameRow.splice(columnIndex, 1);
            frameData.push(frameRow);
          }
        }
        frame["data"] = frameData;
        frames.push(frame);
      }

      return {
        'frameIndices': frameIndices,
        'frames': frames
      }
    },

    /**
     *
     * Frame out a csv based on non-distinct permutations.  Exclude the
     * column pointed to by groupIndex from the permutations.  This will
     * be used to group and typically color the various series contained
     * within the frames.  A set of frames suitable for SPLOM might be
     * generated via a call of getPermutationFrames(csv, 2).  However, as
     * this is written generically, it will also support higher order
     * dimensions as well.
     *
     * @param csv The csv we wish to frame.
     * @param permutationSize The length of the desired permutations.
     * @param groupIndex The index of we are grouping upon.
     * @returns {{frameIndices: Array, frames: Array}}
     *
     */
    'getPermutationFrames': function (csv, permutationSize, groupIndex) {
      var gi = dex.csv.getColumnNumber(csv, groupIndex);

      var plist = dex.range(0, csv.header.length - 1);
      if (gi >= 0) {
        plist.splice(gi, 1);
      }
      var permutations = dex.array.getPermutations(plist, permutationSize);

      return dex.csv.getFrames(csv, permutations, gi);
    },

    /**
     *
     * Generate frames based upon a grouping parameter, then
     *
     * @param csv The csv we wish to frame.
     * @param comboLength The length of the combinations.
     * @param groupIndex The group index.  This column will be present in
     * every combination.
     * @returns {*|{frameIndices, frames}}
     */
    'getCombinationFrames': function (csv, comboLength, groupIndex) {
      var gi = dex.csv.getColumnNumber(csv, groupIndex);

      var plist = dex.range(0, csv.header.length);
      if (gi >= 0) {
        plist.splice(gi, 1);
      }
      dex.console.log("PLIST", plist);
      var combos = dex.array.getCombinations(plist, comboLength);

      return dex.csv.getFrames(csv, combos, gi);
    },
    'getFrames': function (csv, permutations, groupIndex) {
      var frameIndices = [];
      var frames = [];
      var gi = dex.csv.getColumnNumber(csv, groupIndex);

      permutations.forEach(function (permutation) {

        frameIndices.push(permutation.map(function (hi) {
          return csv.header[hi];
        }).join(" vs "));

        var columnIndices = dex.array.copy(permutation);
        if (gi >= 0) {
          columnIndices.unshift(gi);
        }

        frames.push(dex.csv.columnSlice(csv, columnIndices));
      });

      return {'frameIndices': frameIndices, 'frames': frames};
    },

    /**
     *
     * @param csv
     * @returns {Array}
     */
    'getNumericIndices': function (csv) {
      var possibleNumeric =
        {};
      var i, j;
      var numericIndices = [];

      for (i = 0; i < csv.header.length; i++) {
        possibleNumeric[csv.header[i]] = true;
      }

      // Iterate thru the data, skip the header.
      for (i = 1; i < csv.data.length; i++) {
        for (j = 0; j < csv.data[i].length && j < csv.header.length; j++) {
          if (possibleNumeric[csv.header[j]] && !dex.object.isNumeric(csv.data[i][j])) {
            console.log("csv.header[" + j + "]=" + csv.header[j] + " is not numeric due to csv.data[" + i + "]["
              + j + "]=" + csv.data[i][j]);
            possibleNumeric[csv.header[j]] = false;
          }
        }
      }

      for (i = 0; i < csv.header.length; i++) {
        if (possibleNumeric[csv.header[i]]) {
          numericIndices.push(i);
        }
      }

      return numericIndices;
    },

    'getCategoricalIndices': function (csv) {
      var possibleNumeric =
        {};
      var i, j;
      var categoricalIndices = [];

      for (i = 0; i < csv.header.length; i++) {
        possibleNumeric[csv.header[i]] = true;
      }

      // Iterate thru the data, skip the header.
      for (i = 1; i < csv.data.length; i++) {
        for (j = 0; j < csv.data[i].length && j < csv.header.length; j++) {
          if (possibleNumeric[csv.header[j]] && !dex.object.isNumeric(csv.data[i][j])) {
            console.log("csv.header[" + j + "]=" + csv.header[j] + " is not numeric due to csv.data[" + i + "]["
              + j + "]=" + csv.data[i][j]);
            possibleNumeric[csv.header[j]] = false;
          }
        }
      }

      for (i = 0; i < csv.header.length; i++) {
        if (!possibleNumeric[csv.header[i]]) {
          categoricalIndices.push(i);
        }
      }

      return categoricalIndices;
    },

    /**
     *
     * @param csv
     * @param columnNum
     * @returns {boolean}
     */
    'isColumnNumeric': function (csv, columnNum) {
      var i;

      for (i = 0; i < csv.data.length; i++) {
        if (!dex.object.isNumeric(csv.data[i][columnNum])) {
          return false;
        }
      }
      return true;
    },

    /**
     *
     * Given a series of categorical indices into a csv which
     * contains some numeric data, create a new CSV where the
     * first column is the aggregated categorical indices and
     * the contents are the sum of numeric columns matching the
     * aggregated categories.
     *
     * @param csv The csv to summarize.
     * @param columnIndexes The indices to be used in summarization.
     *
     * @returns {{header, data: Array}}
     */
    'summary': function (csv, columnIndexes) {
      // Create summary data groups csv.
      var summaryGroups = dex.csv.columnSlice(csv, columnIndexes);

      // Calculate the indices we will be summarizing.  Omit any
      // numeric indices contained in the grouping.
      var summaryIndices = dex.csv.getNumericIndices(csv)
        .filter(function (el) {
          return columnIndexes.indexOf(el) < 0;
        });

      // Extract a csv containing only what we are summarizing.
      var ncsv = dex.csv.columnSlice(csv, summaryIndices);

      // Initialize a name value pair structure where the key is
      // the aggregated group values.
      var summaryMap = {};
      summaryGroups.data.forEach(function (row) {
        if (!summaryMap[row.join(":")]) {
          summaryMap[row.join(":")] =
            Array.apply(null, Array(summaryIndices.length))
              .map(Number.prototype.valueOf, 0);
        }
      });

      // Add up the summary.
      for (var i = 0; i < ncsv.data.length; i++) {
        var key = summaryGroups.data[i].join(":");
        for (var j = 0; j < ncsv.data[i].length; j++) {
          summaryMap[key][j] += ncsv.data[i][j];
        }
      }

      // Create the base summary csv.
      var summary = {
        "header": ncsv.header,
        "data": []
      };
      // Prepend the aggregated summary name to the csv header.
      summary.header.unshift(summaryGroups.header.join(":"));

      // Iterate over each summary entry creating a row for each.
      for (key in summaryMap) {
        var data = summaryMap[key];
        data.unshift(key);
        summary.data.push(data);
      }

      // Return it back to the user.
      return summary;
    },

    /**
     *
     * @param csv
     * @param columns
     * @returns {*}
     */
    'group': function (csv, columns) {
      var ri, ci;
      var groups = {};
      var returnGroups = [];
      var values;
      var key;
      var otherColumns;
      var otherHeaders;
      var groupName;

      if (arguments < 2) {
        return csv;
      }

      function compare(a, b) {
        var si, h;

        for (si = 0; si < columns.length; si++) {
          h = csv.header[columns[si]]
          if (a[h] < b[h]) {
            return -1;
          }
          else if (a[h] > b[h]) {
            return 1
          }
        }

        return 0;
      }

      //otherColumns = dex.array.difference(dex.range(0, csv.header.length), columns);
      //otherHeaders = dex.array.slice(csv.header, otherColumns);

      for (ri = 0; ri < csv.data.length; ri += 1) {
        values = dex.array.slice(csv.data[ri], columns);
        key = values.join(':::');

        if (groups[key]) {
          group = groups[key];
        }
        else {
          //group = { 'csv' : dex.csv.csv(otherHeaders, []) };
          group =
            {
              'key': key,
              'values': [],
              'csv': dex.csv.csv(csv.header, [])
            };
          for (ci = 0; ci < values.length; ci++) {
            group.values.push({'name': csv.header[columns[ci]], 'value': values[ci]});
          }
          groups[key] = group;
        }
        //group.csv.data.push(dex.array.slice(csv.data[ri], otherColumns));
        group.csv.data.push(csv.data[ri]);
        //groups[key] = group;
      }

      for (groupName in groups) {
        if (groups.hasOwnProperty(groupName)) {
          returnGroups.push(groups[groupName]);
        }
      }

      return returnGroups.sort(compare);
    },

    /**
     *
     * @param csv
     * @param func
     */
    'visitCells': function (csv, func) {
      var ci, ri;

      for (ri = 0; ri < csv.data.length; ri++) {
        for (ci = 0; ci < csv.header.length; ci++) {
          func(ci, ri, csv.data[ri][ci]);
        }
      }
    },

    /**
     *
     * @param csv
     * @returns {number}
     */
    'longestWord': function (csv) {
      var longest = 0;
      for (var row = 0; row < csv.data.length; row++) {
        for (var col = 0; col < csv.data[row].length; col++) {
          if (longest < csv.data[row][col].length) {
            longest = csv.data[row][col].length;
          }
        }
      }
      return longest;
    },

    /**
     *
     * @param csv
     * @returns {{}|*}
     */
    'numericSubset': function (csv) {
      return dex.csv.columnSlice(csv, dex.csv.getNumericIndices(csv));
    },

    'categoricalSubset': function (csv) {
      return dex.csv.columnSlice(csv, dex.csv.getCategoricalIndices(csv));
    },

    'toJsonHierarchy': function (csv, ci) {
      // If 1 argument, then setup and call with 2.
      if (arguments.length == 1) {
        var result = {'name': 'root', children: dex.csv.toJsonHierarchy(csv, 0)};
        //dex.console.log("RESULT", result);
        return result;
      }
      else if (arguments.length == 2) {
        var valueMap = {};

        for (var ri = 0; ri < csv.data.length; ri++) {
          if (valueMap.hasOwnProperty(csv.data[ri][ci])) {
            valueMap[csv.data[ri][ci]]++;
          }
          else {
            valueMap[csv.data[ri][ci]] = 1;
          }
        }

        if (ci >= csv.header.length - 1) {
          return _.keys(valueMap).map(function (key) {
            return {'name': key, 'size': valueMap[key]};
          });
        }
        else {
          return _.keys(valueMap).map(function (key) {
            return {'name': key, 'size': valueMap[key]};
          });
        }
      }
    },

    'getGraph': function (csv) {

      var nodes = [];
      var links = [];
      var nodeNum = 0;
      var indexMap = [];

      // Record uniques across the data, treating each column as it's own namespace.
      csv.header.map(function (col, ci) {
        indexMap.push({});
        csv.data.map(function (row, ri) {
          if (_.isUndefined(indexMap[ci][row[ci]])) {
            indexMap[ci][row[ci]] = nodeNum;
            nodes.push({'name': row[ci]});
            nodeNum++;
          }
        });
      });

      for (var ci = 1; ci < csv.header.length; ci++) {
        csv.data.map(function (row, ri) {
          links.push({'source': indexMap[ci - 1][row[ci - 1]], 'target': indexMap[ci][row[ci]], 'value': 1});
        });
      }

      //dex.console.log("NODES", nodes, links, indexMap);
      return {'nodes': nodes, 'links': links};
    },

    'toNestedJson': function (csv, manualWeight) {
      manualWeight = manualWeight || false;
      //dex.console.log("CMAP", dex.csv.getConnectionMap(csv), manualWeight);
      var result = {
        'name': csv.header[0],
        'children': dex.csv.toNestedJsonChildren(
          dex.csv.getConnectionMap(csv), manualWeight)
      };
      //dex.console.log("toNestedJson.result()", result);
      return result;
    },

    'toNestedJsonChildren': function (cmap, manualWeight) {
      manualWeight = manualWeight || false;
      //dex.console.log("CMAP", cmap);
      var children = [];
      _.keys(cmap).map(function (key) {
        var childMap = cmap[key];

        if (_.keys(childMap).length <= 0) {
          //dex.console.log("Child Map 0", childMap, cmap);
          children.push({'name': key, 'size': 1});
        }
        else if (manualWeight) {

          var props = Object.getOwnPropertyNames(childMap);
          //dex.console.log("KEY", key, "childMap", childMap, "cm.props", props);

          if (props.length == 1) {
            var props2 = Object.getOwnPropertyNames(childMap[props[0]]);
            //dex.console.log("GRANDCHILD-PROPS", props2);
            if (props2.length == 0) {
              children.push({'name': key, size: +props[0]});
            }
            else {
              children.push({
                'name': key,
                'children': dex.csv.toNestedJsonChildren(cmap[key], manualWeight)
              });
            }
          }
          else {
            children.push({
              'name': key,
              'children': dex.csv.toNestedJsonChildren(cmap[key], manualWeight)
            });
          }
        }
        else {
          children.push({
            'name': key,
            'children': dex.csv.toNestedJsonChildren(cmap[key], manualWeight)
          });
        }
      });

//dex.console.log("CHILDREN", children);
      return children;
    },

    'getConnectionMap': function (csv) {
      var rootMap = {};
      var curMap = {}

      for (var row = 0; row < csv.data.length; row++) {
        curMap = rootMap;

        for (var col = 0; col < csv.header.length; col++) {
          if (!_.has(curMap, csv.data[row][col])) {
            curMap[csv.data[row][col]] = {};
          }
          curMap = curMap[csv.data[row][col]];
        }
      }

      return rootMap;
    }
  };
};
},{}],81:[function(require,module,exports){
/**
 *
 * This module provides support for creating various datasets.
 *
 * @module dex/datagen
 *
 */

module.exports = function datagen(dex) {

  return {
    /**
     * Creates a matrix of random integers within the specified range.
     *
     * @param spec The matrix specification.  Ex: \{rows:10, columns: 4, min: 0, max:100\}
     *
     * @returns {Array} An array containing spec.rows number of rows.  Each row consisting of
     * an array containing spec.columns elements.  Each element is a randomly generated integer
     * within the range [spec.min, spec.max]
     *
     */
    'randomMatrix': function (spec) {
      var ri, ci;

      //{rows:10, columns: 4, min, 0, max:100})
      var matrix = [];
      var range = spec.max - spec.min;
      for (ri = 0; ri < spec.rows; ri++) {
        var row = [];

        for (ci = 0; ci < spec.columns; ci++) {
          row.push(Math.random() * range + spec.min);
        }
        matrix.push(row);
      }
      return matrix;
    },

    'randomIndexedMatrix': function (spec) {
      var ri, ci;

      //{rows:10, columns: 4, min, 0, max:100})
      var matrix = [];
      var range = spec.max - spec.min;
      for (ri = 0; ri < spec.rows; ri++) {
        var row = [];

        row.push(ri + 1);
        for (ci = 0; ci < spec.columns - 1; ci++) {
          row.push(Math.random() * range + spec.min);
        }
        matrix.push(row);
      }
      return matrix;
    },


    'randomIndexedIntegerMatrix': function (spec) {
      var ri, ci;

      //{rows:10, columns: 4, min, 0, max:100})
      var matrix = [];
      var range = spec.max - spec.min;
      for (ri = 0; ri < spec.rows; ri++) {
        var row = [];

        row.push(ri + 1);
        for (ci = 0; ci < spec.columns - 1; ci++) {
          row.push(Math.round(Math.random() * range + spec.min));
        }
        matrix.push(row);
      }
      return matrix;
    },
    'randomIntegerMatrix': function (spec) {
      var ri, ci;

      //{rows:10, columns: 4, min, 0, max:100})
      var matrix = [];
      var range = spec.max - spec.min;
      for (ri = 0; ri < spec.rows; ri++) {
        var row = [];

        for (ci = 0; ci < spec.columns; ci++) {
          row.push(Math.round(Math.random() * range + spec.min));
        }
        matrix.push(row);
      }
      return matrix;
    },

    /**
     * Creates a matrix of random integers within the specified range.
     *
     * @param spec The matrix specification.  Ex: \{rows:10, columns:4 \}
     *
     * @returns {Array} An array containing spec.rows number of rows.  Each row consisting of
     * an array containing spec.columns elements.  Each element is a randomly generated integer
     * within the range [spec.min, spec.max]
     *
     */
    'identityCsv': function (spec) {
      var ri, ci;
      var csv = {};
      csv.header = dex.datagen.identityHeader(spec);
      csv.data = dex.datagen.identityMatrix(spec);
      return csv;
    },

    /**
     * This method will return an identity function meeting the supplied
     * specification.
     *
     * @param {object} spec - The identityMatrix specification.
     * @param {number} spec.rows - The number of rows to generate.
     * @param {number} spec.columns - The number of columns to generate.
     * @example {@lang javascript}
     * // Returns: [['R1C1', 'R1C2' ], ['R2C1', 'R2C2'], ['R3C1', 'R3C2']]
     * identityMatrix({rows: 3, columns: 2});
     * @returns {matrix}
     *
     */
    'identityMatrix': function (spec) {
      var ri, ci;

      // { rows:10, columns:4 })
      var matrix = [];
      for (ri = 0; ri < spec.rows; ri++) {
        var row = [];

        for (ci = 0; ci < spec.columns; ci++) {
          row.push("R" + (ri + 1) + "C" + (ci + 1));
        }
        matrix.push(row);
      }
      return matrix;
    },

    /**
     * Returns an identity header array.
     *
     * @param spec - The specification for the header array.
     * @param spec.columns - The number of columns to generate.
     * @example
     * // Returns: [ 'C1', 'C2', 'C3' ]
     * identityHeader({ columns: 3 });
     * @returns {Array} Returns an array of the specified columns.
     *
     */
    'identityHeader': function (spec) {
      return dex.range(1, spec.columns).map(function (i) {
        return "C" + i;
      });
    },
    'usStateInfo': function (format) {
      var stateData = [
        {
          "name": "Alabama",
          "abbreviation": "AL"
        },
        {
          "name": "Alaska",
          "abbreviation": "AK"
        },
        {
          "name": "American Samoa",
          "abbreviation": "AS"
        },
        {
          "name": "Arizona",
          "abbreviation": "AZ"
        },
        {
          "name": "Arkansas",
          "abbreviation": "AR"
        },
        {
          "name": "California",
          "abbreviation": "CA"
        },
        {
          "name": "Colorado",
          "abbreviation": "CO"
        },
        {
          "name": "Connecticut",
          "abbreviation": "CT"
        },
        {
          "name": "Delaware",
          "abbreviation": "DE"
        },
        {
          "name": "District of Columbia",
          "abbreviation": "DC"
        },
        {
          "name": "Federated States Of Micronesia",
          "abbreviation": "FM"
        },
        {
          "name": "Florida",
          "abbreviation": "FL"
        },
        {
          "name": "Georgia",
          "abbreviation": "GA"
        },
        {
          "name": "Guam",
          "abbreviation": "GU"
        },
        {
          "name": "Hawaii",
          "abbreviation": "HI"
        },
        {
          "name": "Idaho",
          "abbreviation": "ID"
        },
        {
          "name": "Illinois",
          "abbreviation": "IL"
        },
        {
          "name": "Indiana",
          "abbreviation": "IN"
        },
        {
          "name": "Iowa",
          "abbreviation": "IA"
        },
        {
          "name": "Kansas",
          "abbreviation": "KS"
        },
        {
          "name": "Kentucky",
          "abbreviation": "KY"
        },
        {
          "name": "Louisiana",
          "abbreviation": "LA"
        },
        {
          "name": "Maine",
          "abbreviation": "ME"
        },
        {
          "name": "Marshall Islands",
          "abbreviation": "MH"
        },
        {
          "name": "Maryland",
          "abbreviation": "MD"
        },
        {
          "name": "Massachusetts",
          "abbreviation": "MA"
        },
        {
          "name": "Michigan",
          "abbreviation": "MI"
        },
        {
          "name": "Minnesota",
          "abbreviation": "MN"
        },
        {
          "name": "Mississippi",
          "abbreviation": "MS"
        },
        {
          "name": "Missouri",
          "abbreviation": "MO"
        },
        {
          "name": "Montana",
          "abbreviation": "MT"
        },
        {
          "name": "Nebraska",
          "abbreviation": "NE"
        },
        {
          "name": "Nevada",
          "abbreviation": "NV"
        },
        {
          "name": "New Hampshire",
          "abbreviation": "NH"
        },
        {
          "name": "New Jersey",
          "abbreviation": "NJ"
        },
        {
          "name": "New Mexico",
          "abbreviation": "NM"
        },
        {
          "name": "New York",
          "abbreviation": "NY"
        },
        {
          "name": "North Carolina",
          "abbreviation": "NC"
        },
        {
          "name": "North Dakota",
          "abbreviation": "ND"
        },
        {
          "name": "Northern Mariana Islands",
          "abbreviation": "MP"
        },
        {
          "name": "Ohio",
          "abbreviation": "OH"
        },
        {
          "name": "Oklahoma",
          "abbreviation": "OK"
        },
        {
          "name": "Oregon",
          "abbreviation": "OR"
        },
        {
          "name": "Palau",
          "abbreviation": "PW"
        },
        {
          "name": "Pennsylvania",
          "abbreviation": "PA"
        },
        {
          "name": "Puerto Rico",
          "abbreviation": "PR"
        },
        {
          "name": "Rhode Island",
          "abbreviation": "RI"
        },
        {
          "name": "South Carolina",
          "abbreviation": "SC"
        },
        {
          "name": "South Dakota",
          "abbreviation": "SD"
        },
        {
          "name": "Tennessee",
          "abbreviation": "TN"
        },
        {
          "name": "Texas",
          "abbreviation": "TX"
        },
        {
          "name": "Utah",
          "abbreviation": "UT"
        },
        {
          "name": "Vermont",
          "abbreviation": "VT"
        },
        {
          "name": "Virgin Islands",
          "abbreviation": "VI"
        },
        {
          "name": "Virginia",
          "abbreviation": "VA"
        },
        {
          "name": "Washington",
          "abbreviation": "WA"
        },
        {
          "name": "West Virginia",
          "abbreviation": "WV"
        },
        {
          "name": "Wisconsin",
          "abbreviation": "WI"
        },
        {
          "name": "Wyoming",
          "abbreviation": "WY"
        }
      ];

      if (format == 'name2abbrev') {
        var nameIndex = {};

        stateData.forEach(function(row) {
          nameIndex[row.name] = row.abbreviation;
        });

        return nameIndex;
      }
      else if (format == 'abbrev2name') {
        var abbrevIndex = {};

        stateData.forEach(function(row) {
          abbrevIndex[row.abbreviation] = row.name;
        });

        return abbrevIndex;
      }

      return stateData;
    }
  };
};

},{}],82:[function(require,module,exports){
// Allow user to override, but define this by default:

/**
 *
 * The main dexjs module.
 *
 * @module dex
 *
 * @requires d3
 * @requires jquery
 * @requires jqueryui
 * @requires underscore
 *
 * @property {string}              version   - Returns the version of dex.js being used.
 * @property {module:dex/bus}      bus       - A module providing a communication bus for charts.
 * @property {module:dex/array}    array     - A module for dealing with arrays.
 * @property {module:dex/csv}      csv       - A module for dealing with csv.
 * @property {module:dex/matrix}   matrix    - A module for dealing with matrices.
 * @property {module:dex/object}   object    - A module for dealing with objects.
 * @property {module:dex/charts}   charts    - The module which provides the various charts.
 * @property {module:dex/color}    color     - A module for dealing with colors.
 * @property {module:dex/datagen}  datagen   - A module for generating data.
 * @property {module:dex/json}     json      - A module for dealing with json.
 * @property {module:dex/charts}   ui        - A module providing ui components.
 * @property {dex/component} component - The base class for all charting components.
 *
 */
var dex = {};

dex.css = require('../css/dex.css');

// Dependencies:
// https://github.com/federico-lox/pubsub.js
dex.bus = require("../lib/pubsub");

// Allow jqueryui to play well with bootstrap.  This
// also means we must include dex.js before bootstrap.
// REM: Would like to break the JQuery UI dependencies.
$.widget.bridge('uitooltip', $.ui.tooltip);
$.widget.bridge('uibutton', $.ui.button);

require("../lib/jquery-layout/jquery-layout");
require("../lib/uix-multiselect/uix.multiselect");
$.widget.bridge('listSelectView', $.uix.multiselect);

require("../lib/bootstrap-multiselect/bootstrap-multiselect");
require("../lib/bootstrap-toggle/bootstrap-toggle");
require("../lib/spectrum/spectrum");

/**
 *
 * The version of dexjs.
 *
 * @name version
 * @type {string}
 *
 */
dex.version = "0.9.0.1";

/**
 * This routine will return an array [ start, ..., start + len ] using an increment of 1.
 *
 * @param {number} start - The starting index.
 * @param {number} len - The number of integers to generate.
 * @example {@lang javascript}
 * // returns [ 0, 1, 2 ]
 * range(0, 3)
 *
 * @returns {Array} An array consisting of elements [ start, ..., start + len ].
 *
 */
dex.range = function (start, len) {
  return _.range(start, start + len);
};

/**
 *
 * This routine is simply a convenience function as it
 * simply wraps underscore's implementation of a shallow
 * copy.  This method will create a shallow-copied clone
 * of the provided plain object. Any nested objects or
 * arrays will be copied by reference, not duplicated.
 *
 * @param obj
 * @returns {*}
 */
dex.copy = function (obj) {
  return _.copy(obj);
};

dex.executeFunctionByName = function (functionName, context) {
  var args = [].slice.call(arguments).splice(2);
  var namespaces = functionName.split(".");
  var func = namespaces.pop();
  for (var i = 0; i < namespaces.length; i++) {
    context = context[namespaces[i]];
  }
  return context[func].apply(context, args);
};

dex.actions = {
  'setSelected': function (src, dest) {
    return function(msg) {
      dest.attr('csv', msg.selected).update();
    }
  }
};

dex.createComponent = function (config) {
    return dex.executeFunctionByName(config.class, window, config.config);
};

dex.create = function (config) {
  var components = [];
  var cmap = {};
  dex.console.log("Creating Config:", config);
  config.components.forEach(function (component) {
    dex.console.log("COMPONENT:", component);
    cmap[component.name] = dex.executeFunctionByName(component.class, window, component.config);
    components.push(cmap[component.name]);
  });

  if (config.interactions != undefined) {
    config.interactions.forEach(function (interaction) {
      interaction.sources.forEach(function (source) {
        interaction.destinations.forEach(function (destination) {
          cmap[destination].subscribe(cmap[source], interaction.event,
            dex.actions[interaction.action](cmap[source], cmap[destination]));
        })
      })
    })
  }

  return components;
};

dex.render = function (config) {
  var components = dex.create(config);
  components.forEach(function (component) {
    component.render();
  });
  return components;
};

dex.util = require('./util/util')(dex);

/**
 *
 * A module for dealing with arrays.
 *
 * @name array
 * @type {module:dex.array}
 *
 */
dex.array = require('./array/array')(dex);

/**
 * A module for dealing with colors.
 *
 * @name color
 * @type {module:dex.color}
 *
 */
dex.color = require("./color/color")(dex);

/**
 *
 * A module for configuring things.
 *
 * @name config
 * @type {module:dex.config}
 *
 */
dex.config = require("./config/config")(dex);

/**
 *
 * A module for logging to the console.
 *
 * @name console
 * @type {module:dex.console}
 *
 */
dex.console = require("./console/console")(dex);

/**
 *
 * A module for handling CSV data structures.
 *
 * @name csv
 * @type {module:dex.csv}
 *
 */
dex.csv = require("./csv/csv")(dex);

/**
 *
 * A module providing utilities for data generation.
 *
 * @name datagen
 * @type {module:dex.datagen}
 *
 */
dex.datagen = require("./datagen/datagen")(dex);

/**
 *
 * A module for dealing with JSON data.
 *
 * @name json
 * @type {module:dex.json}
 *
 */
dex.json = require("./json/json")(dex);

/**
 * A module for dealing with matrices.
 *
 * @name matrix
 * @type {module:dex.matrix}
 *
 */
dex.matrix = require("./matrix/matrix")(dex);

/**
 * @name object
 * @type {module:object}
 *
 */
dex.object = require("./object/object")(dex);

/**
 *
 * A module for creating ui components such as players and sliders.
 *
 * @name ui
 * @type {module:ui}
 *
 */
dex.ui = require("./ui/ui")(dex);

/**
 *
 * A module for dealing with geometric conundrums.
 *
 * @name geometry
 * @type {module:geometry}
 *
 */
dex.geometry = require("./geometry/geometry")(dex);


/**
 *
 * A module for dealing dex components.
 *
 * @name component
 * @type {module:component}
 *
 */
//dex.component = require("./component/component")(dex);
dex.component = require("./component/component2")(dex);

/**
 *
 * An overall charting module composed of many sub-modules.
 *
 * @name charts
 * @type {module:charts}
 *
 */
dex.charts = require("./charts/charts")(dex);

d3 = dex.charts.d3.d3v3;

// This fixes a JQueryUI/Bootstrap icon conflict.
if ($.fn.button.noConflict != undefined) {
  $.fn.button.noConflict();
}

module.exports = dex;
},{"../css/dex.css":1,"../lib/bootstrap-multiselect/bootstrap-multiselect":2,"../lib/bootstrap-toggle/bootstrap-toggle":4,"../lib/jquery-layout/jquery-layout":7,"../lib/pubsub":8,"../lib/spectrum/spectrum":9,"../lib/uix-multiselect/uix.multiselect":10,"./array/array":13,"./charts/charts":24,"./color/color":75,"./component/component2":76,"./config/config":77,"./console/console":79,"./csv/csv":80,"./datagen/datagen":81,"./geometry/geometry":83,"./json/json":84,"./matrix/matrix":85,"./object/object":86,"./ui/ui":93,"./util/util":94}],83:[function(require,module,exports){
/**
 *
 * This module provides routines dealing with geometry.
 *
 * @module dex/geometry
 *
 */

module.exports = function geometry(dex) {

  return {
// square distance between 2 points
    'getSqDist': function (p1, p2) {
      var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

      return dx * dx + dy * dy;
    },

    // square distance from a point to a segment
    'getSqSegDist': function (p, p1, p2) {

      var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

      if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
          x = p2.x;
          y = p2.y;

        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }

      dx = p.x - x;
      dy = p.y - y;

      return dx * dx + dy * dy;
    },

    'simplifyRadialDist': function (points, sqTolerance) {

      var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

      for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (dex.geometry.getSqDist(point, prevPoint) > sqTolerance) {
          newPoints.push(point);
          prevPoint = point;
        }
      }

      if (prevPoint !== point) newPoints.push(point);

      return newPoints;
    },

    'simplifyDPStep': function (points, first, last, sqTolerance, simplified) {
      var maxSqDist = sqTolerance,
        index;

      for (var i = first + 1; i < last; i++) {
        var sqDist = dex.geometry.getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (maxSqDist > sqTolerance) {
        if (index - first > 1) dex.geometry.simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) dex.geometry.simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
    },

    'simplifyDouglasPeucker': function (points, sqTolerance) {
      var last = points.length - 1;

      var simplified = [points[0]];
      dex.geometry.simplifyDPStep(points, 0, last, sqTolerance, simplified);
      simplified.push(points[last]);

      return simplified;
    },

    // both algorithms combined for awesome performance
    'simplify': function (points, tolerance, highestQuality) {

      if (points.length <= 2) return points;

      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

      points = highestQuality ? points : dex.geometry.simplifyRadialDist(points, sqTolerance);
      points = dex.geometry.simplifyDouglasPeucker(points, sqTolerance);

      return points;
    },

    'pointInside': function (point, points) {
      // ray-casting algorithm based on
      // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

      var x = point[0], y = point[1];

      var inside = false;
      for (var i = 0, j = points.length - 1; i < points.length; j = i++) {
        var xi = points[i][0], yi = points[i][1];
        var xj = points[j][0], yj = points[j][1];

        var intersect = ((yi > y) != (yj > y))
          && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }

      return inside;
    },

    'extents': function (points) {
      if (points[0] === undefined || points[0][0] === undefined || points[0][1] === undefined) {
        return undefined;
      }

      var extents = {
        x: {min: points[0][0], max: points[0][0]},
        y: {min: points[0][1], max: points[0][1]}
      };

      points.forEach(function (point) {
        if (extents.x.max < point[0]) {
          extents.x.max = point[0];
        }
        if (extents.y.max < point[1]) {
          extents.y.max = point[1];
        }

        if (extents.x.min > point[0]) {
          extents.x.min = point[0];
        }
        if (extents.y.min > point[1]) {
          extents.y.min = point[1];
        }
      });
      return extents;
    },

    'rasterize': function (points, resolution) {
      var res = resolution || 1.0;
      var extents = dex.geometry.extents(points);
      var x, y;
      var image = [];
      for (y = extents.y.min; y <= extents.y.max; y += res) {
        var scanline = [];
        for (x = extents.x.min; x <= extents.x.max; x += res) {
          scanline.push((dex.geometry.pointInside([x, y], points)) ? 1 : 0);
        }
        image.push(scanline);
      }

      return {
        'image': image,
        'extents': extents,
        'resolution': res
      };
    },

    'maxRect': function (matrix) {
      /*
       Updates maximal rectangle algorithm cache

       @param int[][] matrix 2d array of 1s / 0s rep. game board
       @param int x current cache column
       @param int[] cache
       */
      function updateCache(matrix, x, cache)
      {
        for (var y = 0; y < rows; y++)
          if (matrix[x][y] == 1)
            cache[y]++;
          else
            cache[y] = 0;
      }

      var bestUpperLeft = {x: -1, y: -1};
      var bestLowerRight = {x: -1, y: -1};

      var cache = new Array(rows + 1), stack = []; // JS arrays have push and pop. Awesome!
      for (var i = 0; i < cache.length; i++)
        cache[i] = 0;

      for (var x = cols - 1; x >= 0; x--) {
        updateCache(matrix, x, cache);
        var width = 0;
        for (var y = 0; y < rows + 1; y++) {
          if (cache[y] > width) {
            stack.push({y: y, width: width});
            width = cache[y];
          }
          if (cache[y] < width) {
            while (true) {
              var pop = stack.pop();
              var y0 = pop.y, w0 = pop.width;
              if (((width * (y - y0)) > area(bestUpperLeft, bestLowerRight)) && (y - y0 >= minQuadY) && (width >= minQuadX)) {
                bestUpperLeft = {x: x, y: y0};
                bestLowerRight = {x: x + width - 1, y: y - 1};
              }
              width = w0;
              if (cache[y] >= width)
                break;
            }
            width = cache[y];
            if (width != 0)
              stack.push({y: y0, width: w0});
          }
        }
      }
      return {
        x: bestUpperLeft.x,
        y: bestUpperLeft.y,
        lenX: bestLowerRight.x - bestUpperLeft.x + 1,
        lenY: bestLowerRight.y - bestUpperLeft.y + 1,
        area: area(bestUpperLeft, bestLowerRight)
      };
    },

    'getRectangularArea': function (upperLeft, lowerRight) {
      if (upperLeft.x > lowerRight.x || upperLeft.y > lowerRight.y)
        return 0;
      return ((lowerRight.x + 1) - (upperLeft.x)) * ((lowerRight.y + 1) - (upperLeft.y));
    }
  };
};

},{}],84:[function(require,module,exports){
/**
 *
 * This module provides routines dealing with json data.
 *
 * @module dex/json
 *
 */

module.exports = function json(dex) {

  return {
    /**
     * Converts JSON and a header to a CSV file.  It is used for parallel coordinate brush
     * events where the selected brush must be published to events as a csv.
     *
     * For example, given:
     *
     * json   = [ { A: 1, B: 3, C: 5, D: 7 },
     *            { A: 2, B: 4, C: 6, D: 8 } ];
     * header = [ 'A', 'B', 'C', 'D' ];
     *
     * This will return a csv where:
     *
     * csv = { header: [ 'A', 'B', 'C', 'D' ],
 *         data    [[ 1, 4, 5, 7 ], [ 2, 4, 6, 8 ]];
 *
     * @param json
     * @param header
     * @returns {*}
     */
    'toCsv': function (json, header) {
      var csv;
      var ri, ci;
      var data = [];

      // Keys are provided.
      if (arguments.length == 2) {
        if (Array.isArray(json)) {
          for (ri = 0; ri < json.length; ri++) {
            var row = [];
            for (ci = 0; ci < header.length; ci++) {
              row.push(json[ri][header[ci]]);
            }
            data.push(row);
          }
        }
        else {
          var row = [];
          for (ci = 0; ci < header.length; ci++) {
            row.push(json[ri][header[ci]]);
          }
          data.push(row);
        }
        return dex.csv.csv(header, data);
      }
      else {
        return dex.json.toCsv(json, dex.json.keys(json));
      }
    },

    /**
     * Returns all keys found in a json structure or array of json structures.
     *
     * @param json  The json structure or array of json structures.
     * @returns {Array} A list of keys found within json.
     *
     */
    'keys': function (json) {
      var keyMap = {};
      var keys = [];
      var ri, key;

      if (Array.isArray(json)) {
        for (ri = 0; ri < json.length; ri++) {
          for (key in json[ri]) {
            keyMap[key] = true;
          }
        }
      }
      else {
        for (key in json) {
          keyMap[key] = true;
        }
      }

      for (key in keyMap) {
        keys.push(key);
      }

      return keys;
    },

    'toString' : function(json) {
      return JSON.stringify(json);
    },

    'log' : function(json) {
      dex.console.log(dex.json.toString(json));
    }
  };
};

},{}],85:[function(require,module,exports){
/**
 *
 * This module provides routines dealing with matrices.
 *
 * @module dex/matrix
 *
 */

module.exports = function matrix(dex) {

  return {
    /**
     *
     * Return the specified slice of the matrix.  The original matrix is
     * not altered.
     *
     * @param {matrix} matrix The matrix to be sliced.
     * @param {Array.<number>} columns - An array of column indices to include within the slice.
     * @param {number} [rows] If supplied, the slice will consist only of the specified
     * number of rows.
     *
     * @returns {matrix}
     */
    'slice': function (matrix, columns, rows) {
      var matrixSlice = new Array(0);
      //dex.console.log("PRE-SLICE (matrixSlize):" + matrixSlice);
      var ri;

      if (arguments.length === 3) {
        for (ri = 0; ri < rows.length; ri++) {
          matrixSlice.push(dex.array.slice(matrix[rows[ri]]));
        }
      }
      else {
        for (ri = 0; ri < matrix.length; ri++) {
          //dex.console.log("MATRIX-SLICE-BEFORE[" + ri + "]:" + matrixSlice);
          matrixSlice.push(dex.array.slice(matrix[ri], columns));
          //dex.console.log("MATRIX-SLICE-AFTER[" + ri + "]" + matrixSlice);
        }
      }
      return matrixSlice;
    },

    /**
     *
     * Returns a matrix consisting of unique values relative to each
     * column.
     *
     * @param {matrix} matrix The matrix to evaluate.
     * @param columns The column or array of columns indexes to slice.
     *
     * @returns {Array.<Array.<Object>>} The unique values relative to each column. In the form
     * of [[ column 1 unique values], [column 2 unique values], ...]]
     *
     */
    'uniques': function (matrix, columns) {

      if (arguments.length === 2) {
        if (dex.object.isNumeric(columns)) {
          return dex.matrix.uniques(dex.matrix.slice(matrix, [columns]))[0];
        }
        else {
          return dex.matrix.uniques(dex.matrix.slice(matrix, columns));
        }
      }

      var ci;
      var uniques = [];
      var tmatrix = dex.matrix.transpose(matrix);
      var ncol = tmatrix.length;

      for (ci = 0; ci < ncol; ci += 1) {
        uniques.push(_.uniq(tmatrix[ci]));
      }
      return uniques;
    },

    /**
     *
     * Returns a transposed matrix where the rows of the new matrix are transposed
     * with it's columns.
     *
     * @param {matrix} matrix - The matrix to transpose.
     *
     * @returns {matrix} The transposed matrix, leaving the original matrix untouched.
     *
     * @example {@lang javascript}
     * // Returns [['R1C1', 'R2C1', 'R3C1'], ['R1C2', 'R2C2', 'R3C2' ]]
     * transpose([['R1C1', 'R1C2'], ['R2C1', 'R2C2], ['R3C1', 'R3C2']]);
     *
     */
    'transpose': function (matrix) {
      var ci;
      var ncols;
      var transposedMatrix = [];
      //dex.console.log("Transposing:", matrix);

      if (!matrix || matrix.length <= 0 || !matrix[0] || matrix[0].length <= 0) {
        return [];
      }

      ncols = matrix[0].length;

      for (ci = 0; ci < ncols; ci++) {
        transposedMatrix.push(matrix.map(function (row) {
          return row[ci];
        }));
      }

      return transposedMatrix;
    },

    /**
     *
     * Return a flattened version of the matrix.
     *
     * @param {matrix} matrix - The matrix to flatten.
     *
     * @returns {Array.<Object>} A flattened version of the matrix.
     *
     * @example {@lang javascript}
     * // Define a simple matrix.
     * var matrix = [['r1c1', 'r1c2'], ['r2c1', 'r2c2']]
     *
     * // Returns: ['r1c1', 'r1c2', 'r2c1', 'r2c2']
     * flatten(matrix);
     *
     */
    'flatten': function (matrix) {
      return _.flatten(matrix);
    },

    /**
     *
     * Returns an array of the minimum and maximum value in the form of: [min,max]
     * from the specified subset of the matrix.
     *
     * @param {matrix} matrix - The matrix to scan.
     * @param {Array.<number>|number] [indices] - When supplied, will contrain the extent
 * search to just those columns specified by this list of indices.
 *
     * @returns {Array.<number>} An array of two elements: [ min, max ]
     *
     */
    'extent': function (matrix, indices) {
      var values = matrix;

      if (arguments.length === 2) {
        if (dex.object.isNumeric(indices)) {
          values = dex.matrix.flatten(dex.matrix.slice(matrix, [indices]));
        }
        else {
          values = dex.matrix.flatten(dex.matrix.slice(matrix, indices));
        }
        var max = Math.max.apply(null, values);
        var min = Math.min.apply(null, values);
        return [min, max];
      }
    },

    /**
     *
     * Combine each column in matrix1 with each column in matrix2.
     *
     * @param {matrix} matrix1 The first matrix to combine.
     * @param {matrix} matrix2 The second matrix to combine.
     *
     * @returns {matrix} The combined matrix.
     *
     * @example {@lang javascript}
     * var matrix1 = [['m1r1c1', 'm1r1c2'], ['m1r2c1', 'm1r2c2']]
     * var matrix2 = [['m2r1c1', 'm2r1c2'], ['m2r2c1', 'm2r2c2']]
     *
     * // Returns: [['m1r1c1', 'm1r1c2', 'm2r1c1', 'm2r1c2'], ['m1r2c1', 'm1r2c2', 'm2r2c1', 'm2r2c2']]
     * var result = combine(matrix1, matrix2);
     *
     */
    'combine': function (matrix1, matrix2) {
      var result = _.clone(matrix1);

      var ri;

      for (ri = 0; ri < matrix2.length; ri++) {
        result[ri] = result[ri].concat(matrix2[ri]);
      }

      return result;
    },

    /**
     *
     * Return a copy of the supplied matrix.
     *
     * @param {matrix} matrix The matrix to copy.
     *
     * @returns {Array} A copy of the original matrix.
     *
     */
    'copy': function (matrix) {
      return matrix.map(function (row) {
        return _.clone(row);
      });
    },

    /**
     *
     * Insert a new column at position 0 within this matrix which will contain
     * integer values starting at 1, 2, 3, ...  This is useful if your dataset
     * lacks an existing unique index.
     *
     * @param {matrix} matrix - The matrix to index.
     * @returns {matrix} A copy of the original matrix with the index inserted.
     *
     */
    'addIndex': function (matrix) {
      var indexMatrix = dex.matrix.copy(matrix);

      for (var ri = 0; ri < matrix.length; ri++) {
        indexMatrix[ri].unshift(ri + 1);
      }

      return indexMatrix;
    },

    /**
     *
     * Determine whether the supplied columnNum within the supplied matrix is
     * numeric or not.
     *
     * @param {matrix} matrix - The matrix to evaluate.
     * @param {number} columnNum - The column within the matrix to evaluate.
     *
     * @returns {boolean} True if the column is numeric, false otherwise.
     *
     */
    'isColumnNumeric': function (matrix, columnNum) {
      for (var i = 0; i < matrix.length; i++) {
        if (!_.isNumber(matrix[i][columnNum])) {
          return false;
        }
      }
      return true;
    },

    /**
     *
     * Return the maximum value of the specified columnNum within the
     * supplied matrix.
     *
     * @param matrix The matrix to evaluate.
     * @param columnNum The column number within the matrix to evaluate.
     * @returns {*} The maximum value of the specified column within the
     * supplied matrix.
     *
     */
    'max': function (matrix, columnNum) {
      var maxValue = matrix[0][columnNum];
      var i;

      if (dex.matrix.isColumnNumeric(matrix, columnNum)) {
        maxValue = parseFloat(matrix[0][columnNum]);
        for (i = 1; i < matrix.length; i++) {
          if (maxValue < parseFloat(matrix[i][columnNum])) {
            maxValue = parseFloat(matrix[i][columnNum]);
          }
        }
      }
      else {
        for (i = 1; i < matrix.length; i++) {
          if (maxValue < matrix[i][columnNum]) {
            maxValue = matrix[i][columnNum];
          }
        }
      }

      return maxValue;
    },

    /**
     *
     * Return the minimum value of the specified columnNum within the
     * supplied matrix.
     *
     * @param {matrix} matrix - The matrix to evaluate.
     * @param {number} columnNum - The column number within the matrix to evaluate.
     * @returns {number} The minimum value of the specified column within the
     * supplied matrix.
     *
     */
    'min': function (matrix, columnNum) {
      var minValue = matrix[0][columnNum];
      var i;

      if (dex.matrix.isColumnNumeric(matrix, columnNum)) {
        minValue = parseFloat(matrix[0][columnNum]);
        for (i = 1; i < matrix.length; i++) {
          if (minValue > parseFloat(matrix[i][columnNum])) {
            minValue = parseFloat(matrix[i][columnNum]);
          }
        }
      }
      else {
        for (i = 1; i < matrix.length; i++) {
          if (minValue > matrix[i][columnNum]) {
            minValue = matrix[i][columnNum];
          }
        }
      }

      return minValue;
    }
  };
};

},{}],86:[function(require,module,exports){
/**
 *
 * This module provides routines dealing with javascript objects.
 *
 * @module dex/object
 *
 */

module.exports = function object(dex) {

  return {
    /**
     *
     * Return the local keys of this object without the inherited ones.
     *
     * @param obj The object whose local keys we are interested in.
     *
     * @returns {Array} An array of 0 or more local keys.
     */
    'keys': function keys(obj) {
      var keys = [];

      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          keys.push(key);
        }
      }

      return keys;
    },

    /**
     *
     * A pretty good, but imperfect mechanism for performing a deep
     * clone of an object.
     *
     * @param obj The object to clone.
     * @returns {*} The cloned object.
     *
     */
    'clone': function clone(obj) {
      var i, attr, len;

      // Handle the 3 simple types, and null or undefined
      if (null == obj || "object" != typeof obj)
        return obj;

      // Handle Date
      if (obj instanceof Date) {
        var copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
      }

      // Handle Array
      if (obj instanceof Array) {
        var copy = [];
        for (i = 0, len = obj.length; i < len; i++) {
          copy[i] = dex.object.clone(obj[i]);
        }
        return copy;
      }

      // DOM Nodes are nothing but trouble.
      if (dex.object.isElement(obj) ||
        dex.object.isNode(obj)) {
        return obj;
      }

      // Handle Object
      if (obj instanceof Object) {
        var copy = {};
        //jQuery.extend(copy, obj);
        for (attr in obj) {
          if (obj.hasOwnProperty(attr)) {
            copy[attr] = dex.object.clone(obj[attr]);
            //copy[attr] = obj[attr];
          }
        }
        return copy;
      }

      throw new Error("Unable to copy obj! Its type isn't supported.");
    },

    /**
     *
     * Kind of misleading.  This really signals when expand should quit
     * expanding.  I need to clean this up.
     *
     * @param obj
     * @returns {boolean}
     */
    'isEmpty': function isEmpty(obj) {
      //dex.console.log("isEmpty(" + obj + ") typeof=" + (typeof obj));
      if (!obj || obj instanceof Array) {
        return true;
      }
      if ("object" == typeof obj) {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            //dex.console.log("OBJ: ", obj, " contains key '" + key + "'");
            return false;
          }
        }
      }

      return true;
    },

    /**
     *
     * Overlay the top object on top of the bottom.  This method will first clone
     * the bottom object.  Then it will drop the values within the top object
     * into the clone.
     *
     * @param {Object} top - The object who's properties will be on top.
     * @param {Object} bottom - The object who's properties will be on bottom.
     * @return {Object} The overlaid object where the properties in top override
     *                  properties in bottom.  The return object is a clone or
     *                  copy.
     *
     */
    'overlay': function overlay(top, bottom) {
      // Make a clone of the bottom object.
      var overlay = dex.object.clone(bottom);
      var prop;

      // If we have parameters in the top object, overlay them on top
      // of the bottom object.
      if (top !== 'undefined') {
        // Iterate over the props in top.
        for (prop in top) {
          // Arrays are special cases. [A] on top of [A,B] should give [A], not [A,B]
          if (typeof top[prop] == 'object' && overlay[prop] != null && !(top[prop] instanceof Array)) {
            //console.log("PROP: " + prop + ", top=" + top + ", overlay=" + overlay);
            overlay[prop] = dex.object.overlay(top[prop], overlay[prop]);
          }
          // Simply overwrite for simple cases and arrays.
          else {
            overlay[prop] = top[prop];
          }
        }
      }

      //console.dir(config);
      return overlay;
    },

    /**
     *
     * This method returns whether or not the supplied object is a Node.
     *
     * @param {Object} obj - The object to test.
     *
     * @returns {boolean} True if obj is a Node, false otherwise.
     *
     */
    'isNode': function isNode(obj) {
      return (
        typeof Node === "object" ? obj instanceof Node :
          obj && typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string"
      );
    },

    /**
     *
     * This method returns whether or not the supplied object is a
     * DOM node.
     *
     * @param {Object} obj - The object to test.
     *
     * @returns {boolean} - True if obj is a DOM node, false otherwise.
     *
     */
    'isElement': function isElement(obj) {
      return (
        typeof HTMLElement === "object" ? obj instanceof HTMLElement : //DOM2
          obj && typeof obj === "object" && obj.nodeType === 1 && typeof obj.nodeName === "string"
      );
    },

    /**
     *
     * This method returns a boolean representing whether obj is contained
     * within container.
     *
     * @param {Object} container - The container to test.
     * @param {Object} obj - The object to test.
     *
     * @return True if container contains obj.  False otherwise.
     */
    'contains': function contains(container, obj) {
      var i = container.length;
      while (i--) {
        if (container[i] === obj) {
          return true;
        }
      }
      return false;
    },

    /**
     *
     * Return whether or not the supplied object is a function.
     *
     * @param obj The object to check.
     * @returns {boolean} True if obj is a function, false otherwise.
     *
     */
    'isFunction': function isFunction(obj) {
      //return typeof obj === 'function';
      return (typeof obj === "function");
    },

    /**
     *
     * @param map
     * @param values
     * @returns {exports}
     */
    'connect': function connect(map, values) {
      //dex.console.log("map:", map, "values:", values);

      if (!values || values.length <= 0) {
        return this;
      }
      if (!map[values[0]]) {
        map[values[0]] = {};
      }
      dex.object.connect(map[values[0]], values.slice(1));

      return this;
    },

    /**
     *
     * @param obj
     * @returns {boolean}
     */
    'isNumeric': function (obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },

    /**
     *
     * @param hierarchy
     * @param name
     * @param value
     * @param delimiter
     * @returns {*}
     */
    'setHierarchical': function (hierarchy, name, value, delimiter) {
      if (hierarchy == null) {
        hierarchy = {};
      }

      if (typeof hierarchy != 'object') {
        return hierarchy;
      }

      // Create an array of names by splitting delimiter, then call
      // this function in the 3 argument (Array of paths) context.
      if (arguments.length == 4) {
        return dex.object.setHierarchical(hierarchy,
          name.split(delimiter), value);
      }

      // Array of paths context.
      else {
        // This is the last variable name, just set the value.
        if (name.length === 1) {
          hierarchy[name[0]] = value;
        }
        // We still have to traverse.
        else {
          // Undefined container object, just create an empty.
          if (!(name[0] in hierarchy)) {
            hierarchy[name[0]] = {};
          }

          // Recursively traverse down the hierarchy.
          dex.object.setHierarchical(hierarchy[name[0]], name.splice(1), value);
        }
      }

      return hierarchy;
    },

    'isArray' : function(obj)
    {
      return Array.isArray(obj);
    },

    'getHierarchical': function (hierarchy, name) {
      //dex.console.log("getHierarchical", hierarchy, name);
      if ((typeof hierarchy) == "undefined" ||
        (typeof name == "undefined")) {
        return undefined;
      }
      var nsIndex = name.indexOf(".");
      if (nsIndex >= 0) {
        var key = name.substring(0, nsIndex);
        var remainingKey = name.substring(nsIndex+1);
        //dex.console.log("NAME: ", key, remainingKey);
        return dex.object.getHierarchical(hierarchy[key], remainingKey);
      }
      else
      {
        return hierarchy[name];
      }
    },

    'getValue' : function(hierarchy, name, defaultValue) {
      return dex.object.getHierarchical(hierarchy, name) || defaultValue;
    }

  };
};


},{}],87:[function(require,module,exports){
var configurationpane = function (userConfig) {
  var pane;
  var componentMap = {};
  var targetList = {};

  var defaults = {
    // The parent container of this pane.
    'parent': null,
    'id': 'ConfigurationPaneId',
    'class': 'ConfigurationPaneClass',
    'components': []
  };

  pane = new dex.component(userConfig, defaults);

  pane.render = function () {
    var config = pane.config;
    d3.selectAll(config.parent).selectAll("*").remove();

    var $parent = $(config.parent);
    var $configPane = $("<div></div>")
      .attr("id", config["id"])
      .addClass(config["class"]);

    var $panelGroup = $("<div></div>")
      .addClass("panel-group")
      .attr("id", "control-group");
    var $panel = $("<div></div>")
      .addClass("panel")
      .addClass("panel-default");
    var $panelHeading = $("<div></div>")
      .addClass("panel-heading")
      .append($("<h1></h1>")
        .addClass("panel-title")
        .append($("<a></a>"))
        .attr("data-toggle", "collapse")
        .attr("href", "#collapse-config-pane")
        .text("Configuration"));
    var $panelCollapser = $("<div></div>")
      .attr("id", "collapse-config-pane")
      .addClass("panel-collapse")
      .addClass("collapse")
      .addClass("in");
    var $panelBody = $("<div></div>")
      .addClass("panel-body");

    // Create the data filter parent
    var dataFilterParent = config["id"] + "_DataFilterParent";
    var $dataFilterParent = $("<div></div>")
      .attr("id", dataFilterParent);

    // Create the gui pane parent
    var guiParent = config["id"] + "_GuiParent";
    var $guiParent = $("<div></div>")
      .attr("id", guiParent);

    $panelBody.append($dataFilterParent, $guiParent);
    $panelCollapser.append($panelBody);
    $panel.append($panelHeading);
    $panel.append($panelCollapser);
    $panelGroup.append($panel);

    // Add elements to config pane.
    $configPane.append($panelGroup);
    $parent.append($configPane);

    var dataFilterPane = dex.ui.DataFilterPane({
      parent: "#" + dataFilterParent,
      csv: config.csv
    });
    dataFilterPane.render();

    var guiPane = dex.ui.GuiPane({
      parent: "#" + guiParent,
      components: config.components
    }).render();

    config.components.forEach(function (component) {
      dex.console.log("Component Subscription: ", component, dataFilterPane);
      component.subscribe(dataFilterPane, "select", function (msg) {
        dex.console.log("Component: " + component.config.id + " received select csv event");
        component.attr('csv', msg.selected);
        component.render();
      });
    });

    config.dataFilterPane = dataFilterPane;

    $("#" + dataFilterParent + " .panel-collapse")
      .collapse({hide: true});

    $("#" + guiParent + " .control-group .control-group .panel-collapse")
      .collapse({hide: true});

    return pane;
  };

  pane.update = function () {
    return pane;
  };

  $(document).ready(function () {
    // Make the entire pane draggable.
    //$(pane.config.parent).draggable();
  });

  return pane;
};

module.exports = configurationpane;
},{}],88:[function(require,module,exports){
var datafilterpane = function (userConfig) {
  var chart;
  var selectedCategories = {};
  var selectedRanges = {};
  var defaults = {
    // The parent container of this chart.
    'parent': null,
    'id': 'DataFilterPaneId',
    'class': 'DataFilterPaneClass',
    'width': "30%",
    'height': "30%",
    'csv': undefined
  };

  chart = new dex.component(userConfig, defaults);

  chart.render = function () {
    var config = chart.config;
    var csv = config.csv;
    d3.selectAll(config.parent).selectAll("*").remove();

    var $parent = $(config.parent);
    var $dataFilterPane = $("<div></div>")
      .attr("id", config["id"])
      .addClass(config["class"]);

    var $panelGroup = $("<div></div>")
      .addClass("panel-group")
      .attr("id", "control-group");
    var $panel = $("<div></div>")
      .addClass("panel")
      .addClass("panel-default");
    var $panelHeading = $("<div></div>")
      .addClass("panel-heading")
      .append($("<h2></h2>")
        .addClass("panel-title")
        .append($("<a></a>"))
        .attr("data-toggle", "collapse")
        .attr("href", "#collapse-data-filter-pane")
        .text("Data Filters"));
    var $panelCollapser = $("<div></div>")
      .attr("id", "collapse-data-filter-pane")
      .addClass("panel-collapse")
      .addClass("collapse")
      .addClass("in");
    var $panelBody = $("<div></div>")
      .addClass("panel-body");

    var $root = $("<div></div>");

    // Add the column selector.
    $root.append("<h3>Select Columns</h3>");
    var selector = "<select multiple='multiple' " +
      "id='ColumnSelector'>";
    csv.header.forEach(function (header, hi) {
      selector += "<option value='" + header + "' selected='selected'>" +
        header + "</option>";
    });
    selector += "</select><br>";
    $root.append(selector);

    var gtypes = dex.csv.guessTypes(config.csv);

    if (gtypes.indexOf("string") > -1) {
      $root.append("<div><h3>Categorical Filters</h3>");

      //dex.console.log("GTYPES", gtypes);

      csv.header.forEach(function (header, hi) {
        switch (gtypes[hi]) {
          case "string": {
            selectedCategories[header] = {};
            selector = "<select multiple='multiple' " +
              "id='" + header + "' " +
              "class='" + config["class"] + "_category'>";
            var colValues = dex.csv.uniqueArray(config.csv, hi);
            colValues.forEach(function (colVal) {
              selectedCategories[header][colVal] = true;
              selector += "<option value=\"" + colVal + "\">" +
                colVal + "</option>";
            });
            selector += "</select></div><br>";
            $root.append(selector);
            break;
          }
        }
      });
    }

    if (gtypes.indexOf("number") > -1) {
      $root.append("<div><br><h3>Numeric Filters</h3>");
      csv.header.forEach(function (header, hi) {
        switch (gtypes[hi]) {
          case "number": {
            var extents = dex.csv.extent(csv, [hi]);
            var step = Math.min(Math.abs(extents[1] - extents[0]) * .01, 1);
            if (step != 0 && Math.log(step) < 0) {
              //dex.console.log("Adjusting precision: " + Math.log(step), Math.abs(extents[1] - extents[0]), extents[1], extents[0]);
              step = step.toPrecision(Math.abs(Math.floor(Math.log(step))));
            }
            //dex.console.log("STEP: ", step);
            selectedRanges[header] = {min: extents[0], max: extents[1]};
            var sliderStr = "<h5>" + header + "</h5>" +
              "<input id='" + header + "' " +
              "class='" + config["class"] + "_number' " +
              "type='text' class='span2' value='' " +
              "data-slider-min='" + extents[0] + "' data-slider-max='" +
              extents[1] + "' data-slider-value='[" + extents[0] +
              "," + extents[1] + "]' data-slider-step='" + step + "'/>" +
              "</center></div>";
            $root.append(sliderStr);
            break;
          }
        }
      });
    }

    $panelBody.append($root);
    $panelCollapser.append($panelBody);
    $panel.append($panelHeading);
    $panel.append($panelCollapser);
    $panelGroup.append($panel);
    $dataFilterPane.append($panelGroup);
    $parent.append($dataFilterPane);

    //dex.console.log("NAMESPACES: ", $.uix);
    var columnSelector = $(config.parent + ' #ColumnSelector').listSelectView({
      sortable: true,
      splitRatio: .5
    });

    columnSelector.on('multiselectChange', function (evt, ui) {
      updateCsv();
    });

    columnSelector.on('multiselectReordered', function (evt, ui) {
      updateCsv();
    });

    $(config.parent + ' #UpdateColumns').on('click', function (evt) {
      updateCsv();
    });

    // Enable category selectors
    var categoryFilters = $(config.parent + ' .' + config["class"] + "_category");

    if (categoryFilters.length > 0) {
      categoryFilters.multiselect({
          includeSelectAllOption: true,
          allSelectedText: 'All',
          enableFiltering: true,
          enableFullValueFiltering: true,
          onSelectAll: function (option) {
            //dex.console.log("SELECT-ALL", option);
            updateCsv();
          },
          buttonText: function (options, select) {
            //dex.console.log("OPTIONS", options, "SELECT", select[0]);
            if (options !== undefined && select !== undefined && select.length > 0) {

              if (options.length == select[0].children.length) {
                return select[0].id + ": All (" + select[0].children.length + ")";
              }
              else {
                return select[0].id + ": " + options.length + " of " + select[0].children.length;
              }
            }
            else {
              return "Undefined";
            }
          },
          onChange: function (option, checked, select) {
            updateCsv();
          }
        }
      );


      categoryFilters.multiselect('selectAll', false);
      categoryFilters.multiselect('updateButtonText', false);
    }

    // Enable sliders:
    var numericFilters = $(config.parent + ' .' + config["class"] + "_number");
    if (numericFilters.length > 0) {
      numericFilters.each(function (i, obj) {
        var slider = new dex.ui.BootstrapSlider(obj, {});
        slider.on('slideStop', function (value) {
          selectedRanges[obj.id] = {min: value[0], max: value[1]};
          updateCsv();
        });
      })
    }

    function updateCsv() {
      var selected = columnSelector.find('option:selected');
      var selectedColumns = [];
      var i;

      if (selected !== undefined && selected.length > 0) {
        for (i = 0; i < selected.length; i++) {
          selectedColumns.push(selected[i].innerText);
        }
      }
      //dex.console.log("SELECTED-COLUMNS", selectedColumns);
      // Update the selection map
      $(config.parent + ' .' + config["class"] + "_category").each(function (i, obj) {
        var colMap = {};

        getSelectValues(obj).forEach(function (val) {
          colMap[val] = true;
        });
        selectedCategories[obj.id] = colMap;
      });

      // Update the csv based upon the selection map
      var selectedCsv = dex.csv.selectRows(config.csv, function (row) {
        return row.every(function (col, ci) {
          var header = config.csv.header[ci];
          if (selectedCategories[header]) {
            if (!selectedCategories[header][col]) {
              return false;
            }
            else {
              return true;
            }
          }
          else if (selectedRanges[config.csv.header[ci]]) {
            return (col >= selectedRanges[config.csv.header[ci]].min &&
            col <= selectedRanges[config.csv.header[ci]].max);
          }
          return true;
        });
      });


      //dex.console.log("SELECTED", selectedCsv);
      // Publish the selected subset of the csv.
      chart.publish({"type": "select", "selected": dex.csv.include(selectedCsv, selectedColumns)});
    }

    function getSelectValues(select) {
      var result = [];
      var options = select && select.options;
      var opt;

      for (var i = 0, iLen = options.length; i < iLen; i++) {
        opt = options[i];

        if (opt.selected) {
          result.push(opt.value || opt.text);
        }
      }
      return result;
    }

    return chart;
  };

  chart.update = function () {
    return chart;
  };


  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();

  });

  // This fixes a JQueryUI/Bootstrap icon conflict.
  if ($.fn.button.noConflict != undefined) {
    $.fn.button.noConflict();
  }

  return chart;
};

module.exports = datafilterpane;
},{}],89:[function(require,module,exports){
var guipane = function (userConfig) {
  var pane;
  var componentMap = {};
  var targetList = {};

  var defaults = {
    // The parent container of this pane.
    'parent': null,
    'id': 'GuiPaneId',
    'class': 'GuiPaneClass',
    'components': []
  };

  pane = new dex.component(userConfig, defaults);

  pane.render = function () {
    var config = pane.config;
    d3.selectAll(config.parent).selectAll("*").remove();

    $(config.parent).append("<div id='" + config['id'] + "' class='" +
      config['class'] + "'>");
    var root = $(config.parent + "> #" + config.id);

    config.components.forEach(function (component) {
      componentMap[component.config.parent + " #" + component.config["id"] +
      "." + component.config["class"]] = component;
    });

    addControls(root, config.components);

    // Enable color selectors.
    var $pickers = $(config.parent + ' .control-color input');

    //dex.console.log("PICKERS", $pickers);

    $pickers.spectrum({
      change: function (color) {
        //dex.console.log("COLOR-CHANGE", color, this);
        //$("#basic-log").text("change called: " + color.toHexString());
        var cmp = componentMap[this.getAttribute("targetComponent")];
        var attName = this.getAttribute("targetAttribute");
        var value = color.toHexString();
        cmp.attrSave(attName, value).render()();
      }
    });


    // Enable toggles:
    var $toggles = $(config.parent + ' .control-boolean input');
    $toggles.bootstrapToggle();

    $toggles.change(function () {
      var obj = $(this);
      //dex.console.log("TOGGLE CHANGE:", obj);
      var cmp = componentMap[obj[0].getAttribute("targetComponent")];
      var attName = obj[0].getAttribute("targetAttribute");
      var value = obj.prop('checked');
      cmp.attrSave(attName, value).render()();
    });

    var $choices = $(config.parent + ' .control-choice select');
    $choices.multiselect({
      includeSelectAllOption: true,
      allSelectedText: 'All',
      enableFiltering: true,
      enableFullValueFiltering: true,
      onChange: function (option, checked, select) {
        //dex.console.log("CHANGE", option, checked);
        if (checked) {
          var cmp = componentMap[option[0].getAttribute("targetComponent")];
          var attName = option[0].getAttribute("targetAttribute");
          cmp.attrSave(attName, option[0].getAttribute("value")).render()();
        }
      }
    });

    $choices.multiselect('updateButtonText', false);

    // Enable String Input
    var stringInputs = $(config.parent + ' .control-string input');
    if (stringInputs.length > 0) {
      stringInputs.on('input', function (event) {
        var cmp = componentMap[event.target.getAttribute("targetComponent")];
        var attName = event.target.getAttribute("targetAttribute");
        cmp.attr(attName, event.target.value).render()();
      });
    }

    // Enable float sliders
    var floatSliders = $(config.parent + ' .control-float input');
    if (floatSliders.length > 0) {
      floatSliders.each(function (i, obj) {
        var slider = new dex.ui.BootstrapSlider(obj, {});
        slider.on('slideStop', function (value) {
          //dex.console.log("TARGET", obj.getAttribute("targetComponent"), componentMap);
          var targetComponent = componentMap[obj.getAttribute("targetComponent")];
          var targetAttribute = obj.getAttribute("targetAttribute");
          targetComponent.attr(targetAttribute, +value).render()();
          //dex.console.log("FLOAT-SLIDER", targetComponent, targetAttribute, value);
        });
      });
    }

    // Enable integer sliders
    var intSliders = $(config.parent + ' .control-int input');
    if (intSliders.length > 0) {
      intSliders.each(function (i, obj) {
        var slider = new dex.ui.BootstrapSlider(obj, {});
        slider.on('slideStop', function (value) {
          //dex.console.log("TARGET", obj.getAttribute("targetComponent"), componentMap);
          var targetComponent = componentMap[obj.getAttribute("targetComponent")];
          var targetAttribute = obj.getAttribute("targetAttribute");
          targetComponent.attr(targetAttribute, +value).render()();
          //dex.console.log("FLOAT-SLIDER", targetComponent, targetAttribute, value);
        });
      });
    }

    return pane;
  };

  pane.update = function () {
    return pane;
  };

  function getTargetName(name) {
    var targetName = name.replace(/[\. #:]/g, '-');

    //dex.console.log("NAME(" + name + ")->" + targetName);

    if (targetList[targetName] === undefined) {
      targetList[targetName] = 1;
    }
    else {
      targetList[targetName]++;
    }

    return targetName + "-" + targetList[targetName];
  }

  function addControls($target, components) {
    // Used to ensure all target names are unique.
    targetList = {};

    var $panelGroup = $("<div></div>")
      .addClass("panel-group")
      .addClass("control-group");

    var $panel = $("<div></div>")
      .addClass("panel")
      .addClass("panel-default");
    var $panelHeading = $("<div></div>")
      .addClass("panel-heading")
      .append($("<h2></h2>")
        .addClass("panel-title")
        .append($("<a></a>"))
        .attr("data-toggle", "collapse")
        .attr("href", "#collapse-gui-pane")
        .text("GUI Configuration"));
    var $panelCollapser = $("<div></div>")
      .attr("id", "collapse-gui-pane")
      .addClass("panel-collapse")
      .addClass("collapse")
      .addClass("in");
    var $panelBody = $("<div></div>")
      .addClass("panel-body");

    components.forEach(function (component) {
      var targetComponent = component.config.parent + " #" +
        component.config["id"] + "." + component.config["class"];
      addControl(targetComponent, $panelBody, component.getGuiDefinition(), 0);
    });

    $panelCollapser.append($panelBody);
    $panel.append($panelHeading);
    $panel.append($panelCollapser);
    $panelGroup.append($panel);

    $target.append($panelGroup);
  }

  function getHeading(depth) {
    if (depth === undefined || depth <= 0) {
      return "<h1></h1>";
    }
    else if (depth == 1) {
      return "<h3></h3>";
    }
    else if (depth == 2) {
      return "<h4></h4>";
    }
    else {
      return "<h5></h5>";
    }
  }

  function addControl(targetComponent, $targetElt, guiDef, depth) {

    if (guiDef === undefined || guiDef.type === undefined) {
      return;
    }

    switch (guiDef.type) {
      case "group" :
        addGroup(targetComponent, $targetElt, guiDef, depth+1);
        break;
      case "string" :
        addString(targetComponent, $targetElt, guiDef, depth);
        break;
      case "float" :
        addFloat(targetComponent, $targetElt, guiDef, depth);
        break;
      case "int" :
        addInt(targetComponent, $targetElt, guiDef, depth);
        break;
      case "boolean" :
        addBoolean(targetComponent, $targetElt, guiDef, depth);
        break;
      case "choice" :
        addChoice(targetComponent, $targetElt, guiDef, depth);
        break;
      case "color" :
        addColor(targetComponent, $targetElt, guiDef, depth);
        break;
      default:
        // Choice, color
        dex.console.log("UNRECOGNIZED CONTROL TYPE: '" + guiDef.type + "'");
        break;
    }
  }

  function addGroup(targetComponent, $targetElt, guiDef, depth) {
    //dex.console.log("GROUP", guiDef);

    var groupTarget = getTargetName(
      targetComponent + ":" + guiDef.name);

    var $panelGroup = $("<div></div>")
      .addClass("panel-group")
      .addClass("control-group");

    var $panel = $("<div></div>")
      .addClass("panel")
      .addClass("panel-default");
    var $panelHeading = $("<div></div>")
      .addClass("panel-heading")
      .append($(getHeading(depth))
        .addClass("panel-title")
        .append($("<a></a>"))
        .attr("data-toggle", "collapse")
        .attr("href", "#collapse-target-" + groupTarget)
        .text(guiDef.name));
    var $panelCollapser = $("<div></div>")
      .attr("id", "collapse-target-" + groupTarget)
      .addClass("panel-collapse")
      .addClass("collapse")
      .addClass("in");
    var $panelBody = $("<div></div>")
      .addClass("panel-body");

    guiDef.contents.forEach(function (contentDef) {
      addControl(targetComponent, $panelBody, contentDef, depth);
    });

    $panelCollapser.append($panelBody);
    $panel.append($panelHeading);
    $panel.append($panelCollapser);
    $panelGroup.append($panel);

    $targetElt.append($panelGroup);
  }

  function addColor(targetComponent, $targetElt, guiDef, depth) {

    $container = $("<div></div>")
      .addClass("control-color");

    $label = $("<label></label>")
      .attr("title", guiDef.description)
      .html("<strong>" + guiDef.name + ": </strong>");
    $picker = $("<input></input>")
      .attr("type", "color")
      .attr("value", guiDef.initialValue)
      .attr("targetAttribute", guiDef.target)
      .attr("targetComponent", targetComponent);

    $container.append($label);
    $container.append($picker);

    //dex.console.log("COLOR", guiDef);
    $targetElt.append($container);
  }

  function addChoice(targetComponent, $targetElt, guiDef, depth) {
    var $container = $("<div></div>")
      .addClass("control-choice");
    var $label = $("<label></label>")
      .attr("title", guiDef.description)
      .html("<strong>" + guiDef.name + ": </strong>")

    var $select = $("<select></select>")
      .addClass("control-choice");

    guiDef.choices.forEach(function (choice) {
      var $option = $("<option></option>")
        .attr("value", choice)
        .attr("targetAttribute", guiDef.target)
        .attr("targetComponent", targetComponent)
        .text(choice);

      if (choice === guiDef.initialValue) {
        $option.attr("selected", "selected");
      }

      $select.append($option);
    });

    $container.append($label);
    $container.append($select)

    //dex.console.log("CHOICE", guiDef);
    $targetElt.append($container);
  }

  function addBoolean(targetComponent, $targetElt, guiDef, depth) {

    $checkbox = $("<div></div>")
      .addClass("checkbox")
      .addClass("control-boolean");

    $label = $("<label></label>")
      .attr("title", guiDef.description)
      .html("<strong>" + guiDef.name + ": </strong>");
    $input = $("<input></input>")
      .attr("type", "checkbox")
      .attr("data-toggle", "toggle")
      .attr("targetAttribute", guiDef.target)
      .attr("targetComponent", targetComponent);

    if (guiDef.initialValue == "true") {
      $input.attr("checked");
    }

    $checkbox.append($label);
    $checkbox.append($input);

    //dex.console.log("BOOLEAN", guiDef);
    $targetElt.append($checkbox);
  }

  function addString(targetComponent, $targetElt, guiDef, depth) {

    $form = $("<div></div>")
      .addClass("form")
      .addClass("form-inline")
      .addClass("form-horizontal")
      .addClass("control-string");

    $formGroup = $("<div></div>")
      .addClass("form-group")
      .addClass("control-string");
    $label = $("<label></label>")
      .attr("title", guiDef.description)
      .attr("for", guiDef.target)
      .html("<strong>" + guiDef.name + ": </strong>");

    $input = $("<input></input>")
      .attr("type", "text")
      .attr("targetAttribute", guiDef.target)
      .attr("targetComponent", targetComponent)
      .attr("value", guiDef.initialValue)
      .addClass("form-control")
      .attr("id", guiDef.target);

    $formGroup.append($label);
    $formGroup.append($input);
    $form.append($formGroup);

    //dex.console.log("STRING", guiDef);
    $targetElt.append($form);
  }

  function addFloat(targetComponent, $targetElt, guiDef, depth) {
    //dex.console.log("AddFloat", guiDef);
    $sliderContainer = $("<div></div>")
      .addClass("control-float");

    // Determine an appropriate step
    var step = Math.min(Math.abs(+(guiDef.minValue) - (guiDef.maxValue)) * .01, 1);
    if (step != 0 && Math.log(step) < 0) {
      step = step.toPrecision(Math.abs(Math.floor(Math.log(step))));
    }

    $label = $("<label></label>")
      .attr("title", guiDef.description)
      .html("<strong>" + guiDef.name + ": </strong>");
    $slider = $("<input></input>")
      .attr("type", "text")
      .addClass("span2")
      .attr("value", "")
      .attr("data-slider-min", guiDef.minValue)
      .attr("data-slider-max", guiDef.maxValue)
      .attr("targetAttribute", guiDef.target)
      .attr("targetComponent", targetComponent)
      .attr("data-slider-step", step);

      if (dex.object.isNumeric(guiDef.initialValue)) {
        $slider.attr("data-slider-value", guiDef.initialValue);
      }

    $sliderContainer.append($label);
    $sliderContainer.append($slider);

    $targetElt.append($sliderContainer);
  }

  function addInt(targetComponent, $targetElt, guiDef, depth) {
    //dex.console.log("AddInt", guiDef);
    $sliderContainer = $("<div></div>")
      .addClass("control-int");

    // Determine an appropriate step
    var step = 1;

    $label = $("<label></label>")
      .attr("title", guiDef.description)
      .html("<strong>" + guiDef.name + ": </strong>");
    $slider = $("<input></input>")
      .attr("type", "text")
      .addClass("span2")
      .attr("value", "")
      .attr("data-slider-min", guiDef.minValue)
      .attr("data-slider-max", guiDef.maxValue)
      .attr("targetAttribute", guiDef.target)
      .attr("targetComponent", targetComponent)
      .attr("data-slider-step", step);

    if (dex.object.isNumeric(guiDef.initialValue)) {
      $slider.attr("data-slider-value", guiDef.initialValue);
    }

    $sliderContainer.append($label);
    $sliderContainer.append($slider);

    $targetElt.append($sliderContainer);
  }

  $(document).ready(function () {
    // Make the entire pane draggable.
    //$(pane.config.parent).draggable();
  });

  return pane;
};

module.exports = guipane;
},{}],90:[function(require,module,exports){
var player = function (userConfig) {

  var defaults = {
    // The parent container of this chart.
    'parent': null,
    // Set these when you need to CSS style components independently.
    'id': 'Player',
    'class': 'ui-widget-content',
    'width': 600,
    'height': 100,
    'delay': 1000,
    'frameIndex': 0,
    'csv': {
      header: ['C1', 'C2', 'C3'],
      data: [
        [1, 2, 3],
        [2, 3, 4],
        [3, 4, 5]
      ]
    }
  };

  var chart = new dex.component(userConfig, defaults);
  var config = chart.config;
  var frames;
  var frameNum = 0;

  chart.render = function () {
    var timer;
    var state = "stopped";
    frames = dex.csv.getFramesByIndex(config.csv, config.frameIndex);
    chart.attr("frames", frames);

    dex.console.debug("FRAMES:", frames);

    $(config.parent)
      .append('<div><label>Frame:</label>' +
        '<label id="frameNumber">1 (' + frames.frames[0].header[config.frameIndex] + ')</label>')
      .css('display', 'block')
      .css('text-align', 'center');
    $(config.parent)
      .append("<div id='slider'></div>")
      .css("width", (chart.config.width / 2) + "px")
      .css("margin", "auto");
    // Add our buttons.
    $(config.parent)
      .append("<div id='controls'></div>")
      .css("display", "block")
      .css("text-align", "center");
    $("#controls")
      .append("<button id='beginning'>go to beginning</button>");
    $("#controls")
      .append("<button id='previous'>previous</button>");
    $("#controls")
      .append("<button id='play'>play</button>");
    $("#controls")
      .append("<button id='next'>next</button>");
    $("#controls")
      .append("<button id='end'>go to end</button>");

    $(function () {

      $("#slider").slider({
        value: 1,
        min: 1,
        max: frames.frames.length,
        step: 1,
        classes: {
          "ui-slider": "highlight"
        },
        'slide': function (event, ui) {
          $("#frameNumber").html(ui.value + "foobar")
          gotoFrame(ui.value - 1);

          // Stop playing
          clearTimeout(timer);
          $("#play").button({
            "label": "play",
            "icons": {"primary": "ui-icon-play"}
          });
        }
      });

      $("#beginning").button({
        text: false,
        icons: {
          primary: "ui-icon-seek-start"
        }
      }).click(function () {
        gotoFrame(0);
      });
      $("#previous").button({
        text: false,
        icons: {
          primary: "ui-icon-seek-prev"
        }
      }).click(function () {
        previous();
      });
      $("#play").button({
        text: false,
        icons: {
          primary: "ui-icon-play"
        }
      })
        .click(function () {
          var options;
          if ($(this).text() === "play") {
            options = {
              label: "pause",
              icons: {
                primary: "ui-icon-pause"
              }
            };
            play();
          } else {
            options = {
              label: "play",
              icons: {
                primary: "ui-icon-play"
              }
            };

            clearTimeout(timer);
          }
          $(this).button("option", options);
        });
      $("#next").button({
        text: false,
        icons: {
          primary: "ui-icon-seek-next"
        }
      }).click(function () {
        next();
      });
      $("#end").button({
        text: false,
        icons: {
          primary: "ui-icon-seek-end"
        }
      }).click(function () {
        gotoFrame(frames.frames.length - 1);
      });
    });

    function play() {
      frameNum++;
      gotoFrame((frameNum >= frames.frameIndices.length) ? 0 : frameNum);

      // Set a timer for playing the next frame.
      timer = setTimeout(play, config.delay);
    }

    gotoFrame(0);

    return chart;
  };

  chart.update = function () {
    frames = dex.csv.getFramesByIndex(config.csv, config.frameIndex);
    chart.attr("frames", frames);
    gotoFrame(0);
  };

  function previous() {
    gotoFrame(frameNum > 0 ? (frameNum - 1) : 0)
  }

  function next() {
    gotoFrame((frameNum + 1) % frames.frameIndices.length);
  }

  function gotoFrame(frameIndex) {
    frameNum = frameIndex;
    if ($("#slider").is(":ui-slider")) {
      $("#slider").slider({ "value" : frameNum + 1 });
      $("#frameNumber").html("" + (frameNum + 1) + " (" + frames.frames[frameNum].data[0][config.frameIndex] + ")");
    }
    chart.publish({
        "type": "new-frame",
        "data": frames.frames[frameNum],
        "name": frames.frameIndices[frameNum],
        "frameBy": chart.config.csv.header[config.frameIndex]
      }
    );
    //dex.console.log("Displaying frame: " + frameNum);
  }

  $(document).ready(function () {
    // Make the entire chart draggable.
    //$(chart.config.parent).draggable();
  });

  return chart;
};

module.exports = player;
},{}],91:[function(require,module,exports){
/**
 *
 * This class creates and attaches a SqlQuery user interface onto the
 * parent node.
 *
 * @name dex.ui.SqlQuery
 * @param userConfig The following configuration options are available for configuring the
 * behavior of the SqlQuery component.<br><br>
 *
 * 'parent' : The default
 *
 * @returns {SqlQuery}
 *
 * @constructor
 *
 */
var sqlquery = function (userConfig) {

  var defaults =
  {
    'parent' : '#SqlQuery', // The parent container of this chart.
    // Set these when you need to CSS style components independently.
    'id'     : 'SqlQuery',
    'class'  : 'SqlQuery',
    'query'  : 'select * from dex;',
    // Our data...
    'csv'    : {
      // Give folks without data something to look at anyhow.
      'header' : ["X", "Y", "Z"],
      'data'   : [
        [0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]
      ]
    }
  };

  var chart = new dex.component(userConfig, defaults);
  var config = config;

  var sql = window.SQL;
  var db = new sql.Database();

  chart.render = function () {
    // Create the table only at render time.
    var createStr = "create table dex(" + csv.header.map(function (h, i) {
        var colName = h.trim();
        return "'" + colName + "' " + ((dex.csv.isColumnNumeric(csv, i)) ? "float" : "text");
      }).join(",") + ")";
    console.log("CREATESTR: " + createStr);
    db.exec("drop table if exists dex;");
    db.exec(createStr);

    var populateSql = "BEGIN;" + csv.data.map(function (row) {
        var insertStr =
          "insert into dex values(" + row.map(function (col) {
            return "'" + col.replace("'", "") + "'";
          }).join(",") + ");";
        //console.log(insertStr);
        //db.exec(insertStr);
        return insertStr;
      }).join("") + "COMMIT;";
    console.log(populateSql);
    db.exec(populateSql);
    chart.update();
  };

  chart.query = function (query) {
    var csv = [];
    var myQuery = chart.attr("query");
    if (query && query.length > 0) {
      myQuery = query;
    }
    console.log("QUERY: " + myQuery);

    csv.header = [];
    csv.data = [];

    var rs = db.exec(myQuery);

    console.log("RS:");
    console.dir(rs);
    csv.header = rs[0].columns.map(function (s) {
      return s.trim();
    });
    csv.data = rs[0].values;

    console.log(csv);
    return csv;
  }

  chart.update = function () {
  };

  return chart;
};

module.exports = sqlquery;
},{}],92:[function(require,module,exports){
/**
 *
 * @constructor
 * @classdesc This class constructs an html table from the supplied CSV data.
 * @memberOf dex/ui
 * @implements {dex/component}
 *
 * @example {@lang javascript}
 * var myTable = new dex.ui.Table({
 *   'parent' : "#MyTableContainer",
 *   'id'     : "MyTableId"
 *   'csv'    : { header : [ "X", "Y", "Z" ],
 *                data   : [[ 1, 2, 3 ], [4, 5, 6], [7, 8, 9]]}
 * });
 * @param {object} userConfig - A user supplied configuration object which will override the defaults.
 * @param {string} [userConfig.parent=#Table] - The parent node to which this component will be attached.
 * Ex: #MyParent will attach to a node with an id = "MyParent".
 * @param {string} [userConfig.id=Table] - The id of this component.
 * @param {string} [userConfig.class=Table] - The class of this component.
 * @param {csv} userConfig.csv - The user's CSV data.
 *
 */
var table = function (userConfig) {

  var defaults =
  {
    // The parent container of this chart.
    'parent' : '#TableParent',
    // Set these when you need to CSS style components independently.
    'id'     : 'TableId',
    'class'  : 'TableClass',
    // Our data...
    'csv'    : {
      // Give folks without data something to look at anyhow.
      'header' : ["X", "Y", "Z"],
      'data'   : [
        [0, 0, 0],
        [1, 1, 1],
        [2, 2, 2]
      ]
    }
  };

  var chart = new dex.component(userConfig, defaults);
  var config = chart.config;

  chart.render = function () {
    chart.update();
  };

  chart.update = function () {
    var chart = this;
    var config = chart.config;
    var csv = config.csv;

    d3.selectAll(config.parent).selectAll("*").remove();

    var table = d3.select(config.parent)
      .append("table")
      .attr("height", "100%")
      .attr("width", "100%")
      .attr("border", 1)
      .attr("class", config["class"])
      .attr("id", config["id"]);

    var thead = table.append("thead");
    var tbody = table.append("tbody");

    thead.append("tr")
      .selectAll("th")
      .data(csv.header)
      .enter()
      .append("th")
      .text(function (column) {
        return column;
      });

    var rows = tbody.selectAll("tr")
      .data(csv.data)
      .enter()
      .append("tr");

    var cells = rows.selectAll("td")
      .data(function (row) {
        return csv.header.map(function (column, i) {
          return {column : i, value : row[i]};
        });
      })
      .enter()
      .append("td")
      .html(function (d) {
        return d.value;
      });
  };

  return chart;
};

module.exports = table;
},{}],93:[function(require,module,exports){
/**
 *
 * This module provides ui components from a variety of sources.
 *
 @module dex/ui
 *
 */

/**
 *
 * A module for creating ui components such as players and sliders.
 *
 * @name ui
 * @type {module:ui}
 *
 */
module.exports = function ui(dex) {

  return {
    'Player' : require("./Player"),
    'SqlQuery': require("./SqlQuery"),
    'Table': require("./Table"),
    'ConfigurationPane': require("./ConfigurationPane"),
    'DataFilterPane': require("./DataFilterPane"),
    'GuiPane': require("./GuiPane"),
    'BootstrapSlider': require("../../lib/bootstrap-slider/bootstrap-slider")
  };
};
},{"../../lib/bootstrap-slider/bootstrap-slider":3,"./ConfigurationPane":87,"./DataFilterPane":88,"./GuiPane":89,"./Player":90,"./SqlQuery":91,"./Table":92}],94:[function(require,module,exports){
/**
 *
 * This module provides utility routines.
 *
 * @module dex/util
 *
 */

module.exports = function util(dex) {

  return {
    /**
     *
     * @module dex/util/d3
     */
    'd3': {
      /**
       *
       * Given a d3 element, this routine will determine the parent's
       * bounding box and annotate information related to the bounds
       * in which this element can expand.
       *
       * @memberOf dex/util/d3
       * @param d The d3 element we wish to size.
       * @returns The annotated d3 element.
       *
       */
      'autosize': function (d) {
        var bbox = this.getBBox();
        var cbbox = this.parentNode.getBBox();
        var hMargin = Math.min(30, cbbox.height * .1);
        var wMargin = Math.min(30, cbbox.width * .1);
        var wscale = Math.min((cbbox.width - wMargin) / bbox.width);
        var hscale = Math.min((cbbox.height - hMargin) / bbox.height);

        d.bounds = {
          'container-bounds': cbbox,
          'bounds': bbox,
          'scale': Math.min(wscale, hscale),
          'height-scale': hscale,
          'width-scale': wscale
        };
      },
      'addRadialGradients': function (svg, id, data, colorScheme) {
        var defs = svg.selectAll("defs")
          .data(['defs'])
          .enter()
          .append("defs");

        var grads = defs.selectAll("radialGradient")
          .data(data)
          .enter()
          .append("radialGradient")
          .attr("gradientUnits", "userSpaceOnUse")
          .attr("cx", 0)
          .attr("cy", 0)
          .attr("r", "100%")
          .attr("id", function (d, i) {
            return id + "_" + i;
          });

        grads.append("stop").attr("offset", "15%").style("stop-color", function (d, i) {
          return colorScheme(i);
        });
        grads.append("stop").attr("offset", "20%").style("stop-color", "white");
        grads.append("stop").attr("offset", "27%").style("stop-color", function (d, i) {
          return colorScheme(i);
        });
      }
    }
  };
};
},{}]},{},[82])(82)
});